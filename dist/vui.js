'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var PropTypes = require('prop-types');
var ReactDOM = require('react-dom');
var clsx = require('clsx');
var Cookies = require('js-cookie');
var react = require('@emotion/react');
var vicon = require('@vbd/vicon');
var reactAnimatedCss = require('react-animated-css');
var reactDeviceDetect = require('react-device-detect');
var mapboxgl = require('mapbox-gl');
var reactRouterDom = require('react-router-dom');
var moment = require('moment');
var reactColor = require('react-color');
var reactDnd = require('react-dnd');
var Switch = require('react-switch');
var update = require('immutability-helper');
var reactDndHtml5Backend = require('react-dnd-html5-backend');
var AwesomeDebouncePromise = require('awesome-debounce-promise');
var reactChartjs2 = require('react-chartjs-2');
var reactZoomPanPinch = require('react-zoom-pan-pinch');
var EXIF = require('exif-js');
var reactHookForm = require('react-hook-form');
var reactChildrenUtilities = require('react-children-utilities');
var useDeepCompareEffect = require('use-deep-compare-effect');
var mapValuesDeep = require('deepdash/es/mapValuesDeep');
var MapboxDraw = require('@mapbox/mapbox-gl-draw');
var ReactMapboxGl = require('react-mapbox-gl');
var THREE = require('three');
var GLTFLoader = require('three-gltf-loader');
var reactFullScreen = require('react-full-screen');
var reactResizable = require('react-resizable');
var pannellumReact = require('pannellum-react');
var ReactMoment = require('react-moment');
var Plyr = require('plyr');
var JSONInput = require('react-json-editor-ajrm');
var ChartDataLabels = require('chartjs-plugin-datalabels');
require('chartjs-adapter-moment');
var diff = require('diff');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var React__namespace = /*#__PURE__*/_interopNamespace(React);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);
var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);
var clsx__default = /*#__PURE__*/_interopDefaultLegacy(clsx);
var Cookies__default = /*#__PURE__*/_interopDefaultLegacy(Cookies);
var mapboxgl__default = /*#__PURE__*/_interopDefaultLegacy(mapboxgl);
var moment__default = /*#__PURE__*/_interopDefaultLegacy(moment);
var Switch__default = /*#__PURE__*/_interopDefaultLegacy(Switch);
var update__default = /*#__PURE__*/_interopDefaultLegacy(update);
var AwesomeDebouncePromise__default = /*#__PURE__*/_interopDefaultLegacy(AwesomeDebouncePromise);
var EXIF__default = /*#__PURE__*/_interopDefaultLegacy(EXIF);
var useDeepCompareEffect__default = /*#__PURE__*/_interopDefaultLegacy(useDeepCompareEffect);
var mapValuesDeep__default = /*#__PURE__*/_interopDefaultLegacy(mapValuesDeep);
var MapboxDraw__default = /*#__PURE__*/_interopDefaultLegacy(MapboxDraw);
var ReactMapboxGl__default = /*#__PURE__*/_interopDefaultLegacy(ReactMapboxGl);
var THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);
var GLTFLoader__default = /*#__PURE__*/_interopDefaultLegacy(GLTFLoader);
var ReactMoment__default = /*#__PURE__*/_interopDefaultLegacy(ReactMoment);
var Plyr__default = /*#__PURE__*/_interopDefaultLegacy(Plyr);
var JSONInput__default = /*#__PURE__*/_interopDefaultLegacy(JSONInput);
var ChartDataLabels__default = /*#__PURE__*/_interopDefaultLegacy(ChartDataLabels);
var diff__namespace = /*#__PURE__*/_interopNamespace(diff);

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$1(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$1(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose$1(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function get(element) {
  return getComputedStyle(element);
}
function set(element, obj) {
  for (var key in obj) {
    var val = obj[key];

    if (typeof val === 'number') {
      val = "".concat(val, "px");
    }

    element.style[key] = val;
  }

  return element;
}

function div(className) {
  var div = document.createElement('div');
  div.className = className;
  return div;
}
var elMatches = typeof Element !== 'undefined' && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function matches(element, query) {
  if (!elMatches) {
    throw new Error('No element matching method supported');
  }

  return elMatches.call(element, query);
}
function remove(element) {
  if (element.remove) {
    element.remove();
  } else {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
}
function queryChildren(element, selector) {
  return Array.prototype.filter.call(element.children, function (child) {
    return matches(child, selector);
  });
}

var cls = {
  main: 'ps',
  rtl: 'ps__rtl',
  element: {
    thumb: function thumb(x) {
      return "ps__thumb-".concat(x);
    },
    rail: function rail(x) {
      return "ps__rail-".concat(x);
    },
    consuming: 'ps__child--consume'
  },
  state: {
    focus: 'ps--focus',
    clicking: 'ps--clicking',
    active: function active(x) {
      return "ps--active-".concat(x);
    },
    scrolling: function scrolling(x) {
      return "ps--scrolling-".concat(x);
    }
  }
};
/*
 * Helper methods
 */

var scrollingClassTimeout = {
  x: null,
  y: null
};
function addScrollingClass(i, x) {
  var classList = i.element.classList;
  var className = cls.state.scrolling(x);

  if (classList.contains(className)) {
    clearTimeout(scrollingClassTimeout[x]);
  } else {
    classList.add(className);
  }
}
function removeScrollingClass(i, x) {
  scrollingClassTimeout[x] = setTimeout(function () {
    return i.isAlive && i.element.classList.remove(cls.state.scrolling(x));
  }, i.settings.scrollingThreshold);
}
function setScrollingClassInstantly(i, x) {
  addScrollingClass(i, x);
  removeScrollingClass(i, x);
}

var EventElement = /*#__PURE__*/function () {
  function EventElement(element) {
    _classCallCheck(this, EventElement);

    this.element = element;
    this.handlers = {};
  }

  _createClass(EventElement, [{
    key: "bind",
    value: function bind(eventName, handler) {
      if (typeof this.handlers[eventName] === 'undefined') {
        this.handlers[eventName] = [];
      }

      this.handlers[eventName].push(handler);
      this.element.addEventListener(eventName, handler, false);
    }
  }, {
    key: "unbind",
    value: function unbind(eventName, target) {
      var _this = this;

      this.handlers[eventName] = this.handlers[eventName].filter(function (handler) {
        if (target && handler !== target) {
          return true;
        }

        _this.element.removeEventListener(eventName, handler, false);

        return false;
      });
    }
  }, {
    key: "unbindAll",
    value: function unbindAll() {
      for (var name in this.handlers) {
        this.unbind(name);
      }
    }
  }, {
    key: "isEmpty",
    get: function get() {
      var _this2 = this;

      return Object.keys(this.handlers).every(function (key) {
        return _this2.handlers[key].length === 0;
      });
    }
  }]);

  return EventElement;
}();

var EventManager = /*#__PURE__*/function () {
  function EventManager() {
    _classCallCheck(this, EventManager);

    this.eventElements = [];
  }

  _createClass(EventManager, [{
    key: "eventElement",
    value: function eventElement(element) {
      var ee = this.eventElements.filter(function (ee) {
        return ee.element === element;
      })[0];

      if (!ee) {
        ee = new EventElement(element);
        this.eventElements.push(ee);
      }

      return ee;
    }
  }, {
    key: "bind",
    value: function bind(element, eventName, handler) {
      this.eventElement(element).bind(eventName, handler);
    }
  }, {
    key: "unbind",
    value: function unbind(element, eventName, handler) {
      var ee = this.eventElement(element);
      ee.unbind(eventName, handler);

      if (ee.isEmpty) {
        // remove
        this.eventElements.splice(this.eventElements.indexOf(ee), 1);
      }
    }
  }, {
    key: "unbindAll",
    value: function unbindAll() {
      this.eventElements.forEach(function (e) {
        return e.unbindAll();
      });
      this.eventElements = [];
    }
  }, {
    key: "once",
    value: function once(element, eventName, handler) {
      var ee = this.eventElement(element);

      var onceHandler = function onceHandler(evt) {
        ee.unbind(eventName, onceHandler);
        handler(evt);
      };

      ee.bind(eventName, onceHandler);
    }
  }]);

  return EventManager;
}();

function createEvent(name) {
  if (typeof window.CustomEvent === 'function') {
    return new CustomEvent(name);
  } else {
    var evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(name, false, false, undefined);
    return evt;
  }
}

function processScrollDiff (i, axis, diff) {
  var useScrollingClass = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var forceFireReachEvent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var fields;

  if (axis === 'top') {
    fields = ['contentHeight', 'containerHeight', 'scrollTop', 'y', 'up', 'down'];
  } else if (axis === 'left') {
    fields = ['contentWidth', 'containerWidth', 'scrollLeft', 'x', 'left', 'right'];
  } else {
    throw new Error('A proper axis should be provided');
  }

  processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent);
}

function processScrollDiff$1(i, diff, _ref) {
  var _ref2 = _slicedToArray(_ref, 6),
      contentHeight = _ref2[0],
      containerHeight = _ref2[1],
      scrollTop = _ref2[2],
      y = _ref2[3],
      up = _ref2[4],
      down = _ref2[5];

  var useScrollingClass = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var forceFireReachEvent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var element = i.element; // reset reach

  i.reach[y] = null; // 1 for subpixel rounding

  if (element[scrollTop] < 1) {
    i.reach[y] = 'start';
  } // 1 for subpixel rounding


  if (element[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {
    i.reach[y] = 'end';
  }

  if (diff) {
    element.dispatchEvent(createEvent("ps-scroll-".concat(y)));

    if (diff < 0) {
      element.dispatchEvent(createEvent("ps-scroll-".concat(up)));
    } else if (diff > 0) {
      element.dispatchEvent(createEvent("ps-scroll-".concat(down)));
    }

    if (useScrollingClass) {
      setScrollingClassInstantly(i, y);
    }
  }

  if (i.reach[y] && (diff || forceFireReachEvent)) {
    element.dispatchEvent(createEvent("ps-".concat(y, "-reach-").concat(i.reach[y])));
  }
}

function toInt(x) {
  return parseInt(x, 10) || 0;
}
function isEditable(el) {
  return matches(el, 'input,[contenteditable]') || matches(el, 'select,[contenteditable]') || matches(el, 'textarea,[contenteditable]') || matches(el, 'button,[contenteditable]');
}
function outerWidth(element) {
  var styles = get(element);
  return toInt(styles.width) + toInt(styles.paddingLeft) + toInt(styles.paddingRight) + toInt(styles.borderLeftWidth) + toInt(styles.borderRightWidth);
}
var env = {
  isWebKit: typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style,
  supportsTouch: typeof window !== 'undefined' && ('ontouchstart' in window || 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator !== 'undefined' && navigator.msMaxTouchPoints,
  isChrome: typeof navigator !== 'undefined' && /Chrome/i.test(navigator && navigator.userAgent)
};

function updateGeometry (i) {
  var element = i.element;
  var roundedScrollTop = Math.floor(element.scrollTop);
  var rect = element.getBoundingClientRect();
  i.containerWidth = Math.ceil(rect.width);
  i.containerHeight = Math.ceil(rect.height);
  i.contentWidth = element.scrollWidth;
  i.contentHeight = element.scrollHeight;

  if (!element.contains(i.scrollbarXRail)) {
    // clean up and append
    queryChildren(element, cls.element.rail('x')).forEach(function (el) {
      return remove(el);
    });
    element.appendChild(i.scrollbarXRail);
  }

  if (!element.contains(i.scrollbarYRail)) {
    // clean up and append
    queryChildren(element, cls.element.rail('y')).forEach(function (el) {
      return remove(el);
    });
    element.appendChild(i.scrollbarYRail);
  }

  if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
    i.scrollbarXActive = true;
    i.railXWidth = i.containerWidth - i.railXMarginWidth;
    i.railXRatio = i.containerWidth / i.railXWidth;
    i.scrollbarXWidth = getThumbSize(i, toInt(i.railXWidth * i.containerWidth / i.contentWidth));
    i.scrollbarXLeft = toInt((i.negativeScrollAdjustment + element.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth));
  } else {
    i.scrollbarXActive = false;
  }

  if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
    i.scrollbarYActive = true;
    i.railYHeight = i.containerHeight - i.railYMarginHeight;
    i.railYRatio = i.containerHeight / i.railYHeight;
    i.scrollbarYHeight = getThumbSize(i, toInt(i.railYHeight * i.containerHeight / i.contentHeight));
    i.scrollbarYTop = toInt(roundedScrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight));
  } else {
    i.scrollbarYActive = false;
  }

  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
  }

  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
  }

  updateCss(element, i);

  if (i.scrollbarXActive) {
    element.classList.add(cls.state.active('x'));
  } else {
    element.classList.remove(cls.state.active('x'));
    i.scrollbarXWidth = 0;
    i.scrollbarXLeft = 0;
    element.scrollLeft = i.isRtl === true ? i.contentWidth : 0;
  }

  if (i.scrollbarYActive) {
    element.classList.add(cls.state.active('y'));
  } else {
    element.classList.remove(cls.state.active('y'));
    i.scrollbarYHeight = 0;
    i.scrollbarYTop = 0;
    element.scrollTop = 0;
  }
}

function getThumbSize(i, thumbSize) {
  if (i.settings.minScrollbarLength) {
    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
  }

  if (i.settings.maxScrollbarLength) {
    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
  }

  return thumbSize;
}

function updateCss(element, i) {
  var xRailOffset = {
    width: i.railXWidth
  };
  var roundedScrollTop = Math.floor(element.scrollTop);

  if (i.isRtl) {
    xRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth - i.contentWidth;
  } else {
    xRailOffset.left = element.scrollLeft;
  }

  if (i.isScrollbarXUsingBottom) {
    xRailOffset.bottom = i.scrollbarXBottom - roundedScrollTop;
  } else {
    xRailOffset.top = i.scrollbarXTop + roundedScrollTop;
  }

  set(i.scrollbarXRail, xRailOffset);
  var yRailOffset = {
    top: roundedScrollTop,
    height: i.railYHeight
  };

  if (i.isScrollbarYUsingRight) {
    if (i.isRtl) {
      yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth - 9;
    } else {
      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
    }
  } else {
    if (i.isRtl) {
      yRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
    } else {
      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
    }
  }

  set(i.scrollbarYRail, yRailOffset);
  set(i.scrollbarX, {
    left: i.scrollbarXLeft,
    width: i.scrollbarXWidth - i.railBorderXWidth
  });
  set(i.scrollbarY, {
    top: i.scrollbarYTop,
    height: i.scrollbarYHeight - i.railBorderYWidth
  });
}

function clickRail (i) {
  i.element;
  i.event.bind(i.scrollbarY, 'mousedown', function (e) {
    return e.stopPropagation();
  });
  i.event.bind(i.scrollbarYRail, 'mousedown', function (e) {
    var positionTop = e.pageY - window.pageYOffset - i.scrollbarYRail.getBoundingClientRect().top;
    var direction = positionTop > i.scrollbarYTop ? 1 : -1;
    i.element.scrollTop += direction * i.containerHeight;
    updateGeometry(i);
    e.stopPropagation();
  });
  i.event.bind(i.scrollbarX, 'mousedown', function (e) {
    return e.stopPropagation();
  });
  i.event.bind(i.scrollbarXRail, 'mousedown', function (e) {
    var positionLeft = e.pageX - window.pageXOffset - i.scrollbarXRail.getBoundingClientRect().left;
    var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;
    i.element.scrollLeft += direction * i.containerWidth;
    updateGeometry(i);
    e.stopPropagation();
  });
}

function dragThumb (i) {
  bindMouseScrollHandler(i, ['containerWidth', 'contentWidth', 'pageX', 'railXWidth', 'scrollbarX', 'scrollbarXWidth', 'scrollLeft', 'x', 'scrollbarXRail']);
  bindMouseScrollHandler(i, ['containerHeight', 'contentHeight', 'pageY', 'railYHeight', 'scrollbarY', 'scrollbarYHeight', 'scrollTop', 'y', 'scrollbarYRail']);
}

function bindMouseScrollHandler(i, _ref) {
  var _ref2 = _slicedToArray(_ref, 9),
      containerHeight = _ref2[0],
      contentHeight = _ref2[1],
      pageY = _ref2[2],
      railYHeight = _ref2[3],
      scrollbarY = _ref2[4],
      scrollbarYHeight = _ref2[5],
      scrollTop = _ref2[6],
      y = _ref2[7],
      scrollbarYRail = _ref2[8];

  var element = i.element;
  var startingScrollTop = null;
  var startingMousePageY = null;
  var scrollBy = null;

  function mouseMoveHandler(e) {
    if (e.touches && e.touches[0]) {
      e[pageY] = e.touches[0].pageY;
    }

    element[scrollTop] = startingScrollTop + scrollBy * (e[pageY] - startingMousePageY);
    addScrollingClass(i, y);
    updateGeometry(i);
    e.stopPropagation();
    e.preventDefault();
  }

  function mouseUpHandler() {
    removeScrollingClass(i, y);
    i[scrollbarYRail].classList.remove(cls.state.clicking);
    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
  }

  function bindMoves(e, touchMode) {
    startingScrollTop = element[scrollTop];

    if (touchMode && e.touches) {
      e[pageY] = e.touches[0].pageY;
    }

    startingMousePageY = e[pageY];
    scrollBy = (i[contentHeight] - i[containerHeight]) / (i[railYHeight] - i[scrollbarYHeight]);

    if (!touchMode) {
      i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
      i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);
      e.preventDefault();
    } else {
      i.event.bind(i.ownerDocument, 'touchmove', mouseMoveHandler);
    }

    i[scrollbarYRail].classList.add(cls.state.clicking);
    e.stopPropagation();
  }

  i.event.bind(i[scrollbarY], 'mousedown', function (e) {
    bindMoves(e);
  });
  i.event.bind(i[scrollbarY], 'touchstart', function (e) {
    bindMoves(e, true);
  });
}

function keyboard (i) {
  var element = i.element;

  var elementHovered = function elementHovered() {
    return matches(element, ':hover');
  };

  var scrollbarFocused = function scrollbarFocused() {
    return matches(i.scrollbarX, ':focus') || matches(i.scrollbarY, ':focus');
  };

  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);

    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }

      if (scrollTop === 0 && deltaY > 0 || scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0) {
        return !i.settings.wheelPropagation;
      }
    }

    var scrollLeft = element.scrollLeft;

    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }

      if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0) {
        return !i.settings.wheelPropagation;
      }
    }

    return true;
  }

  i.event.bind(i.ownerDocument, 'keydown', function (e) {
    if (e.isDefaultPrevented && e.isDefaultPrevented() || e.defaultPrevented) {
      return;
    }

    if (!elementHovered() && !scrollbarFocused()) {
      return;
    }

    var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;

    if (activeElement) {
      if (activeElement.tagName === 'IFRAME') {
        activeElement = activeElement.contentDocument.activeElement;
      } else {
        // go deeper if element is a webcomponent
        while (activeElement.shadowRoot) {
          activeElement = activeElement.shadowRoot.activeElement;
        }
      }

      if (isEditable(activeElement)) {
        return;
      }
    }

    var deltaX = 0;
    var deltaY = 0;

    switch (e.which) {
      case 37:
        // left
        if (e.metaKey) {
          deltaX = -i.contentWidth;
        } else if (e.altKey) {
          deltaX = -i.containerWidth;
        } else {
          deltaX = -30;
        }

        break;

      case 38:
        // up
        if (e.metaKey) {
          deltaY = i.contentHeight;
        } else if (e.altKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = 30;
        }

        break;

      case 39:
        // right
        if (e.metaKey) {
          deltaX = i.contentWidth;
        } else if (e.altKey) {
          deltaX = i.containerWidth;
        } else {
          deltaX = 30;
        }

        break;

      case 40:
        // down
        if (e.metaKey) {
          deltaY = -i.contentHeight;
        } else if (e.altKey) {
          deltaY = -i.containerHeight;
        } else {
          deltaY = -30;
        }

        break;

      case 32:
        // space bar
        if (e.shiftKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = -i.containerHeight;
        }

        break;

      case 33:
        // page up
        deltaY = i.containerHeight;
        break;

      case 34:
        // page down
        deltaY = -i.containerHeight;
        break;

      case 36:
        // home
        deltaY = i.contentHeight;
        break;

      case 35:
        // end
        deltaY = -i.contentHeight;
        break;

      default:
        return;
    }

    if (i.settings.suppressScrollX && deltaX !== 0) {
      return;
    }

    if (i.settings.suppressScrollY && deltaY !== 0) {
      return;
    }

    element.scrollTop -= deltaY;
    element.scrollLeft += deltaX;
    updateGeometry(i);

    if (shouldPreventDefault(deltaX, deltaY)) {
      e.preventDefault();
    }
  });
}

function wheel (i) {
  var element = i.element;

  function shouldPreventDefault(deltaX, deltaY) {
    var roundedScrollTop = Math.floor(element.scrollTop);
    var isTop = element.scrollTop === 0;
    var isBottom = roundedScrollTop + element.offsetHeight === element.scrollHeight;
    var isLeft = element.scrollLeft === 0;
    var isRight = element.scrollLeft + element.offsetWidth === element.scrollWidth;
    var hitsBound; // pick axis with primary direction

    if (Math.abs(deltaY) > Math.abs(deltaX)) {
      hitsBound = isTop || isBottom;
    } else {
      hitsBound = isLeft || isRight;
    }

    return hitsBound ? !i.settings.wheelPropagation : true;
  }

  function getDeltaFromEvent(e) {
    var deltaX = e.deltaX;
    var deltaY = -1 * e.deltaY;

    if (typeof deltaX === 'undefined' || typeof deltaY === 'undefined') {
      // OS X Safari
      deltaX = -1 * e.wheelDeltaX / 6;
      deltaY = e.wheelDeltaY / 6;
    }

    if (e.deltaMode && e.deltaMode === 1) {
      // Firefox in deltaMode 1: Line scrolling
      deltaX *= 10;
      deltaY *= 10;
    }

    if (deltaX !== deltaX && deltaY !== deltaY
    /* NaN checks */
    ) {
      // IE in some mouse drivers
      deltaX = 0;
      deltaY = e.wheelDelta;
    } // if (e.shiftKey)
    // {
    //     // reverse axis with shift key
    //     return [-deltaY, -deltaX];
    // }


    return [deltaX, deltaY];
  }

  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    // FIXME: this is a workaround for <select> issue in FF and IE #571
    if (!env.isWebKit && element.querySelector('select:focus')) {
      return true;
    }

    if (!element.contains(target)) {
      return false;
    }

    var cursor = target;

    while (cursor && cursor !== element) {
      if (cursor.classList.contains(cls.element.consuming)) {
        return true;
      }

      var style = get(cursor); // if deltaY && vertical scrollable

      if (deltaY && style.overflowY.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;

        if (maxScrollTop > 0) {
          if (cursor.scrollTop > 0 && deltaY < 0 || cursor.scrollTop < maxScrollTop && deltaY > 0) {
            return true;
          }
        }
      } // if deltaX && horizontal scrollable


      if (deltaX && style.overflowX.match(/(scroll|auto)/)) {
        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;

        if (maxScrollLeft > 0) {
          if (cursor.scrollLeft > 0 && deltaX < 0 || cursor.scrollLeft < maxScrollLeft && deltaX > 0) {
            return true;
          }
        }
      }

      cursor = cursor.parentNode;
    }

    return false;
  }

  function mousewheelHandler(e) {
    var _getDeltaFromEvent = getDeltaFromEvent(e),
        _getDeltaFromEvent2 = _slicedToArray(_getDeltaFromEvent, 2),
        deltaX = _getDeltaFromEvent2[0],
        deltaY = _getDeltaFromEvent2[1];

    if (shouldBeConsumedByChild(e.target, deltaX, deltaY)) {
      return;
    } // console.log('element', element);


    var shouldPrevent = false;

    if (!i.settings.useBothWheelAxes) {
      // deltaX will only be used for horizontal scrolling and deltaY will
      // only be used for vertical scrolling - this is the default
      element.scrollTop -= deltaY * i.settings.wheelSpeed;
      element.scrollLeft += deltaX * i.settings.wheelSpeed;
    } else if (i.scrollbarYActive && !i.scrollbarXActive) {
      // only vertical scrollbar is active and useBothWheelAxes option is
      // active, so let's scroll vertical bar using both mouse wheel axes
      if (deltaY) {
        element.scrollTop -= deltaY * i.settings.wheelSpeed;
      } else {
        element.scrollTop += deltaX * i.settings.wheelSpeed;
      }

      shouldPrevent = true;
    } else if (i.scrollbarXActive && !i.scrollbarYActive) {
      // useBothWheelAxes and only horizontal bar is active, so use both
      // wheel axes for horizontal bar
      if (deltaX) {
        element.scrollLeft += deltaX * i.settings.wheelSpeed;
      } else {
        element.scrollLeft -= deltaY * i.settings.wheelSpeed;
      }

      shouldPrevent = true;
    }

    updateGeometry(i);
    shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);

    if (shouldPrevent && !e.ctrlKey) {
      e.stopPropagation();
      e.preventDefault();
    }
  }

  if (typeof window.onwheel !== 'undefined') {
    i.event.bind(element, 'wheel', mousewheelHandler);
  } else if (typeof window.onmousewheel !== 'undefined') {
    i.event.bind(element, 'mousewheel', mousewheelHandler);
  }
}

function touch (i) {
  if (!env.supportsTouch && !env.supportsIePointer) {
    return;
  }

  var element = i.element;

  function shouldPrevent(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    var scrollLeft = element.scrollLeft;
    var magnitudeX = Math.abs(deltaX);
    var magnitudeY = Math.abs(deltaY);

    if (magnitudeY > magnitudeX) {
      // user is perhaps trying to swipe up/down the page
      if (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight || deltaY > 0 && scrollTop === 0) {
        // set prevent for mobile Chrome refresh
        return window.scrollY === 0 && deltaY > 0 && env.isChrome;
      }
    } else if (magnitudeX > magnitudeY) {
      // user is perhaps trying to swipe left/right across the page
      if (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth || deltaX > 0 && scrollLeft === 0) {
        return true;
      }
    }

    return true;
  }

  function applyTouchMove(differenceX, differenceY) {
    element.scrollTop -= differenceY;
    element.scrollLeft -= differenceX;
    updateGeometry(i);
  }

  var startOffset = {};
  var startTime = 0;
  var speed = {};
  var easingLoop = null;

  function getTouch(e) {
    if (e.targetTouches) {
      return e.targetTouches[0];
    } else {
      // Maybe IE pointer
      return e;
    }
  }

  function shouldHandle(e) {
    if (e.pointerType && e.pointerType === 'pen' && e.buttons === 0) {
      return false;
    }

    if (e.targetTouches && e.targetTouches.length === 1) {
      return true;
    }

    if (e.pointerType && e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
      return true;
    }

    return false;
  }

  function touchStart(e) {
    if (!shouldHandle(e)) {
      return;
    }

    var touch = getTouch(e);
    startOffset.pageX = touch.pageX;
    startOffset.pageY = touch.pageY;
    startTime = new Date().getTime();

    if (easingLoop !== null) {
      clearInterval(easingLoop);
    }
  }

  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!element.contains(target)) {
      return false;
    }

    var cursor = target;

    while (cursor && cursor !== element) {
      if (cursor.classList.contains(cls.element.consuming)) {
        return true;
      }

      var style = get(cursor); // if deltaY && vertical scrollable

      if (deltaY && style.overflowY.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;

        if (maxScrollTop > 0) {
          if (cursor.scrollTop > 0 && deltaY < 0 || cursor.scrollTop < maxScrollTop && deltaY > 0) {
            return true;
          }
        }
      } // if deltaX && horizontal scrollable


      if (deltaX && style.overflowX.match(/(scroll|auto)/)) {
        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;

        if (maxScrollLeft > 0) {
          if (cursor.scrollLeft > 0 && deltaX < 0 || cursor.scrollLeft < maxScrollLeft && deltaX > 0) {
            return true;
          }
        }
      }

      cursor = cursor.parentNode;
    }

    return false;
  }

  function touchMove(e) {
    if (shouldHandle(e)) {
      var touch = getTouch(e);
      var currentOffset = {
        pageX: touch.pageX,
        pageY: touch.pageY
      };
      var differenceX = currentOffset.pageX - startOffset.pageX;
      var differenceY = currentOffset.pageY - startOffset.pageY;

      if (shouldBeConsumedByChild(e.target, differenceX, differenceY)) {
        return;
      }

      applyTouchMove(differenceX, differenceY);
      startOffset = currentOffset;
      var currentTime = new Date().getTime();
      var timeGap = currentTime - startTime;

      if (timeGap > 0) {
        speed.x = differenceX / timeGap;
        speed.y = differenceY / timeGap;
        startTime = currentTime;
      }

      if (shouldPrevent(differenceX, differenceY)) {
        e.preventDefault();
      }
    }
  }

  function touchEnd() {
    if (i.settings.swipeEasing) {
      clearInterval(easingLoop);
      easingLoop = setInterval(function () {
        if (i.isInitialized) {
          clearInterval(easingLoop);
          return;
        }

        if (!speed.x && !speed.y) {
          clearInterval(easingLoop);
          return;
        }

        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
          clearInterval(easingLoop);
          return;
        }

        applyTouchMove(speed.x * 30, speed.y * 30);
        speed.x *= 0.8;
        speed.y *= 0.8;
      }, 10);
    }
  }

  if (env.supportsTouch) {
    i.event.bind(element, 'touchstart', touchStart);
    i.event.bind(element, 'touchmove', touchMove);
    i.event.bind(element, 'touchend', touchEnd);
  } else if (env.supportsIePointer) {
    if (window.PointerEvent) {
      i.event.bind(element, 'pointerdown', touchStart);
      i.event.bind(element, 'pointermove', touchMove);
      i.event.bind(element, 'pointerup', touchEnd);
    } else if (window.MSPointerEvent) {
      i.event.bind(element, 'MSPointerDown', touchStart);
      i.event.bind(element, 'MSPointerMove', touchMove);
      i.event.bind(element, 'MSPointerUp', touchEnd);
    }
  }
}

var defaultSettings = function defaultSettings() {
  return {
    handlers: ['click-rail', 'drag-thumb', 'keyboard', 'wheel', 'touch'],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1000,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: false,
    suppressScrollY: false,
    swipeEasing: true,
    useBothWheelAxes: false,
    wheelPropagation: true,
    wheelSpeed: 1
  };
};

var handlers = {
  'click-rail': clickRail,
  'drag-thumb': dragThumb,
  keyboard: keyboard,
  wheel: wheel,
  touch: touch
};

var PerfectScrollbar = /*#__PURE__*/function () {
  function PerfectScrollbar(element) {
    var _this = this;

    var userSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, PerfectScrollbar);

    if (typeof element === 'string') {
      element = document.querySelector(element);
    }

    if (!element || !element.nodeName) {
      throw new Error('no element is specified to initialize PerfectScrollbar');
    }

    this.element = element;
    element.classList.add(cls.main);
    this.settings = defaultSettings();

    for (var key in userSettings) {
      this.settings[key] = userSettings[key];
    }

    this.containerWidth = null;
    this.containerHeight = null;
    this.contentWidth = null;
    this.contentHeight = null;

    var focus = function focus() {
      return element.classList.add(cls.state.focus);
    };

    var blur = function blur() {
      return element.classList.remove(cls.state.focus);
    };

    this.isRtl = get(element).direction === 'rtl';

    if (this.isRtl === true) {
      element.classList.add(cls.rtl);
    }

    this.isNegativeScroll = function () {
      var originalScrollLeft = element.scrollLeft;
      var result = null;
      element.scrollLeft = -1;
      result = element.scrollLeft < 0;
      element.scrollLeft = originalScrollLeft;
      return result;
    }();

    this.negativeScrollAdjustment = this.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
    this.event = new EventManager();
    this.ownerDocument = element.ownerDocument || document;
    this.scrollbarXRail = div(cls.element.rail('x'));
    element.appendChild(this.scrollbarXRail);
    this.scrollbarX = div(cls.element.thumb('x'));
    this.scrollbarXRail.appendChild(this.scrollbarX);
    this.scrollbarX.setAttribute('tabindex', 0);
    this.event.bind(this.scrollbarX, 'focus', focus);
    this.event.bind(this.scrollbarX, 'blur', blur);
    this.scrollbarXActive = null;
    this.scrollbarXWidth = null;
    this.scrollbarXLeft = null;
    var railXStyle = get(this.scrollbarXRail);
    this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);

    if (isNaN(this.scrollbarXBottom)) {
      this.isScrollbarXUsingBottom = false;
      this.scrollbarXTop = toInt(railXStyle.top);
    } else {
      this.isScrollbarXUsingBottom = true;
    }

    this.railBorderXWidth = toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth); // Set rail to display:block to calculate margins

    set(this.scrollbarXRail, {
      display: 'block'
    });
    this.railXMarginWidth = toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);
    set(this.scrollbarXRail, {
      display: ''
    });
    this.railXWidth = null;
    this.railXRatio = null;
    this.scrollbarYRail = div(cls.element.rail('y'));
    element.appendChild(this.scrollbarYRail);
    this.scrollbarY = div(cls.element.thumb('y'));
    this.scrollbarYRail.appendChild(this.scrollbarY);
    this.scrollbarY.setAttribute('tabindex', 0);
    this.event.bind(this.scrollbarY, 'focus', focus);
    this.event.bind(this.scrollbarY, 'blur', blur);
    this.scrollbarYActive = null;
    this.scrollbarYHeight = null;
    this.scrollbarYTop = null;
    var railYStyle = get(this.scrollbarYRail);
    this.scrollbarYRight = parseInt(railYStyle.right, 10);

    if (isNaN(this.scrollbarYRight)) {
      this.isScrollbarYUsingRight = false;
      this.scrollbarYLeft = toInt(railYStyle.left);
    } else {
      this.isScrollbarYUsingRight = true;
    }

    this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;
    this.railBorderYWidth = toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);
    set(this.scrollbarYRail, {
      display: 'block'
    });
    this.railYMarginHeight = toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);
    set(this.scrollbarYRail, {
      display: ''
    });
    this.railYHeight = null;
    this.railYRatio = null;
    this.reach = {
      x: element.scrollLeft <= 0 ? 'start' : element.scrollLeft >= this.contentWidth - this.containerWidth ? 'end' : null,
      y: element.scrollTop <= 0 ? 'start' : element.scrollTop >= this.contentHeight - this.containerHeight ? 'end' : null
    };
    this.isAlive = true;
    this.settings.handlers.forEach(function (handlerName) {
      return handlers[handlerName](_this);
    });
    this.lastScrollTop = Math.floor(element.scrollTop); // for onScroll only

    this.lastScrollLeft = element.scrollLeft; // for onScroll only

    this.event.bind(this.element, 'scroll', function (e) {
      return _this.onScroll(e);
    });
    updateGeometry(this);
  }

  _createClass(PerfectScrollbar, [{
    key: "update",
    value: function update() {
      if (!this.isAlive) {
        return;
      } // Recalcuate negative scrollLeft adjustment


      this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0; // Recalculate rail margins

      set(this.scrollbarXRail, {
        display: 'block'
      });
      set(this.scrollbarYRail, {
        display: 'block'
      });
      this.railXMarginWidth = toInt(get(this.scrollbarXRail).marginLeft) + toInt(get(this.scrollbarXRail).marginRight);
      this.railYMarginHeight = toInt(get(this.scrollbarYRail).marginTop) + toInt(get(this.scrollbarYRail).marginBottom); // Hide scrollbars not to affect scrollWidth and scrollHeight

      set(this.scrollbarXRail, {
        display: 'none'
      });
      set(this.scrollbarYRail, {
        display: 'none'
      });
      updateGeometry(this);
      processScrollDiff(this, 'top', 0, false, true);
      processScrollDiff(this, 'left', 0, false, true);
      set(this.scrollbarXRail, {
        display: ''
      });
      set(this.scrollbarYRail, {
        display: ''
      });
    }
  }, {
    key: "onScroll",
    value: function onScroll(e) {
      if (!this.isAlive) {
        return;
      }

      updateGeometry(this);
      processScrollDiff(this, 'top', this.element.scrollTop - this.lastScrollTop);
      processScrollDiff(this, 'left', this.element.scrollLeft - this.lastScrollLeft);
      this.lastScrollTop = Math.floor(this.element.scrollTop);
      this.lastScrollLeft = this.element.scrollLeft;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (!this.isAlive) {
        return;
      }

      this.event.unbindAll();
      remove(this.scrollbarX);
      remove(this.scrollbarY);
      remove(this.scrollbarXRail);
      remove(this.scrollbarYRail);
      this.removePsClasses(); // unset elements

      this.element = null;
      this.scrollbarX = null;
      this.scrollbarY = null;
      this.scrollbarXRail = null;
      this.scrollbarYRail = null;
      this.isAlive = false;
    }
  }, {
    key: "removePsClasses",
    value: function removePsClasses() {
      this.element.className = this.element.className.split(' ').filter(function (name) {
        return !name.match(/^ps([-_].+|)$/);
      }).join(' ');
    }
  }]);

  return PerfectScrollbar;
}();

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

/** @license React v16.14.0
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var reactJsxRuntime_production_min = createCommonjsModule(function (module, exports) {
var g=60103;exports.Fragment=60107;if("function"===typeof Symbol&&Symbol.for){var h=Symbol.for;g=h("react.element");exports.Fragment=h("react.fragment");}var m=React__default['default'].__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,n=Object.prototype.hasOwnProperty,p={key:!0,ref:!0,__self:!0,__source:!0};
function q(c,a,k){var b,d={},e=null,l=null;void 0!==k&&(e=""+k);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(l=a.ref);for(b in a)n.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return {$$typeof:g,type:c,key:e,ref:l,props:d,_owner:m.current}}exports.jsx=q;exports.jsxs=q;
});

/** @license React v16.14.0
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var reactJsxRuntime_development = createCommonjsModule(function (module, exports) {

if (process.env.NODE_ENV !== "production") {
  (function() {

var React = React__default['default'];

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  symbolFor('react.scope');
  symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = '';

    if (currentlyValidatingElement) {
      var name = getComponentName(currentlyValidatingElement.type);
      var owner = currentlyValidatingElement._owner;
      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
    }

    stack += ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}


var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
function describeComponentFrame (name, source, ownerName) {
  var sourceInfo = '';

  if (source) {
    var path = source.fileName;
    var fileName = path.replace(BEFORE_SLASH_RE, '');

    {
      // In DEV, include code for a common special case:
      // prefer "folder/index.js" instead of just "index.js".
      if (/^index\./.test(fileName)) {
        var match = path.match(BEFORE_SLASH_RE);

        if (match) {
          var pathBeforeSlash = match[1];

          if (pathBeforeSlash) {
            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
            fileName = folderName + '/' + fileName;
          }
        }
      }
    }

    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
  } else if (ownerName) {
    sourceInfo = ' (created by ' + ownerName + ')';
  }

  return '\n    in ' + (name || 'Unknown') + sourceInfo;
}

var Resolved = 1;
function refineResolvedLazyComponent(lazyComponent) {
  return lazyComponent._status === Resolved ? lazyComponent._result : null;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return "Profiler";

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return 'Context.Consumer';

      case REACT_PROVIDER_TYPE:
        return 'Context.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type.render);

      case REACT_LAZY_TYPE:
        {
          var thenable = type;
          var resolvedThenable = refineResolvedLazyComponent(thenable);

          if (resolvedThenable) {
            return getComponentName(resolvedThenable);
          }

          break;
        }
    }
  }

  return null;
}

var loggedTypeFailures = {};
ReactSharedInternals.ReactDebugCurrentFrame;
var currentlyValidatingElement = null;

function setCurrentlyValidatingElement(element) {
  {
    currentlyValidatingElement = element;
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  currentlyValidatingElement = element;
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentName(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (Array.isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === exports.Fragment) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev
// even with the prod transform. This means that jsxDEV is purely
// opt-in behavior for better messages but that we won't stop
// giving you warnings if you use production apis.

function jsxWithValidationStatic(type, props, key) {
  {
    return jsxWithValidation(type, props, key, true);
  }
}
function jsxWithValidationDynamic(type, props, key) {
  {
    return jsxWithValidation(type, props, key, false);
  }
}

var jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.
// for now we can ship identical prod functions

var jsxs =  jsxWithValidationStatic ;

exports.jsx = jsx;
exports.jsxs = jsxs;
  })();
}
});

var jsxRuntime = createCommonjsModule(function (module) {

if (process.env.NODE_ENV === 'production') {
  module.exports = reactJsxRuntime_production_min;
} else {
  module.exports = reactJsxRuntime_development;
}
});

var _excluded$F = ["className", "style", "option", "options", "containerRef", "onScrollY", "onScrollX", "onScrollUp", "onScrollDown", "onScrollLeft", "onScrollRight", "onYReachStart", "onYReachEnd", "onXReachStart", "onXReachEnd", "component", "onSync", "children"];
var handlerNameByEvent = {
  'ps-scroll-y': 'onScrollY',
  'ps-scroll-x': 'onScrollX',
  'ps-scroll-up': 'onScrollUp',
  'ps-scroll-down': 'onScrollDown',
  'ps-scroll-left': 'onScrollLeft',
  'ps-scroll-right': 'onScrollRight',
  'ps-y-reach-start': 'onYReachStart',
  'ps-y-reach-end': 'onYReachEnd',
  'ps-x-reach-start': 'onXReachStart',
  'ps-x-reach-end': 'onXReachEnd'
};
Object.freeze(handlerNameByEvent);

var ScrollBar = /*#__PURE__*/function (_Component) {
  _inherits(ScrollBar, _Component);

  var _super = _createSuper(ScrollBar);

  function ScrollBar(props) {
    var _this;

    _classCallCheck(this, ScrollBar);

    _this = _super.call(this, props);
    _this.handleRef = _this.handleRef.bind(_assertThisInitialized(_this));
    _this._handlerByEvent = {};
    return _this;
  }

  _createClass(ScrollBar, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.option) {
        console.warn('react-perfect-scrollbar: the "option" prop has been deprecated in favor of "options"');
      }

      this._ps = new PerfectScrollbar(this._container, this.props.options || this.props.option); // hook up events

      this._updateEventHook();

      this._updateClassName();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      this._updateEventHook(prevProps);

      this.updateScroll();

      if (prevProps.className !== this.props.className) {
        this._updateClassName();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this2 = this;

      // unhook up evens
      Object.keys(this._handlerByEvent).forEach(function (key) {
        var value = _this2._handlerByEvent[key];

        if (value) {
          _this2._container.removeEventListener(key, value, false);
        }
      });
      this._handlerByEvent = {};

      this._ps.destroy();

      this._ps = null;
    }
  }, {
    key: "_updateEventHook",
    value: function _updateEventHook() {
      var _this3 = this;

      var prevProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // hook up events
      Object.keys(handlerNameByEvent).forEach(function (key) {
        var callback = _this3.props[handlerNameByEvent[key]];
        var prevCallback = prevProps[handlerNameByEvent[key]];

        if (callback !== prevCallback) {
          if (prevCallback) {
            var prevHandler = _this3._handlerByEvent[key];

            _this3._container.removeEventListener(key, prevHandler, false);

            _this3._handlerByEvent[key] = null;
          }

          if (callback) {
            var handler = function handler() {
              return callback(_this3._container);
            };

            _this3._container.addEventListener(key, handler, false);

            _this3._handlerByEvent[key] = handler;
          }
        }
      });
    }
  }, {
    key: "_updateClassName",
    value: function _updateClassName() {
      var className = this.props.className;

      var psClassNames = this._container.className.split(' ').filter(function (name) {
        return name.match(/^ps([-_].+|)$/);
      }).join(' ');

      if (this._container) {
        this._container.className = "scrollbar-container".concat(className ? " ".concat(className) : '').concat(psClassNames ? " ".concat(psClassNames) : '');
      }
    }
  }, {
    key: "updateScroll",
    value: function updateScroll() {
      this.props.onSync && this.props.onSync(this._ps);
    }
  }, {
    key: "handleRef",
    value: function handleRef(ref) {
      this._container = ref;
      this.props.containerRef(ref);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props;
          _this$props.className;
          var style = _this$props.style;
          _this$props.option;
          _this$props.options;
          _this$props.containerRef;
          _this$props.onScrollY;
          _this$props.onScrollX;
          _this$props.onScrollUp;
          _this$props.onScrollDown;
          _this$props.onScrollLeft;
          _this$props.onScrollRight;
          _this$props.onYReachStart;
          _this$props.onYReachEnd;
          _this$props.onXReachStart;
          _this$props.onXReachEnd;
          var component = _this$props.component;
          _this$props.onSync;
          var children = _this$props.children,
          remainProps = _objectWithoutProperties(_this$props, _excluded$F);

      var Comp = component;
      return /*#__PURE__*/jsxRuntime.jsx(Comp, _objectSpread2(_objectSpread2({
        style: style,
        ref: this.handleRef
      }, remainProps), {}, {
        children: children
      }));
    }
  }]);

  return ScrollBar;
}(React.Component);
ScrollBar.defaultProps = {
  className: '',
  style: undefined,
  option: undefined,
  options: undefined,
  containerRef: function containerRef() {},
  onScrollY: undefined,
  onScrollX: undefined,
  onScrollUp: undefined,
  onScrollDown: undefined,
  onScrollLeft: undefined,
  onScrollRight: undefined,
  onYReachStart: undefined,
  onYReachEnd: undefined,
  onXReachStart: undefined,
  onXReachEnd: undefined,
  onSync: function onSync(ps) {
    return ps.update();
  },
  component: 'div'
};
ScrollBar.propTypes = {
  children: PropTypes.PropTypes.node.isRequired,
  className: PropTypes.PropTypes.string,
  style: PropTypes.PropTypes.object,
  option: PropTypes.PropTypes.object,
  options: PropTypes.PropTypes.object,
  containerRef: PropTypes.PropTypes.func,
  onScrollY: PropTypes.PropTypes.func,
  onScrollX: PropTypes.PropTypes.func,
  onScrollUp: PropTypes.PropTypes.func,
  onScrollDown: PropTypes.PropTypes.func,
  onScrollLeft: PropTypes.PropTypes.func,
  onScrollRight: PropTypes.PropTypes.func,
  onYReachStart: PropTypes.PropTypes.func,
  onYReachEnd: PropTypes.PropTypes.func,
  onXReachStart: PropTypes.PropTypes.func,
  onXReachEnd: PropTypes.PropTypes.func,
  onSync: PropTypes.PropTypes.func,
  component: PropTypes.PropTypes.string
};

var _excluded$E = ["scrollX", "scrollY", "children"];
var ScrollView = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _props$scrollX = props.scrollX,
      scrollX = _props$scrollX === void 0 ? true : _props$scrollX,
      _props$scrollY = props.scrollY,
      scrollY = _props$scrollY === void 0 ? true : _props$scrollY,
      children = props.children,
      ScrollViewProps = _objectWithoutProperties(props, _excluded$E);

  return /*#__PURE__*/jsxRuntime.jsx(ScrollBar, _objectSpread2(_objectSpread2({}, ScrollViewProps), {}, {
    ref: ref,
    options: {
      suppressScrollX: !scrollX,
      suppressScrollY: !scrollY
    },
    containerRef: function containerRef(ref) {
      if (ref) {
        // fix scroll exceed content
        ref._getBoundingClientRect = ref.getBoundingClientRect;

        ref.getBoundingClientRect = function () {
          var original = ref._getBoundingClientRect();

          return _objectSpread2(_objectSpread2({}, original), {}, {
            height: Math.round(original.height),
            width: Math.round(original.width)
          });
        }; // set external ref


        props.containerRef && props.containerRef(ref);
      }
    },
    children: children
  }));
});
ScrollView.displayName = 'ScrollView';

/**
 * Hook to create a React Portal.
 * Automatically handles creating and tearing-down the root elements (no SRR
 * makes this trivial), so there is no need to ensure the parent target already
 * exists.
 * @example
 * const target = usePortal(id, [id]);
 * return createPortal(children, target);
 * @param {String} id The id of the target container, e.g 'modal' or 'spotlight'
 * @returns {HTMLElement} The DOM node to use as the Portal target.
 */
var usePortal = function usePortal(params) {
  var id = params.id;
  var rootElemRef = React.useRef(null);

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isMounted = _useState2[0],
      setMount = _useState2[1];

  React.useLayoutEffect(function () {
    // * ============= Setup element ==============
    // Look for existing target dom element to append to
    var existingParent = document.querySelector("#".concat(id)) || document.getElementById('modal-root'); // Parent is either a new root or the existing dom element

    var parentElem = existingParent || createRootElement(id) || 'modal-root'; // If there is no existing DOM element, add a new one.

    !existingParent && addRootElement(parentElem); // Add the detached element to the parent

    rootElemRef.current && parentElem.appendChild(rootElemRef.current);
    setMount(true);
    return function () {
      var _rootElemRef$current;

      // * ============= Remove Element ==============
      (_rootElemRef$current = rootElemRef.current) === null || _rootElemRef$current === void 0 ? void 0 : _rootElemRef$current.remove();

      if (!parentElem.childElementCount) {
        parentElem.remove();
      }
    };
  }, [id]);
  /**
   * It's important we evaluate this lazily:
   * - We need first render to contain the DOM element, so it shouldn't happen
   *   in useEffect. We would normally put this in the constructor().
   * - We can't do 'const rootElemRef = useRef(document.createElement('div))',
   *   since this will run every single render (that's a lot).
   * - We want the ref to consistently point to the same DOM element and only
   *   ever run once.
   * @link https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily
   */

  var getRootElem = function getRootElem() {
    if (!rootElemRef.current) {
      rootElemRef.current = document.createElement('div');
    }

    return rootElemRef.current;
  };

  return {
    isMounted: isMounted,
    target: getRootElem()
  };
};

var createRootElement = function createRootElement(id) {
  var rootContainer = document.createElement('div');
  rootContainer.setAttribute('id', id || 'modal-root');
  return rootContainer;
};
/**
 * Appends element as last child of body.
 * @param {HTMLElement} rootElem
 */


var addRootElement = function addRootElement(rootElem) {
  var appContainer = document.getElementById('appContainer');

  if (!appContainer) {
    return;
  }

  appContainer.appendChild(rootElem);
};

var Overlay = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var id = props.id,
      className = props.className,
      innerClassName = props.innerClassName,
      children = props.children,
      _props$width = props.width,
      width = _props$width === void 0 ? '' : _props$width,
      _props$height = props.height,
      height = _props$height === void 0 ? 'auto' : _props$height,
      _props$backdrop = props.backdrop,
      backdrop = _props$backdrop === void 0 ? true : _props$backdrop,
      fullscreen = props.fullscreen,
      onBackgroundClick = props.onBackgroundClick,
      onBackgroundMouseMove = props.onBackgroundMouseMove,
      _props$overlayMainSty = props.overlayMainStyle,
      overlayMainStyle = _props$overlayMainSty === void 0 ? {} : _props$overlayMainSty,
      hasAnchor = props.hasAnchor;

  var _usePortal = usePortal({
    id: id
  }),
      isMounted = _usePortal.isMounted,
      target = _usePortal.target;

  var defaultStyles = {
    width: fullscreen ? '100%' : width,
    maxWidth: fullscreen ? '' : '90%',
    height: fullscreen ? '100%' : height,
    maxHeight: fullscreen ? '' : '90%',
    minWidth: width || 130
  };
  var wrapperClassNames = clsx__default['default']('app-overlay', {
    'overlay-popover': hasAnchor,
    'no-background': !backdrop
  }, className);
  var innerClassNames = clsx__default['default']('overlay-main', {
    'overlay-main--fullscreen': fullscreen
  }, innerClassName);

  var content = /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: wrapperClassNames,
    children: [backdrop && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'overlay-background',
      onMouseDown: onBackgroundClick,
      onMouseMove: onBackgroundMouseMove
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      ref: ref,
      className: innerClassNames,
      style: _objectSpread2(_objectSpread2({}, defaultStyles), overlayMainStyle),
      children: isMounted && children
    })]
  });

  return /*#__PURE__*/ReactDOM.createPortal(content, target);
});

/**
 * Hook to calculate AnchorOverlay's wrapped element position.
 *
 * Placement system is base on ant-design popover: {@link https://ant.design/components/popover/#header Ant-design's popover placement system}.
 * Supported feature:
 * - Automatically flip wrapped element in out of screen cases.
 * - Automatically align wrapped element if wrapped element's height is longer than anchor coordinate and related screen's border distance.
 * - Automatically add scroll-bar (vertically) when wrapped element's height is longer than view-port's height (vertical alignment case).
 * - Automatically add scroll-bar (vertically) when wrapped element's height is longer than the longest distance between anchor coordinate and screen's border (vertical direction case).

 * @example
 * const { overlayMainStyle, scrollBarStyle } = useAnchorHandle({ wrappedElement, anchorElement, anchorPosition, placement });
 * @returns overlayMainStyle and scrollbarStyle
 */
var useAnchorHandle = function useAnchorHandle(params) {
  var anchorElement = params.anchorElement,
      wrappedElement = params.wrappedElement,
      anchorPosition = params.anchorPosition,
      dynamicContent = params.dynamicContent,
      _params$placement = params.placement,
      placement = _params$placement === void 0 ? 'bottom-left' : _params$placement;

  var _useState = React.useState({}),
      _useState2 = _slicedToArray(_useState, 2),
      overlayStyle = _useState2[0],
      setOverlayStyle = _useState2[1];

  var _useState3 = React.useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      scrollBarStyle = _useState4[0],
      setScrollBarStyle = _useState4[1];

  var _useState5 = React.useState({
    width: 0,
    height: 0
  }),
      _useState6 = _slicedToArray(_useState5, 2),
      observerSize = _useState6[0],
      setObserverSize = _useState6[1];

  React.useEffect(function () {
    if (!dynamicContent || !wrappedElement) {
      return;
    }

    var resizeObserver = new ResizeObserver(function (entries) {
      var _iterator = _createForOfIteratorHelper(entries),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var entry = _step.value;

          if (entry.contentRect) {
            setObserverSize({
              width: entry.contentRect.width,
              height: entry.contentRect.height
            });
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
    resizeObserver.observe(wrappedElement);
    return function () {
      return resizeObserver.unobserve(wrappedElement);
    };
  }, [wrappedElement, dynamicContent]);
  React.useLayoutEffect(function () {
    if (!wrappedElement) {
      return setOverlayStyle({});
    }

    var anchorCoordinate = getAnchorCoordinate(anchorPosition, anchorElement);
    var wrappedElementCoordinate = getWrappedElementCoordinateByPlacement(wrappedElement, anchorCoordinate, placement);
    var suitablePlacement = getSuitablePlacementByCoordinate(placement, wrappedElement, wrappedElementCoordinate); // Automatically flip wrapped element in out of screen cases.

    var suitableCoordinate = getWrappedElementCoordinateByPlacement(wrappedElement, anchorCoordinate, suitablePlacement); // Automatically attach wrapped element (horizontally) to nearest screen border (of flipped placement) if original & flipped placement out of screen.

    var isStillOutOfScreen = checkOutOfScreen(wrappedElement, suitableCoordinate);
    var adjustments = {};

    if (isStillOutOfScreen !== null && isStillOutOfScreen !== void 0 && isStillOutOfScreen.horizontal) {
      var left = suitableCoordinate.left;
      var horizontalAttach = !!left && (left < 0 && 'left' || left + wrappedElement.offsetWidth > window.innerWidth && 'right');
      wrappedElement.setAttribute('data-placement', suitablePlacement);

      if (horizontalAttach) {
        adjustments[horizontalAttach] = 0;
        adjustments[flipItem(horizontalAttach)] = undefined; // Remove opposite property
      }
    } // Automatically attach wrapped element (vertically) to nearest screen border if wrapped element's height is longer than anchor coordinate and related screen's border distance.
    // Automatically add scroll-bar (vertically) when wrapped element's height is longer than view-port's height (vertical alignment case).


    var VERTICAL_ALIGNMENT_CASES = ['left-top', 'left-bottom', 'right-top', 'right-bottom', 'left', 'right'];

    if (VERTICAL_ALIGNMENT_CASES.includes(placement) && checkOutOfScreen(wrappedElement, wrappedElementCoordinate)) {
      var _ref = checkOutOfScreen(wrappedElement, wrappedElementCoordinate),
          horizontal = _ref.horizontal;

      var _ref2 = !horizontal ? wrappedElementCoordinate : getWrappedElementCoordinateByPlacement(wrappedElement, anchorCoordinate, suitablePlacement),
          _left = _ref2.left,
          top = _ref2.top;

      var verticalAttach = !!top && (top < 0 && 'top' || top + wrappedElement.offsetHeight > window.innerHeight && 'bottom');

      if (verticalAttach) {
        setScrollBarStyle({
          maxHeight: window.innerHeight
        });
        setOverlayStyle(function (prev) {
          var _objectSpread2$1;

          return _objectSpread2(_objectSpread2({}, prev), {}, (_objectSpread2$1 = {
            left: _left
          }, _defineProperty$1(_objectSpread2$1, "".concat(verticalAttach), 0), _defineProperty$1(_objectSpread2$1, "maxHeight", '100%'), _objectSpread2$1), adjustments);
        });
        return;
      }
    } // Automatically add scroll-bar (vertically) when wrapped element's height is longer than
    // the longest distance between anchor coordinate and screen's border (vertical direction case).


    var HORIZONTAL_DIRECTION_CASES = ['top-left', 'top', 'top-right', 'bottom-left', 'bottom', 'bottom-right'];

    if (HORIZONTAL_DIRECTION_CASES.includes(suitablePlacement) && getPlacementDirection(suitablePlacement) !== getPlacementDirection(placement)) {
      var _compareVerticalViewP = compareVerticalViewPortDistance(anchorCoordinate, suitablePlacement),
          detectedPlacement = _compareVerticalViewP.detectedPlacement,
          maxHeight = _compareVerticalViewP.maxHeight;

      var _detectedPlacement$sp = detectedPlacement.split('-'),
          _detectedPlacement$sp2 = _slicedToArray(_detectedPlacement$sp, 1),
          detectedDirection = _detectedPlacement$sp2[0];

      var detectedCoordinate = getWrappedElementCoordinateByPlacement(wrappedElement, anchorCoordinate, detectedPlacement);
      var isOutOfScreen = checkOutOfScreen(wrappedElement, detectedCoordinate);

      if (isOutOfScreen !== null && isOutOfScreen !== void 0 && isOutOfScreen.vertical) {
        setOverlayStyle(function (prev) {
          return _objectSpread2(_objectSpread2(_objectSpread2({}, prev), detectedCoordinate), {}, _defineProperty$1({
            maxHeight: maxHeight
          }, "".concat(detectedDirection), 0), adjustments);
        });
        setScrollBarStyle({
          maxHeight: maxHeight
        });
        return;
      }
    }

    if (suitablePlacement === placement) {
      setOverlayStyle(function (prev) {
        return _objectSpread2(_objectSpread2(_objectSpread2({}, prev), wrappedElementCoordinate), adjustments);
      });
      return;
    }

    setOverlayStyle(function (prev) {
      return _objectSpread2(_objectSpread2(_objectSpread2({}, prev), suitableCoordinate), adjustments);
    });
  }, [wrappedElement, anchorElement, anchorPosition, placement, observerSize]);
  return {
    overlayMainStyle: overlayStyle,
    scrollBarStyle: scrollBarStyle
  };
};

var getWrappedElementCoordinateByPlacement = function getWrappedElementCoordinateByPlacement(wrappedElement, anchorCoordinate, placement) {
  var anchorCoordinateByPlacement = generateAnchorCoordinateByPlacement(anchorCoordinate, placement);
  var wrappedElementCoordinateByPlacement = generateCoordinateByWrappedElement(wrappedElement, placement, anchorCoordinateByPlacement);
  return wrappedElementCoordinateByPlacement;
};

var getSuitablePlacementByCoordinate = function getSuitablePlacementByCoordinate(placement, wrappedElement, wrappedElementCoordinate) {
  var isOutOfScreen = checkOutOfScreen(wrappedElement, wrappedElementCoordinate);
  var suitablePlacement = detectSuitablePlacement(placement, isOutOfScreen);
  return suitablePlacement;
};

var getPlacementDirection = function getPlacementDirection(placement) {
  var _placement$split = placement.split('-'),
      _placement$split2 = _slicedToArray(_placement$split, 1),
      direction = _placement$split2[0];

  return direction;
};

var generateAnchorCoordinateByPlacement = function generateAnchorCoordinateByPlacement(anchorCoordinate, placement) {
  var x = anchorCoordinate.x,
      _anchorCoordinate$y = anchorCoordinate.y,
      y = _anchorCoordinate$y === void 0 ? 0 : _anchorCoordinate$y,
      width = anchorCoordinate.width,
      height = anchorCoordinate.height;

  var _placementCalculator = placementCalculator({
    placement: placement,
    width: width,
    height: height
  }),
      complementX = _placementCalculator.complementX,
      complementY = _placementCalculator.complementY;

  return _objectSpread2(_objectSpread2({}, isDefined(x) && {
    left: x + complementX
  }), isDefined(y) && {
    top: y + complementY
  });
};

var generateCoordinateByWrappedElement = function generateCoordinateByWrappedElement(wrappedElement, placement, anchorCoordinate) {
  if (!wrappedElement) {
    return anchorCoordinate;
  }

  var _ref3 = placement.split('-'),
      _ref4 = _slicedToArray(_ref3, 2),
      direction = _ref4[0],
      alignment = _ref4[1];

  var _wrappedElement$getBo = wrappedElement.getBoundingClientRect(),
      width = _wrappedElement$getBo.width,
      height = _wrappedElement$getBo.height;

  var complementX = !alignment && ['bottom', 'top'].includes(direction) ? -(width / 2) : direction === 'left' || alignment === 'right' ? -width : 0;
  var complementY = !alignment && ['left', 'right'].includes(direction) ? -(height / 2) : direction === 'top' || alignment === 'bottom' ? -height : 0;
  return _objectSpread2(_objectSpread2({}, isDefined(anchorCoordinate.left) && {
    left: anchorCoordinate.left + complementX
  }), isDefined(anchorCoordinate.top) && {
    top: anchorCoordinate.top + complementY
  });
};

var checkOutOfScreen = function checkOutOfScreen(wrappedElement, wrappedElementCoordinate) {
  var _wrappedElement$getBo2;

  var _wrappedElementCoordi = wrappedElementCoordinate.left,
      left = _wrappedElementCoordi === void 0 ? 0 : _wrappedElementCoordi,
      _wrappedElementCoordi2 = wrappedElementCoordinate.top,
      top = _wrappedElementCoordi2 === void 0 ? 0 : _wrappedElementCoordi2;

  var _ref5 = (_wrappedElement$getBo2 = wrappedElement === null || wrappedElement === void 0 ? void 0 : wrappedElement.getBoundingClientRect()) !== null && _wrappedElement$getBo2 !== void 0 ? _wrappedElement$getBo2 : {},
      height = _ref5.height,
      width = _ref5.width;

  var isOutOfScreenHorizontal = left + (width !== null && width !== void 0 ? width : 0) > window.innerWidth || left < 0;
  var isOutOfScreenVertical = top + (height !== null && height !== void 0 ? height : 0) > window.innerHeight || top < 0;

  if (!isOutOfScreenVertical && !isOutOfScreenHorizontal) {
    return;
  }

  return {
    vertical: isOutOfScreenVertical,
    horizontal: isOutOfScreenHorizontal
  };
};

var isDefined = function isDefined(value) {
  return typeof value !== 'undefined';
};

var detectSuitablePlacement = function detectSuitablePlacement(placement, isOutOfScreen) {
  if (!isOutOfScreen) {
    return placement;
  }

  var HORIZONTAL_DIR = ['left', 'right'];
  var VERTICAL_DIR = ['top', 'bottom'];

  var _ref6 = placement.split('-'),
      _ref7 = _slicedToArray(_ref6, 2),
      direction = _ref7[0],
      alignment = _ref7[1];

  var flippedDirection = isOutOfScreen.horizontal && HORIZONTAL_DIR.includes(direction) || isOutOfScreen.vertical && VERTICAL_DIR.includes(direction) ? flipItem(direction) : direction;

  if (!alignment) {
    return flippedDirection;
  }

  var flippedAlignment = isOutOfScreen.horizontal && HORIZONTAL_DIR.includes(alignment) || isOutOfScreen.vertical && VERTICAL_DIR.includes(alignment) ? flipItem(alignment) : alignment;
  return "".concat(flippedDirection, "-").concat(flippedAlignment);
};

var flipItem = function flipItem(item) {
  var MAPPED_OPPOSITE_DIRECTION = {
    top: 'bottom',
    bottom: 'top',
    left: 'right',
    right: 'left'
  };
  return MAPPED_OPPOSITE_DIRECTION[item];
};

var getAnchorCoordinate = function getAnchorCoordinate(anchorPosition, anchorEl) {
  var _ref8, _anchorEl$getBounding;

  return (_ref8 = (_anchorEl$getBounding = anchorEl === null || anchorEl === void 0 ? void 0 : anchorEl.getBoundingClientRect()) !== null && _anchorEl$getBounding !== void 0 ? _anchorEl$getBounding : anchorPosition) !== null && _ref8 !== void 0 ? _ref8 : {};
};

var placementCalculator = function placementCalculator(params) {
  var placement = params.placement,
      _params$width = params.width,
      width = _params$width === void 0 ? 0 : _params$width,
      _params$height = params.height,
      height = _params$height === void 0 ? 0 : _params$height;
  var MAPPED_COMPLEMENT = {
    'bottom-left': {
      complementX: 0,
      complementY: height
    },
    'bottom': {
      complementX: width / 2,
      complementY: height
    },
    'bottom-right': {
      complementX: width,
      complementY: height
    },
    'top-left': {
      complementX: 0,
      complementY: 0
    },
    'top': {
      complementX: width / 2,
      complementY: 0
    },
    'top-right': {
      complementX: width,
      complementY: 0
    },
    'left-top': {
      complementX: 0,
      complementY: 0
    },
    'left': {
      complementX: 0,
      complementY: height / 2
    },
    'left-bottom': {
      complementX: 0,
      complementY: height
    },
    'right-top': {
      complementX: width,
      complementY: 0
    },
    'right': {
      complementX: width,
      complementY: height / 2
    },
    'right-bottom': {
      complementX: width,
      complementY: height
    }
  };
  return MAPPED_COMPLEMENT[placement];
};

var compareVerticalViewPortDistance = function compareVerticalViewPortDistance(anchorCoordinate, placement) {
  var _anchorCoordinate$y2 = anchorCoordinate.y,
      topDistance = _anchorCoordinate$y2 === void 0 ? 0 : _anchorCoordinate$y2,
      _anchorCoordinate$hei = anchorCoordinate.height,
      height = _anchorCoordinate$hei === void 0 ? 0 : _anchorCoordinate$hei;
  var bottomDistance = window.innerHeight - (topDistance + height); // eslint-disable-next-line @typescript-eslint/no-unused-vars

  var _ref9 = placement.split('-'),
      _ref10 = _slicedToArray(_ref9, 2);
      _ref10[0];
      var alignment = _ref10[1];

  var isBottomLonger = bottomDistance > topDistance;
  var newDirection = isBottomLonger ? 'bottom' : 'top';
  var newPlacement = !alignment ? newDirection : [newDirection, alignment].join('-');
  var maxHeight = isBottomLonger ? bottomDistance : topDistance;
  return {
    detectedPlacement: newPlacement,
    maxHeight: maxHeight
  };
};

var _excluded$D = ["anchorEl", "position", "children", "placement", "scroll", "dynamicContent"];

/**
 * AnchorOverlay component execute useAnchorHandle hook to calculate children position
 *
 * @param placement Define placement of children compare to anchor coordinate.
 * @param scroll Enable/Disable automatic adding scroll-bar feature.
 * @param anchorEl The anchor element ref which contain coordinate (x, y) and size (width, height) for calculate where wrapped element should locale
 * @param position The coordinate point (x,y) for wrapped element locate
 * @param wrappedEl This is OverlayMain div which is the container of AnchorOverlay's wrapped element.
 * @returns Overlay component width detected child position
 */
var AnchorOverlay = /*#__PURE__*/React.forwardRef(function (props, _ref) {
  var anchorEl = props.anchorEl,
      position = props.position,
      children = props.children,
      placement = props.placement,
      _props$scroll = props.scroll,
      scroll = _props$scroll === void 0 ? true : _props$scroll,
      dynamicContent = props.dynamicContent,
      rest = _objectWithoutProperties(props, _excluded$D);

  var wrappedEl = React.useRef(null);

  var _useAnchorHandle = useAnchorHandle({
    wrappedElement: wrappedEl.current,
    anchorElement: anchorEl === null || anchorEl === void 0 ? void 0 : anchorEl.current,
    anchorPosition: position,
    placement: placement,
    dynamicContent: dynamicContent
  }),
      overlayMainStyle = _useAnchorHandle.overlayMainStyle,
      scrollBarStyle = _useAnchorHandle.scrollBarStyle;

  return /*#__PURE__*/jsxRuntime.jsxs(Overlay, _objectSpread2(_objectSpread2({}, rest), {}, {
    ref: function ref(element) {
      if (typeof _ref === 'function') {
        _ref(element);
      } else if (_ref) {
        _ref.current = element;
      }

      wrappedEl.current = element;
    },
    overlayMainStyle: overlayMainStyle,
    hasAnchor: true,
    children: [scroll && scrollBarStyle && /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
      children: children
    }), (!scroll || !scrollBarStyle) && children]
  }));
});

var HttpClient = /*#__PURE__*/function () {
  function HttpClient() {
    _classCallCheck(this, HttpClient);
  }

  _createClass(HttpClient, [{
    key: "get",
    value: function get(url) {
      var header = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      return fetch(url, {
        method: 'GET',
        headers: new Headers(header || {
          'Content-Type': 'application/json'
        })
      }).then(this.checkStatus).then(this.parseJSON).then(this.checkError).then(cb);
    }
  }, {
    key: "getImage",
    value: function getImage(url) {
      var header = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      return fetch(url, {
        method: 'GET',
        headers: new Headers(header || {
          'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8'
        })
      }).then(this.checkStatus).then(this.checkError).then(cb);
    }
  }, {
    key: "post",
    value: function post(url, data) {
      var header = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
      return fetch(url, {
        method: 'POST',
        headers: new Headers(header || {
          'Content-Type': 'application/json'
        }),
        body: JSON.stringify(data)
      }).then(this.checkStatus).then(this.parseJSON).then(this.checkError).then(cb);
    }
  }, {
    key: "postFile",
    value: function postFile(url, formData) {
      var header = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
      return fetch(url, {
        method: 'POST',
        headers: header,
        body: formData
      }).then(this.checkStatus).then(this.parseJSON).then(this.checkError).then(cb);
    }
  }, {
    key: "patch",
    value: function patch(url, data) {
      var header = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
      return fetch(url, {
        method: 'PATCH',
        headers: new Headers(header || {
          'Content-Type': 'application/json'
        }),
        body: JSON.stringify(data)
      }).then(this.checkStatus).then(this.parseJSON).then(this.checkError).then(cb);
    }
  }, {
    key: "put",
    value: function put(url, data) {
      var header = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
      return fetch(url, {
        method: 'PUT',
        headers: new Headers(header || {
          'Content-Type': 'application/json'
        }),
        body: JSON.stringify(data)
      }).then(this.checkStatus).then(this.parseJSON).then(this.checkError).then(cb);
    }
  }, {
    key: "delete",
    value: function _delete(url, data) {
      var header = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
      return fetch(url, {
        method: 'DELETE',
        headers: new Headers(header || {
          'Content-Type': 'application/json'
        }),
        body: data ? JSON.stringify(data) : null
      }).then(this.checkStatus).then(this.parseJSON).then(this.checkError).then(cb);
    }
  }, {
    key: "checkStatus",
    value: function checkStatus(response) {
      if (response.status >= 200 && response.status < 300) {
        return response;
      }

      var error = new Error("HTTP Error ".concat(response.statusText));
      error.status = response.statusText;
      error.response = response; // throw error;

      return response;
    }
  }, {
    key: "parseJSON",
    value: function parseJSON(response) {
      return response.json();
    }
  }, {
    key: "checkError",
    value: function checkError(response) {
      if (response && response.error) {
        // todo: add dialog style later
        // alert(response.error.message);
        return null;
      }

      return response;
    }
  }]);

  return HttpClient;
}();

var OverflowContent = function OverflowContent(props) {
  return /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
    className: "overflow-container",
    children: props.children
  });
};

/**
 * Convert Strings from camelCase to kebab-case
 * @returns {string}
 * @param input
 */
var camelToKebab = function camelToKebab(input) {
  return input.replace(/[A-Z]+(?![a-z])|[A-Z]/g, function (match, offset) {
    return (offset > 0 ? '-' : '') + match;
  }).toLowerCase();
};

/**
 *
 * Cache the results of pure function
 *
 */
function memoize$1(fn) {
  var cache = {};
  return function () {
    var key = [arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1]];

    if (cache[key] === undefined) {
      cache[key] = fn.apply(void 0, arguments);
    }

    return cache[key];
  };
}

var breakpoints = {
  'xs': 0,
  'mobile': 576,
  'tablet': 768,
  'desktopSm': 992,
  'desktop': 1024,
  '1280': 1280,
  '1440': 1440,
  'hd': 1600,
  '1800': 1800,
  'wqhd': 2500,
  '4k': 4000,
  '5k': 5100
};

var margin = {
  m: 'margin'
};
var padding = {
  p: 'padding'
};
var directions = {
  t: 'Top',
  r: 'Right',
  b: 'Bottom',
  l: 'Left',
  x: ['Left', 'Right'],
  y: ['Top', 'Bottom']
};
var spaceBetween = {
  spaceBetweenX: 'mx',
  spaceBetweenY: 'my'
};
var spaceBetweenCssVarReverse = {
  spaceBetweenXReverse: '--space-x-reverse',
  spaceBetweenYReverse: '--space-y-reverse'
};

var spaceBetweenCssVar = _objectSpread2(_objectSpread2({}, spaceBetweenCssVarReverse), {}, {
  spaceBetweenX: '--space-x-reverse',
  spaceBetweenY: '--space-y-reverse'
});

var spaceBetweenSelector = {
  spaceBetweenX: '> * + *',
  spaceBetweenY: '> * + *',
  spaceBetweenXReverse: '> * + *',
  spaceBetweenYReverse: '> * + *'
};
var spacingSystem = {
  px: '1px',
  0: '0',
  0.5: '0.125rem',
  1: '0.25rem',
  1.5: '0.375rem',
  2: '0.5rem',
  2.5: '0.625rem',
  3: '0.75rem',
  3.5: '0.875rem',
  4: '1rem',
  5: '1.25rem',
  6: '1.5rem',
  7: '1.75rem',
  8: '2rem',
  9: '2.25rem',
  10: '2.5rem',
  11: '2.75rem',
  12: '3rem',
  14: '3.5rem',
  16: '4rem',
  20: '5rem',
  24: '6rem',
  28: '7rem',
  32: '8rem',
  36: '9rem',
  40: '10rem',
  44: '11rem',
  48: '12rem',
  52: '13rem',
  56: '14rem',
  60: '15rem',
  64: '16rem',
  72: '18rem',
  80: '20rem',
  96: '24rem'
};

var getVal = function getVal(value) {
  value = value.toString();

  if (value[0] === '-') {
    return '-' + spacingSystem[value.slice(1)];
  }

  return spacingSystem[value] + ' !important';
};

var getSpaceBetweenVal = function getSpaceBetweenVal(value, key) {
  return ['0', "calc(".concat(value, " * calc(1 - var(--space-").concat(key[1], "-reverse)))"), "calc(".concat(value, " * var(--space-").concat(key[1], "-reverse))")];
};

var getCssSpacingProperties = function getCssSpacingProperties(prop, abbrProp, directions) {
  var _prop$split = prop.split(''),
      _prop$split2 = _slicedToArray(_prop$split, 2),
      a = _prop$split2[0],
      b = _prop$split2[1];

  var property = abbrProp[a];
  var direction = directions[b] || '';
  return Array.isArray(direction) ? direction.map(function (dir) {
    return property + dir;
  }) : [property + direction];
}; // memoize() impact:
// Increase performance by ~25%


var getCssSpacingOutsideProperties = memoize$1(function (prop) {
  return getCssSpacingProperties(prop, margin, directions);
});
var getCssSpacingInsideProperties = memoize$1(function (prop) {
  // It's for space between
  if (spaceBetweenCssVarReverse[prop]) {
    return [spaceBetweenCssVarReverse[prop]];
  }

  if (spaceBetween[prop]) {
    var abbrProp = spaceBetween[prop];
    return [spaceBetweenCssVar[prop]].concat(_toConsumableArray(getCssSpacingProperties(abbrProp, margin, directions)));
  }

  return getCssSpacingProperties(prop, padding, directions);
});
var getCssSpacingValues = memoize$1(function (value, prop) {
  var val = getVal(value); // It's for space between

  if (spaceBetweenCssVarReverse[prop]) {
    return ['1'];
  }

  if (spaceBetween[prop]) {
    return getSpaceBetweenVal(val, spaceBetween[prop]);
  }

  if ((prop === null || prop === void 0 ? void 0 : prop.length) === 2 && Array.isArray(directions[prop[1]])) {
    return [val, val];
  }

  return [val];
});

function deepMergeObj(target, source) {
  var destination = target;
  var srcKeys = Object.keys(source);

  for (var i = 0; i < srcKeys.length; i++) {
    var key = srcKeys[i];

    if (key in target) {
      destination[key] = deepMergeObj(target[key], source[key]);
    } else {
      destination[key] = source[key];
    }
  }

  return destination;
}

function deepMergeAll(array) {
  var result = {};

  for (var i = 1; i < array.length; i++) {
    var init = i === 0 ? result : array[i - 1];
    result = deepMergeObj(init, array[i]);
  }

  return result;
}

var makeResponsiveStyled = function makeResponsiveStyled(params) {
  var bps = params.bps,
      sxKey = params.sxKey,
      sxVal = params.sxVal,
      cssSelector = params.cssSelector,
      getCssProps = params.getCssProps,
      getValues = params.getValues,
      sxSelector = params.sxSelector;
  var styled = params.styled;

  for (var i = 0; i < bps.length; i++) {
    if (typeof (sxVal === null || sxVal === void 0 ? void 0 : sxVal[bps[i]]) === 'string' || typeof (sxVal === null || sxVal === void 0 ? void 0 : sxVal[bps[i]]) === 'number' || typeof (sxVal === null || sxVal === void 0 ? void 0 : sxVal[bps[i]]) === 'boolean') {
      var bp = bps[i];
      var media = "@media (min-width: ".concat(breakpoints[bp], "px)");
      var objStyle = {};
      sxSelector && (styled[media] = styled[media] || {});

      if (cssSelector !== null && cssSelector !== void 0 && cssSelector[sxKey]) {
        var _styled$media;

        var subSelector = cssSelector[sxKey];
        objStyle[subSelector] = ((_styled$media = styled[media]) === null || _styled$media === void 0 ? void 0 : _styled$media[subSelector]) || {};

        for (var g = 0; g < getCssProps(sxKey).length; g++) {
          var cssP = getCssProps(sxKey)[g];
          objStyle[subSelector][cssP] = getValues(sxVal[bp], sxKey)[g];
        }
      } else {
        for (var h = 0; h < getCssProps(sxKey).length; h++) {
          objStyle[getCssProps(sxKey)[h]] = getValues(sxVal[bp], sxKey)[h];
        }
      }

      if (sxSelector) {
        styled[media][sxSelector] = _objectSpread2(_objectSpread2({}, styled[media][sxSelector]), objStyle);
      } else {
        styled[media] = _objectSpread2(_objectSpread2({}, styled[media]), objStyle);
      }
    }
  }

  return styled;
};

var makeFamiliarStyled = function makeFamiliarStyled(params) {
  var sx = params.sx,
      sxFamiliarProps = params.sxFamiliarProps,
      cssSelector = params.cssSelector,
      getCssProps = params.getCssProps,
      getValues = params.getValues;

  if (_typeof(sx) !== 'object') {
    return {};
  }

  var styled = {};
  var sxKeys = Object.keys(sx);

  for (var i = 0; i < sxKeys.length; i++) {
    // Handle sx keys with responsive values
    if (sxFamiliarProps.indexOf(sxKeys[i]) >= 0 && _typeof(sx[sxKeys[i]]) === 'object') {
      var bps = Object.keys(breakpoints);
      styled = _objectSpread2(_objectSpread2({}, styled), makeResponsiveStyled({
        bps: bps,
        sxKey: sxKeys[i],
        sxVal: sx[sxKeys[i]],
        getCssProps: getCssProps,
        getValues: getValues,
        styled: styled,
        cssSelector: cssSelector
      }));
    } // Handle sx keys as CSS selector
    else {
      if (_typeof(sx[sxKeys[i]]) !== 'object' || // if value is object but keys of this object are breakpoints
      _typeof(sx[sxKeys[i]]) === 'object' && breakpoints[Object.keys(sx[sxKeys[i]])[0]] >= 0) {
        continue;
      }

      var selector = sxKeys[i];
      var subSx = sx[selector];
      var subSxKeys = Object.keys(subSx);

      for (var a = 0; a < subSxKeys.length; a++) {
        if (sxFamiliarProps.indexOf(subSxKeys[a]) === -1) {
          continue;
        }

        var sxKey = subSxKeys[a];
        var sxVal = subSx[sxKey];

        var _bps = Object.keys(breakpoints);

        if (_typeof(sxVal) === 'object') {
          styled = _objectSpread2(_objectSpread2({}, styled), makeResponsiveStyled({
            bps: _bps,
            sxKey: sxKey,
            sxVal: sxVal,
            getCssProps: getCssProps,
            getValues: getValues,
            styled: styled,
            cssSelector: cssSelector,
            sxSelector: selector
          }));
        } else if (sxVal !== undefined) {
          var objStyle = {};
          objStyle[selector] = styled[selector] || {};

          for (var g = 0; g < getCssProps(sxKey).length; g++) {
            var cssP = getCssProps(sxKey)[g];
            objStyle[selector][cssP] = getValues(sxVal, sxKey)[g];
          }

          styled[selector] = _objectSpread2(_objectSpread2({}, styled[selector]), objStyle[selector]);
        }
      }
    }
  }

  return styled;
};

var makeStyled = function makeStyled(sx) {
  var spacingOutsideBox = makeFamiliarStyled({
    sx: sx,
    sxFamiliarProps: spacingOutsideBoxKeys,
    getCssProps: getCssSpacingOutsideProperties,
    getValues: getCssSpacingValues
  });
  var spacingInsideBox = makeFamiliarStyled({
    sx: sx,
    sxFamiliarProps: spacingInsideBoxKeys,
    cssSelector: spaceBetweenSelector,
    getCssProps: getCssSpacingInsideProperties,
    getValues: getCssSpacingValues
  });
  var jssOutsideBoxStyled = deepMergeAll([spacingOutsideBox]);
  var jssInsideBoxStyled = deepMergeAll([spacingInsideBox]);
  var jssStyled = deepMergeObj(spacingOutsideBox, spacingInsideBox);
  return {
    jssOutsideBoxStyled: jssOutsideBoxStyled,
    jssInsideBoxStyled: jssInsideBoxStyled,
    jssStyled: jssStyled
  };
};

var borderWidth = ['border', 'borderTop', 'borderRight', 'borderBottom', 'borderLeft'];
var borderRadius = ['borderRadius', 'borderTopRadius', 'borderRightRadius', 'borderBottomRadius', 'borderLeftRadius', 'borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomRightRadius', 'borderBottomLeftRadius'];
var borderKeys = [].concat(borderWidth, borderRadius, ['borderColor', 'borderOpacity']);
var spacingOutsideBoxKeys = ['m', 'mx', 'my', 'mt', 'mr', 'mb', 'ml']; // spaceBetweenReverse has different value than another of spacing

var spaceBetweenReverse = ['spaceBetweenXReverse', 'spaceBetweenYReverse'];
var spacingInsideBoxKeys = ['p', 'px', 'py', 'pt', 'pr', 'pb', 'pl', 'spaceBetweenX', 'spaceBetweenY'].concat(spaceBetweenReverse);
[].concat(spacingOutsideBoxKeys, _toConsumableArray(spacingInsideBoxKeys));
var sizingKeys = ['width', 'minWidth', 'maxWidth', 'height', 'minHeight', 'maxHeight'];
var positions = ['inset', 'insetX', 'insetY', 'top', 'right', 'bottom', 'left'];
var positionKeys = ['position'].concat(positions);
var textKeys = ['color', 'fontSize', 'fontStyle', 'fontWeight', 'textOpacity', 'textAlign', 'textDecoration', 'textTransform', 'textOverflow', 'textTruncate', 'lineHeight', 'letterSpacing', 'verticalAlign', 'whiteSpace', 'workBreak', 'listStyleType', 'listStylePosition'];
var backgroundKeys = ['bgColor', 'bgOpacity'];
var opacityKeys = ['opacity']; // The special cases have sx value is 'none', so the css class name is different sx key name.

var specialCase = {
  textDecoration: 'no-underline',
  textTransform: 'normal-case',
  lineHeight: 'leading-none',
  listStyleType: 'list-none'
};

var separateNumberAsKebab = function separateNumberAsKebab(value) {
  var kebab = camelToKebab(value);
  var match = kebab.match(/\d/);
  var index = match ? match.index : -1;

  if (index === 0 || index === -1) {
    return kebab;
  } else {
    return kebab.slice(0, index) + '-' + kebab.slice(index, kebab.length);
  }
};

var handleBorderPrefix = function handleBorderPrefix(name) {
  var prefix = name;

  if (name.indexOf('Radius') !== -1) {
    prefix = name.replace(/border/, 'rounded');
  }

  return camelToKebab(prefix.replace(/Color|Radius/, '').replace(/Opacity/, 'Alpha').replace(/Top/, 'T').replace(/Right/, 'R').replace(/Bottom/, 'B').replace(/Left/, 'L').replace(/TopLeft/, 'TL').replace(/TopRight/, 'TR').replace(/BottomRight/, 'BR').replace(/BottomLeft/, 'BL'));
};

var handleBorderValue = function handleBorderValue(value) {
  return separateNumberAsKebab(value.replace(/px|sm/, ''));
};

var handleInsideBoxPrefix = function handleInsideBoxPrefix(name) {
  return camelToKebab(name.replace(/Between/, ''));
};

var handleSizingPrefix = function handleSizingPrefix(name) {
  return camelToKebab(name.replace(/width|Width/, 'W').replace(/height|Height/, 'H'));
};

var handlePositionPrefix = function handlePositionPrefix(name) {
  return camelToKebab(name.replace(/position/, ''));
};

var handleTextPrefix = function handleTextPrefix(name) {
  return camelToKebab(name.replace(/Weight|textDecoration|textTransform|StyleType|StylePosition/, '').replace(/color|fontSize|textAlign/, 'text').replace(/verticalAlign/, 'align').replace(/textOverflow/, 'overflow').replace(/textTruncate/, 'truncate').replace(/lineHeight/, 'leading').replace(/letterSpacing/, 'tracking').replace(/whiteSpace/, 'whitespace').replace(/workBreak/, 'break').replace(/Opacity/, 'Alpha'));
};

var handleTextValue = function handleTextValue(value) {
  return separateNumberAsKebab(value.replace(/none/, ''));
};

var handleBackgroundPrefix = function handleBackgroundPrefix(name) {
  return camelToKebab(name.replace(/Color/, ''));
};
/**
 * Get an atomic css class name from the sx key and value.
 * @param sxKey Property of sx - String
 * @param value Value of sxKey - Number | String | Boolean.
 * @param handlePrefix Optional - Convert prefix String for specific cases - Function
 * @param handleStringValue Optional - Convert value String for specific cases - Function
 * @return String
 * @example
 * 'pt-2 '
 */


var getAtomicClass = memoize$1(function (sxKey, value, handlePrefix, handleStringValue) {
  var _specialCase;

  // fontStyle with value is 'italic'/'normal' are not same as `font-style-suffix`, so handle it separately.
  if (sxKey === 'fontStyle') {
    if (value === 'italic') {
      return 'italic ';
    } else if (value === 'normal') {
      return 'not-italic ';
    }
  }

  var val = value === true ? '' : value; // Handle the prefix class name of special cases have 'none' value.

  var prefixSpecialCase = value === 'none' && (_specialCase = specialCase[sxKey]) !== null && _specialCase !== void 0 && _specialCase.length ? specialCase[sxKey] : ''; // Convert the prefix class name to match scss atomic

  var prefix = prefixSpecialCase.length ? prefixSpecialCase : handlePrefix ? handlePrefix(sxKey) : sxKey;

  if (typeof val === 'string') {
    var stringVal = handleStringValue ? handleStringValue(val) : val; // Positive is common case, so control the positive first, negative later.

    if (stringVal.indexOf('-') !== 0) {
      var separator = stringVal === '' || prefix === '' ? '' : '-';
      return prefix + separator + stringVal + ' ';
    }

    return '-' + prefix + stringVal + ' ';
  }

  if (typeof val === 'number') {
    if (val >= 0) {
      return prefix + '-' + val + ' ';
    }

    return '-' + prefix + val + ' ';
  }
});

/**
 * Generate the string of atomic class name
 * @param sxFamiliarProps An array of properties sx whose set has similar CSS features - Array
 * @param sx sx prop - Object.
 * @param handlePrefix Optional - Convert prefix String for specific cases - Function
 * @param handleStringValue Optional - Convert value String for specific cases - Function
 * @return String
 * @example
 * 'pt-2 pr-3 pb-4 pl-5 flex '
 */
var genClassName = function genClassName(params) {
  var sxFamiliarProps = params.sxFamiliarProps,
      sx = params.sx,
      handlePrefix = params.handlePrefix,
      handleStringValue = params.handleStringValue;

  if (_typeof(sx) !== 'object') {
    return '';
  }

  var className = '';
  var sxKeys = Object.keys(sx);

  for (var i = 0; i < sxKeys.length; i++) {
    // If key of sx does not include in sxFamiliarProps OR is pseudo selector OR value is object of breakpoints, skip using clsx
    if (sxFamiliarProps.indexOf(sxKeys[i]) === -1 || _typeof(sx[sxKeys[i]]) === 'object') {
      continue;
    }

    className += getAtomicClass(sxKeys[i], sx[sxKeys[i]], handlePrefix, handleStringValue);
  }

  return className;
};

/**
 * Convert `sx` system to an object of class names and object styles.
 * @param sx sx prop - Define custom style and responsive.
 * @returns Collection of class names and CSSProperties.
 */
var useSx = function useSx(sx) {
  if (!sx) {
    return {};
  }

  var border = genClassName({
    sxFamiliarProps: borderKeys,
    sx: sx,
    handlePrefix: handleBorderPrefix,
    handleStringValue: handleBorderValue
  });
  var spacingOutsideBox = genClassName({
    sxFamiliarProps: spacingOutsideBoxKeys,
    sx: sx
  });
  var spacingInsideBox = genClassName({
    sxFamiliarProps: spacingInsideBoxKeys,
    sx: sx,
    handlePrefix: handleInsideBoxPrefix
  });
  var sizing = genClassName({
    sxFamiliarProps: sizingKeys,
    sx: sx,
    handlePrefix: handleSizingPrefix
  });
  var position = genClassName({
    sxFamiliarProps: positionKeys,
    sx: sx,
    handlePrefix: handlePositionPrefix
  });
  var text = genClassName({
    sxFamiliarProps: textKeys,
    sx: sx,
    handlePrefix: handleTextPrefix,
    handleStringValue: handleTextValue
  });
  var background = genClassName({
    sxFamiliarProps: backgroundKeys,
    sx: sx,
    handlePrefix: handleBackgroundPrefix,
    handleStringValue: separateNumberAsKebab
  });
  var opacity = genClassName({
    sxFamiliarProps: opacityKeys,
    sx: sx
  });
  var sxOutsideBoxClass = (border + spacingOutsideBox + sizing + position + background + opacity).trim();
  var sxInsideBoxClass = (spacingInsideBox + text).trim();
  var sxClass = "".concat(sxOutsideBoxClass, " ").concat(sxInsideBoxClass);

  var _makeStyled = makeStyled(sx),
      jssOutsideBoxStyled = _makeStyled.jssOutsideBoxStyled,
      jssInsideBoxStyled = _makeStyled.jssInsideBoxStyled,
      jssStyled = _makeStyled.jssStyled;

  return {
    sxClass: sxClass,
    sxOutsideBoxClass: sxOutsideBoxClass,
    sxInsideBoxClass: sxInsideBoxClass,
    jssOutsideBoxStyled: jssOutsideBoxStyled,
    jssInsideBoxStyled: jssInsideBoxStyled,
    jssStyled: jssStyled
  };
};

/*

Based off glamor's StyleSheet, thanks Sunil ❤️

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/
// $FlowFixMe
function sheetForTag(tag) {
  if (tag.sheet) {
    // $FlowFixMe
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */


  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      // $FlowFixMe
      return document.styleSheets[i];
    }
  }
}

function createStyleElement(options) {
  var tag = document.createElement('style');
  tag.setAttribute('data-emotion', options.key);

  if (options.nonce !== undefined) {
    tag.setAttribute('nonce', options.nonce);
  }

  tag.appendChild(document.createTextNode(''));
  tag.setAttribute('data-s', '');
  return tag;
}

var StyleSheet = /*#__PURE__*/function () {
  function StyleSheet(options) {
    var _this = this;

    this._insertTag = function (tag) {
      var before;

      if (_this.tags.length === 0) {
        before = _this.prepend ? _this.container.firstChild : _this.before;
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }

      _this.container.insertBefore(tag, before);

      _this.tags.push(tag);
    };

    this.isSpeedy = options.speedy === undefined ? process.env.NODE_ENV === 'production' : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.before = null;
  }

  var _proto = StyleSheet.prototype;

  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };

  _proto.insert = function insert(rule) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }

    var tag = this.tags[this.tags.length - 1];

    if (process.env.NODE_ENV !== 'production') {
      var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;

      if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {
        // this would only cause problem in speedy mode
        // but we don't want enabling speedy to affect the observable behavior
        // so we report this error at all times
        console.error("You're attempting to insert the following rule:\n" + rule + '\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.');
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;
    }

    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);

      try {
        // this is the ultrafast version, works across browsers
        // the big drawback is that the css won't be editable in devtools
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
        if (process.env.NODE_ENV !== 'production' && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear){/.test(rule)) {
          console.error("There was a problem inserting the following rule: \"" + rule + "\"", e);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }

    this.ctr++;
  };

  _proto.flush = function flush() {
    // $FlowFixMe
    this.tags.forEach(function (tag) {
      return tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;

    if (process.env.NODE_ENV !== 'production') {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };

  return StyleSheet;
}();

var MS = '-ms-';
var MOZ = '-moz-';
var WEBKIT = '-webkit-';

var COMMENT = 'comm';
var RULESET = 'rule';
var DECLARATION = 'decl';
var IMPORT = '@import';
var KEYFRAMES = '@keyframes';

/**
 * @param {number}
 * @return {number}
 */
var abs = Math.abs;

/**
 * @param {number}
 * @return {string}
 */
var from = String.fromCharCode;

/**
 * @param {string} value
 * @param {number} length
 * @return {number}
 */
function hash$2 (value, length) {
	return (((((((length << 2) ^ charat(value, 0)) << 2) ^ charat(value, 1)) << 2) ^ charat(value, 2)) << 2) ^ charat(value, 3)
}

/**
 * @param {string} value
 * @return {string}
 */
function trim (value) {
	return value.trim()
}

/**
 * @param {string} value
 * @param {RegExp} pattern
 * @return {string?}
 */
function match (value, pattern) {
	return (value = pattern.exec(value)) ? value[0] : value
}

/**
 * @param {string} value
 * @param {(string|RegExp)} pattern
 * @param {string} replacement
 * @return {string}
 */
function replace (value, pattern, replacement) {
	return value.replace(pattern, replacement)
}

/**
 * @param {string} value
 * @param {string} value
 * @return {number}
 */
function indexof (value, search) {
	return value.indexOf(search)
}

/**
 * @param {string} value
 * @param {number} index
 * @return {number}
 */
function charat (value, index) {
	return value.charCodeAt(index) | 0
}

/**
 * @param {string} value
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function substr (value, begin, end) {
	return value.slice(begin, end)
}

/**
 * @param {string} value
 * @return {number}
 */
function strlen (value) {
	return value.length
}

/**
 * @param {any[]} value
 * @return {number}
 */
function sizeof (value) {
	return value.length
}

/**
 * @param {any} value
 * @param {any[]} array
 * @return {any}
 */
function append (value, array) {
	return array.push(value), value
}

/**
 * @param {string[]} array
 * @param {function} callback
 * @return {string}
 */
function combine (array, callback) {
	return array.map(callback).join('')
}

var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = '';

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {string} type
 * @param {string[]} props
 * @param {object[]} children
 * @param {number} length
 */
function node (value, root, parent, type, props, children, length) {
	return {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: ''}
}

/**
 * @param {string} value
 * @param {object} root
 * @param {string} type
 */
function copy (value, root, type) {
	return node(value, root.root, root.parent, type, root.props, root.children, 0)
}

/**
 * @return {number}
 */
function char () {
	return character
}

/**
 * @return {number}
 */
function prev () {
	character = position > 0 ? charat(characters, --position) : 0;

	if (column--, character === 10)
		column = 1, line--;

	return character
}

/**
 * @return {number}
 */
function next () {
	character = position < length ? charat(characters, position++) : 0;

	if (column++, character === 10)
		column = 1, line++;

	return character
}

/**
 * @return {number}
 */
function peek () {
	return charat(characters, position)
}

/**
 * @return {number}
 */
function caret () {
	return position
}

/**
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function slice (begin, end) {
	return substr(characters, begin, end)
}

/**
 * @param {number} type
 * @return {number}
 */
function token (type) {
	switch (type) {
		// \0 \t \n \r \s whitespace token
		case 0: case 9: case 10: case 13: case 32:
			return 5
		// ! + , / > @ ~ isolate token
		case 33: case 43: case 44: case 47: case 62: case 64: case 126:
		// ; { } breakpoint token
		case 59: case 123: case 125:
			return 4
		// : accompanied token
		case 58:
			return 3
		// " ' ( [ opening delimit token
		case 34: case 39: case 40: case 91:
			return 2
		// ) ] closing delimit token
		case 41: case 93:
			return 1
	}

	return 0
}

/**
 * @param {string} value
 * @return {any[]}
 */
function alloc (value) {
	return line = column = 1, length = strlen(characters = value), position = 0, []
}

/**
 * @param {any} value
 * @return {any}
 */
function dealloc (value) {
	return characters = '', value
}

/**
 * @param {number} type
 * @return {string}
 */
function delimit (type) {
	return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))
}

/**
 * @param {number} type
 * @return {string}
 */
function whitespace (type) {
	while (character = peek())
		if (character < 33)
			next();
		else
			break

	return token(type) > 2 || token(character) > 3 ? '' : ' '
}

/**
 * @param {number} index
 * @param {number} count
 * @return {string}
 */
function escaping (index, count) {
	while (--count && next())
		// not 0-9 A-F a-f
		if (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97))
			break

	return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32))
}

/**
 * @param {number} type
 * @return {number}
 */
function delimiter (type) {
	while (next())
		switch (character) {
			// ] ) " '
			case type:
				return position
			// " '
			case 34: case 39:
				return delimiter(type === 34 || type === 39 ? type : character)
			// (
			case 40:
				if (type === 41)
					delimiter(type);
				break
			// \
			case 92:
				next();
				break
		}

	return position
}

/**
 * @param {number} type
 * @param {number} index
 * @return {number}
 */
function commenter (type, index) {
	while (next())
		// //
		if (type + character === 47 + 10)
			break
		// /*
		else if (type + character === 42 + 42 && peek() === 47)
			break

	return '/*' + slice(index, position - 1) + '*' + from(type === 47 ? type : next())
}

/**
 * @param {number} index
 * @return {string}
 */
function identifier (index) {
	while (!token(peek()))
		next();

	return slice(index, position)
}

/**
 * @param {string} value
 * @return {object[]}
 */
function compile (value) {
	return dealloc(parse$2('', null, null, null, [''], value = alloc(value), 0, [0], value))
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {string[]} rule
 * @param {string[]} rules
 * @param {string[]} rulesets
 * @param {number[]} pseudo
 * @param {number[]} points
 * @param {string[]} declarations
 * @return {object}
 */
function parse$2 (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
	var index = 0;
	var offset = 0;
	var length = pseudo;
	var atrule = 0;
	var property = 0;
	var previous = 0;
	var variable = 1;
	var scanning = 1;
	var ampersand = 1;
	var character = 0;
	var type = '';
	var props = rules;
	var children = rulesets;
	var reference = rule;
	var characters = type;

	while (scanning)
		switch (previous = character, character = next()) {
			// " ' [ (
			case 34: case 39: case 91: case 40:
				characters += delimit(character);
				break
			// \t \n \r \s
			case 9: case 10: case 13: case 32:
				characters += whitespace(previous);
				break
			// \
			case 92:
				characters += escaping(caret() - 1, 7);
				continue
			// /
			case 47:
				switch (peek()) {
					case 42: case 47:
						append(comment(commenter(next(), caret()), root, parent), declarations);
						break
					default:
						characters += '/';
				}
				break
			// {
			case 123 * variable:
				points[index++] = strlen(characters) * ampersand;
			// } ; \0
			case 125 * variable: case 59: case 0:
				switch (character) {
					// \0 }
					case 0: case 125: scanning = 0;
					// ;
					case 59 + offset:
						if (property > 0 && (strlen(characters) - length))
							append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations);
						break
					// @ ;
					case 59: characters += ';';
					// { rule/at-rule
					default:
						append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);

						if (character === 123)
							if (offset === 0)
								parse$2(characters, root, reference, reference, props, rulesets, length, points, children);
							else
								switch (atrule) {
									// d m s
									case 100: case 109: case 115:
										parse$2(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);
										break
									default:
										parse$2(characters, reference, reference, reference, [''], children, length, points, children);
								}
				}

				index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
				break
			// :
			case 58:
				length = 1 + strlen(characters), property = previous;
			default:
				if (variable < 1)
					if (character == 123)
						--variable;
					else if (character == 125 && variable++ == 0 && prev() == 125)
						continue

				switch (characters += from(character), character * variable) {
					// &
					case 38:
						ampersand = offset > 0 ? 1 : (characters += '\f', -1);
						break
					// ,
					case 44:
						points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
						break
					// @
					case 64:
						// -
						if (peek() === 45)
							characters += delimit(next());

						atrule = peek(), offset = strlen(type = characters += identifier(caret())), character++;
						break
					// -
					case 45:
						if (previous === 45 && strlen(characters) == 2)
							variable = 0;
				}
		}

	return rulesets
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} index
 * @param {number} offset
 * @param {string[]} rules
 * @param {number[]} points
 * @param {string} type
 * @param {string[]} props
 * @param {string[]} children
 * @param {number} length
 * @return {object}
 */
function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length) {
	var post = offset - 1;
	var rule = offset === 0 ? rules : [''];
	var size = sizeof(rule);

	for (var i = 0, j = 0, k = 0; i < index; ++i)
		for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
			if (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x])))
				props[k++] = z;

	return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length)
}

/**
 * @param {number} value
 * @param {object} root
 * @param {object?} parent
 * @return {object}
 */
function comment (value, root, parent) {
	return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0)
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} length
 * @return {object}
 */
function declaration (value, root, parent, length) {
	return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length)
}

/**
 * @param {string} value
 * @param {number} length
 * @return {string}
 */
function prefix (value, length) {
	switch (hash$2(value, length)) {
		// color-adjust
		case 5103:
			return WEBKIT + 'print-' + value + value
		// animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
		case 5737: case 4201: case 3177: case 3433: case 1641: case 4457: case 2921:
		// text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
		case 5572: case 6356: case 5844: case 3191: case 6645: case 3005:
		// mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
		case 6391: case 5879: case 5623: case 6135: case 4599: case 4855:
		// background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
		case 4215: case 6389: case 5109: case 5365: case 5621: case 3829:
			return WEBKIT + value + value
		// appearance, user-select, transform, hyphens, text-size-adjust
		case 5349: case 4246: case 4810: case 6968: case 2756:
			return WEBKIT + value + MOZ + value + MS + value + value
		// flex, flex-direction
		case 6828: case 4268:
			return WEBKIT + value + MS + value + value
		// order
		case 6165:
			return WEBKIT + value + MS + 'flex-' + value + value
		// align-items
		case 5187:
			return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value
		// align-self
		case 5443:
			return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/, '') + value
		// align-content
		case 4675:
			return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/, '') + value
		// flex-shrink
		case 5548:
			return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value
		// flex-basis
		case 5292:
			return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value
		// flex-grow
		case 6060:
			return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value
		// transition
		case 4554:
			return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value
		// cursor
		case 6187:
			return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value
		// background, background-image
		case 5495: case 3959:
			return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1')
		// justify-content
		case 4968:
			return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value
		// (margin|padding)-inline-(start|end)
		case 4095: case 3583: case 4068: case 2532:
			return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value
		// (min|max)?(width|height|inline-size|block-size)
		case 8116: case 7059: case 5753: case 5535:
		case 5445: case 5701: case 4933: case 4677:
		case 5533: case 5789: case 5021: case 4765:
			// stretch, max-content, min-content, fill-available
			if (strlen(value) - 1 - length > 6)
				switch (charat(value, length + 1)) {
					// (m)ax-content, (m)in-content
					case 109:
						// -
						if (charat(value, length + 4) !== 45)
							break
					// (f)ill-available, (f)it-content
					case 102:
						return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value
					// (s)tretch
					case 115:
						return ~indexof(value, 'stretch') ? prefix(replace(value, 'stretch', 'fill-available'), length) + value : value
				}
			break
		// position: sticky
		case 4949:
			// (s)ticky?
			if (charat(value, length + 1) !== 115)
				break
		// display: (flex|inline-flex)
		case 6444:
			switch (charat(value, strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
				// stic(k)y
				case 107:
					return replace(value, ':', ':' + WEBKIT) + value
				// (inline-)?fl(e)x
				case 101:
					return replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value
			}
			break
		// writing-mode
		case 5936:
			switch (charat(value, length + 11)) {
				// vertical-l(r)
				case 114:
					return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value
				// vertical-r(l)
				case 108:
					return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value
				// horizontal(-)tb
				case 45:
					return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value
			}

			return WEBKIT + value + MS + value + value
	}

	return value
}

/**
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function serialize (children, callback) {
	var output = '';
	var length = sizeof(children);

	for (var i = 0; i < length; i++)
		output += callback(children[i], i, children, callback) || '';

	return output
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function stringify (element, index, children, callback) {
	switch (element.type) {
		case IMPORT: case DECLARATION: return element.return = element.return || element.value
		case COMMENT: return ''
		case RULESET: element.value = element.props.join(',');
	}

	return strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''
}

/**
 * @param {function[]} collection
 * @return {function}
 */
function middleware (collection) {
	var length = sizeof(collection);

	return function (element, index, children, callback) {
		var output = '';

		for (var i = 0; i < length; i++)
			output += collection[i](element, index, children, callback) || '';

		return output
	}
}

/**
 * @param {function} callback
 * @return {function}
 */
function rulesheet (callback) {
	return function (element) {
		if (!element.root)
			if (element = element.return)
				callback(element);
	}
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 */
function prefixer (element, index, children, callback) {
	if (!element.return)
		switch (element.type) {
			case DECLARATION: element.return = prefix(element.value, element.length);
				break
			case KEYFRAMES:
				return serialize([copy(replace(element.value, '@', '@' + WEBKIT), element, '')], callback)
			case RULESET:
				if (element.length)
					return combine(element.props, function (value) {
						switch (match(value, /(::plac\w+|:read-\w+)/)) {
							// :read-(only|write)
							case ':read-only': case ':read-write':
								return serialize([copy(replace(value, /:(read-\w+)/, ':' + MOZ + '$1'), element, '')], callback)
							// :placeholder
							case '::placeholder':
								return serialize([
									copy(replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1'), element, ''),
									copy(replace(value, /:(plac\w+)/, ':' + MOZ + '$1'), element, ''),
									copy(replace(value, /:(plac\w+)/, MS + 'input-$1'), element, '')
								], callback)
						}

						return ''
					})
		}
}

var last = function last(arr) {
  return arr.length ? arr[arr.length - 1] : null;
};

var toRules = function toRules(parsed, points) {
  // pretend we've started with a comma
  var index = -1;
  var character = 44;

  do {
    switch (token(character)) {
      case 0:
        // &\f
        if (character === 38 && peek() === 12) {
          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
          // and when it should just concatenate the outer and inner selectors
          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
          points[index] = 1;
        }

        parsed[index] += identifier(position - 1);
        break;

      case 2:
        parsed[index] += delimit(character);
        break;

      case 4:
        // comma
        if (character === 44) {
          // colon
          parsed[++index] = peek() === 58 ? '&\f' : '';
          points[index] = parsed[index].length;
          break;
        }

      // fallthrough

      default:
        parsed[index] += from(character);
    }
  } while (character = next());

  return parsed;
};

var getRules = function getRules(value, points) {
  return dealloc(toRules(alloc(value), points));
}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


var fixedElements = /* #__PURE__ */new WeakMap();
var compat = function compat(element) {
  if (element.type !== 'rule' || !element.parent || // .length indicates if this rule contains pseudo or not
  !element.length) {
    return;
  }

  var value = element.value,
      parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;

  while (parent.type !== 'rule') {
    parent = parent.parent;
    if (!parent) return;
  } // short-circuit for the simplest case


  if (element.props.length === 1 && value.charCodeAt(0) !== 58
  /* colon */
  && !fixedElements.get(parent)) {
    return;
  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


  if (isImplicitRule) {
    return;
  }

  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;

  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel(element) {
  if (element.type === 'decl') {
    var value = element.value;

    if ( // charcode for l
    value.charCodeAt(0) === 108 && // charcode for b
    value.charCodeAt(2) === 98) {
      // this ignores label
      element["return"] = '';
      element.value = '';
    }
  }
};
var ignoreFlag = 'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason';

var isIgnoringComment = function isIgnoringComment(element) {
  return !!element && element.type === 'comm' && element.children.indexOf(ignoreFlag) > -1;
};

var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {
  return function (element, index, children) {
    if (element.type !== 'rule') return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);

    if (unsafePseudoClasses && cache.compat !== true) {
      var prevElement = index > 0 ? children[index - 1] : null;

      if (prevElement && isIgnoringComment(last(prevElement.children))) {
        return;
      }

      unsafePseudoClasses.forEach(function (unsafePseudoClass) {
        console.error("The pseudo class \"" + unsafePseudoClass + "\" is potentially unsafe when doing server-side rendering. Try changing it to \"" + unsafePseudoClass.split('-child')[0] + "-of-type\".");
      });
    }
  };
};

var isImportRule = function isImportRule(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};

var isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {
  for (var i = index - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }

  return false;
}; // use this to remove incorrect elements from further processing
// so they don't get handed to the `sheet` (or anything else)
// as that could potentially lead to additional logs which in turn could be overhelming to the user


var nullifyElement = function nullifyElement(element) {
  element.type = '';
  element.value = '';
  element["return"] = '';
  element.children = '';
  element.props = '';
};

var incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {
  if (!isImportRule(element)) {
    return;
  }

  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};

var defaultStylisPlugins = [prefixer];

var createCache = function createCache(options) {
  var key = options.key;

  if (process.env.NODE_ENV !== 'production' && !key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\n" + "If multiple caches share the same key they might \"fight\" for each other's style elements.");
  }

  if ( key === 'css') {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
    // note this very very intentionally targets all style elements regardless of the key to ensure
    // that creating a cache works inside of render of a React component

    Array.prototype.forEach.call(ssrStyles, function (node) {
      // we want to only move elements which have a space in the data-emotion attribute value
      // because that indicates that it is an Emotion 11 server-side rendered style elements
      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
      // will not result in the Emotion 10 styles being destroyed
      var dataEmotionAttribute = node.getAttribute('data-emotion');

      if (dataEmotionAttribute.indexOf(' ') === -1) {
        return;
      }
      document.head.appendChild(node);
      node.setAttribute('data-s', '');
    });
  }

  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

  if (process.env.NODE_ENV !== 'production') {
    // $FlowFixMe
    if (/[^a-z-]/.test(key)) {
      throw new Error("Emotion key must only contain lower case alphabetical characters and - but \"" + key + "\" was passed");
    }
  }

  var inserted = {}; // $FlowFixMe

  var container;
  var nodesToHydrate = [];

  {
    container = options.container || document.head;
    Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
      var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

      for (var i = 1; i < attrib.length; i++) {
        inserted[attrib[i]] = true;
      }

      nodesToHydrate.push(node);
    });
  }

  var _insert;

  var omnipresentPlugins = [compat, removeLabel];

  if (process.env.NODE_ENV !== 'production') {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache.compat;
      }

    }), incorrectImportAlarm);
  }

  {
    var currentSheet;
    var finalizingPlugins = [stringify, process.env.NODE_ENV !== 'production' ? function (element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== COMMENT) {
          // insert empty rule in non-production environments
          // so @emotion/jest can grab `key` from the (JS)DOM for caches without any rules inserted yet
          currentSheet.insert(element.value + "{}");
        }
      }
    } : rulesheet(function (rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

    var stylis = function stylis(styles) {
      return serialize(compile(styles), serializer);
    };

    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;

      if (process.env.NODE_ENV !== 'production' && serialized.map !== undefined) {
        currentSheet = {
          insert: function insert(rule) {
            sheet.insert(rule + serialized.map);
          }
        };
      }

      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }

  var cache = {
    key: key,
    sheet: new StyleSheet({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}var AsyncMode=l;var ConcurrentMode=m;var ContextConsumer=k;var ContextProvider=h;var Element$1=c;var ForwardRef=n;var Fragment=e;var Lazy=t;var Memo=r;var Portal=d;
var Profiler=g;var StrictMode=f;var Suspense=p;var isAsyncMode=function(a){return A(a)||z(a)===l};var isConcurrentMode=A;var isContextConsumer=function(a){return z(a)===k};var isContextProvider=function(a){return z(a)===h};var isElement$1=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};var isForwardRef=function(a){return z(a)===n};var isFragment=function(a){return z(a)===e};var isLazy=function(a){return z(a)===t};
var isMemo=function(a){return z(a)===r};var isPortal=function(a){return z(a)===d};var isProfiler=function(a){return z(a)===g};var isStrictMode=function(a){return z(a)===f};var isSuspense=function(a){return z(a)===p};
var isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};var typeOf=z;

var reactIs_production_min = {
	AsyncMode: AsyncMode,
	ConcurrentMode: ConcurrentMode,
	ContextConsumer: ContextConsumer,
	ContextProvider: ContextProvider,
	Element: Element$1,
	ForwardRef: ForwardRef,
	Fragment: Fragment,
	Lazy: Lazy,
	Memo: Memo,
	Portal: Portal,
	Profiler: Profiler,
	StrictMode: StrictMode,
	Suspense: Suspense,
	isAsyncMode: isAsyncMode,
	isConcurrentMode: isConcurrentMode,
	isContextConsumer: isContextConsumer,
	isContextProvider: isContextProvider,
	isElement: isElement$1,
	isForwardRef: isForwardRef,
	isFragment: isFragment,
	isLazy: isLazy,
	isMemo: isMemo,
	isPortal: isPortal,
	isProfiler: isProfiler,
	isStrictMode: isStrictMode,
	isSuspense: isSuspense,
	isValidElementType: isValidElementType,
	typeOf: typeOf
};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var reactIs_development = createCommonjsModule(function (module, exports) {



if (process.env.NODE_ENV !== "production") {
  (function() {

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}
});

var reactIs = createCommonjsModule(function (module) {

if (process.env.NODE_ENV === 'production') {
  module.exports = reactIs_production_min;
} else {
  module.exports = reactIs_development;
}
});

var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

var isBrowser = "object" !== 'undefined';
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = '';
  classNames.split(' ').forEach(function (className) {
    if (registered[className] !== undefined) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var insertStyles = function insertStyles(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;

  if ( // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (isStringTag === false || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser === false ) && cache.registered[className] === undefined) {
    cache.registered[className] = serialized.styles;
  }

  if (cache.inserted[serialized.name] === undefined) {
    var current = serialized;

    do {
      cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);

      current = current.next;
    } while (current !== undefined);
  }
};

/* eslint-disable */
// Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
function murmur2(str) {
  // 'm' and 'r' are mixing constants generated offline.
  // They're not really 'magic', they just happen to work well.
  // const m = 0x5bd1e995;
  // const r = 24;
  // Initialize the hash
  var h = 0; // Mix 4 bytes at a time into the hash

  var k,
      i = 0,
      len = str.length;

  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
    k ^=
    /* k >>> r: */
    k >>> 24;
    h =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
    /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Handle the last few bytes of the input array


  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Do a few final mixes of the hash to ensure the last few
  // bytes are well-incorporated.


  h ^= h >>> 13;
  h =
  /* Math.imul(h, m): */
  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

function memoize(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

var isCustomProperty = function isCustomProperty(property) {
  return property.charCodeAt(1) === 45;
};

var isProcessableValue = function isProcessableValue(value) {
  return value != null && typeof value !== 'boolean';
};

var processStyleName = /* #__PURE__ */memoize(function (styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
});

var processStyleValue = function processStyleValue(key, value) {
  switch (key) {
    case 'animation':
    case 'animationName':
      {
        if (typeof value === 'string') {
          return value.replace(animationRegex, function (match, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
  }

  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
    return value + 'px';
  }

  return value;
};

if (process.env.NODE_ENV !== 'production') {
  var contentValuePattern = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  var contentValues = ['normal', 'none', 'initial', 'inherit', 'unset'];
  var oldProcessStyleValue = processStyleValue;
  var msPattern = /^-ms-/;
  var hyphenPattern = /-(.)/g;
  var hyphenatedCache = {};

  processStyleValue = function processStyleValue(key, value) {
    if (key === 'content') {
      if (typeof value !== 'string' || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }

    var processed = oldProcessStyleValue(key, value);

    if (processed !== '' && !isCustomProperty(key) && key.indexOf('-') !== -1 && hyphenatedCache[key] === undefined) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, 'ms-').replace(hyphenPattern, function (str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }

    return processed;
  };
}

function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return '';
  }

  if (interpolation.__emotion_styles !== undefined) {
    if (process.env.NODE_ENV !== 'production' && interpolation.toString() === 'NO_COMPONENT_SELECTOR') {
      throw new Error('Component selectors can only be used in conjunction with @emotion/babel-plugin.');
    }

    return interpolation;
  }

  switch (typeof interpolation) {
    case 'boolean':
      {
        return '';
      }

    case 'object':
      {
        if (interpolation.anim === 1) {
          cursor = {
            name: interpolation.name,
            styles: interpolation.styles,
            next: cursor
          };
          return interpolation.name;
        }

        if (interpolation.styles !== undefined) {
          var next = interpolation.next;

          if (next !== undefined) {
            // not the most efficient thing ever but this is a pretty rare case
            // and there will be very few iterations of this generally
            while (next !== undefined) {
              cursor = {
                name: next.name,
                styles: next.styles,
                next: cursor
              };
              next = next.next;
            }
          }

          var styles = interpolation.styles + ";";

          if (process.env.NODE_ENV !== 'production' && interpolation.map !== undefined) {
            styles += interpolation.map;
          }

          return styles;
        }

        return createStringFromObject(mergedProps, registered, interpolation);
      }

    case 'function':
      {
        if (mergedProps !== undefined) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        } else if (process.env.NODE_ENV !== 'production') {
          console.error('Functions that are interpolated in css calls will be stringified.\n' + 'If you want to have a css call based on props, create a function that returns a css call like this\n' + 'let dynamicStyle = (props) => css`color: ${props.color}`\n' + 'It can be called directly with props or interpolated in a styled call like this\n' + "let SomeComponent = styled('div')`${dynamicStyle}`");
        }

        break;
      }

    case 'string':
      if (process.env.NODE_ENV !== 'production') {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function (match, p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, '') + "`");
          return "${" + fakeVarName + "}";
        });

        if (matched.length) {
          console.error('`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\n' + 'Instead of doing this:\n\n' + [].concat(matched, ["`" + replaced + "`"]).join('\n') + '\n\nYou should wrap it with `css` like this:\n\n' + ("css`" + replaced + "`"));
        }
      }

      break;
  } // finalize string values (regular strings and functions interpolated into css calls)


  if (registered == null) {
    return interpolation;
  }

  var cached = registered[interpolation];
  return cached !== undefined ? cached : interpolation;
}

function createStringFromObject(mergedProps, registered, obj) {
  var string = '';

  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];

      if (typeof value !== 'object') {
        if (registered != null && registered[value] !== undefined) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === 'NO_COMPONENT_SELECTOR' && process.env.NODE_ENV !== 'production') {
          throw new Error('Component selectors can only be used in conjunction with @emotion/babel-plugin.');
        }

        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);

          switch (_key) {
            case 'animation':
            case 'animationName':
              {
                string += processStyleName(_key) + ":" + interpolated + ";";
                break;
              }

            default:
              {
                if (process.env.NODE_ENV !== 'production' && _key === 'undefined') {
                  console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
                }

                string += _key + "{" + interpolated + "}";
              }
          }
        }
      }
    }
  }

  return string;
}

var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;

if (process.env.NODE_ENV !== 'production') {
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
} // this is the cursor for keyframes
// keyframes are stored on the SerializedStyles object as a linked list


var cursor;
var serializeStyles = function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
    return args[0];
  }

  var stringMode = true;
  var styles = '';
  cursor = undefined;
  var strings = args[0];

  if (strings == null || strings.raw === undefined) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    if (process.env.NODE_ENV !== 'production' && strings[0] === undefined) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }

    styles += strings[0];
  } // we start at 1 since we've already handled the first arg


  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);

    if (stringMode) {
      if (process.env.NODE_ENV !== 'production' && strings[i] === undefined) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }

      styles += strings[i];
    }
  }

  var sourceMap;

  if (process.env.NODE_ENV !== 'production') {
    styles = styles.replace(sourceMapPattern, function (match) {
      sourceMap = match;
      return '';
    });
  } // using a global regex with .exec is stateful so lastIndex has to be reset each time


  labelPattern.lastIndex = 0;
  var identifierName = '';
  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

  while ((match = labelPattern.exec(styles)) !== null) {
    identifierName += '-' + // $FlowFixMe we know it's not null
    match[1];
  }

  var name = murmur2(styles) + identifierName;

  if (process.env.NODE_ENV !== 'production') {
    // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)
    return {
      name: name,
      styles: styles,
      map: sourceMap,
      next: cursor,
      toString: function toString() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
  }

  return {
    name: name,
    styles: styles,
    next: cursor
  };
};

var hasOwnProperty$a = Object.prototype.hasOwnProperty;

var EmotionCacheContext = /* #__PURE__ */React.createContext( // we're doing this to avoid preconstruct's dead code elimination in this one case
// because this module is primarily intended for the browser and node
// but it's also required in react native and similar environments sometimes
// and we could have a special build just for that
// but this is much easier and the native packages
// might use a different theme context in the future anyway
typeof HTMLElement !== 'undefined' ? /* #__PURE__ */createCache({
  key: 'css'
}) : null);

if (process.env.NODE_ENV !== 'production') {
  EmotionCacheContext.displayName = 'EmotionCacheContext';
}

EmotionCacheContext.Provider;

var withEmotionCache = function withEmotionCache(func) {
  // $FlowFixMe
  return /*#__PURE__*/React.forwardRef(function (props, ref) {
    // the cache will never be null in the browser
    var cache = React.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};

var ThemeContext$1 = /* #__PURE__ */React.createContext({});

if (process.env.NODE_ENV !== 'production') {
  ThemeContext$1.displayName = 'EmotionThemeContext';
}

// thus we only need to replace what is a valid character for JS, but not for CSS

var sanitizeIdentifier = function sanitizeIdentifier(identifier) {
  return identifier.replace(/\$/g, '-');
};

var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
var labelPropName = '__EMOTION_LABEL_PLEASE_DO_NOT_USE__';
var createEmotionProps = function createEmotionProps(type, props) {
  if (process.env.NODE_ENV !== 'production' && typeof props.css === 'string' && // check if there is a css declaration
  props.css.indexOf(':') !== -1) {
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props.css + "`");
  }

  var newProps = {};

  for (var key in props) {
    if (hasOwnProperty$a.call(props, key)) {
      newProps[key] = props[key];
    }
  }

  newProps[typePropName] = type;

  if (process.env.NODE_ENV !== 'production') {
    var error = new Error();

    if (error.stack) {
      // chrome
      var match = error.stack.match(/at (?:Object\.|Module\.|)(?:jsx|createEmotionProps).*\n\s+at (?:Object\.|)([A-Z][A-Za-z0-9$]+) /);

      if (!match) {
        // safari and firefox
        match = error.stack.match(/.*\n([A-Z][A-Za-z0-9$]+)@/);
      }

      if (match) {
        newProps[labelPropName] = sanitizeIdentifier(match[1]);
      }
    }
  }

  return newProps;
};
var Emotion = /* #__PURE__ */withEmotionCache(function (props, cache, ref) {
  var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
  // not passing the registered cache to serializeStyles because it would
  // make certain babel optimisations not possible

  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
    cssProp = cache.registered[cssProp];
  }

  var type = props[typePropName];
  var registeredStyles = [cssProp];
  var className = '';

  if (typeof props.className === 'string') {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }

  var serialized = serializeStyles(registeredStyles, undefined, React.useContext(ThemeContext$1));

  if (process.env.NODE_ENV !== 'production' && serialized.name.indexOf('-') === -1) {
    var labelFromStack = props[labelPropName];

    if (labelFromStack) {
      serialized = serializeStyles([serialized, 'label:' + labelFromStack + ';']);
    }
  }

  insertStyles(cache, serialized, typeof type === 'string');
  className += cache.key + "-" + serialized.name;
  var newProps = {};

  for (var key in props) {
    if (hasOwnProperty$a.call(props, key) && key !== 'css' && key !== typePropName && (process.env.NODE_ENV === 'production' || key !== labelPropName)) {
      newProps[key] = props[key];
    }
  }

  newProps.ref = ref;
  newProps.className = className;
  var ele = /*#__PURE__*/React.createElement(type, newProps);

  return ele;
});

if (process.env.NODE_ENV !== 'production') {
  Emotion.displayName = 'EmotionCssPropInternal';
}

function jsx(type, props, key) {
  if (!hasOwnProperty$a.call(props, 'css')) {
    return jsxRuntime.jsx(type, props, key);
  }

  return jsxRuntime.jsx(Emotion, createEmotionProps(type, props), key);
}

var _excluded$C = ["component", "sx", "scroll", "outsideClassName", "insideClassName", "className", "children"];

/**
 *  The default value of the prop `component`
 *  @default
 *  div
 */
var defaultElement = 'div';

/**
 * Box is a component that has the attributes as an HTML Element with CSS properties based on the VUI system (`sx` prop).
 * @param component The tag/component to render. Default is `div`.
 * @param sx The VUI styled system to serve as the CSS properties, responsive and custom.
 */
// eslint-disable-next-line react/display-name
var Box = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var component = props.component,
      sx = props.sx,
      scroll = props.scroll,
      outsideClassName = props.outsideClassName,
      insideClassName = props.insideClassName,
      className = props.className,
      children = props.children,
      rest = _objectWithoutProperties(props, _excluded$C);

  var Element = component || defaultElement;

  var _useSx = useSx(sx),
      sxClass = _useSx.sxClass,
      sxOutsideBoxClass = _useSx.sxOutsideBoxClass,
      sxInsideBoxClass = _useSx.sxInsideBoxClass,
      jssOutsideBoxStyled = _useSx.jssOutsideBoxStyled,
      jssInsideBoxStyled = _useSx.jssInsideBoxStyled,
      jssStyled = _useSx.jssStyled;

  var fullClass = clsx__default['default'](className, outsideClassName, insideClassName, sxClass);
  var outsideClass = clsx__default['default'](className, outsideClassName, sxOutsideBoxClass);
  var insideClass = clsx__default['default'](insideClassName, sxInsideBoxClass);
  var responsiveOutside = jssOutsideBoxStyled ? react.css(_objectSpread2({}, jssOutsideBoxStyled)) : null;
  var responsiveInside = jssInsideBoxStyled ? react.css(_objectSpread2({}, jssInsideBoxStyled)) : null;
  var responsive = jssStyled ? react.css(_objectSpread2({}, jssStyled)) : null;
  var scrollProps = _typeof(scroll) === 'object' ? _objectSpread2({}, scroll) : null;
  var kids = typeof children === 'string' ? jsx(T, {
    children: children
  }) : children;
  return jsx(Element, _objectSpread2(_objectSpread2({
    ref: ref,
    className: !scroll ? fullClass : outsideClass,
    css: !scroll ? responsive : responsiveOutside
  }, rest), {}, {
    children: !scroll ? kids : jsx(ScrollView, _objectSpread2(_objectSpread2({
      className: insideClass,
      css: responsiveInside
    }, scrollProps), {}, {
      children: kids
    }))
  }));
});

var _excluded$B = ["children", "direction", "wrap", "justify", "items", "content", "gap", "width", "height", "divide", "item", "order", "grow", "shrink", "self", "panel", "scroll", "sx"],
    _excluded2$6 = ["children"];

// If `directionProp` is equal to `undefined` meaning Flexbox has the default direction is `row`.
var flexIs = function flexIs(directionProp, direction) {
  return directionProp ? directionProp.indexOf(direction) !== -1 : direction === 'row' ? true : false;
};

var validateFlexItem = function validateFlexItem(itemProps) {
  if (itemProps[0] === true) {
    return;
  }

  var existProps = itemProps.filter(function (prop) {
    return typeof prop !== 'undefined' || prop === 0 || prop;
  });

  if (existProps.length) {
    throw new Error('Prop `item` is missing for the component `Flex`.');
  }
};

var validateDivide = function validateDivide(divide) {
  if (typeof divide === 'string' || typeof divide === 'number') {
    return;
  }

  if (_typeof(divide) === 'object') {
    var x = divide.x,
        y = divide.y;

    if ((x || x === 0) && !y || !x && (y || y === 0)) {
      return;
    } else {
      throw new Error('Prop `divide` can only have `x` or `y`.');
    }
  }
};

var PreFlex = function PreFlex(props) {
  var _commonClass, _objectSpread2$1, _objectSpread3;

  var children = props.children,
      direction = props.direction,
      wrap = props.wrap,
      justify = props.justify,
      items = props.items,
      content = props.content,
      gap = props.gap,
      width = props.width,
      height = props.height,
      divide = props.divide,
      item = props.item,
      order = props.order,
      grow = props.grow,
      shrink = props.shrink,
      self = props.self,
      _props$panel = props.panel,
      panel = _props$panel === void 0 ? false : _props$panel,
      scroll = props.scroll,
      sx = props.sx,
      rest = _objectWithoutProperties(props, _excluded$B);

  validateDivide(divide);
  validateFlexItem([item, order, grow, shrink, self]);

  var orderSwitcher = function orderSwitcher(order) {
    return order === 'first' ? -9999 : order === 'last' ? 9999 : order;
  };

  var getGapClass = function getGapClass(gap) {
    if (typeof gap === 'undefined') {
      return;
    }

    if (_typeof(gap) === 'object') {
      var classObj = {};
      var dimensions = Object.keys(gap);

      for (var i = 0; i < dimensions.length; i++) {
        classObj["gap-".concat(dimensions[i], "-").concat(gap[dimensions[i]])] = gap[dimensions[i]] === 0 || gap[dimensions[i]];
      }

      return classObj;
    }

    return _defineProperty$1({}, "gap-".concat(gap), gap === 0 || gap);
  };

  var getDivideClass = function getDivideClass(divide) {
    if (_typeof(divide) === 'object' && (typeof divide.x === 'number' || typeof divide.y === 'number')) {
      var _ref2;

      return _ref2 = {}, _defineProperty$1(_ref2, "divide-x-".concat(divide.x), typeof divide.x === 'number'), _defineProperty$1(_ref2, "divide-y-".concat(divide.y), typeof divide.y === 'number'), _ref2;
    } else if (_typeof(divide) === 'object' && _typeof(divide === null || divide === void 0 ? void 0 : divide.x) === 'object') {
      var _divide$x, _ref3;

      return _ref3 = {}, _defineProperty$1(_ref3, "divide-x-".concat(divide === null || divide === void 0 ? void 0 : (_divide$x = divide.x) === null || _divide$x === void 0 ? void 0 : _divide$x.width), typeof divide.x.width === 'number'), _defineProperty$1(_ref3, 'divide-x-reverse', divide.x.reverse), _ref3;
    } else if (_typeof(divide) === 'object' && _typeof(divide === null || divide === void 0 ? void 0 : divide.y) === 'object') {
      var _divide$y, _ref4;

      return _ref4 = {}, _defineProperty$1(_ref4, "divide-y-".concat(divide === null || divide === void 0 ? void 0 : (_divide$y = divide.y) === null || _divide$y === void 0 ? void 0 : _divide$y.width), typeof divide.y.width === 'number'), _defineProperty$1(_ref4, 'divide-y-reverse', divide.y.reverse), _ref4;
    }

    return _defineProperty$1({}, "divide-".concat(divide), typeof divide === 'string');
  };

  var commonClass = (_commonClass = {
    'w-full': wrap && typeof width === 'undefined',
    'h-full': wrap && typeof height === 'undefined'
  }, _defineProperty$1(_commonClass, "w-".concat(width), typeof (sx === null || sx === void 0 ? void 0 : sx.width) === 'undefined' && (width === 0 || width)), _defineProperty$1(_commonClass, "h-".concat(height), typeof (sx === null || sx === void 0 ? void 0 : sx.height) === 'undefined' && (height === 0 || height)), _defineProperty$1(_commonClass, 'overflow-hidden', panel && (flexIs(direction, 'row') && typeof height === 'undefined' || flexIs(direction, 'col') && typeof width === 'undefined' && !wrap)), _commonClass);

  var containerClass = _objectSpread2(_objectSpread2((_objectSpread2$1 = {}, _defineProperty$1(_objectSpread2$1, "flex-".concat(direction), direction), _defineProperty$1(_objectSpread2$1, "justify-".concat(justify), justify), _defineProperty$1(_objectSpread2$1, "items-".concat(items), items), _defineProperty$1(_objectSpread2$1, "content-".concat(content), content), _defineProperty$1(_objectSpread2$1, "flex-".concat(wrap === true ? 'wrap' : 'wrap-reverse'), wrap), _objectSpread2$1), getGapClass(gap)), getDivideClass(divide));

  var itemClass = item ? _objectSpread2((_objectSpread3 = {}, _defineProperty$1(_objectSpread3, "order-".concat(orderSwitcher(order)), order === 0 || order), _defineProperty$1(_objectSpread3, "flex-grow-".concat(grow), grow === 0 || grow), _defineProperty$1(_objectSpread3, "flex-shrink-".concat(shrink), shrink === 0 || shrink), _defineProperty$1(_objectSpread3, "self-".concat(self), self), _objectSpread3), commonClass) : _objectSpread2({}, commonClass);
  var flexPanel = clsx__default['default']('flex', // The VUI layout panel concept is the application panels
  // `flex: 1` to stretch the flex container to the full width of the parent.
  // 2nd condition to ensure the exact sizing has been set.
  {
    'flex-grow flex-shrink flex-basis-0': panel && !(width === 0 || width || height === 0 || height)
  });
  var outsideClass = scroll ? clsx__default['default'](flexPanel, itemClass) : clsx__default['default'](flexPanel, _objectSpread2(_objectSpread2({}, containerClass), itemClass));
  var insideClass = scroll ? clsx__default['default']('flex flex-scroll-inner', {
    // Ensure the Perfect Scrollbar stretch full size of the container if direction is column.
    'w-full': direction === 'col' || direction === 'col-reverse'
  }, containerClass) : '';
  return /*#__PURE__*/jsxRuntime.jsx(Box, _objectSpread2(_objectSpread2({
    outsideClassName: outsideClass,
    insideClassName: insideClass,
    scroll: scroll,
    sx: sx
  }, rest), {}, {
    children: children
  }));
};
/**
 * Flex is a component-based on Flexbox with the custom prop `panel` to set the layout to panel environment.
 *
 * If panel is set to `true`, the component will be a panel environment, which has the following layout:
 *
 * - The component will stretch to fill the flexbox wrapping if does not set the size.
 *
 * - Set the CSS property `overflow` is hidden to make sure the elements have specific size (width, height) are not pushed by elements with `flex-grow` greater than 0.
 */
// eslint-disable-next-line react/display-name


var Flex = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var children = props.children,
      rest = _objectWithoutProperties(props, _excluded2$6);

  return /*#__PURE__*/jsxRuntime.jsx(PreFlex, _objectSpread2(_objectSpread2({
    ref: ref
  }, rest), {}, {
    children: children
  }));
});

var _excluded$A = ["children", "divide", "reverse", "panel"],
    _excluded2$5 = ["children"];
var Column = function Column(props) {
  var _clsx;

  var _props$className = props.className,
      className = _props$className === void 0 ? '' : _props$className,
      _props$mainAxisAlignm = props.mainAxisAlignment,
      mainAxisAlignment = _props$mainAxisAlignm === void 0 ? 'start' : _props$mainAxisAlignm,
      _props$crossAxisAlign = props.crossAxisAlignment,
      crossAxisAlignment = _props$crossAxisAlign === void 0 ? 'stretch' : _props$crossAxisAlign,
      mainAxisSize = props.mainAxisSize,
      crossAxisSize = props.crossAxisSize,
      _props$itemMargin = props.itemMargin,
      itemMargin = _props$itemMargin === void 0 ? 'none' : _props$itemMargin,
      width = props.width,
      height = props.height,
      _props$flex = props.flex,
      flex = _props$flex === void 0 ? 1 : _props$flex,
      scroll = props.scroll,
      wrap = props.wrap,
      reverse = props.reverse,
      _props$clipped = props.clipped,
      clipped = _props$clipped === void 0 ? true : _props$clipped,
      innerRef = props.innerRef,
      border = props.border,
      borderLeft = props.borderLeft,
      borderRight = props.borderRight,
      borderBottom = props.borderBottom,
      borderTop = props.borderTop,
      style = props.style,
      onClick = props.onClick;
  var colClass = clsx__default['default']('layout-column', (_clsx = {
    'flex-column-reverse': reverse,
    'flex-wrap': wrap,
    'overflow-hidden': !width && clipped
  }, _defineProperty$1(_clsx, "justify-".concat(mainAxisAlignment), mainAxisAlignment !== 'start'), _defineProperty$1(_clsx, "items-".concat(crossAxisAlignment), crossAxisAlignment !== 'stretch'), _defineProperty$1(_clsx, "main-".concat(mainAxisSize), mainAxisSize), _defineProperty$1(_clsx, "cross-".concat(crossAxisSize), crossAxisSize), _defineProperty$1(_clsx, "item-margin-".concat(itemMargin), itemMargin !== 'none'), _defineProperty$1(_clsx, 'border', border), _defineProperty$1(_clsx, 'border-left', borderLeft), _defineProperty$1(_clsx, 'border-right', borderRight), _defineProperty$1(_clsx, 'border-bottom', borderBottom), _defineProperty$1(_clsx, 'border-top', borderTop), _defineProperty$1(_clsx, "".concat(className), className), _clsx));
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    ref: innerRef,
    className: colClass,
    style: _objectSpread2(_objectSpread2({}, style), {}, {
      width: width,
      height: height,
      flexGrow: height || width ? 0 : flex > 0 ? flex : undefined,
      flexShrink: height || width ? 0 : flex > 0 ? 1 : undefined,
      flexBasis: height || width ? 'auto' : flex > 0 ? '0%' : undefined
    }),
    onClick: onClick,
    children: scroll ? /*#__PURE__*/jsxRuntime.jsx(OverflowContent, {
      children: props.children
    }) : props.children
  });
}; // =============================================================================
// Column version 2
// =============================================================================

var PreCol2 = function PreCol2(props) {
  var children = props.children,
      divide = props.divide,
      reverse = props.reverse,
      _props$panel = props.panel,
      panel = _props$panel === void 0 ? true : _props$panel,
      rest = _objectWithoutProperties(props, _excluded$A);

  var divideConvert = function divideConvert(divide) {
    if (divide === true) {
      return 'y';
    } else if (typeof divide === 'number') {
      return {
        y: divide
      };
    } else if (_typeof(divide) === 'object') {
      return {
        y: divide
      };
    } else {
      return divide;
    }
  };

  return /*#__PURE__*/jsxRuntime.jsx(Flex, _objectSpread2(_objectSpread2({
    divide: divideConvert(divide),
    direction: reverse ? 'col-reverse' : 'col',
    panel: panel
  }, rest), {}, {
    children: children
  }));
};
/**
 * Column is a component-based on Flex with its props as the panel environment and the direction of items is y-axis.
 *
 * Prop `panel` - Default `true`.
 *
 * - The element will stretch to fill the flexbox wrapping if does not set the size.
 *
 * - The content is clipped `overflow: hidden` to make sure the elements have specific size are not pushed by elements with `flex-grow` greater than `0`.
 *
 * The `direction` prop of Flex is prevented to be set. So want to reverse the direction of items, you can use the `reverse` prop.
 */
// eslint-disable-next-line react/display-name


var Col2 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var children = props.children,
      rest = _objectWithoutProperties(props, _excluded2$5);

  return /*#__PURE__*/jsxRuntime.jsx(PreCol2, _objectSpread2(_objectSpread2({
    ref: ref
  }, rest), {}, {
    children: children
  }));
});

var _excluded$z = ["children", "divide", "reverse", "panel"],
    _excluded2$4 = ["children"];
var Row = function Row(props) {
  var _clsx;

  var _props$className = props.className,
      className = _props$className === void 0 ? '' : _props$className,
      _props$mainAxisAlignm = props.mainAxisAlignment,
      mainAxisAlignment = _props$mainAxisAlignm === void 0 ? 'start' : _props$mainAxisAlignm,
      _props$crossAxisAlign = props.crossAxisAlignment,
      crossAxisAlignment = _props$crossAxisAlign === void 0 ? 'stretch' : _props$crossAxisAlign,
      mainAxisSize = props.mainAxisSize,
      crossAxisSize = props.crossAxisSize,
      _props$itemMargin = props.itemMargin,
      itemMargin = _props$itemMargin === void 0 ? 'none' : _props$itemMargin,
      width = props.width,
      height = props.height,
      _props$flex = props.flex,
      flex = _props$flex === void 0 ? 1 : _props$flex,
      scroll = props.scroll,
      wrap = props.wrap,
      innerRef = props.innerRef,
      _props$clipped = props.clipped,
      clipped = _props$clipped === void 0 ? true : _props$clipped,
      reverse = props.reverse,
      _props$border = props.border,
      border = _props$border === void 0 ? false : _props$border,
      _props$borderLeft = props.borderLeft,
      borderLeft = _props$borderLeft === void 0 ? false : _props$borderLeft,
      _props$borderRight = props.borderRight,
      borderRight = _props$borderRight === void 0 ? false : _props$borderRight,
      _props$borderBottom = props.borderBottom,
      borderBottom = _props$borderBottom === void 0 ? false : _props$borderBottom,
      _props$borderTop = props.borderTop,
      borderTop = _props$borderTop === void 0 ? false : _props$borderTop,
      style = props.style,
      onClick = props.onClick;
  var rowClass = clsx__default['default']('layout-row', (_clsx = {
    'flex-row-reverse': reverse,
    'flex-wrap': wrap,
    'overflow-hidden': !height && clipped
  }, _defineProperty$1(_clsx, "justify-".concat(mainAxisAlignment), mainAxisAlignment !== 'start'), _defineProperty$1(_clsx, "items-".concat(crossAxisAlignment), crossAxisAlignment !== 'stretch'), _defineProperty$1(_clsx, "main-".concat(mainAxisSize), mainAxisSize), _defineProperty$1(_clsx, "cross-".concat(crossAxisSize), crossAxisSize), _defineProperty$1(_clsx, "item-margin-".concat(itemMargin), itemMargin !== 'none'), _defineProperty$1(_clsx, 'border', border), _defineProperty$1(_clsx, 'border-left', borderLeft), _defineProperty$1(_clsx, 'border-right', borderRight), _defineProperty$1(_clsx, 'border-bottom', borderBottom), _defineProperty$1(_clsx, 'border-top', borderTop), _clsx), className);
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    ref: innerRef,
    className: rowClass,
    style: _objectSpread2(_objectSpread2({}, style), {}, {
      width: width,
      height: height,
      maxHeight: height,
      flexGrow: height || width ? 0 : flex > 0 ? flex : undefined,
      flexShrink: height || width ? 0 : flex > 0 ? 1 : undefined,
      flexBasis: height || width ? 'auto' : flex > 0 ? '0%' : undefined
    }),
    onClick: onClick,
    children: scroll ? /*#__PURE__*/jsxRuntime.jsx(OverflowContent, {
      children: props.children
    }) : props.children
  });
}; // =============================================================================
// Row version 2
// =============================================================================

var PreRow2 = function PreRow2(props) {
  var children = props.children,
      divide = props.divide,
      reverse = props.reverse,
      _props$panel = props.panel,
      panel = _props$panel === void 0 ? true : _props$panel,
      rest = _objectWithoutProperties(props, _excluded$z);

  var divideConvert = function divideConvert(divide) {
    if (divide === true) {
      return 'x';
    } else if (typeof divide === 'number') {
      return {
        x: divide
      };
    } else if (_typeof(divide) === 'object') {
      return {
        x: divide
      };
    } else {
      return divide;
    }
  };

  return /*#__PURE__*/jsxRuntime.jsx(Flex, _objectSpread2(_objectSpread2({
    divide: divideConvert(divide),
    direction: reverse ? 'row-reverse' : undefined,
    panel: panel
  }, rest), {}, {
    children: children
  }));
};
/**
 * Row is a component-based on Flex with its props as the panel environment and the direction of items is x-axis.
 *
 * Prop `panel` - Default `true`.
 *
 * - The element will stretch to fill the flexbox wrapping if does not set the size.
 *
 * - The content is clipped `overflow: hidden` to make sure the elements have specific size are not pushed by elements with `flex-grow` greater than `0`.
 *
 * The `direction` prop of Flex is prevented to be set. So want to reverse the direction of items, you can use the `reverse` prop.
 */
// eslint-disable-next-line react/display-name


var Row2 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var children = props.children,
      rest = _objectWithoutProperties(props, _excluded2$4);

  return /*#__PURE__*/jsxRuntime.jsx(PreRow2, _objectSpread2(_objectSpread2({
    ref: ref
  }, rest), {}, {
    children: children
  }));
});

var Spinner = function Spinner(props) {
  var className = props.className,
      _props$size = props.size,
      size = _props$size === void 0 ? 'md' : _props$size,
      _props$color = props.color,
      color = _props$color === void 0 ? 'primary' : _props$color;
  var classNames = clsx__default['default']('spinner', _defineProperty$1({}, "size-".concat(size), size), className);
  var spinnerStyle = {
    '--line-color': color ? "var(--".concat(color, "-color)") : ''
  };
  return /*#__PURE__*/jsxRuntime.jsxs("svg", {
    className: classNames,
    style: spinnerStyle,
    viewBox: "0 0 50 50",
    children: [/*#__PURE__*/jsxRuntime.jsx("circle", {
      className: "spinner__ring",
      cx: "25",
      cy: "25",
      r: "22.5"
    }), /*#__PURE__*/jsxRuntime.jsx("circle", {
      className: "spinner__line",
      cx: "25",
      cy: "25",
      r: "22.5"
    })]
  });
};

var _excluded$y = ["className", "color", "secondary", "children", "variant"];
var MAPPED_TEXT_VARIANT_CLASSES = {
  TB1: 'tb tb1',
  TB2: 'tb tb2',
  HD1: 'hd hd1',
  HD2: 'hd hd2',
  HD3: 'hd hd3',
  HD4: 'hd hd4',
  HD5: 'hd hd5',
  HD6: 'hd hd6',
  Sub1: 'sub sub1',
  Sub2: 'sub sub2'
};

var Typography = function Typography(props) {
  var className = props.className,
      color = props.color,
      secondary = props.secondary,
      children = props.children,
      variant = props.variant,
      restProps = _objectWithoutProperties(props, _excluded$y);

  var validSecondaryVariants = ['TB1', 'TB2'];
  var typographyClasses = clsx__default['default'](className, MAPPED_TEXT_VARIANT_CLASSES[variant], color && "sub-".concat(color), validSecondaryVariants.includes(variant) && secondary && 'tb-secondary');
  return /*#__PURE__*/jsxRuntime.jsx("span", _objectSpread2(_objectSpread2({
    className: typographyClasses
  }, restProps), {}, {
    children: /*#__PURE__*/jsxRuntime.jsx(T, {
      children: children
    })
  }));
};

var TB1 = function TB1(props) {
  return /*#__PURE__*/jsxRuntime.jsx(Typography, _objectSpread2({
    variant: "TB1"
  }, props));
};

var TB2 = function TB2(props) {
  return /*#__PURE__*/jsxRuntime.jsx(Typography, _objectSpread2({
    variant: "TB2"
  }, props));
};

var HD1 = function HD1(props) {
  return /*#__PURE__*/jsxRuntime.jsx(Typography, _objectSpread2({
    variant: "HD1"
  }, props));
};

var HD2 = function HD2(props) {
  return /*#__PURE__*/jsxRuntime.jsx(Typography, _objectSpread2({
    variant: "HD2"
  }, props));
};

var HD3 = function HD3(props) {
  return /*#__PURE__*/jsxRuntime.jsx(Typography, _objectSpread2({
    variant: "HD3"
  }, props));
};

var HD4 = function HD4(props) {
  return /*#__PURE__*/jsxRuntime.jsx(Typography, _objectSpread2({
    variant: "HD4"
  }, props));
};

var HD5 = function HD5(props) {
  return /*#__PURE__*/jsxRuntime.jsx(Typography, _objectSpread2({
    variant: "HD5"
  }, props));
};

var HD6 = function HD6(props) {
  return /*#__PURE__*/jsxRuntime.jsx(Typography, _objectSpread2({
    variant: "HD6"
  }, props));
};

var Sub1 = function Sub1(props) {
  return /*#__PURE__*/jsxRuntime.jsx(Typography, _objectSpread2({
    variant: "Sub1"
  }, props));
};

var Sub2 = function Sub2(props) {
  return /*#__PURE__*/jsxRuntime.jsx(Typography, _objectSpread2({
    variant: "Sub2"
  }, props));
};

/**
* ConditionalWrapper is HOC component use for add an wrapper conditionally
*
* @param condition add/remove wrapper
* @param wrapper React component which can wrap other components
* @example
    From:
        {!!formName
            ? <Section>
                <ChildComponent/>
              <Section/>
            : <ChildComponent />

    To:
        <ConditionalWrapper
            condition={!!formName}
            wrapper={(children) => <Section header={formName as string}>{children}</Section>}
        >
            <ChildComponent/>
        </ConditionalWrapper>
*/
var ConditionalWrapper = function ConditionalWrapper(_ref) {
  var condition = _ref.condition,
      children = _ref.children,
      wrapper = _ref.wrapper;
  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: condition ? wrapper(children) : children
  });
};

var MAPPED_TEXT_SIZE = {
  xs: 'TB2',
  sm: 'TB1',
  md: 'Sub1',
  lg: 'HD6',
  xl: 'HD5',
  xxl: 'HD4'
};
var Loading = function Loading(props) {
  var className = props.className,
      fullscreen = props.fullscreen,
      spinnerSize = props.spinnerSize,
      text = props.text,
      _props$direction = props.direction,
      direction = _props$direction === void 0 ? 'column' : _props$direction,
      overlay = props.overlay;
  var classNames = clsx__default['default']('loading', overlay && 'loading--overlay', className);
  var size = !spinnerSize ? fullscreen ? 'xl' : 'md' : spinnerSize;
  var Wrapper = direction === 'column' ? Col2 : Row2;

  var Inner = function Inner() {
    return /*#__PURE__*/jsxRuntime.jsxs(Wrapper, {
      className: fullscreen ? '' : classNames,
      height: "full",
      justify: "center",
      items: "center",
      gap: direction === 'row' ? 2 : undefined,
      children: [/*#__PURE__*/jsxRuntime.jsx(Spinner, {
        size: size
      }), text && /*#__PURE__*/jsxRuntime.jsx(Typography, {
        variant: MAPPED_TEXT_SIZE[size],
        children: text
      })]
    });
  };

  return /*#__PURE__*/jsxRuntime.jsx(ConditionalWrapper, {
    condition: fullscreen,
    wrapper: function wrapper(children) {
      return /*#__PURE__*/jsxRuntime.jsx(Overlay, {
        className: classNames,
        fullscreen: true,
        children: children
      });
    },
    children: /*#__PURE__*/jsxRuntime.jsx(Inner, {})
  });
};

var http = new HttpClient();
var TenantContext = /*#__PURE__*/React.createContext({});

var TenantProvider = function TenantProvider(_ref) {
  var apiURL = _ref.apiURL,
      children = _ref.children;

  var _useState = React.useState({}),
      _useState2 = _slicedToArray(_useState, 2),
      tenantConfig = _useState2[0],
      setTenantConfig = _useState2[1];

  var _useState3 = React.useState(true),
      _useState4 = _slicedToArray(_useState3, 2),
      loading = _useState4[0],
      setLoading = _useState4[1];

  React.useEffect(function () {
    if (apiURL) {
      http.get(apiURL).then(function (config) {
        var _config$vdms;

        // if config has public access token, write it down
        if (config !== null && config !== void 0 && (_config$vdms = config.vdms) !== null && _config$vdms !== void 0 && _config$vdms.publicAccessToken) {
          Cookies__default['default'].set('vdmsPublicAccesstoken', config.vdms.publicAccessToken);
        }

        setTenantConfig(config);
        setLoading(false);
      });
    } else {
      setLoading(false);
    }
  }, []);
  return /*#__PURE__*/jsxRuntime.jsx(TenantContext.Provider, {
    value: {
      config: tenantConfig
    },
    children: loading ? /*#__PURE__*/jsxRuntime.jsx(Loading, {
      fullscreen: true
    }) : children
  });
};

var enData = {
	"Trường này là bắt buộc.": "This field is required.",
	"Giá trị của trường nhỏ hơn giá trị tối thiểu.": "This field's value is smaller than min value.",
	"Giá trị của trường lớn hơn giá trị tối đa.": "This field's value is greater than max value.",
	"Số ký tự của trường nhỏ hơn giới hạn tối thiểu.": "This field's value length is smaller than min field value length.",
	"Số ký tự của trường vượt quá giới hạn tối đa.": "This field's value length is greater than max field value length.",
	"Giá trị của trường sai mẫu.": "This field's value is not match the pattern.",
	"Giá trị của trường không hợp lệ.": "This field's value is not pass the validation."
};

var I18nContext = /*#__PURE__*/React.createContext();

var I18nProvider = function I18nProvider(props) {
  var tenantContext = React.useContext(TenantContext);

  var _useState = React.useState(localStorage.getItem('locale') || tenantContext.config['locale'] || 'vi'),
      _useState2 = _slicedToArray(_useState, 2),
      locale = _useState2[0];
      _useState2[1];

  var _useState3 = React.useState(localStorage.getItem('language') || tenantContext.config['language'] || 'vi'),
      _useState4 = _slicedToArray(_useState3, 2),
      language = _useState4[0],
      setLanguage = _useState4[1];

  var translates = _objectSpread2(_objectSpread2({}, getVuiTranslate(language)), props.translates(language));

  if (language !== 'en') {
    require('moment/locale/' + language);
  }

  var handleSetLocale = function handleSetLocale(lo) {// keep it here for backward compatibility
  };

  var handleSetLanguage = function handleSetLanguage(newLanguage) {
    // newLanguage here can be 'en', 'vi', 'en-in'... So it actually is a locale
    localStorage.setItem('language', newLanguage); // also set locale

    localStorage.setItem('locale', newLanguage); // no more reload window, now it all react base on context, still bug in store context (misuse of translation context)
    // window.location.reload();

    setLanguage(newLanguage);
  };

  var addTranslate = function addTranslate(key, value) {
    translates[key] = value;
  };

  var addTranslates = function addTranslates(trans) {
    if (Array.isArray(trans)) {
      trans.forEach(function (d) {
        translates[d.key] = d.value;
      });
    }
  };

  var translate = function translate(text, params, domain) {
    if (typeof text !== 'string') {
      return text;
    }

    var output = text;

    if (translates) {
      if (domain && translates[domain] && translates[domain][text]) {
        output = translates[domain][text];
      } else if (translates[text]) {
        output = translates[text];
      }
    }

    if (Array.isArray(params)) {
      params.forEach(function (p, index) {
        output = output.replace("%".concat(index, "%"), p);
      });
    }

    return output;
  };

  return /*#__PURE__*/jsxRuntime.jsx(I18nContext.Provider, {
    value: {
      locale: locale,
      setLocale: handleSetLocale,
      language: language,
      setLanguage: handleSetLanguage,
      t: translate,
      addTranslate: addTranslate,
      addTranslates: addTranslates
    },
    children: props.children
  });
};

var getVuiTranslate = function getVuiTranslate(language) {
  var MAPPED_LANGUAGE = {
    en: enData
  };

  try {
    return MAPPED_LANGUAGE[language] ? enData : {};
  } catch (error) {
    console.log(error);
    return {};
  }
};

var DomainContext = /*#__PURE__*/React.createContext();
var DomainProvider = function DomainProvider(props) {
  var domain = props.domain;
  return /*#__PURE__*/jsxRuntime.jsx(DomainContext.Provider, {
    value: {
      domain: domain
    },
    children: props.children
  });
};

var useI18n = function useI18n() {
  var i18n = React.useContext(I18nContext);
  var domainContext = React.useContext(DomainContext);
  var domain = domainContext === null || domainContext === void 0 ? void 0 : domainContext['domain'];

  if (!i18n) {
    throw new Error('useI18n must be within I18nProvider');
  }

  var language = (i18n === null || i18n === void 0 ? void 0 : i18n.language) || 'vi';

  var t = function t(text) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return i18n ? i18n.t(text, params, domain) : text;
  };

  var setLocale = function setLocale() {
    i18n && i18n.setLocale();
  };

  var setLanguage = function setLanguage(lang) {
    i18n && i18n.setLanguage(lang);
  };

  var addTranslates = function addTranslates(trans) {
    i18n && i18n.addTranslates(trans);
  };

  return {
    language: language,
    setLocale: setLocale,
    setLanguage: setLanguage,
    addTranslates: addTranslates,
    t: t
  };
};

var language = localStorage.getItem('language') || 'vi';
var T = function T(props) {
  var _useI18n = useI18n(),
      t = _useI18n.t;

  var children = props.children,
      params = props.params;

  if (!children) {
    return null;
  }

  return t(children, params);
};

var _excluded$x = ["id", "className", "onClick", "children", "width", "style", "height", "flex"];
var Container = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var id = props.id,
      className = props.className,
      onClick = props.onClick,
      children = props.children,
      width = props.width,
      style = props.style,
      height = props.height,
      flex = props.flex,
      containerProps = _objectWithoutProperties(props, _excluded$x);

  return /*#__PURE__*/jsxRuntime.jsx("div", _objectSpread2(_objectSpread2({}, containerProps), {}, {
    ref: ref,
    id: id,
    className: className,
    style: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, style), width && {
      width: width
    }), height && {
      height: height
    }), !width && !height && {
      flex: flex
    }),
    onClick: onClick,
    children: typeof children === 'string' ? /*#__PURE__*/jsxRuntime.jsx(T, {
      children: children
    }) : children
  }));
});
Container.displayName = 'Container';

var useStateCallback = function useStateCallback(initialState) {
  var _useState = React.useState(initialState),
      _useState2 = _slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  var callbackRef = React.useRef(null); // init mutable ref container for callbacks

  var setStateCallback = React.useCallback(function (state, callback) {
    callbackRef.current = callback ? callback : null;
    setState(state);
  }, []);
  React.useEffect(function () {
    callbackRef.current && callbackRef.current(state);
    callbackRef.current = null;
  }, [state]);
  return [state, setStateCallback];
};

var isCallBackRef$4 = function isCallBackRef(ref) {
  return !('current' in ref);
};

// Math.random should be unique because of its seeding algorithm.
// Convert it to base 36 (numbers + letters), and grab the first 9 characters
// after the decimal.
var createUniqueId = function createUniqueId() {
  return '_' + Math.random().toString(36).substr(2, 9);
};

var Constants = {
  MY_LAST_COORD: 'vbd_my_last_coordinate',
  MY_LAST_LANGUAGE: 'vbd_my_last_language',
  MY_LAST_MAP_STYLE: 'vbd_my_last_map_style',
  MY_LAST_TRAVEL_MODE: 'vbd_my_last_travel_mode',
  MY_LAST_ROUTE_CRITERIA: 'vbd_my_last_route_criteria',
  DIRECTION_LAYER_ID: 'direction_path_layer',
  DIRECTION_ARROW_BODY_LAYER_ID: 'direction_arrow_layer_body',
  DIRECTION_ARROW_HEAD_LAYER_ID: 'direction_arrow_layer_head',
  DIRECTION_DASH_PATH_LAYER_ID: 'direction_dash_path_layer',
  ARROW_BORDER_COLOR: '#44a0f6',
  PATH_PRIMARY_COLOR: 'rgba(0, 134, 255, 0.5)',
  PATH_PRIMARY_BORDER_COLOR: 'rgba(0, 102, 204, 0.5)',
  PATH_SECONDARY_COLOR: 'rgba(187, 188, 189, 0.5)',
  PATH_SECONDARY_BORDER_COLOR: 'rgba(140, 140, 140, 0.5)',
  DASH_PATH_COLOR: '#888',
  MAP_OBJECT_LINES_LAYER_ID: 'map_object_lines_layer_id',
  MAP_OBJECT_POLYGONS_LAYER_ID: 'map_object_polygons_layer_id',
  LINES_BUFFER_LAYER_ID: 'lines_buffer_layer_id',
  POINTS_BUFFER_LAYER_ID: 'points_buffer_layer_id',
  GEOFENCE_LINES_BUFFER_LAYER_ID: 'geofence_lines_buffer_layer_id',
  GEOFENCE_POINTS_BUFFER_LAYER_ID: 'geofence_points_buffer_layer_id',
  BLOCKADE_LINES_BUFFER_LAYER_ID: 'blockade_lines_buffer_layer_id',
  BLOCKADE_POINTS_BUFFER_LAYER_ID: 'blockade_points_buffer_layer_id',
  DRAWING_MAP_OBJECT_LINE_LAYER_ID: 'drawing_map_object_line_layer_id',
  DRAWING_MAP_OBJECT_POLYGON_LAYER_ID: 'drawing_map_object_polygon_layer_id',
  DRAG_MAP_OBJECT_LINE_LAYER_ID: 'drag_map_object_line_layer_id',
  MAP_OBJECT_MARKER_COLOR: '#c62026',
  MAP_OBJECT_MARKER_SYMBOL: 'default',
  MAP_OBJECT_LINE_COLOR: '#0dadff',
  MAP_OBJECT_LINE_OPACITY: 1,
  MAP_OBJECT_LINE_WIDTH: 3,
  MAP_OBJECT_POLYGON_COLOR: '#0dadff',
  MAP_OBJECT_GEOFENCE_POLYGON_COLOR: 'yellow',
  MAP_OBJECT_POLYGON_OPACITY: 0.2,
  // MAP_MEASURE_DISTANCE_ID: 'map_gl_measure_distance_id',
  // MAP_MEASURE_DISTANCE_POINT: '#0dadff',
  // MAP_MEASURE_DISTANCE_RADIUS: 8,
  // MAP_MEASURE_DISTANCE_LINE_COLOR: '#0dadff',
  // MAP_MEASURE_DISTANCE_LINE_OPACITY: 0.5,
  // MAP_MEASURE_DISTANCE_LINE_WIDTH: 4,
  // blockade style
  MAP_OBJECT_BLOCKADE_POLYGON_COLOR: '#DC143C',
  MAP_OBJECT_BLOCKADE_FLAGPOLE_COLOR: '#DC143C',
  MAP_OBJECT_BLOCKADE_POLYGON_OPACITY: 0.2,
  ADMINISTRATIVE_BOUNDARIES_LAYER_ID: 'administrative_boundaries_layer',
  ADMINISTRATIVE_BOUNDARIES_POLYGON_OPACITY: 0.3,
  ADMINISTRATIVE_BOUNDARIES_POLYGON_COLOR: '#000',
  ADMINISTRATIVE_BOUNDARIES_OUTLINE_COLOR: '#a53b53',
  ADMINISTRATIVE_BOUNDARIES_OUTLINE_WIDTH: 2,
  CIRCLE_SEARCH_NEAR_BY_LAYER_ID: 'circle_search_near_by_layer',
  LEVEL_PROVINCE: 0,
  LEVEL_PROVINCE_TITLE: 'Thành phố / Tỉnh thành',
  TYPE_PROVINCE: 'P',
  LEVEL_DISTRICT: 1,
  LEVEL_DISTRICT_TITLE: 'Quận / Huyện / Thị Xã',
  TYPE_DISTRICT: 'D',
  LEVEL_WARD: 2,
  LEVEL_WARD_TITLE: 'Phường / Xã / Thị Trấn',
  TYPE_WARD: 'W',
  LEVEL_VILLAGE: 3,
  LEVEL_VILLAGE_TITLE: 'Làng / Thôn / Ấp',
  TYPE_PLACE_LIST_FAVORITE: 1,
  NAME_PLACE_LIST_FAVORITE: 'Mục yêu thích',
  TYPE_PLACE_LIST_WANT_GO: 2,
  NAME_PLACE_LIST_WANT_GO: 'Mục muốn đi',
  TYPE_PLACE_LIST_STAR: 3,
  NAME_PLACE_LIST_STAR: 'Địa điểm có gắn dấu sao',
  MY_PLACES_SHOW_HIDE_MARKER: 'my_places_show_hide_marker',
  UNKNOWN_LOCATION: 'Địa điểm chưa xác định',
  MEASURE_LINE_LAYER_ID: 'measure_line_layer_id',
  MEASURE_DRAWING_LINES_LAYER_ID: 'measure_drawing_line_layer_id',
  MEASURE_DRAWING_LINE_OPACITY: 0.6,
  MEASURE_DRAG_LINE_LAYER_ID: 'measure_drag_line_layer_id',
  MEASURE_LINE_COLOR: '#0dadff',
  MEASURE_LINE_WIDTH: 3,
  BARRIER_ID_TEST: 'barrier_id_test',
  GET_VIRTUAL_ROUTE_ID: 'get_virtual_route_id',
  INCIDENT_PATH_PRIMARY_COLOR: '#ffa700',
  INCIDENT_PATH_PRIMARY_BORDER_COLOR: '#684300',
  INCIDENT_DIRECTION_LAYER_ID: 'incident_direction_path_layer',
  INCIDENT_DIRECTION_DASH_PATH_LAYER_ID: 'direction_dash_path_layer',
  MAP_OBJECT: {
    POINTER: 0,
    MARKER: 1,
    LINES: 2,
    POLYGON: 3,
    PATH: 4
  },
  LABEL_FONTSIZE: 12,
  COLORS: [['#0dadff', '#a52713', '#e55100', '#f9a824', '#ffd600', '#817716', '#558b2f', '#0a7138', '#00579b'], ['#673ab7', '#4d342e', '#c2175b', '#ff5252', '#f57c01', '#ffea02', '#afb32a', '#7cb242', '#0097a7']],
  POPULAR_ICONS: [['home', 'utensils-alt', 'glass-cheers', 'shopping-bag', 'clinic-medical', 'bus', 'star', 'parking', 'question-circle'], ['camera', 'traffic-cone', 'do-not-enter', 'car-crash', 'traffic-light', 'broadcast-tower', 'snowplow', 'bullhorn', 'map-marker']],
  INACTIVE_USER_TIMEOUT: 60,
  DEFAULT_IMAGE_ICON_SIZE: 1,
  DEFAULT_VIDEO_MARKER_ICON: 'play-circle',
  DEFAULT_IMAGE_MARKER_ICON: 'image',
  KEYS: {
    ESC: 27,
    TAB: 9,
    RETURN: 13,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    ENTER: 13
  },
  PLATE_DETECTION_HISTORY_VIRTUAL_ROUTE_LAYER_ID: 'PLATE_DETECTION_HISTORY_VIRTUAL_ROUTE_LAYER_ID',
  FACE_DETECTION_HISTORY_VIRTUAL_ROUTE_LAYER_ID: 'FACE_DETECTION_HISTORY_VIRTUAL_ROUTE_LAYER_ID',
  WHAT_HERE_POPUP_ID: 'what-here-marker-popup-id',
  CAMERA_MONITORING_LAYER_ID: 'camera-monitoring-layer-id',
  CAMERA_STATUS_COLOR: {
    BAD: '#ffc107',
    BROKEN: '#ff253a',
    GOOD: '#00a65a'
  },
  CAMERA_STATUS: {
    NO_DATA: 0,
    GOOD: 1,
    BROKEN: 2
  }
};

var Tag = function Tag(props) {
  var _props$text = props.text,
      text = _props$text === void 0 ? '' : _props$text,
      _props$size = props.size,
      size = _props$size === void 0 ? 'small' : _props$size,
      _props$textCase = props.textCase,
      textCase = _props$textCase === void 0 ? 'default' : _props$textCase,
      color = props.color,
      textStyle = props.textStyle,
      isRound = props.isRound,
      className = props.className,
      onCloseClick = props.onCloseClick;
  var style = color ? _objectSpread2({
    backgroundColor: color
  }, textStyle && textStyle) : undefined;
  var textCaseClass = textCase === 'sentence' ? 'first-letter-up' : "tag--".concat(textCase);
  var classes = clsx__default['default']('tag-container', textCase !== 'default' && textCaseClass, isRound && 'tag--round', size && "tag--".concat(size), className);
  return text && /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: classes,
    style: style,
    children: [/*#__PURE__*/jsxRuntime.jsx(T, {
      children: text
    }), onCloseClick && /*#__PURE__*/jsxRuntime.jsx("button", {
      className: 'tag-close-button',
      onClick: onCloseClick,
      children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
        icon: 'times',
        size: size === 'small' ? '0.75rem' : '1rem'
      })
    })]
  });
};

var Tooltip$1 = function Tooltip(props) {
  var children = props.children,
      content = props.content,
      _props$trigger = props.trigger,
      trigger = _props$trigger === void 0 ? ['hover'] : _props$trigger,
      _props$position = props.position,
      position = _props$position === void 0 ? 'top' : _props$position;

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      show = _useState2[0],
      setShow = _useState2[1];

  var inputRef = React.useRef(null);

  var handleMouseIn = function handleMouseIn() {
    return setShow(true);
  };

  var handleMouseOut = function handleMouseOut() {
    return setShow(false);
  };

  var handleClick = function handleClick() {
    return setShow(function (prev) {
      return !prev;
    });
  };

  return /*#__PURE__*/jsxRuntime.jsxs("span", {
    ref: inputRef,
    onMouseOver: trigger.includes('hover') ? handleMouseIn : undefined,
    onMouseLeave: trigger.includes('hover') ? handleMouseOut : undefined,
    onClick: trigger.includes('click') ? handleClick : undefined,
    children: [show && /*#__PURE__*/jsxRuntime.jsx(AnchorOverlay, {
      placement: position,
      anchorEl: inputRef,
      onBackgroundClick: handleMouseOut,
      onBackgroundMouseMove: handleMouseOut,
      children: /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "tooltip",
        children: /*#__PURE__*/jsxRuntime.jsx(T, {
          children: content
        })
      })
    }), children]
  });
};

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

var ManagerReferenceNodeContext = React__namespace.createContext();
var ManagerReferenceNodeSetterContext = React__namespace.createContext();
function Manager(_ref) {
  var children = _ref.children;

  var _React$useState = React__namespace.useState(null),
      referenceNode = _React$useState[0],
      setReferenceNode = _React$useState[1];

  var hasUnmounted = React__namespace.useRef(false);
  React__namespace.useEffect(function () {
    return function () {
      hasUnmounted.current = true;
    };
  }, []);
  var handleSetReferenceNode = React__namespace.useCallback(function (node) {
    if (!hasUnmounted.current) {
      setReferenceNode(node);
    }
  }, []);
  return /*#__PURE__*/React__namespace.createElement(ManagerReferenceNodeContext.Provider, {
    value: referenceNode
  }, /*#__PURE__*/React__namespace.createElement(ManagerReferenceNodeSetterContext.Provider, {
    value: handleSetReferenceNode
  }, children));
}

/**
 * Takes an argument and if it's an array, returns the first item in the array,
 * otherwise returns the argument. Used for Preact compatibility.
 */
var unwrapArray = function unwrapArray(arg) {
  return Array.isArray(arg) ? arg[0] : arg;
};
/**
 * Takes a maybe-undefined function and arbitrary args and invokes the function
 * only if it is defined.
 */

var safeInvoke = function safeInvoke(fn) {
  if (typeof fn === 'function') {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return fn.apply(void 0, args);
  }
};
/**
 * Sets a ref using either a ref callback or a ref object
 */

var setRef$2 = function setRef(ref, node) {
  // if its a function call it
  if (typeof ref === 'function') {
    return safeInvoke(ref, node);
  } // otherwise we should treat it as a ref object
  else if (ref != null) {
      ref.current = node;
    }
};
/**
 * Simple ponyfill for Object.fromEntries
 */

var fromEntries = function fromEntries(entries) {
  return entries.reduce(function (acc, _ref) {
    var key = _ref[0],
        value = _ref[1];
    acc[key] = value;
    return acc;
  }, {});
};
/**
 * Small wrapper around `useLayoutEffect` to get rid of the warning on SSR envs
 */

var useIsomorphicLayoutEffect = typeof window !== 'undefined' && window.document && window.document.createElement ? React__namespace.useLayoutEffect : React__namespace.useEffect;

var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$2,
  requires: ['computeStyles']
};

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

var round$1 = Math.round;
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (isHTMLElement(element) && includeScale) {
    // Fallback to 1 in case both values are `0`
    scaleX = rect.width / element.offsetWidth || 1;
    scaleY = rect.height / element.offsetHeight || 1;
  }

  return {
    width: round$1(rect.width / scaleX),
    height: round$1(rect.height / scaleY),
    top: round$1(rect.top / scaleY),
    right: round$1(rect.right / scaleX),
    bottom: round$1(rect.bottom / scaleY),
    left: round$1(rect.left / scaleX),
    x: round$1(rect.left / scaleX),
    y: round$1(rect.top / scaleY)
  };
}

// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
  var isIE = navigator.userAgent.indexOf('Trident') !== -1;

  if (isIE && isHTMLElement(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle$1(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = getParentNode(element);

  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

var max = Math.max;
var min = Math.min;
var round = Math.round;

function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect$1(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (process.env.NODE_ENV !== "production") {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }

  if (!contains(state.elements.popper, arrowElement)) {
    if (process.env.NODE_ENV !== "production") {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }

    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


var arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect$1,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(round(x * dpr) / dpr) || 0,
    y: round(round(y * dpr) / dpr) || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets;

  var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,
      _ref3$x = _ref3.x,
      x = _ref3$x === void 0 ? 0 : _ref3$x,
      _ref3$y = _ref3.y,
      y = _ref3$y === void 0 ? 0 : _ref3$y;

  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);

      if (getComputedStyle$1(offsetParent).position !== 'static') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === top) {
      sideY = bottom; // $FlowFixMe[prop-missing]

      y -= offsetParent[heightProp] - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left) {
      sideX = right; // $FlowFixMe[prop-missing]

      x -= offsetParent[widthProp] - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref4) {
  var state = _ref4.state,
      options = _ref4.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

  if (process.env.NODE_ENV !== "production") {
    var transitionProperty = getComputedStyle$1(state.elements.popper).transitionProperty || '';

    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }

  var commonStyles = {
    placement: getBasePlacement(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
};

var hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash$1[matched];
  });
}

var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
  // can be obscured underneath it.
  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
  // if it isn't open, so if this isn't available, the popper will be detected
  // to overflow the bottom of the screen too early.

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
    // errors due to floating point numbers, so we need to check precision.
    // Safari returns a number <= 0, usually < -1 when pinch-zoomed
    // Feature detection fails in mobile emulation mode in Chrome.
    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
    // 0.001
    // Fallback here: "Not Safari" userAgent

    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle$1(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle$1(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}

function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

function getVariation(placement) {
  return placement.split('-')[1];
}

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }

  return offsets;
}

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var referenceElement = state.elements.reference;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(referenceElement);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;

    if (process.env.NODE_ENV !== "production") {
      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
    }
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


var flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


var hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var offset$1 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis || checkAltAxis) {
    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min$1 = popperOffsets[mainAxis] + overflow[mainSide];
    var max$1 = popperOffsets[mainAxis] - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;

    if (checkMainAxis) {
      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
      popperOffsets[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset;
    }

    if (checkAltAxis) {
      var _mainSide = mainAxis === 'x' ? top : left;

      var _altSide = mainAxis === 'x' ? bottom : right;

      var _offset = popperOffsets[altAxis];

      var _min = _offset + overflow[_mainSide];

      var _max = _offset - overflow[_altSide];

      var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);

      popperOffsets[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = rect.width / element.offsetWidth || 1;
  var scaleY = rect.height / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}

var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    Object.keys(modifier).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }

          break;

        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }

        case 'phase':
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }

          break;

        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'effect':
          if (typeof modifier.effect !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'requires':
          if (!Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }

          break;

        case 'options':
        case 'data':
          break;

        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }

      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);

    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(options) {
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if (process.env.NODE_ENV !== "production") {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);

          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });

            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }

          var _getComputedStyle = getComputedStyle$1(popper),
              marginTop = _getComputedStyle.marginTop,
              marginRight = _getComputedStyle.marginRight,
              marginBottom = _getComputedStyle.marginBottom,
              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
          // cause bugs with positioning, so we'll warn the consumer


          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }

        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if (process.env.NODE_ENV !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (process.env.NODE_ENV !== "production") {
            __debug_loops__ += 1;

            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      if (process.env.NODE_ENV !== "production") {
        console.error(INVALID_ELEMENT_ERROR);
      }

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

/* global Map:readonly, Set:readonly, ArrayBuffer:readonly */
var hasElementType = typeof Element !== 'undefined';
var hasMap = typeof Map === 'function';
var hasSet = typeof Set === 'function';
var hasArrayBuffer = typeof ArrayBuffer === 'function' && !!ArrayBuffer.isView;

// Note: We **don't** need `envHasBigInt64Array` in fde es6/index.js

function equal(a, b) {
  // START: fast-deep-equal es6/index.js 3.1.1
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }

    // START: Modifications:
    // 1. Extra `has<Type> &&` helpers in initial condition allow es6 code
    //    to co-exist with es5.
    // 2. Replace `for of` with es5 compliant iteration using `for`.
    //    Basically, take:
    //
    //    ```js
    //    for (i of a.entries())
    //      if (!b.has(i[0])) return false;
    //    ```
    //
    //    ... and convert to:
    //
    //    ```js
    //    it = a.entries();
    //    while (!(i = it.next()).done)
    //      if (!b.has(i.value[0])) return false;
    //    ```
    //
    //    **Note**: `i` access switches to `i.value`.
    var it;
    if (hasMap && (a instanceof Map) && (b instanceof Map)) {
      if (a.size !== b.size) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!b.has(i.value[0])) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!equal(i.value[1], b.get(i.value[0]))) return false;
      return true;
    }

    if (hasSet && (a instanceof Set) && (b instanceof Set)) {
      if (a.size !== b.size) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!b.has(i.value[0])) return false;
      return true;
    }
    // END: Modifications

    if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (a[i] !== b[i]) return false;
      return true;
    }

    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
    // END: fast-deep-equal

    // START: react-fast-compare
    // custom handling for DOM elements
    if (hasElementType && a instanceof Element) return false;

    // custom handling for React/Preact
    for (i = length; i-- !== 0;) {
      if ((keys[i] === '_owner' || keys[i] === '__v' || keys[i] === '__o') && a.$$typeof) {
        // React-specific: avoid traversing React elements' _owner
        // Preact-specific: avoid traversing Preact elements' __v and __o
        //    __v = $_original / $_vnode
        //    __o = $_owner
        // These properties contain circular references and are not needed when
        // comparing the actual elements (and not their owners)
        // .$$typeof and ._store on just reasonable markers of elements

        continue;
      }

      // all other properties should be traversed as usual
      if (!equal(a[keys[i]], b[keys[i]])) return false;
    }
    // END: react-fast-compare

    // START: fast-deep-equal
    return true;
  }

  return a !== a && b !== b;
}
// end fast-deep-equal

var reactFastCompare = function isEqual(a, b) {
  try {
    return equal(a, b);
  } catch (error) {
    if (((error.message || '').match(/stack|recursion/i))) {
      // warn on circular references, don't crash
      // browsers give this different errors name and messages:
      // chrome/safari: "RangeError", "Maximum call stack size exceeded"
      // firefox: "InternalError", too much recursion"
      // edge: "Error", "Out of stack space"
      console.warn('react-fast-compare cannot handle circular refs');
      return false;
    }
    // some other error. we should definitely know about these
    throw error;
  }
};

var EMPTY_MODIFIERS$1 = [];
var usePopper = function usePopper(referenceElement, popperElement, options) {
  if (options === void 0) {
    options = {};
  }

  var prevOptions = React__namespace.useRef(null);
  var optionsWithDefaults = {
    onFirstUpdate: options.onFirstUpdate,
    placement: options.placement || 'bottom',
    strategy: options.strategy || 'absolute',
    modifiers: options.modifiers || EMPTY_MODIFIERS$1
  };

  var _React$useState = React__namespace.useState({
    styles: {
      popper: {
        position: optionsWithDefaults.strategy,
        left: '0',
        top: '0'
      },
      arrow: {
        position: 'absolute'
      }
    },
    attributes: {}
  }),
      state = _React$useState[0],
      setState = _React$useState[1];

  var updateStateModifier = React__namespace.useMemo(function () {
    return {
      name: 'updateState',
      enabled: true,
      phase: 'write',
      fn: function fn(_ref) {
        var state = _ref.state;
        var elements = Object.keys(state.elements);
        setState({
          styles: fromEntries(elements.map(function (element) {
            return [element, state.styles[element] || {}];
          })),
          attributes: fromEntries(elements.map(function (element) {
            return [element, state.attributes[element]];
          }))
        });
      },
      requires: ['computeStyles']
    };
  }, []);
  var popperOptions = React__namespace.useMemo(function () {
    var newOptions = {
      onFirstUpdate: optionsWithDefaults.onFirstUpdate,
      placement: optionsWithDefaults.placement,
      strategy: optionsWithDefaults.strategy,
      modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
        name: 'applyStyles',
        enabled: false
      }])
    };

    if (reactFastCompare(prevOptions.current, newOptions)) {
      return prevOptions.current || newOptions;
    } else {
      prevOptions.current = newOptions;
      return newOptions;
    }
  }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
  var popperInstanceRef = React__namespace.useRef();
  useIsomorphicLayoutEffect(function () {
    if (popperInstanceRef.current) {
      popperInstanceRef.current.setOptions(popperOptions);
    }
  }, [popperOptions]);
  useIsomorphicLayoutEffect(function () {
    if (referenceElement == null || popperElement == null) {
      return;
    }

    var createPopper$1 = options.createPopper || createPopper;
    var popperInstance = createPopper$1(referenceElement, popperElement, popperOptions);
    popperInstanceRef.current = popperInstance;
    return function () {
      popperInstance.destroy();
      popperInstanceRef.current = null;
    };
  }, [referenceElement, popperElement, options.createPopper]);
  return {
    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
    styles: state.styles,
    attributes: state.attributes,
    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
  };
};

var NOOP = function NOOP() {
  return void 0;
};

var NOOP_PROMISE = function NOOP_PROMISE() {
  return Promise.resolve(null);
};

var EMPTY_MODIFIERS = [];
function Popper(_ref) {
  var _ref$placement = _ref.placement,
      placement = _ref$placement === void 0 ? 'bottom' : _ref$placement,
      _ref$strategy = _ref.strategy,
      strategy = _ref$strategy === void 0 ? 'absolute' : _ref$strategy,
      _ref$modifiers = _ref.modifiers,
      modifiers = _ref$modifiers === void 0 ? EMPTY_MODIFIERS : _ref$modifiers,
      referenceElement = _ref.referenceElement,
      onFirstUpdate = _ref.onFirstUpdate,
      innerRef = _ref.innerRef,
      children = _ref.children;
  var referenceNode = React__namespace.useContext(ManagerReferenceNodeContext);

  var _React$useState = React__namespace.useState(null),
      popperElement = _React$useState[0],
      setPopperElement = _React$useState[1];

  var _React$useState2 = React__namespace.useState(null),
      arrowElement = _React$useState2[0],
      setArrowElement = _React$useState2[1];

  React__namespace.useEffect(function () {
    setRef$2(innerRef, popperElement);
  }, [innerRef, popperElement]);
  var options = React__namespace.useMemo(function () {
    return {
      placement: placement,
      strategy: strategy,
      onFirstUpdate: onFirstUpdate,
      modifiers: [].concat(modifiers, [{
        name: 'arrow',
        enabled: arrowElement != null,
        options: {
          element: arrowElement
        }
      }])
    };
  }, [placement, strategy, onFirstUpdate, modifiers, arrowElement]);

  var _usePopper = usePopper(referenceElement || referenceNode, popperElement, options),
      state = _usePopper.state,
      styles = _usePopper.styles,
      forceUpdate = _usePopper.forceUpdate,
      update = _usePopper.update;

  var childrenProps = React__namespace.useMemo(function () {
    return {
      ref: setPopperElement,
      style: styles.popper,
      placement: state ? state.placement : placement,
      hasPopperEscaped: state && state.modifiersData.hide ? state.modifiersData.hide.hasPopperEscaped : null,
      isReferenceHidden: state && state.modifiersData.hide ? state.modifiersData.hide.isReferenceHidden : null,
      arrowProps: {
        style: styles.arrow,
        ref: setArrowElement
      },
      forceUpdate: forceUpdate || NOOP,
      update: update || NOOP_PROMISE
    };
  }, [setPopperElement, setArrowElement, placement, state, styles, update, forceUpdate]);
  return unwrapArray(children)(childrenProps);
}

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var __DEV__ = process.env.NODE_ENV !== 'production';

var warning = function() {};

if (__DEV__) {
  var printWarning = function printWarning(format, args) {
    var len = arguments.length;
    args = new Array(len > 1 ? len - 1 : 0);
    for (var key = 1; key < len; key++) {
      args[key - 1] = arguments[key];
    }
    var argIndex = 0;
    var message = 'Warning: ' +
      format.replace(/%s/g, function() {
        return args[argIndex++];
      });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
          '`warning(condition, format, ...args)` requires a warning ' +
          'message argument'
      );
    }
    if (!condition) {
      printWarning.apply(null, [format].concat(args));
    }
  };
}

var warning_1 = warning;

function Reference(_ref) {
  var children = _ref.children,
      innerRef = _ref.innerRef;
  var setReferenceNode = React__namespace.useContext(ManagerReferenceNodeSetterContext);
  var refHandler = React__namespace.useCallback(function (node) {
    setRef$2(innerRef, node);
    safeInvoke(setReferenceNode, node);
  }, [innerRef, setReferenceNode]); // ran on unmount

  React__namespace.useEffect(function () {
    return function () {
      return setRef$2(innerRef, null);
    };
  });
  React__namespace.useEffect(function () {
    warning_1(Boolean(setReferenceNode), '`Reference` should not be used outside of a `Manager` component.');
  }, [setReferenceNode]);
  return unwrapArray(children)({
    ref: refHandler
  });
}

var TooltipContext = /*#__PURE__*/React__default['default'].createContext({}); // eslint-disable-next-line @typescript-eslint/no-explicit-any

// eslint-disable-next-line @typescript-eslint/no-explicit-any
var callAll = function callAll() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return fns.forEach(function (fn) {
      return fn && fn.apply(void 0, args);
    });
  };
};
var noop = function noop() {// do nothing
};
var canUseDOM = function canUseDOM() {
  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
};
var setRef$1 = function setRef(ref, node) {
  if (typeof ref === 'function') {
    return ref(node);
  } else if (ref != null) {
    ref.current = node;
  }
};

var Tooltip = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Tooltip, _Component);

  function Tooltip() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.observer = void 0;
    _this.tooltipRef = void 0;

    _this.handleOutsideClick = function (event) {
      if (_this.tooltipRef && !_this.tooltipRef.contains(event.target)) {
        var parentOutsideClickHandler = _this.context.parentOutsideClickHandler;
        var _this$props = _this.props,
            hideTooltip = _this$props.hideTooltip,
            clearScheduled = _this$props.clearScheduled;
        clearScheduled();
        hideTooltip();

        if (parentOutsideClickHandler) {
          parentOutsideClickHandler(event);
        }
      }
    };

    _this.handleOutsideRightClick = function (event) {
      if (_this.tooltipRef && !_this.tooltipRef.contains(event.target)) {
        var parentOutsideRightClickHandler = _this.context.parentOutsideRightClickHandler;
        var _this$props2 = _this.props,
            hideTooltip = _this$props2.hideTooltip,
            clearScheduled = _this$props2.clearScheduled;
        clearScheduled();
        hideTooltip();

        if (parentOutsideRightClickHandler) {
          parentOutsideRightClickHandler(event);
        }
      }
    };

    _this.addOutsideClickHandler = function () {
      document.body.addEventListener('touchend', _this.handleOutsideClick);
      document.body.addEventListener('click', _this.handleOutsideClick);
    };

    _this.removeOutsideClickHandler = function () {
      document.body.removeEventListener('touchend', _this.handleOutsideClick);
      document.body.removeEventListener('click', _this.handleOutsideClick);
    };

    _this.addOutsideRightClickHandler = function () {
      return document.body.addEventListener('contextmenu', _this.handleOutsideRightClick);
    };

    _this.removeOutsideRightClickHandler = function () {
      return document.body.removeEventListener('contextmenu', _this.handleOutsideRightClick);
    };

    _this.getTooltipRef = function (node) {
      _this.tooltipRef = node;
      setRef$1(_this.props.innerRef, node);
    };

    _this.getArrowProps = function (props) {
      if (props === void 0) {
        props = {};
      }

      return _extends({}, props, {
        style: _extends({}, props.style, _this.props.arrowProps.style)
      });
    };

    _this.getTooltipProps = function (props) {
      if (props === void 0) {
        props = {};
      }

      return _extends({}, props, _this.isTriggeredBy('hover') && {
        onMouseEnter: callAll(_this.props.clearScheduled, props.onMouseEnter),
        onMouseLeave: callAll(_this.props.hideTooltip, props.onMouseLeave)
      }, {
        style: _extends({}, props.style, _this.props.style)
      });
    };

    _this.contextValue = {
      isParentNoneTriggered: _this.props.trigger === 'none',
      addParentOutsideClickHandler: _this.addOutsideClickHandler,
      addParentOutsideRightClickHandler: _this.addOutsideRightClickHandler,
      parentOutsideClickHandler: _this.handleOutsideClick,
      parentOutsideRightClickHandler: _this.handleOutsideRightClick,
      removeParentOutsideClickHandler: _this.removeOutsideClickHandler,
      removeParentOutsideRightClickHandler: _this.removeOutsideRightClickHandler
    };
    return _this;
  }

  var _proto = Tooltip.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var observer = this.observer = new MutationObserver(function () {
      _this2.props.update();
    });
    observer.observe(this.tooltipRef, this.props.mutationObserverOptions);

    if (this.isTriggeredBy('hover') || this.isTriggeredBy('click') || this.isTriggeredBy('right-click')) {
      var _this$context = this.context,
          removeParentOutsideClickHandler = _this$context.removeParentOutsideClickHandler,
          removeParentOutsideRightClickHandler = _this$context.removeParentOutsideRightClickHandler;
      this.addOutsideClickHandler();
      this.addOutsideRightClickHandler();

      if (removeParentOutsideClickHandler) {
        removeParentOutsideClickHandler();
      }

      if (removeParentOutsideRightClickHandler) {
        removeParentOutsideRightClickHandler();
      }
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    if (this.props.closeOnReferenceHidden && this.props.isReferenceHidden) {
      this.props.hideTooltip();
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.observer) {
      this.observer.disconnect();
    }

    if (this.isTriggeredBy('hover') || this.isTriggeredBy('click') || this.isTriggeredBy('right-click')) {
      var _this$context2 = this.context,
          isParentNoneTriggered = _this$context2.isParentNoneTriggered,
          addParentOutsideClickHandler = _this$context2.addParentOutsideClickHandler,
          addParentOutsideRightClickHandler = _this$context2.addParentOutsideRightClickHandler;
      this.removeOutsideClickHandler();
      this.removeOutsideRightClickHandler();
      this.handleOutsideClick = undefined;
      this.handleOutsideRightClick = undefined;

      if (!isParentNoneTriggered && addParentOutsideClickHandler) {
        addParentOutsideClickHandler();
      }

      if (!isParentNoneTriggered && addParentOutsideRightClickHandler) {
        addParentOutsideRightClickHandler();
      }
    }
  };

  _proto.render = function render() {
    var _this$props3 = this.props,
        arrowProps = _this$props3.arrowProps,
        placement = _this$props3.placement,
        tooltip = _this$props3.tooltip;
    return /*#__PURE__*/React__default['default'].createElement(TooltipContext.Provider, {
      value: this.contextValue
    }, tooltip({
      arrowRef: arrowProps.ref,
      getArrowProps: this.getArrowProps,
      getTooltipProps: this.getTooltipProps,
      placement: placement,
      tooltipRef: this.getTooltipRef
    }));
  };

  _proto.isTriggeredBy = function isTriggeredBy(event) {
    var trigger = this.props.trigger;
    return trigger === event || Array.isArray(trigger) && trigger.includes(event);
  };

  return Tooltip;
}(React.Component);

Tooltip.contextType = TooltipContext;

var DEFAULT_MUTATION_OBSERVER_CONFIG = {
  childList: true,
  subtree: true
};

var TooltipTrigger = /*#__PURE__*/function (_Component) {
  _inheritsLoose(TooltipTrigger, _Component);

  function TooltipTrigger() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.state = {
      tooltipShown: _this.props.defaultTooltipShown
    };
    _this.hideTimeout = void 0;
    _this.showTimeout = void 0;
    _this.popperOffset = void 0;

    _this.setTooltipState = function (state) {
      var cb = function cb() {
        return _this.props.onVisibilityChange(state.tooltipShown);
      };

      _this.isControlled() ? cb() : _this.setState(state, cb);
    };

    _this.clearScheduled = function () {
      clearTimeout(_this.hideTimeout);
      clearTimeout(_this.showTimeout);
    };

    _this.showTooltip = function (_ref) {
      var pageX = _ref.pageX,
          pageY = _ref.pageY;

      _this.clearScheduled();

      var state = {
        tooltipShown: true
      };

      if (_this.props.followCursor) {
        state = _extends({}, state, {
          pageX: pageX,
          pageY: pageY
        });
      }

      _this.showTimeout = window.setTimeout(function () {
        return _this.setTooltipState(state);
      }, _this.props.delayShow);
    };

    _this.hideTooltip = function () {
      _this.clearScheduled();

      _this.hideTimeout = window.setTimeout(function () {
        return _this.setTooltipState({
          tooltipShown: false
        });
      }, _this.props.delayHide);
    };

    _this.toggleTooltip = function (_ref2) {
      var pageX = _ref2.pageX,
          pageY = _ref2.pageY;
      var action = _this.getState() ? 'hideTooltip' : 'showTooltip';

      _this[action]({
        pageX: pageX,
        pageY: pageY
      });
    };

    _this.clickToggle = function (event) {
      event.preventDefault();
      var pageX = event.pageX,
          pageY = event.pageY;
      var action = _this.props.followCursor ? 'showTooltip' : 'toggleTooltip';

      _this[action]({
        pageX: pageX,
        pageY: pageY
      });
    };

    _this.contextMenuToggle = function (event) {
      event.preventDefault();
      var pageX = event.pageX,
          pageY = event.pageY;
      var action = _this.props.followCursor ? 'showTooltip' : 'toggleTooltip';

      _this[action]({
        pageX: pageX,
        pageY: pageY
      });
    };

    _this.getTriggerProps = function (props) {
      if (props === void 0) {
        props = {};
      }

      return _extends({}, props, _this.isTriggeredBy('click') && {
        onClick: callAll(_this.clickToggle, props.onClick),
        onTouchEnd: callAll(_this.clickToggle, props.onTouchEnd)
      }, _this.isTriggeredBy('right-click') && {
        onContextMenu: callAll(_this.contextMenuToggle, props.onContextMenu)
      }, _this.isTriggeredBy('hover') && _extends({
        onMouseEnter: callAll(_this.showTooltip, props.onMouseEnter),
        onMouseLeave: callAll(_this.hideTooltip, props.onMouseLeave)
      }, _this.props.followCursor && {
        onMouseMove: callAll(_this.showTooltip, props.onMouseMove)
      }), _this.isTriggeredBy('focus') && {
        onFocus: callAll(_this.showTooltip, props.onFocus),
        onBlur: callAll(_this.hideTooltip, props.onBlur)
      });
    };

    return _this;
  }

  var _proto = TooltipTrigger.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.clearScheduled();
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props = this.props,
        children = _this$props.children,
        tooltip = _this$props.tooltip,
        placement = _this$props.placement,
        trigger = _this$props.trigger,
        getTriggerRef = _this$props.getTriggerRef,
        modifiers = _this$props.modifiers,
        closeOnReferenceHidden = _this$props.closeOnReferenceHidden,
        usePortal = _this$props.usePortal,
        portalContainer = _this$props.portalContainer,
        followCursor = _this$props.followCursor,
        getTooltipRef = _this$props.getTooltipRef,
        mutationObserverOptions = _this$props.mutationObserverOptions,
        restProps = _objectWithoutPropertiesLoose(_this$props, ["children", "tooltip", "placement", "trigger", "getTriggerRef", "modifiers", "closeOnReferenceHidden", "usePortal", "portalContainer", "followCursor", "getTooltipRef", "mutationObserverOptions"]);

    var popper = /*#__PURE__*/React__default['default'].createElement(Popper, _extends({
      innerRef: getTooltipRef,
      placement: placement,
      modifiers: [{
        name: 'followCursor',
        enabled: followCursor,
        phase: 'main',
        fn: function fn(data) {
          _this2.popperOffset = data.state.rects.popper;
        }
      }].concat(modifiers)
    }, restProps), function (_ref3) {
      var ref = _ref3.ref,
          style = _ref3.style,
          placement = _ref3.placement,
          arrowProps = _ref3.arrowProps,
          isReferenceHidden = _ref3.isReferenceHidden,
          update = _ref3.update;

      if (followCursor && _this2.popperOffset) {
        var _this2$state = _this2.state,
            pageX = _this2$state.pageX,
            pageY = _this2$state.pageY;
        var _this2$popperOffset = _this2.popperOffset,
            width = _this2$popperOffset.width,
            height = _this2$popperOffset.height;
        var x = pageX + width > window.pageXOffset + document.body.offsetWidth ? pageX - width : pageX;
        var y = pageY + height > window.pageYOffset + document.body.offsetHeight ? pageY - height : pageY;
        style.transform = "translate3d(" + x + "px, " + y + "px, 0";
      }

      return /*#__PURE__*/React__default['default'].createElement(Tooltip, _extends({
        arrowProps: arrowProps,
        closeOnReferenceHidden: closeOnReferenceHidden,
        isReferenceHidden: isReferenceHidden,
        placement: placement,
        update: update,
        style: style,
        tooltip: tooltip,
        trigger: trigger,
        mutationObserverOptions: mutationObserverOptions
      }, {
        clearScheduled: _this2.clearScheduled,
        hideTooltip: _this2.hideTooltip,
        innerRef: ref
      }));
    });
    return /*#__PURE__*/React__default['default'].createElement(Manager, null, /*#__PURE__*/React__default['default'].createElement(Reference, {
      innerRef: getTriggerRef
    }, function (_ref4) {
      var ref = _ref4.ref;
      return children({
        getTriggerProps: _this2.getTriggerProps,
        triggerRef: ref
      });
    }), this.getState() && (usePortal ? /*#__PURE__*/ReactDOM.createPortal(popper, portalContainer) : popper));
  };

  _proto.isControlled = function isControlled() {
    return this.props.tooltipShown !== undefined;
  };

  _proto.getState = function getState() {
    return this.isControlled() ? this.props.tooltipShown : this.state.tooltipShown;
  };

  _proto.isTriggeredBy = function isTriggeredBy(event) {
    var trigger = this.props.trigger;
    return trigger === event || Array.isArray(trigger) && trigger.includes(event);
  };

  return TooltipTrigger;
}(React.Component);

TooltipTrigger.defaultProps = {
  closeOnReferenceHidden: true,
  defaultTooltipShown: false,
  delayHide: 0,
  delayShow: 0,
  followCursor: false,
  onVisibilityChange: noop,
  placement: 'right',
  portalContainer: canUseDOM() ? document.body : null,
  trigger: 'hover',
  usePortal: canUseDOM(),
  mutationObserverOptions: DEFAULT_MUTATION_OBSERVER_CONFIG,
  modifiers: []
};

var _excluded$w = ["children", "tooltip", "hideArrow", "tag", "tagClassName", "className"];
var PopperTooltip = function PopperTooltip(_ref) {
  var _children = _ref.children,
      _tooltip = _ref.tooltip,
      hideArrow = _ref.hideArrow,
      tag = _ref.tag,
      tagClassName = _ref.tagClassName,
      className = _ref.className,
      props = _objectWithoutProperties(_ref, _excluded$w);

  var CustomTag = "".concat(tag !== null && tag !== void 0 ? tag : 'span');
  return _tooltip ? /*#__PURE__*/jsxRuntime.jsx(TooltipTrigger, _objectSpread2(_objectSpread2({}, props), {}, {
    tooltip: function tooltip(_ref2) {
      var arrowRef = _ref2.arrowRef,
          tooltipRef = _ref2.tooltipRef,
          getArrowProps = _ref2.getArrowProps,
          getTooltipProps = _ref2.getTooltipProps,
          placement = _ref2.placement;
      return /*#__PURE__*/jsxRuntime.jsxs("div", _objectSpread2(_objectSpread2({}, getTooltipProps({
        ref: tooltipRef,
        className: "".concat(className || '', " popper-tooltip-container")
      })), {}, {
        children: [!hideArrow && /*#__PURE__*/jsxRuntime.jsx("div", _objectSpread2({}, getArrowProps({
          ref: arrowRef,
          className: 'tooltip-arrow',
          'data-placement': placement
        }))), /*#__PURE__*/jsxRuntime.jsx(T, {
          children: _tooltip
        })]
      }));
    },
    children: function children(_ref3) {
      var getTriggerProps = _ref3.getTriggerProps,
          triggerRef = _ref3.triggerRef;
      return /*#__PURE__*/jsxRuntime.jsx(CustomTag, _objectSpread2(_objectSpread2({}, getTriggerProps({
        ref: triggerRef,
        className: 'trigger'
      })), {}, {
        className: tagClassName,
        children: /*#__PURE__*/jsxRuntime.jsx(T, {
          children: _children
        })
      }));
    }
  })) : _children;
};
PopperTooltip.propTypes = {
  placement: PropTypes__default['default'].string,
  // top, right
  trigger: PropTypes__default['default'].array,
  // ['hover','click']
  tooltip: PropTypes__default['default'].any
};

var usePopOverOption = function usePopOverOption(params) {
  var isResponsive = params.isResponsive,
      header = params.header,
      width = params.width,
      maxHeight = params.maxHeight,
      wrappedEl = params.wrappedEl;

  var _useState = React.useState({}),
      _useState2 = _slicedToArray(_useState, 2),
      psSize = _useState2[0],
      setPsSize = _useState2[1];

  React.useLayoutEffect(function () {
    var newPsSize = isResponsive ? getPsSizeResponsive(header) : getNormalPsSize(wrappedEl, width, maxHeight);
    setPsSize(newPsSize);
  }, [header, isResponsive, maxHeight, width, wrappedEl]);

  var getPsSizeResponsive = function getPsSizeResponsive(header) {
    var responsiveWidth = window.innerWidth - 100;
    var responsiveHeight = window.innerHeight - 150;
    return {
      minWidth: responsiveWidth,
      maxWidth: responsiveWidth,
      maxHeight: responsiveHeight + (header ? -25 : 0)
    };
  };

  var getNormalPsSize = function getNormalPsSize(wrappedEl, width, maxHeight) {
    var DEFAULT_MIN_WIDTH = 150;
    var rect = wrappedEl === null || wrappedEl === void 0 ? void 0 : wrappedEl.getBoundingClientRect();
    return _objectSpread2(_objectSpread2(_objectSpread2({
      minWidth: DEFAULT_MIN_WIDTH
    }, (rect === null || rect === void 0 ? void 0 : rect.width) && {
      width: rect.width
    }), width && {
      width: width
    }), maxHeight && {
      maxHeight: maxHeight
    });
  };

  return {
    psSize: psSize
  };
};

var PopOverTooltip = function PopOverTooltip(props) {
  var className = props.className,
      header = props.header,
      children = props.children,
      isResponsive = props.isResponsive,
      width = props.width,
      maxHeight = props.maxHeight,
      subHeader = props.subHeader,
      onMap = props.onMap;
  var popoverTooltipRef = React.useRef(null);

  var _usePopOverOption = usePopOverOption({
    isResponsive: isResponsive,
    header: header,
    width: width,
    maxHeight: maxHeight,
    wrappedEl: popoverTooltipRef.current
  }),
      psSize = _usePopOverOption.psSize;

  var classes = clsx__default['default']('popover-tooltip', className, reactDeviceDetect.isMobile && onMap && 'popover-on-map');
  return /*#__PURE__*/jsxRuntime.jsx(AnchorOverlay // {...props}
  , {
    position: props.position,
    className: classes,
    backdrop: props.backdrop,
    onBackgroundClick: props.onClose,
    children: /*#__PURE__*/jsxRuntime.jsxs("div", {
      ref: popoverTooltipRef,
      className: 'popover-tooltip-container',
      children: [header && /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "popover-tooltip-header",
        children: [/*#__PURE__*/jsxRuntime.jsx(T, {
          children: header
        }), subHeader && /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "popover-tooltip-sub-header",
          children: /*#__PURE__*/jsxRuntime.jsx(T, {
            children: subHeader
          })
        })]
      }), /*#__PURE__*/jsxRuntime.jsx(ScrollBar, {
        className: "popover-tooltip-content",
        style: psSize,
        children: children
      })]
    })
  });
};

var Tooltip2 = function Tooltip2(props) {
  var triggerEl = props.triggerEl,
      tooltipEl = props.tooltipEl,
      tooltip = props.tooltip,
      _props$placement = props.placement,
      placement = _props$placement === void 0 ? 'bottom' : _props$placement,
      className = props.className,
      hideArrow = props.hideArrow,
      _props$trigger = props.trigger,
      trigger = _props$trigger === void 0 ? ['hover'] : _props$trigger;

  var _useI18n = useI18n(),
      t = _useI18n.t;

  var triggerType = React.useRef();

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      visible = _useState2[0],
      setVisible = _useState2[1];

  React.useLayoutEffect(function () {
    if (!triggerEl) {
      return;
    }

    if (trigger.includes('hover')) {
      triggerEl.addEventListener('mouseenter', handleEnter);
      triggerEl.addEventListener('mouseleave', handleLeave);
    }

    return function () {
      triggerEl.removeEventListener('mouseenter', handleEnter);
      triggerEl.removeEventListener('mouseleave', handleLeave);
    };
  }, [triggerEl]);
  React.useLayoutEffect(function () {
    trigger.includes('click') && triggerEl && triggerEl.addEventListener('click', handleClick);
    return function () {
      return triggerEl === null || triggerEl === void 0 ? void 0 : triggerEl.removeEventListener('click', handleClick);
    };
  }, [visible]);

  var handleEnter = function handleEnter() {
    triggerType.current = 'hover';
    setVisible(true);
  };

  var handleLeave = function handleLeave() {
    triggerType.current = undefined;
    setVisible(false);
  };

  var handleClick = function handleClick() {
    triggerType.current = 'click';
    setVisible(!visible);
  };

  return visible && !!tooltip ? /*#__PURE__*/jsxRuntime.jsx(AnchorOverlay, _objectSpread2(_objectSpread2({
    className: clsx__default['default']('tooltip-v2-container', !hideArrow && 'show-arrow', className),
    anchorEl: {
      current: tooltipEl || triggerEl
    },
    placement: placement,
    backdrop: triggerType.current === 'click'
  }, triggerType.current === 'click' && {
    onBackgroundClick: function onBackgroundClick() {
      triggerType.current = undefined;
      setVisible(false);
    }
  }), {}, {
    children: /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "tooltip-wrapper",
      children: typeof tooltip === 'string' ? t(tooltip) : tooltip
    })
  })) : /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {});
};

var _excluded$v = ["innerRef", "isLoading", "loadingText", "text", "iconType", "iconLocation", "onlyIcon", "icon", "iconSize", "isDefault", "className", "color", "size", "onClick", "disabled", "tooltip", "isRound", "pressed", "variant", "fullWidth", "minWidth", "type", "tooltipPosition", "hideTooltipArrow"],
    _excluded2$3 = ["className", "text"],
    _excluded3$2 = ["className", "variant", "color", "isRound"];

var Button = function Button(props) {
  var innerRef = props.innerRef,
      _props$isLoading = props.isLoading,
      isLoading = _props$isLoading === void 0 ? false : _props$isLoading,
      loadingText = props.loadingText,
      _props$text = props.text,
      text = _props$text === void 0 ? 'Button' : _props$text,
      _props$iconType = props.iconType,
      iconType = _props$iconType === void 0 ? 'light' : _props$iconType,
      _props$iconLocation = props.iconLocation,
      iconLocation = _props$iconLocation === void 0 ? 'left' : _props$iconLocation,
      _props$onlyIcon = props.onlyIcon,
      onlyIcon = _props$onlyIcon === void 0 ? false : _props$onlyIcon,
      icon = props.icon,
      _props$iconSize = props.iconSize,
      iconSize = _props$iconSize === void 0 ? 'sm' : _props$iconSize,
      _props$isDefault = props.isDefault,
      isDefault = _props$isDefault === void 0 ? false : _props$isDefault,
      className = props.className,
      _props$color = props.color,
      color = _props$color === void 0 ? 'default' : _props$color,
      _props$size = props.size,
      size = _props$size === void 0 ? 'md' : _props$size,
      _onClick = props.onClick,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      tooltip = props.tooltip,
      _props$isRound = props.isRound,
      isRound = _props$isRound === void 0 ? false : _props$isRound,
      pressed = props.pressed,
      _props$variant = props.variant,
      variant = _props$variant === void 0 ? 'fill' : _props$variant,
      _props$fullWidth = props.fullWidth,
      fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
      minWidth = props.minWidth,
      _props$type = props.type,
      type = _props$type === void 0 ? 'button' : _props$type,
      tooltipPosition = props.tooltipPosition,
      hideTooltipArrow = props.hideTooltipArrow,
      buttonProps = _objectWithoutProperties(props, _excluded$v);

  var _useState = React.useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      buttonEl = _useState2[0],
      setButtonEl = _useState2[1];

  var iconNode = /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
    icon: icon,
    type: iconType
  });

  var iconClasses = clsx__default['default'](isDefault && className, size && "btn--".concat(size), onlyIcon && 'btn--only-icon', icon && "btn--icon-".concat(iconSize));
  var buttonClasses = clsx__default['default']('btn', "btn--".concat(color), pressed && 'btn--active', variant && "btn--".concat(variant), isRound && 'btn--round', fullWidth && 'btn--full-width', isLoading && 'btn--loading', iconClasses, className);
  var contentClasses = clsx__default['default']('inline-flex justify-center items-center', !onlyIcon && iconLocation && "btn--icon-".concat(iconLocation));
  var translatedText = typeof text === 'string' ? /*#__PURE__*/jsxRuntime.jsx(T, {
    children: text
  }) : text;
  var translatedLoadingText = typeof loadingText === 'string' ? /*#__PURE__*/jsxRuntime.jsx(T, {
    children: loadingText
  }) : loadingText;
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsxs("button", _objectSpread2(_objectSpread2({
      ref: function ref(node) {
        !!innerRef && (isCallBackRef$3(innerRef) ? innerRef(node) : innerRef.current = node);
        setButtonEl(node);
      },
      className: isDefault ? onlyIcon ? iconClasses : className : buttonClasses,
      disabled: disabled || isLoading,
      style: {
        minWidth: minWidth
        /* stylelint-disable-line value-keyword-case */

      },
      "aria-pressed": pressed,
      "aria-disabled": disabled || isLoading,
      type: type,
      onClick: function onClick(e) {
        e.stopPropagation();
        !isLoading && _onClick && _onClick(e);
      }
    }, buttonProps), {}, {
      children: [isLoading && /*#__PURE__*/jsxRuntime.jsx("svg", {
        children: isRound ? /*#__PURE__*/jsxRuntime.jsx("rect", {
          x: "0",
          y: "0",
          rx: "0",
          ry: "0"
        }) : /*#__PURE__*/jsxRuntime.jsx("rect", {
          rx: "0",
          ry: "0"
        })
      }), /*#__PURE__*/jsxRuntime.jsxs("span", {
        className: contentClasses,
        children: [icon && iconLocation === 'left' && (typeof icon === 'string' ? iconNode : icon), !onlyIcon && isLoading && /*#__PURE__*/jsxRuntime.jsx("span", {
          className: "btn__text",
          children: translatedLoadingText ? translatedLoadingText : translatedText
        }), !onlyIcon && !isLoading && /*#__PURE__*/jsxRuntime.jsx("span", {
          className: "btn__text",
          children: translatedText
        }), icon && iconLocation === 'right' && (typeof icon === 'string' ? iconNode : icon)]
      })]
    })), !!tooltip && /*#__PURE__*/jsxRuntime.jsx(Tooltip2, {
      triggerEl: buttonEl,
      placement: tooltipPosition,
      hideArrow: hideTooltipArrow,
      tooltip: tooltip
    })]
  });
};

var EmptyButton = function EmptyButton(props) {
  var className = props.className,
      _props$text2 = props.text,
      text = _props$text2 === void 0 ? '' : _props$text2,
      rest = _objectWithoutProperties(props, _excluded2$3);

  var classes = clsx__default['default']('btn--empty', // noSpace && 'p-0',
  className);
  return /*#__PURE__*/jsxRuntime.jsx(Button, _objectSpread2({
    className: classes,
    text: text
  }, rest));
};

var IconButton = function IconButton(props) {
  var className = props.className,
      _props$variant2 = props.variant,
      variant = _props$variant2 === void 0 ? 'outline' : _props$variant2,
      _props$color2 = props.color,
      color = _props$color2 === void 0 ? 'default' : _props$color2,
      _props$isRound2 = props.isRound,
      isRound = _props$isRound2 === void 0 ? true : _props$isRound2,
      rest = _objectWithoutProperties(props, _excluded3$2);

  var classes = clsx__default['default'](variant !== 'empty' && 'btn-icon', className);
  var View = variant === 'empty' ? EmptyButton : Button;
  return /*#__PURE__*/jsxRuntime.jsx(View, _objectSpread2(_objectSpread2({
    className: classes,
    color: color,
    isRound: isRound,
    onlyIcon: true
  }, variant === 'empty' ? {} : {
    variant: variant
  }), rest));
};
var isCallBackRef$3 = function isCallBackRef(ref) {
  return !('current' in ref);
};

var PopupManager = /*#__PURE__*/function () {
  function PopupManager() {
    _classCallCheck(this, PopupManager);

    _defineProperty$1(this, "popups", []);
  }

  _createClass(PopupManager, [{
    key: "handleKeydown",
    value: function handleKeydown(event) {
      if (event.code === 'Escape') {
        var popup = this.popups[this.popups.length - 1];

        if (popup) {
          popup.handleClose();
        }
      }
    }
  }, {
    key: "add",
    value: function add(popup) {
      this.popups.map(function (popup) {
        return popup.setTopPopup(false);
      });
      this.popups.push(popup);
    }
  }, {
    key: "remove",
    value: function remove(popup) {
      var _this = this;

      this.popups = this.popups.filter(function (p) {
        return p !== popup;
      });
      this.popups.map(function (popup, index) {
        return popup.setTopPopup(index === _this.popups.length - 1);
      });
    }
  }], [{
    key: "init",
    value: function init() {
      if (!this.instance) {
        this.instance = new PopupManager();
        document.addEventListener('keydown', this.instance.handleKeydown.bind(this.instance), false);
        return this.instance;
      }
    }
  }]);

  return PopupManager;
}();

_defineProperty$1(PopupManager, "instance", void 0);

var popupManager = PopupManager.init();
var Popup = /*#__PURE__*/function (_Component) {
  _inherits(Popup, _Component);

  var _super = _createSuper(Popup);

  function Popup() {
    var _this;

    _classCallCheck(this, Popup);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      isVisible: true,
      topPopup: true
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleClose", function () {
      var isClose = !_this.props.onBeforeClose || _this.props.onBeforeClose();

      if (isClose) {
        _this.setState({
          isVisible: false
        });

        var _this$props = _this.props,
            onClose = _this$props.onClose,
            animationDurationOut = _this$props.animationDurationOut;
        setTimeout(function () {
          _this.props.escape && popupManager.remove(_assertThisInitialized(_this));
          onClose && onClose();
        }, animationDurationOut);
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "setTopPopup", function (bool) {
      return _this.setState({
        topPopup: bool
      });
    });

    return _this;
  }

  _createClass(Popup, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var isEscapable = this.props.escape || true;
      isEscapable && popupManager.add(this);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props2 = this.props,
          isShowContentOnly = _this$props2.isShowContentOnly,
          _this$props2$scroll = _this$props2.scroll,
          scroll = _this$props2$scroll === void 0 ? true : _this$props2$scroll,
          _this$props2$showClos = _this$props2.showCloseIcon,
          showCloseIcon = _this$props2$showClos === void 0 ? true : _this$props2$showClos,
          _this$props2$focusOn = _this$props2.focusOn,
          focusOn = _this$props2$focusOn === void 0 ? 'ok' : _this$props2$focusOn;
      var _this$props3 = this.props,
          _this$props3$animatio = _this$props3.animationIn,
          animationIn = _this$props3$animatio === void 0 ? 'fadeIn' : _this$props3$animatio,
          _this$props3$animatio2 = _this$props3.animationOut,
          animationOut = _this$props3$animatio2 === void 0 ? 'zoomOut' : _this$props3$animatio2,
          _this$props3$animatio3 = _this$props3.animationDurationIn,
          animationDurationIn = _this$props3$animatio3 === void 0 ? 250 : _this$props3$animatio3,
          _this$props3$animatio4 = _this$props3.animationDurationOut,
          animationDurationOut = _this$props3$animatio4 === void 0 ? 250 : _this$props3$animatio4;
      var _this$props4 = this.props,
          _this$props4$cancelTe = _this$props4.cancelText,
          cancelText = _this$props4$cancelTe === void 0 ? 'Hủy' : _this$props4$cancelTe,
          onCancel = _this$props4.onCancel;
      var _this$props5 = this.props,
          _this$props5$okText = _this$props5.okText,
          okText = _this$props5$okText === void 0 ? 'Xác nhận' : _this$props5$okText,
          _this$props5$okType = _this$props5.okType,
          okType = _this$props5$okType === void 0 ? 'primary' : _this$props5$okType,
          onOk = _this$props5.onOk;
      var _this$props6 = this.props,
          _this$props6$title = _this$props6.title,
          title = _this$props6$title === void 0 ? '' : _this$props6$title,
          headerActions = _this$props6.headerActions;
      var _this$props7 = this.props,
          _this$props7$width = _this$props7.width,
          width = _this$props7$width === void 0 ? 'fit-content' : _this$props7$width,
          _this$props7$height = _this$props7.height,
          height = _this$props7$height === void 0 ? 'auto' : _this$props7$height,
          _this$props7$padding = _this$props7.padding,
          padding = _this$props7$padding === void 0 ? '1rem' : _this$props7$padding,
          className = _this$props7.className;
      var children = Array.isArray(this.props.children) ? this.props.children : [this.props.children];
      var footer = children.find(function (child) {
        return (child === null || child === void 0 ? void 0 : child.type) === PopupFooter;
      });
      children = children.filter(function (child) {
        return (child === null || child === void 0 ? void 0 : child.type) !== PopupFooter;
      });

      var content = /*#__PURE__*/jsxRuntime.jsxs(reactAnimatedCss.Animated, {
        className: clsx__default['default']('popup-container', showCloseIcon && 'with-close-icon') // className={'popup-container'}
        ,
        animationIn: animationIn,
        animationOut: animationOut,
        animationInDuration: animationDurationIn,
        animationOutDuration: animationDurationOut,
        isVisible: this.state.isVisible,
        children: [!isShowContentOnly && /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "popup-header",
          children: /*#__PURE__*/jsxRuntime.jsx("h3", {
            children: /*#__PURE__*/jsxRuntime.jsx(T, {
              children: title
            })
          })
        }), /*#__PURE__*/jsxRuntime.jsxs("div", {
          className: "popup-header-actions",
          children: [headerActions && headerActions.map(function (action, index) {
            return /*#__PURE__*/jsxRuntime.jsx("button", {
              onClick: action.onClick,
              children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                icon: action.icon,
                size: '1.25rem'
              })
            }, index);
          }), showCloseIcon && /*#__PURE__*/jsxRuntime.jsx("button", {
            onClick: this.handleClose,
            children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
              icon: "times",
              size: '1.25rem'
            })
          })]
        }), scroll ? /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
          className: "popup-body",
          style: {
            padding: padding
          },
          children: children
        }) : /*#__PURE__*/jsxRuntime.jsx(Col2, {
          className: "popup-body",
          children: children
        }), footer || onCancel || onOk ? /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "popup-footer",
          children: footer ? footer : /*#__PURE__*/jsxRuntime.jsxs(PopupFooter, {
            children: [onCancel && /*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
              text: cancelText,
              autoFocus: focusOn === 'cancel',
              onClick: function onClick() {
                _this2.handleClose();

                onCancel();
              }
            }), onOk && /*#__PURE__*/jsxRuntime.jsx(Button, {
              color: okType,
              autoFocus: focusOn === 'ok',
              text: okText,
              onClick: function onClick() {
                _this2.handleClose();

                onOk();
              }
            })]
          })
        }) : scroll && /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "empty-popup-footer"
        })]
      });

      return /*#__PURE__*/jsxRuntime.jsx(Overlay, {
        className: clsx__default['default'](className, !this.state.topPopup && 'previous-popup'),
        width: width,
        height: height,
        onBackgroundClick: this.handleClose,
        children: content
      });
    }
  }]);

  return Popup;
}(React.Component);

var PopupFooter = function PopupFooter(_ref) {
  var className = _ref.className,
      children = _ref.children;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: clsx__default['default']('popup-footer-content', className),
    children: children
  });
};

var Alert = function Alert(props) {
  var _props$title = props.title,
      title = _props$title === void 0 ? 'Thông báo' : _props$title,
      message = props.message,
      onOk = props.onOk;
  return /*#__PURE__*/jsxRuntime.jsxs(Popup, {
    title: title,
    className: 'dialog-popup',
    onClose: onOk,
    children: [/*#__PURE__*/jsxRuntime.jsx(T, {
      children: message
    }), /*#__PURE__*/jsxRuntime.jsx(PopupFooter, {
      children: /*#__PURE__*/jsxRuntime.jsx(Button, {
        color: 'primary',
        text: 'Đồng ý',
        autoFocus: true,
        onClick: onOk
      })
    })]
  });
};

var Confirm = function Confirm(props) {
  var _props$title = props.title,
      title = _props$title === void 0 ? 'Xác nhận' : _props$title,
      message = props.message,
      _props$focusOn = props.focusOn,
      focusOn = _props$focusOn === void 0 ? 'ok' : _props$focusOn,
      danger = props.danger;
  var _props$okText = props.okText,
      okText = _props$okText === void 0 ? 'Xác nhận' : _props$okText,
      onOk = props.onOk;
  var _props$cancelText = props.cancelText,
      cancelText = _props$cancelText === void 0 ? 'Hủy' : _props$cancelText,
      onCancel = props.onCancel;
  var _props$loading = props.loading,
      loading = _props$loading === void 0 ? false : _props$loading;
  var cancelRef = React.useRef(null);
  var okRef = React.useRef(null);
  return /*#__PURE__*/jsxRuntime.jsxs(Popup, {
    className: 'dialog-popup',
    title: title,
    padding: '2rem',
    onClose: onCancel,
    children: [typeof message === 'string' ? /*#__PURE__*/jsxRuntime.jsx(T, {
      children: message
    }) : message, /*#__PURE__*/jsxRuntime.jsxs(PopupFooter, {
      children: [/*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
        text: cancelText,
        innerRef: cancelRef,
        autoFocus: focusOn === 'cancel',
        onClick: onCancel
      }), /*#__PURE__*/jsxRuntime.jsx(Button, {
        innerRef: okRef,
        color: danger ? 'danger' : 'primary',
        text: okText,
        isLoading: loading,
        autoFocus: focusOn === 'ok',
        onClick: onOk
      })]
    })]
  });
};

var _excluded$u = ["children"];
var PopOver = function PopOver(_ref) {
  var children = _ref.children,
      rest = _objectWithoutProperties(_ref, _excluded$u);

  return /*#__PURE__*/jsxRuntime.jsx(AnchorOverlay, _objectSpread2(_objectSpread2({
    innerClassName: 'popover-container'
  }, rest), {}, {
    children: children
  }));
};

var Drawer = function Drawer(props) {
  var _props$width = props.width,
      width = _props$width === void 0 ? '22rem' : _props$width,
      _props$scroll = props.scroll,
      scroll = _props$scroll === void 0 ? true : _props$scroll,
      _props$position = props.position,
      position = _props$position === void 0 ? 'left' : _props$position,
      _props$animationIn = props.animationIn,
      animationIn = _props$animationIn === void 0 ? 'slideInRight' : _props$animationIn,
      _props$animationOut = props.animationOut,
      animationOut = _props$animationOut === void 0 ? 'slideOutRight' : _props$animationOut,
      onClose = props.onClose,
      children = props.children,
      showCloseIcon = props.showCloseIcon;
  return /*#__PURE__*/jsxRuntime.jsx(Popup, {
    className: "drawer ".concat(position === 'right' ? 'drawer--right' : ''),
    animationIn: animationIn,
    animationOut: animationOut,
    width: width,
    padding: '0',
    escape: false,
    scroll: scroll,
    showCloseIcon: showCloseIcon,
    isShowContentOnly: true,
    onClose: onClose,
    children: children
  });
};

var ToastStack = function ToastStack(props) {
  var id = props.id,
      _props$location = props.location,
      location = _props$location === void 0 ? 'top-right' : _props$location,
      items = props.items;
  return /*#__PURE__*/jsxRuntime.jsx(Container, {
    id: id,
    className: "toast-items toast-location-".concat(location),
    children: Array.isArray(items) && items.map(function (toast, index) {
      return /*#__PURE__*/jsxRuntime.jsx(Toast, {
        message: toast.message,
        type: toast.type,
        icon: toast.icon,
        onClick: toast.onClick
      }, toast.id || index);
    })
  });
};
var Toast = function Toast(props) {
  var message = props.message,
      type = props.type,
      onClick = props.onClick,
      icon = props.icon,
      child = props.child;
  return /*#__PURE__*/jsxRuntime.jsx(reactAnimatedCss.Animated, {
    animationIn: "slideInRight",
    animationOut: "slideOutLeft",
    animationInDuration: 250,
    isVisible: true,
    children: /*#__PURE__*/jsxRuntime.jsx(Container, {
      className: "toast toast-".concat(type),
      style: {
        cursor: onClick ? 'pointer' : ''
      },
      onClick: onClick,
      children: child || /*#__PURE__*/jsxRuntime.jsxs(Container, {
        className: 'toast-container ',
        children: [icon && /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          className: 'toast-icon',
          icon: icon
        }), /*#__PURE__*/jsxRuntime.jsx(Container, {
          className: 'toast-message',
          children: message
        })]
      })
    })
  });
};

var CommonHelper = /*#__PURE__*/function () {
  function CommonHelper() {
    _classCallCheck(this, CommonHelper);
  }

  _createClass(CommonHelper, null, [{
    key: "formatDate",
    value: function formatDate(date) {
      var d = new Date(date);
      var month = '' + (d.getMonth() + 1);
      var day = '' + d.getDate();
      var year = d.getFullYear();
      var hour = '' + d.getHours();
      var min = '' + d.getMinutes();
      var sec = '' + d.getSeconds();

      if (month.length < 2) {
        month = '0' + month;
      }

      if (day.length < 2) {
        day = '0' + day;
      }

      if (hour.length < 2) {
        hour = '0' + hour;
      }

      if (min.length < 2) {
        min = '0' + min;
      }

      if (sec.length < 2) {
        sec = '0' + sec;
      }

      return "".concat([year, month, day].join('-'), " ").concat([hour, min, sec].join(':'));
    }
  }, {
    key: "formatDategetTime",
    value: function formatDategetTime(date) {
      var d = new Date(date);
      var hour = '' + d.getHours();
      var min = '' + d.getMinutes();

      if (hour.length < 2) {
        hour = '0' + hour;
      }

      if (min.length < 2) {
        min = '0' + min;
      }

      return "".concat([hour, min].join(':'));
    }
  }, {
    key: "clone",
    value: function clone(item) {
      if (!item) {
        return item;
      } // null, undefined values check
      // tslint:disable-next-line: prefer-const


      var types = [Number, String, Boolean];
      var result; // normalizing primitives if someone did new String('aaa'), or new Number('444');

      types.forEach(function (type) {
        if (item instanceof type) {
          result = type(item);
        }
      }); // tslint:disable-next-line: triple-equals

      if (typeof result === 'undefined') {
        if (Object.prototype.toString.call(item) === '[object Array]') {
          result = [];
          item.forEach(function (child, index) {
            result[index] = CommonHelper.clone(child);
          });
        } else if (_typeof(item) === 'object') {
          // testing that this is DOM
          if (item.nodeType && typeof item.cloneNode === 'function') {
            result = item.cloneNode(true);
          } else if (!item.prototype) {
            // check that this is a literal
            if (item instanceof Date) {
              result = new Date(item);
            } else {
              // it is an object literal
              result = {};

              for (var i in item) {
                result[i] = CommonHelper.clone(item[i]);
              }
            }
          } else {
            result = item;
          }
        } else {
          result = item;
        }
      }

      return result;
    }
  }, {
    key: "coordsDecode",
    value: function coordsDecode(str, precision) {
      var index = 0;
      var lat = 0;
      var lng = 0;
      var coordinates = [];
      var shift = 0;
      var result = 0;
      var _byte = null;
      var latitude_change, longitude_change;
      var factor = Math.pow(10, Number.isInteger(precision) ? precision : 6); // Coordinates have variable length when encoded, so just keep
      // track of whether we've hit the end of the string. In each
      // loop iteration, a single coordinate is decoded.

      while (index < str.length) {
        // Reset shift, result, and byte
        _byte = null;
        shift = 0;
        result = 0;

        do {
          _byte = str.charCodeAt(index++) - 63;
          result |= (_byte & 0x1f) << shift;
          shift += 5;
        } while (_byte >= 0x20);

        latitude_change = result & 1 ? ~(result >> 1) : result >> 1;
        shift = result = 0;

        do {
          _byte = str.charCodeAt(index++) - 63;
          result |= (_byte & 0x1f) << shift;
          shift += 5;
        } while (_byte >= 0x20);

        longitude_change = result & 1 ? ~(result >> 1) : result >> 1;
        lat += latitude_change;
        lng += longitude_change;
        coordinates.push([lat / factor, lng / factor]);
      }

      return coordinates;
    }
  }, {
    key: "coordsEncode",
    value: function coordsEncode(coordinates, precision) {
      // convert poins to coords
      if (coordinates && coordinates[0] && coordinates[0].Latitude) {
        for (var i = 0; i < coordinates.length; i++) {
          coordinates[i] = [coordinates[i].Latitude, coordinates[i].Longitude];
        }
      }

      function py2_round(value) {
        // Google's polyline algorithm uses the same rounding strategy as Python 2, which is different from JS for negative values
        return Math.floor(Math.abs(value) + 0.5) * (value >= 0 ? 1 : -1);
      }

      function encode(current, previous, factor) {
        current = py2_round(current * factor);
        previous = py2_round(previous * factor);
        var coordinate = current - previous;
        coordinate <<= 1;

        if (current - previous < 0) {
          coordinate = ~coordinate;
        }

        var output = '';

        while (coordinate >= 0x20) {
          output += String.fromCharCode((0x20 | coordinate & 0x1f) + 63);
          coordinate >>= 5;
        }

        output += String.fromCharCode(coordinate + 63);
        return output;
      }

      if (!coordinates.length) {
        return '';
      }

      var factor = Math.pow(10, Number.isInteger(precision) ? precision : 6);
      var output = encode(coordinates[0][0], 0, factor) + encode(coordinates[0][1], 0, factor);

      for (var _i = 1; _i < coordinates.length; _i++) {
        var a = coordinates[_i];
        var b = coordinates[_i - 1];
        output += encode(a[0], b[0], factor);
        output += encode(a[1], b[1], factor);
      }

      return output;
    }
  }, {
    key: "uuid",
    value: function uuid() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
      });
    }
  }, {
    key: "removeItemInArray",
    value: function removeItemInArray(array, index) {
      var result = [];

      for (var i = 0; i < array.length; i++) {
        if (i !== index) {
          result.push(array[i]);
        }
      }

      return result;
    }
  }, {
    key: "copyToClipboard",
    value: function copyToClipboard(str) {
      if (!str) {
        return null;
      }

      createTextArea(str);
      selectText();
      copyToClipboard();

      function isOS() {
        return navigator.userAgent.match(/ipad|iphone/i);
      }

      function createTextArea(text) {
        str = document.createElement('textArea');
        str.value = text;
        document.body.appendChild(str);
      }

      function selectText() {
        var range, selection;

        if (isOS()) {
          range = document.createRange();
          range.selectNodeContents(str);
          selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
          str.setSelectionRange(0, 999999);
        } else {
          str.select();
        }
      }

      function copyToClipboard() {
        document.execCommand('copy');
        document.body.removeChild(str);
      }
    }
  }]);

  return CommonHelper;
}();

_defineProperty$1(CommonHelper, "getFontAwesomeStringFromClassName", function (className) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'light';

  if (!CommonHelper.cachedIcon) {
    CommonHelper.cachedIcon = {};
  }

  var key = "".concat(className, "-").concat(type);

  if (CommonHelper.cachedIcon[key]) {
    return CommonHelper.cachedIcon[key];
  } else {
    var prefix = '';

    switch (type) {
      case 'solid':
        prefix = 'fas';
        break;

      case 'regular':
        prefix = 'far';
        break;

      default:
      case 'light':
        prefix = 'fal';
        break;
    }

    var element = document.createElement('i');
    element.className = "".concat(prefix, " fa-").concat(className);
    element.style.display = 'none';
    document.body.appendChild(element);
    var contentValue = window.getComputedStyle(element, ':before').getPropertyValue('content');
    document.body.removeChild(element);
    CommonHelper.cachedIcon[key] = contentValue;
    return contentValue;
  }
});

_defineProperty$1(CommonHelper, "arrayIntersection", function (array1, array2) {
  if (array1) {
    return array1.filter(function (n) {
      return array2.indexOf(n) !== -1;
    });
  }
});

_defineProperty$1(CommonHelper, "getCentroid", function (geoJson) {
  if (typeof geoJson === 'string') {
    geoJson = JSON.parse(geoJson);
  }

  var bounds = new mapboxgl__default['default'].LngLatBounds();

  if (geoJson.type === 'Label' || geoJson.type === 'Point') {
    bounds.extend(geoJson.coordinates);
  } else if (geoJson.type === 'LineString') {
    geoJson.coordinates.forEach(function (c) {
      bounds.extend(c);
    });
  } else if (geoJson.type === 'MultiPolygon') {
    geoJson.coordinates.forEach(function (arrCoords) {
      arrCoords[0].forEach(function (c) {
        bounds.extend(c);
      });
    });
  } else {
    geoJson.coordinates[0].forEach(function (c) {
      bounds.extend(c);
    });
  }

  return bounds.getCenter();
});

_defineProperty$1(CommonHelper, "getUniqueValues", function (array, key) {
  var unique = [];
  var distinct = [];

  for (var i = 0; i < array.length; i++) {
    var value = array[i][key];

    if (!unique[value]) {
      distinct.push(value);
      unique[value] = 1;
    }
  }

  return distinct;
});

_defineProperty$1(CommonHelper, "toDictionary", function (array, key, value) {
  var dict = {};
  array.forEach(function (item) {
    if (item[key]) {
      dict[item[key]] = value ? item[value] : item;
    }
  });
  return dict;
});

var ContextMenuItem = function ContextMenuItem(props) {
  var label = props.label,
      className = props.className,
      disabled = props.disabled,
      iconStyle = props.iconStyle,
      iconClassName = props.iconClassName,
      icon = props.icon,
      to = props.to,
      style = props.style,
      index = props.index,
      sub = props.sub,
      onClick = props.onClick,
      onClose = props.onClose;
  var ref = React.useRef(null);
  React.useEffect(function () {
    var _ref$current;

    (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.addEventListener(reactDeviceDetect.isMobile ? 'touchstart' : 'mousedown', handleOnClickAction);
    return function () {
      var _ref$current2;

      return (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.removeEventListener(reactDeviceDetect.isMobile ? 'touchstart' : 'mousedown', handleOnClickAction);
    };
  }, []);

  var handleMouseEnter = function handleMouseEnter() {
    var _ref$current3;

    (_ref$current3 = ref.current) === null || _ref$current3 === void 0 ? void 0 : _ref$current3.focus();
  };

  var handleOnClickAction = function handleOnClickAction(e) {
    !disabled && onClick && onClick(e);
    !disabled && onClose();
  };

  if (!label) {
    return null;
  }

  if (label === '-') {
    return /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "action-menu-horizontal-line"
    });
  }

  return /*#__PURE__*/jsxRuntime.jsx(React__default['default'].Fragment, {
    children: /*#__PURE__*/jsxRuntime.jsxs("div", {
      ref: ref,
      className: clsx__default['default']('action-menu-entry', className, disabled && 'disabled'),
      style: style,
      onMouseEnter: handleMouseEnter,
      children: [/*#__PURE__*/jsxRuntime.jsx("div", {
        className: clsx__default['default']('action-menu-entry-icon', iconClassName),
        style: iconStyle,
        children: icon && typeof icon === 'string' ? /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          type: 'regular',
          icon: icon,
          size: '1rem'
        }) : icon
      }), /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: 'action-menu-entry-text',
        children: [/*#__PURE__*/jsxRuntime.jsx("div", {
          className: "ml-ellipsis",
          children: to ? /*#__PURE__*/jsxRuntime.jsx(reactRouterDom.Link, {
            to: to,
            children: /*#__PURE__*/jsxRuntime.jsx(T, {
              children: label
            })
          }) : /*#__PURE__*/jsxRuntime.jsx(T, {
            children: label
          })
        }), sub && /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "action-menu-sub ml-ellipsis",
          children: /*#__PURE__*/jsxRuntime.jsx(T, {
            children: sub
          })
        })]
      })]
    })
  }, index);
};

var ContextMenu = function ContextMenu(props) {
  var backdrop = props.backdrop,
      className = props.className,
      isResponsive = props.isResponsive,
      onClose = props.onClose,
      isCloseOnBlur = props.isCloseOnBlur,
      position = props.position,
      header = props.header,
      width = props.width,
      maxHeight = props.maxHeight;
  var contextMenuRef = React.useRef(null);
  var defaultMenu = {
    id: undefined,
    header: '',
    position: {
      x: 0,
      y: 0
    },
    isTopLeft: true,
    // have two options, top-left and top-right TODO: if false not work, need investigate
    isCloseOnAction: true,
    isCloseOnBlur: false,
    disabled: false,
    actions: []
  };
  var menuStyle = clsx__default['default']({
    fullscreen: isResponsive
  });

  var _usePopOverOption = usePopOverOption({
    isResponsive: isResponsive,
    header: header,
    width: width,
    maxHeight: maxHeight,
    wrappedEl: contextMenuRef.current
  }),
      psSize = _usePopOverOption.psSize;

  React.useEffect(function () {
    var appBody = document.getElementById('appContainer'); // Event mousedown to handle close map context menu when clicking right mouse

    appBody === null || appBody === void 0 ? void 0 : appBody.addEventListener(reactDeviceDetect.isMobile ? 'touchstart' : 'mousedown', handleOnClose);
    return function () {
      return appBody === null || appBody === void 0 ? void 0 : appBody.removeEventListener(reactDeviceDetect.isMobile ? 'touchstart' : 'mousedown', handleOnClose);
    };
  }, []);

  var updateMenu = function updateMenu(menu, props) {
    var filteredData = Object.entries(props).filter(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          key = _ref2[0];

      return key in menu;
    });
    var updatedMenu = Object.fromEntries(filteredData);
    return _objectSpread2(_objectSpread2({}, menu), updatedMenu);
  };

  var handleOnClose = function handleOnClose() {
    onClose && onClose();
  };

  var handleContainerClick = function handleContainerClick() {
    // to prevent it auto close on iOS, we just close when it's in fullscreen mode
    if (isResponsive) {
      handleOnClose();
    }
  };

  var handleOnBlur = function handleOnBlur() {
    console.log('onBlur'); // not work

    if (isCloseOnBlur) {
      handleOnClose();
    }
  };

  var menu = updateMenu(defaultMenu, props);
  return /*#__PURE__*/jsxRuntime.jsx(AnchorOverlay, _objectSpread2(_objectSpread2({}, props), {}, {
    position: position,
    className: className !== null && className !== void 0 ? className : undefined,
    backdrop: backdrop,
    onBackgroundClick: handleOnClose,
    children: /*#__PURE__*/jsxRuntime.jsx("div", {
      tabIndex: 0,
      id: menu.id ? menu.id : undefined,
      className: 'action-menu ' + menuStyle,
      onBlur: handleOnBlur,
      onContextMenu: function onContextMenu(e) {
        return e.preventDefault();
      },
      children: /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "action-menu-widget",
        onClick: handleContainerClick,
        children: [menu.header && /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "action-menu-header",
          children: /*#__PURE__*/jsxRuntime.jsx("div", {
            className: "action-menu-entry-text",
            children: /*#__PURE__*/jsxRuntime.jsx(T, {
              children: menu.header
            })
          })
        }), menu.header && /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "action-menu-horizontal-line"
        }), /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
          className: "action-menu-content",
          style: psSize,
          children: menu.actions.map(function (action, i) {
            return /*#__PURE__*/jsxRuntime.jsx(ContextMenuItem, {
              index: i,
              label: action.label,
              className: action.className,
              disabled: action.disabled,
              iconStyle: action.iconStyle,
              iconClassName: action.iconClassName,
              icon: action.icon,
              to: action.to,
              style: action.style,
              sub: action.sub,
              onClick: action.onClick,
              onClose: handleOnClose
            }, i);
          })
        })]
      })
    })
  }));
};

var ModalContext = /*#__PURE__*/React.createContext(null);
var toastIcons$1 = {
  'info': 'info-circle',
  'success': 'check-circle',
  'warning': 'exclamation-triangle',
  'error': 'exclamation-circle',
  'default': ''
};

/**
 * This component was created to avoid render on ModalContext causing re-render the whole app
 */
// eslint-disable-next-line react/display-name
var ModalController = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _useState = React.useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      modals = _useState2[0],
      setModals = _useState2[1];

  var _useState3 = React.useState([]),
      _useState4 = _slicedToArray(_useState3, 2),
      toasts = _useState4[0],
      setToasts = _useState4[1];

  var add = function add(modal) {
    setModals([].concat(_toConsumableArray(modals), [modal]));
  };

  var remove = function remove(modal) {
    setModals(function (modals) {
      return modals.filter(function (m) {
        return m !== modal;
      });
    });
  };

  var addToast = function addToast(toast) {
    setToasts([].concat(_toConsumableArray(toasts), [toast]));
  };

  var removeToast = function removeToast(toast) {
    setToasts(function (toasts) {
      return toasts.filter(function (t) {
        return t !== toast;
      });
    });
  };

  React.useImperativeHandle(ref, function () {
    return {
      alert: function alert(props) {
        var onOk = props.onOk;

        function handleClickOk() {
          onOk && onOk();
          remove(modal);
        }

        var modal = /*#__PURE__*/jsxRuntime.jsx(Alert, _objectSpread2(_objectSpread2({}, props), {}, {
          onOk: handleClickOk
        }), CommonHelper.uuid());

        add(modal);
      },
      confirm: function confirm(props) {
        // const modal = { type: 'confirm', props };
        var onCancel = props.onCancel,
            onOk = props.onOk;

        var handleClickCancel = function handleClickCancel() {
          onCancel && onCancel();
          remove(modal);
        };

        var handleClickOk = function handleClickOk() {
          onOk && onOk();
          remove(modal);
        };

        var modal = /*#__PURE__*/jsxRuntime.jsx(Confirm, _objectSpread2(_objectSpread2({}, props), {}, {
          onOk: handleClickOk,
          onCancel: handleClickCancel
        }), CommonHelper.uuid());

        add(modal);
      },
      toast: function toast(props) {
        var onClick = props.onClick,
            _props$timeout = props.timeout,
            timeout = _props$timeout === void 0 ? 3000 : _props$timeout;
        var icon = props.icon || toastIcons$1[props.type] || toastIcons$1['default'];

        var handleClick = function handleClick() {
          onClick && onClick();
          remove(toast);
        };

        var toast = /*#__PURE__*/jsxRuntime.jsx(Toast, _objectSpread2(_objectSpread2({}, props), {}, {
          icon: icon,
          onClick: handleClick
        }), CommonHelper.uuid());

        addToast(toast);
        timeout !== 0 && setTimeout(function () {
          return removeToast(toast);
        }, timeout);
      },
      spin: function spin(props) {
        var timeout = props.timeout;

        var modal = /*#__PURE__*/jsxRuntime.jsx(Loading, {
          fullscreen: true
        });

        add(modal);

        if (timeout) {
          if (typeof timeout === 'number') {
            setTimeout(function () {
              return remove(modal);
            }, timeout);
          } else {
            // timeout is a promise, it's confusing, change later
            Promise.resolve(timeout)["finally"](function () {
              return remove(modal);
            });
          }
        }
      },
      menu: function menu(props) {
        var onClose = props.onClose;

        var handleClose = function handleClose() {
          onClose && onClose();
          remove(modal);
        };

        var modal = /*#__PURE__*/jsxRuntime.jsx(ContextMenu, _objectSpread2(_objectSpread2({}, props), {}, {
          onClose: handleClose
        }), CommonHelper.uuid());

        add(modal);
      }
    };
  });
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [modals, /*#__PURE__*/jsxRuntime.jsx(Container, {
      className: 'toast-items toast-location-top-right',
      children: toasts
    })]
  });
});

var ModalProvider = function ModalProvider(props) {
  var modalRef = React.useRef(null);
  var value = {
    alert: function alert(props) {
      var _modalRef$current;

      return modalRef === null || modalRef === void 0 ? void 0 : (_modalRef$current = modalRef.current) === null || _modalRef$current === void 0 ? void 0 : _modalRef$current.alert(props);
    },
    confirm: function confirm(props) {
      var _modalRef$current2;

      return modalRef === null || modalRef === void 0 ? void 0 : (_modalRef$current2 = modalRef.current) === null || _modalRef$current2 === void 0 ? void 0 : _modalRef$current2.confirm(props);
    },
    toast: function toast(props) {
      var _modalRef$current3;

      return modalRef === null || modalRef === void 0 ? void 0 : (_modalRef$current3 = modalRef.current) === null || _modalRef$current3 === void 0 ? void 0 : _modalRef$current3.toast(props);
    },
    spin: function spin(props) {
      var _modalRef$current4;

      return modalRef === null || modalRef === void 0 ? void 0 : (_modalRef$current4 = modalRef.current) === null || _modalRef$current4 === void 0 ? void 0 : _modalRef$current4.spin(props);
    },
    menu: function menu(props) {
      var _modalRef$current5;

      return modalRef === null || modalRef === void 0 ? void 0 : (_modalRef$current5 = modalRef.current) === null || _modalRef$current5 === void 0 ? void 0 : _modalRef$current5.menu(props);
    }
  };
  return /*#__PURE__*/jsxRuntime.jsxs(ModalContext.Provider, {
    value: value,
    children: [/*#__PURE__*/jsxRuntime.jsx(Container, {
      id: "appContainer",
      children: props === null || props === void 0 ? void 0 : props.children
    }), /*#__PURE__*/jsxRuntime.jsx(ModalController, {
      ref: modalRef
    })]
  });
};

var _excluded$t = ["onCancel", "onOk"],
    _excluded2$2 = ["onOk"],
    _excluded3$1 = ["onClose"],
    _excluded4$1 = ["location", "onClick", "timeout", "type"];

var renderModal = function renderModal(element) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var timeout = options.timeout;

  var close = function close() {
    return destroy(modalRoot);
  };

  var appContainer = document.getElementById('appContainer');
  var modalRoot = document.createElement('modal-root');
  appContainer === null || appContainer === void 0 ? void 0 : appContainer.appendChild(modalRoot);
  ReactDOM__default['default'].render(element, modalRoot);

  if (typeof timeout === 'number') {
    setTimeout(close, timeout);
  } else if (timeout instanceof Promise) {
    Promise.resolve(timeout)["finally"](function () {
      return close();
    });
  }

  return {
    close: close
  };
};

var destroy = function destroy(div) {
  var unmountResult = ReactDOM__default['default'].unmountComponentAtNode(div);
  unmountResult && div.parentNode && div.parentNode.removeChild(div);
};

var confirm = function confirm(props) {
  var onCancel = props.onCancel,
      onOk = props.onOk,
      resProps = _objectWithoutProperties(props, _excluded$t);

  function handleClickCancel() {
    onCancel && onCancel();
    render.close();
  }

  function handleClickOk() {
    onOk && onOk();
    render.close();
  }

  var render = renderModal( /*#__PURE__*/jsxRuntime.jsx(Confirm, _objectSpread2(_objectSpread2({}, resProps), {}, {
    onOk: handleClickOk,
    onCancel: handleClickCancel
  })));
};
var alert = function alert(props) {
  var onOk = props.onOk,
      restProps = _objectWithoutProperties(props, _excluded2$2);

  function handleClickOk() {
    onOk && onOk();
    render.close();
  }

  var render = renderModal( /*#__PURE__*/jsxRuntime.jsx(Alert, _objectSpread2(_objectSpread2({}, restProps), {}, {
    onOk: handleClickOk
  })));
};
var drawer = function drawer(props) {
  var onClose = props.onClose,
      restProps = _objectWithoutProperties(props, _excluded3$1);

  function handleClickOk() {
    onClose && onClose();
    render.close();
  }

  var render = renderModal( /*#__PURE__*/jsxRuntime.jsx(Drawer, _objectSpread2(_objectSpread2({}, restProps), {}, {
    onClose: handleClickOk
  })));
};
var toastIcons = {
  'info': 'info-circle',
  'success': 'check-circle',
  'warning': 'exclamation-triangle',
  'error': 'exclamation-circle',
  'default': ''
};
var toast = function toast(props) {
  var location = props.location,
      onClick = props.onClick,
      _props$timeout = props.timeout,
      timeout = _props$timeout === void 0 ? 3000 : _props$timeout,
      type = props.type,
      restProps = _objectWithoutProperties(props, _excluded4$1);

  var icon = props.icon || toastIcons[type] || toastIcons['default'];

  var handleClick = function handleClick(toastDiv) {
    onClick && onClick();
    destroy(toastDiv);
  };

  function addToast() {
    var toastDiv = document.createElement('div');
    var toastStack = document.getElementById('toast-stack');

    if (toastStack) {
      toastStack.appendChild(toastDiv);
      ReactDOM__default['default'].render( /*#__PURE__*/jsxRuntime.jsx(Toast, _objectSpread2(_objectSpread2({}, restProps), {}, {
        type: type,
        icon: icon,
        onClick: function onClick() {
          return handleClick(toastDiv);
        }
      })), toastDiv);
      timeout !== 0 && setTimeout(function () {
        return destroy(toastDiv);
      }, timeout);
    }
  }

  var div = document.getElementById('toast-stack');

  if (!div) {
    renderModal( /*#__PURE__*/jsxRuntime.jsx(ToastStack, {
      location: location,
      id: 'toast-stack'
    })); // Wait until React render ToastStack to render Toast

    setTimeout(addToast, 100);
    return;
  }

  addToast();
};
var spin = function spin() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var timeout = props.timeout;
  var render = renderModal( /*#__PURE__*/jsxRuntime.jsx(Loading, {
    fullscreen: true
  }), {
    timeout: timeout
  });
  return render;
};

var useModal = function useModal() {
  var modal = React.useContext(ModalContext);

  if (!modal) {
    throw new Error('useModal must be within ModalProvider');
  }

  return modal;
};

var withModal = function withModal(Component) {
  // eslint-disable-next-line react/display-name
  return function (props) {
    var modal = useModal();
    return /*#__PURE__*/jsxRuntime.jsx(Component, _objectSpread2({}, _objectSpread2(_objectSpread2({}, modal), props)));
  };
};

var AdvanceSelectControl = function AdvanceSelectControl(props) {
  var _defaultOptions$find;

  var defaultOptions = props.defaultOptions,
      searchMode = props.searchMode,
      disabled = props.disabled,
      searchable = props.searchable,
      controlRef = props.controlRef,
      value = props.value,
      options = props.options,
      multi = props.multi,
      placeholder = props.placeholder,
      isVisible = props.isVisible,
      isLoading = props.isLoading,
      searchKey = props.searchKey,
      defaultValue = props.defaultValue,
      isNoneSelect = props.isNoneSelect,
      clearable = props.clearable,
      selectedOptions = props.selectedOptions,
      onSearchKey = props.onSearchKey,
      onOptionsChange = props.onOptionsChange,
      onClear = props.onClear,
      onControlClick = props.onControlClick,
      onTagRemoved = props.onTagRemoved,
      onRemoteFetch = props.onRemoteFetch;

  var _useI18n = useI18n(),
      t = _useI18n.t;

  var inputRef = React.useRef(null);
  var containerRef = React.useRef(null);
  var contentRef = React.useRef(null);
  var searchboxWidth = React.useRef(0);
  React.useLayoutEffect(function () {
    if (!contentRef.current) {
      return;
    }

    var resize = new ResizeObserver(function (entries) {
      var contentWidth = entries[0].contentRect.width;
      searchboxWidth.current = contentWidth;
    });
    resize.observe(contentRef.current);
    return function () {
      return resize.disconnect();
    };
  }, [contentRef]);
  React.useEffect(function () {
    isVisible && document.addEventListener('mousedown', handleClosePopup);
    isVisible && document.addEventListener('scroll', handleClosePopup, true);
    return function () {
      document.removeEventListener('mousedown', handleClosePopup);
      document.removeEventListener('scroll', handleClosePopup, true);
    };
  }, [isVisible]);
  React.useEffect(function () {
    if (disabled) {
      return;
    }

    if (searchMode === 'local') {
      if (!searchKey) {
        onOptionsChange && onOptionsChange(defaultOptions || []);
        return;
      }

      var newOptions = (defaultOptions || []).filter(function (option) {
        var display = typeof option.inputDisplay === 'string' && option.inputDisplay || typeof option.dropdownDisplay === 'string' && option.dropdownDisplay || typeof option.label === 'string' && option.label || option.id || '';
        return t(display).toLowerCase().includes(searchKey.toLowerCase());
      });
      onOptionsChange && onOptionsChange(newOptions);
      return;
    }

    onRemoteFetch && onRemoteFetch(searchKey || ''); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchKey]);

  var handleClosePopup = function handleClosePopup(event) {
    event.target !== inputRef.current && event.target !== containerRef.current && !event.composedPath().some(function (elm) {
      var _classList;

      return elm === inputRef.current || elm === containerRef.current || ((_classList = elm.classList) === null || _classList === void 0 ? void 0 : _classList.value.includes('as-overlay'));
    }) && isVisible && onControlClick();
    return;
  };

  var handleClearValueClick = function handleClearValueClick(event) {
    var _inputRef$current;

    event.stopPropagation();
    onClear ? onClear() : onSearchKey && onSearchKey('');
    onClear && ((_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus());
  };

  var handleKeyPress = function handleKeyPress(event) {
    var key = event.which;
    key === Constants.KEYS.ENTER && onControlClick() && event.preventDefault();
  };

  var handleInputKeyDown = function handleInputKeyDown(event) {
    var key = event.which;
    (key === Constants.KEYS.DOWN || key === Constants.KEYS.UP) && event.preventDefault();
  };

  var content;
  var contentAsString = !multi && ((defaultOptions === null || defaultOptions === void 0 ? void 0 : (_defaultOptions$find = defaultOptions.find(function (o) {
    return o.id === (value || defaultValue);
  })) === null || _defaultOptions$find === void 0 ? void 0 : _defaultOptions$find.label) || value);

  var placeholderTag = /*#__PURE__*/jsxRuntime.jsx("span", {
    className: 'placeholder',
    children: /*#__PURE__*/jsxRuntime.jsx(T, {
      children: placeholder
    })
  });

  if (multi && Array.isArray(value) && value.length) {
    content = value.map(function (val) {
      var _ref, _options$find$label, _options$find, _selectedOptions$find;

      return /*#__PURE__*/jsxRuntime.jsx(Tag, {
        text: (_ref = (_options$find$label = options === null || options === void 0 ? void 0 : (_options$find = options.find(function (o) {
          return o.id === val;
        })) === null || _options$find === void 0 ? void 0 : _options$find.label) !== null && _options$find$label !== void 0 ? _options$find$label : selectedOptions === null || selectedOptions === void 0 ? void 0 : (_selectedOptions$find = selectedOptions.find(function (o) {
          return o.id === val;
        })) === null || _selectedOptions$find === void 0 ? void 0 : _selectedOptions$find.label) !== null && _ref !== void 0 ? _ref : placeholder,
        onCloseClick: function onCloseClick(event) {
          event.stopPropagation();
          onTagRemoved && onTagRemoved(event, val);
        }
      }, val);
    });
  } else {
    if (defaultValue === undefined && (value === undefined || Array.isArray(value) && value.length === 0) || isNoneSelect) {
      content = placeholderTag;
    } else if (value === undefined) {
      var _content;

      content = options === null || options === void 0 ? void 0 : options.find(function (o) {
        return o.id === defaultValue;
      });
      content = content ? (_content = content) === null || _content === void 0 ? void 0 : _content.inputDisplay : props.searchKey || placeholderTag || '';
    } else {
      var _content2;

      content = options === null || options === void 0 ? void 0 : options.find(function (o) {
        return o.id === value;
      });
      content = content ? (_content2 = content) === null || _content2 === void 0 ? void 0 : _content2.inputDisplay : props.searchKey || t(value) || placeholderTag || '';
    }

    content = /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'dropdown-btn-text',
      children: /*#__PURE__*/jsxRuntime.jsx(T, {
        children: content
      })
    });
  }

  var hasValue = value !== null && value !== undefined && value !== '' && (!Array.isArray(value) || value.length > 0);
  var inputValue = typeof props.searchKey === 'string' ? props.searchKey : t(contentAsString) || '';
  var isShowClearButton = clearable && !disabled && hasValue;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    ref: function ref(elm) {
      controlRef.current = elm;
      containerRef.current = elm;
    },
    className: "as-container ".concat(disabled ? 'as-container-disabled' : ''),
    tabIndex: 0,
    "data-autofocus": true,
    onClick: function onClick() {
      return (!searchable || searchable && !isVisible) && onControlClick();
    },
    onKeyPress: handleKeyPress,
    children: /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: "as-control-container",
      children: [searchable && isVisible && /*#__PURE__*/jsxRuntime.jsxs(Container, {
        className: "dropdown-btn dropdown-btn--searchable",
        width: searchboxWidth.current + 'px',
        children: [multi && Array.isArray(value) && value.length > 0 && /*#__PURE__*/jsxRuntime.jsx(T, {
          children: content
        }), /*#__PURE__*/jsxRuntime.jsx("input", {
          ref: inputRef,
          className: "dropdown-input",
          placeholder: t(placeholder),
          value: inputValue,
          autoFocus: true,
          onChange: function onChange(event) {
            return onSearchKey && onSearchKey(event.target.value);
          },
          onKeyDown: handleInputKeyDown
        })]
      }), /*#__PURE__*/jsxRuntime.jsx(Container, {
        ref: contentRef,
        className: clsx__default['default']('dropdown-btn', {
          'dropdown-btn--hidden': searchable && isVisible
        }),
        children: /*#__PURE__*/jsxRuntime.jsx(T, {
          children: content
        })
      }), isLoading && !isVisible && /*#__PURE__*/jsxRuntime.jsx(Loading, {
        spinnerSize: "sm"
      }), isShowClearButton && /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "clear",
        children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          icon: 'times',
          size: '1rem',
          onClick: handleClearValueClick
        })
      }), /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "arrow",
        children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, _objectSpread2({
          icon: isVisible ? 'chevron-up' : 'chevron-down',
          size: '1rem',
          type: 'regular'
        }, searchable && {
          onClick: function onClick(e) {
            e.stopPropagation();
            onControlClick();
          }
        }))
      })]
    })
  });
};

var AdvanceSelectPopup = /*#__PURE__*/function (_Component) {
  _inherits(AdvanceSelectPopup, _Component);

  var _super = _createSuper(AdvanceSelectPopup);

  function AdvanceSelectPopup() {
    var _this;

    _classCallCheck(this, AdvanceSelectPopup);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      options: [],
      keyPressValue: null
    });

    _defineProperty$1(_assertThisInitialized(_this), "scrollRef", /*#__PURE__*/React.createRef());

    _defineProperty$1(_assertThisInitialized(_this), "containerRef", /*#__PURE__*/React.createRef());

    _defineProperty$1(_assertThisInitialized(_this), "clickable", false);

    _defineProperty$1(_assertThisInitialized(_this), "numOfCol", 1);

    _defineProperty$1(_assertThisInitialized(_this), "preventScroll", function (event) {
      var path = event.path || event.composedPath && event.composedPath(); // event.composedPath() for cross browser compatibility

      var isAdvanceSelectDropdown = path === null || path === void 0 ? void 0 : path.some(function (elm) {
        return _this.scrollRef.current === elm;
      });

      if (!isAdvanceSelectDropdown) {
        event.preventDefault();
        event.stopPropagation();
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleKeyPress", function (e) {
      // stop scroll when click arrow up arrow down
      e.stopPropagation();
      var _this$props = _this.props,
          multi = _this$props.multi,
          selectedValue = _this$props.selectedValue,
          isGridView = _this$props.isGridView,
          getInputRef = _this$props.getInputRef,
          searchable = _this$props.searchable;
      var _this$state = _this.state,
          keyPressValue = _this$state.keyPressValue,
          options = _this$state.options;

      if (_this.props.isVisible) {
        var currentTarget = document.activeElement;
        var index = (options === null || options === void 0 ? void 0 : options.findIndex(function (op) {
          return op.id === keyPressValue;
        })) || 0;
        var isFocusPopup = currentTarget && currentTarget === _this.containerRef.current;

        switch (e.which) {
          case Constants.KEYS.ENTER:
            multi ? _this.onSelectItem(e, keyPressValue, !selectedValue.includes(keyPressValue)) : _this.props.onSelectChange && _this.props.onSelectChange(keyPressValue, undefined, e);
            return;

          case Constants.KEYS.UP:
            if (!isGridView) {
              index--;
              index = index < 0 ? options.length - 1 : index;
              break;
            }

            if (!isFocusPopup) {
              return;
            }

            index -= _this.numOfCol;

            if (searchable && isFocusPopup && index < 0) {
              var input = getInputRef();
              input && input.focus();
              index = -1;
              break;
            }

            index = index < 0 ? index + options.length : index;
            break;

          case Constants.KEYS.DOWN:
            if (!isGridView) {
              index++;
              index = index >= options.length ? 0 : index;
              break;
            }

            if (!isFocusPopup) {
              _this.containerRef.current.focus();

              break;
            }

            index += _this.numOfCol;
            index = index >= options.length ? index - options.length : index;
            break;

          case Constants.KEYS.LEFT:
            if (isGridView) {
              if (currentTarget && currentTarget === _this.containerRef.current) {
                index--;
                index = index < 0 ? options.length - 1 : index;
                break;
              }
            }

            return;

          case Constants.KEYS.RIGHT:
            if (isGridView) {
              if (currentTarget && currentTarget === _this.containerRef.current) {
                index++;
                index = index >= options.length ? 0 : index;
                break;
              }
            }

            return;

          default:
            return;
        }

        if (index >= 0 && !!options[index]) {
          _this.setState({
            keyPressValue: options[index].id
          }, function () {
            var element = document.querySelector('.as-dropdown-item.keypress-active');
            element && element.scrollIntoView({
              block: 'center'
            });
          });
        }
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "onSelectItem", function (e, optionId, active) {
      var _this$props2 = _this.props,
          multi = _this$props2.multi,
          selectedValue = _this$props2.selectedValue,
          onSelectChange = _this$props2.onSelectChange;

      if (multi && Array.isArray(selectedValue)) {
        var values;

        if (active) {
          values = [].concat(_toConsumableArray(selectedValue), [optionId]);
        } else {
          values = selectedValue.filter(function (val) {
            return val !== optionId;
          });
        }

        onSelectChange(values, optionId, e);
      } else {
        onSelectChange(optionId, undefined, e);
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "renderDropdownContent", function (option, hasDividers) {
      var _this$props3 = _this.props,
          selectedValue = _this$props3.selectedValue,
          multi = _this$props3.multi;
      var keyPressActive = _this.state.keyPressValue === option.id;
      var isActive = false;

      if (multi && Array.isArray(selectedValue)) {
        isActive = selectedValue.includes(option.id);
      } else {
        isActive = selectedValue === option.id;
      }

      return /*#__PURE__*/jsxRuntime.jsx("li", {
        className: "as-dropdown-item ".concat(isActive ? 'active' : '', "                      ").concat(keyPressActive ? 'keypress-active' : '', "                      ").concat(hasDividers ? 'dividers' : ''),
        onClick: function onClick(e) {
          return _this.onSelectItem(e, option.id, !isActive);
        },
        children: /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "as-dropdown-item-button",
          children: /*#__PURE__*/jsxRuntime.jsx(T, {
            children: option.dropdownDisplay
          })
        })
      }, option.id);
    });

    return _this;
  }

  _createClass(AdvanceSelectPopup, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$containerRef$cu;

      var _this$props4 = this.props,
          options = _this$props4.options,
          noneSelectValue = _this$props4.noneSelectValue,
          searchKey = _this$props4.searchKey,
          searchable = _this$props4.searchable;
      this.setState({
        searchKey: searchKey
      });
      !searchable && ((_this$containerRef$cu = this.containerRef.current) === null || _this$containerRef$cu === void 0 ? void 0 : _this$containerRef$cu.focus());

      var isEmpty = function isEmpty(value) {
        return !value || Object.keys(value).length === 0;
      };

      if (!isEmpty(noneSelectValue)) {
        options.unshift({
          id: 'non-select',
          dropdownDisplay: noneSelectValue
        });
      }

      document.addEventListener('keydown', this.handleKeyPress, true);
      document.addEventListener('wheel', this.preventScroll, {
        capture: true,
        passive: false
      });
      var element = document.querySelector('.as-dropdown-item.active');
      element && element.scrollIntoView({
        block: 'center'
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      document.removeEventListener('keydown', this.handleKeyPress, true);
      document.removeEventListener('wheel', this.preventScroll, {
        capture: true,
        passive: false
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var options = this.state.options;
      var _this$props5 = this.props,
          isVisible = _this$props5.isVisible,
          titleText = _this$props5.titleText,
          width = _this$props5.width,
          hasDividers = _this$props5.hasDividers,
          searchable = _this$props5.searchable,
          isGridView = _this$props5.isGridView,
          isLoading = _this$props5.isLoading;
      var col = options.length === 1 || options.length === 2 ? options.length : Math.ceil(Math.sqrt(options.length));
      this.numOfCol = col;
      var gridTemplateColumns = '';

      for (var i = 1; i <= col; i++) {
        gridTemplateColumns += 'auto ';
      }

      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        ref: this.containerRef,
        id: "advance-select-popup",
        className: "as-dropdown-container ".concat(isVisible ? 'visible' : ''),
        style: {
          width: width
        },
        tabIndex: !searchable && !isGridView ? 0 : 1,
        children: [isLoading && /*#__PURE__*/jsxRuntime.jsx(Loading, {
          spinnerSize: "sm",
          direction: "row",
          text: "Loading options...",
          overlay: true
        }), titleText && /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "as-dropdown-title",
          children: /*#__PURE__*/jsxRuntime.jsx("span", {
            children: /*#__PURE__*/jsxRuntime.jsx(T, {
              children: titleText
            })
          })
        }), /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
          containerRef: function containerRef(scrollElm) {
            return _this2.scrollRef.current = scrollElm;
          },
          children: /*#__PURE__*/jsxRuntime.jsx("ul", {
            className: clsx__default['default']('as-dropdown-list', {
              'grid-view': isGridView
            }),
            style: _objectSpread2({}, isGridView ? {
              gridTemplateColumns: gridTemplateColumns
            } : {}),
            children: options && options.map(function (option) {
              return _this2.renderDropdownContent(option, hasDividers);
            })
          })
        })]
      });
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.options && nextProps.options !== prevState.options) {
        if (nextProps.isVisible) {
          // when searching
          if (prevState.isSearching) {
            return {
              options: prevState.options
            };
          } else // load state when option change
            {
              return {
                options: nextProps.options,
                keyPressValue: nextProps.selectedValue
              };
            }
        } else {
          // when turn off popup
          return {
            options: nextProps.options
          };
        }
      }

      return null;
    }
  }]);

  return AdvanceSelectPopup;
}(React.Component);
AdvanceSelectPopup.propTypes = {
  onSelectChange: PropTypes__default['default'].func,
  multi: PropTypes__default['default'].bool,
  isVisible: PropTypes__default['default'].bool,
  isLoading: PropTypes__default['default'].bool,
  options: PropTypes__default['default'].array.isRequired,
  selectedValue: PropTypes__default['default'].any,
  width: PropTypes__default['default'].string,
  noneSelectValue: PropTypes__default['default'].string,
  titleText: PropTypes__default['default'].string,
  searchable: PropTypes__default['default'].bool,
  isGridView: PropTypes__default['default'].bool,
  getInputRef: PropTypes__default['default'].func
};
AdvanceSelectPopup.defaultProps = {
  selectedValue: '',
  titleText: '',
  noneSelectValue: '',
  isVisible: false,
  isGridView: false,
  onSelectChange: function onSelectChange() {}
};

var AdvanceSelect = /*#__PURE__*/React__default['default'].memo( /*#__PURE__*/React.forwardRef(function (props, _ref2) {
  var _props$value, _selectRef$current, _containerRef$current2;

  var _props$selectedOption = props.selectedOptions,
      selectedOptions = _props$selectedOption === void 0 ? [] : _props$selectedOption,
      defaultValue = props.defaultValue,
      noneSelectValue = props.noneSelectValue,
      _props$placeholder = props.placeholder,
      placeholder = _props$placeholder === void 0 ? '...' : _props$placeholder,
      _props$searchMode = props.searchMode,
      searchMode = _props$searchMode === void 0 ? 'local' : _props$searchMode,
      tagRemoveConfirm = props.tagRemoveConfirm;
  var onChange = props.onChange,
      onRemoteFetch = props.onRemoteFetch,
      _props$textChangeDela = props.textChangeDelay,
      textChangeDelay = _props$textChangeDela === void 0 ? 300 : _props$textChangeDela,
      onClear = props.onClear,
      customOnChange = props.customOnChange,
      onSearch = props.onSearch,
      onDropdownClosed = props.onDropdownClosed,
      onControlClick = props.onControlClick;
  var _props$searchable = props.searchable,
      searchable = _props$searchable === void 0 ? true : _props$searchable,
      hasDividers = props.hasDividers,
      disabled = props.disabled,
      multi = props.multi,
      clearable = props.clearable,
      isLoading = props.isLoading;
  var flex = props.flex,
      width = props.width;
  var name = props.name;
  var controlRef = React.useRef(null);
  var selectRef = React.useRef(null);
  var containerRef = React.useRef(null);

  var _useState = React.useState(props.options),
      _useState2 = _slicedToArray(_useState, 2),
      options = _useState2[0],
      setOptions = _useState2[1];

  var _useState3 = React.useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isNoneSelect = _useState4[0],
      setIsNoneSelect = _useState4[1];

  var _useStateCallback = useStateCallback(!!props.isVisible),
      _useStateCallback2 = _slicedToArray(_useStateCallback, 2),
      isVisible = _useStateCallback2[0],
      setIsVisible = _useStateCallback2[1];

  var _useState5 = React.useState(),
      _useState6 = _slicedToArray(_useState5, 2),
      searchKey = _useState6[0],
      setSearchKey = _useState6[1];

  var _useState7 = React.useState(),
      _useState8 = _slicedToArray(_useState7, 2),
      textChangeDelayTimeout = _useState8[0],
      setTextChangeDelayTimeout = _useState8[1];

  var _useState9 = React.useState(width !== null && width !== void 0 ? width : '100px'),
      _useState10 = _slicedToArray(_useState9, 2),
      controlWidth = _useState10[0],
      setControlWidth = _useState10[1];

  var defaultSelectValue = defaultValue !== null && defaultValue !== void 0 ? defaultValue : multi ? [] : undefined;

  var _useStateCallback3 = useStateCallback((_props$value = props.value) !== null && _props$value !== void 0 ? _props$value : defaultSelectValue),
      _useStateCallback4 = _slicedToArray(_useStateCallback3, 2),
      value = _useStateCallback4[0],
      setValue = _useStateCallback4[1];

  var _useState11 = React.useState(),
      _useState12 = _slicedToArray(_useState11, 2),
      prevValue = _useState12[0],
      setPrevValue = _useState12[1];

  var _useModal = useModal(),
      confirm = _useModal.confirm;

  var eventListener = function eventListener(event) {
    return event.code === 'Escape' && setIsVisible(false);
  };

  React.useEffect(function () {
    setOptions(props.options);
  }, [props.options]);
  React.useEffect(function () {
    !isVisible && setSearchKey(undefined);
  }, [isVisible]);
  React.useEffect(function () {
    setIsVisible(!!props.isVisible); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [props.isVisible]);
  React.useEffect(function () {
    document.addEventListener('keydown', eventListener, false);
    return function () {
      document.removeEventListener('keydown', eventListener, false);
    };
  }, []);

  var handleClosePopup = function handleClosePopup() {
    return setIsVisible(false, function () {
      var _controlRef$current;

      (_controlRef$current = controlRef.current) === null || _controlRef$current === void 0 ? void 0 : _controlRef$current.focus();
      onDropdownClosed && onDropdownClosed();
    });
  };

  var handleTextChange = function handleTextChange(key) {
    setSearchKey(key);
    typeof key !== 'string' && setIsVisible(!!key);
    typeof key !== 'string' && !key && handleSelectChange('non-select');
    onSearch && onSearch(key);
  };

  var handleSelectChange = function handleSelectChange(value, currentSelect, e) {
    var filteredNoneSelectValue = value === 'non-select' ? undefined : value;
    onChange && onChange(filteredNoneSelectValue, currentSelect);
    setValue(filteredNoneSelectValue, function () {
      var event = new Event('change', {
        bubbles: true
      });
      selectRef.current && selectRef.current.dispatchEvent(event);
    });
    setIsNoneSelect(value === 'non-select');
    multi && ((e === null || e === void 0 ? void 0 : e.ctrlKey) || (e === null || e === void 0 ? void 0 : e.metaKey)) || handleClosePopup();
  };

  var closeAdvanceSelect = function closeAdvanceSelect() {
    return setIsVisible(false);
  };

  var handleTagRemoved = function handleTagRemoved(e, val) {
    e.stopPropagation();
    var newValue = value.filter(function (v) {
      return v !== val;
    });

    if (tagRemoveConfirm) {
      confirm({
        title: 'Xác nhận',
        message: 'Xác nhận xoá lựa chọn này?',
        onOk: function onOk() {
          handleSelectChange(newValue, val);
        }
      });
    } else {
      handleSelectChange(newValue, val);
    }
  };

  var handleControlClick = function handleControlClick() {
    var _containerRef$current;

    onControlClick && onControlClick();
    !disabled && setIsVisible(function (prev) {
      return !prev;
    });
    var offsetWidth = containerRef ? (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.offsetWidth : 100;
    !disabled && setControlWidth("".concat(offsetWidth, "px"));
  }; // this is here because QueryBuilderRule use value as a state and it set state whenever it's parent call fillRuleStatus


  if (defaultValue === undefined && !!onChange && props.value !== prevValue) {
    var _props$value2;

    setValue((_props$value2 = props.value) !== null && _props$value2 !== void 0 ? _props$value2 : multi ? [] : '');
    setPrevValue(props.value);
  }

  var displayAppendedOptions = options === null || options === void 0 ? void 0 : options.map(function (option) {
    return _objectSpread2(_objectSpread2({}, option), {}, {
      dropdownDisplay: option.dropdownDisplay || option.label || option.id || '',
      inputDisplay: option.inputDisplay || option.dropdownDisplay || option.label || option.id || ''
    });
  });

  var handleRemoteFetch = function handleRemoteFetch(value) {
    if (textChangeDelayTimeout) {
      clearTimeout(textChangeDelayTimeout);
      setTextChangeDelayTimeout(null);
    }

    setTextChangeDelayTimeout(setTimeout(function () {
      onRemoteFetch && onRemoteFetch(value);
    }, textChangeDelay));
  };

  var handleClear = function handleClear() {
    clearable && onClear && onClear();
    var clearedValue = multi ? [] : '';
    clearable && onChange && onChange(clearedValue);
    clearable && !onChange && setValue(clearedValue);
  };

  var selectElementValue = (_selectRef$current = selectRef.current) === null || _selectRef$current === void 0 ? void 0 : _selectRef$current.value;
  return /*#__PURE__*/jsxRuntime.jsxs(Container, {
    ref: containerRef,
    flex: flex,
    width: width,
    children: [/*#__PURE__*/jsxRuntime.jsx(AdvanceSelectControl, {
      controlRef: controlRef,
      defaultValue: defaultValue,
      value: !value && value !== '' ? selectElementValue : value,
      selectedOptions: selectedOptions,
      options: displayAppendedOptions,
      defaultOptions: props.options || [],
      multi: multi,
      placeholder: placeholder,
      isVisible: isVisible,
      isNoneSelect: isNoneSelect,
      isLoading: isLoading,
      disabled: disabled,
      clearable: clearable,
      searchable: searchable,
      searchKey: searchKey,
      searchMode: searchMode,
      onTagRemoved: handleTagRemoved,
      onControlClick: handleControlClick,
      onClear: handleClear,
      onSearchKey: handleTextChange,
      onOptionsChange: function onOptionsChange(ops) {
        return setOptions(ops);
      },
      onRemoteFetch: handleRemoteFetch
    }), isVisible && /*#__PURE__*/jsxRuntime.jsx(AnchorOverlay, {
      className: 'as-overlay',
      width: Math.max(((_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.clientWidth) || 0, 130) // 130 is AdvanceSelectPopup's min-width.
      ,
      anchorEl: controlRef,
      backdrop: false,
      dynamicContent: searchable,
      onBackgroundClick: handleClosePopup,
      children: /*#__PURE__*/jsxRuntime.jsx(AdvanceSelectPopup, {
        width: controlWidth,
        multi: multi,
        noneSelectValue: noneSelectValue,
        selectedValue: value,
        isVisible: isVisible,
        isLoading: isLoading,
        options: displayAppendedOptions,
        hasDividers: hasDividers,
        searchable: searchable,
        onSelectChange: handleSelectChange,
        onClose: closeAdvanceSelect
      })
    }), /*#__PURE__*/jsxRuntime.jsxs("select", {
      ref: function ref(e) {
        !!_ref2 && isCallBackRef$4(_ref2) && _ref2(e);
        selectRef.current = e;
      },
      multiple: multi,
      name: name,
      value: Array.isArray(value) ? _toConsumableArray(value) : value,
      defaultValue: defaultValue,
      hidden: true,
      onChange: customOnChange,
      children: [/*#__PURE__*/jsxRuntime.jsx("option", {}), options.map(function (_ref) {
        var id = _ref.id,
            label = _ref.label;
        return /*#__PURE__*/jsxRuntime.jsx("option", {
          value: id,
          children: label
        }, createUniqueId());
      })]
    })]
  });
}));
AdvanceSelect.displayName = 'AdvanceSelect';

var _excluded$s = ["className", "children"],
    _excluded2$1 = ["className", "children"],
    _excluded3 = ["flex", "width", "className", "children"],
    _excluded4 = ["className", "scroll", "children"],
    _excluded5 = ["children", "className"],
    _excluded6 = ["className", "children"],
    _excluded7 = ["className", "children"],
    _excluded8 = ["className", "children"],
    _excluded9 = ["children", "scroll"],
    _excluded10 = ["className", "children"];
var BorderPanel = function BorderPanel(props) {
  var className = props.className,
      children = props.children,
      restProps = _objectWithoutProperties(props, _excluded$s);

  return /*#__PURE__*/jsxRuntime.jsx(FlexPanel, _objectSpread2(_objectSpread2({}, restProps), {}, {
    className: clsx__default['default']('border-panel', className),
    children: children
  }));
};
var Panel = function Panel(_ref) {
  var className = _ref.className,
      children = _ref.children,
      restProps = _objectWithoutProperties(_ref, _excluded2$1);

  return /*#__PURE__*/jsxRuntime.jsx("div", _objectSpread2(_objectSpread2({}, restProps), {}, {
    className: clsx__default['default']('panel', className),
    children: children
  }));
};
var FlexPanel = function FlexPanel(props) {
  var flex = props.flex,
      width = props.width,
      _props$className = props.className,
      className = _props$className === void 0 ? '' : _props$className,
      children = props.children,
      restProps = _objectWithoutProperties(props, _excluded3);

  return /*#__PURE__*/jsxRuntime.jsx(Column, _objectSpread2(_objectSpread2({}, restProps), {}, {
    width: width,
    className: clsx__default['default']('flex-panel', className),
    flex: width ? 0 : flex,
    children: children
  }));
};
var PanelBody = function PanelBody(props) {
  var className = props.className,
      scroll = props.scroll,
      children = props.children,
      restProps = _objectWithoutProperties(props, _excluded4);

  return /*#__PURE__*/jsxRuntime.jsx("div", _objectSpread2(_objectSpread2({}, restProps), {}, {
    className: clsx__default['default']('panel-body', className),
    children: scroll ? /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
      scrollX: false,
      children: children
    }) : children
  }));
};
var ContainerPanel = function ContainerPanel(_ref2) {
  var children = _ref2.children,
      className = _ref2.className,
      restProps = _objectWithoutProperties(_ref2, _excluded5);

  return /*#__PURE__*/jsxRuntime.jsx(Container, _objectSpread2(_objectSpread2({}, restProps), {}, {
    className: clsx__default['default']('flex', 'full-height', className),
    children: children
  }));
}; // ===================================================================================================
// New Component based on Col2, Flex, Box

var BorderPanel2 = function BorderPanel2(props) {
  var className = props.className,
      children = props.children,
      rest = _objectWithoutProperties(props, _excluded6);

  return /*#__PURE__*/jsxRuntime.jsx(FlexPanel2, _objectSpread2(_objectSpread2({
    className: clsx__default['default']('border-panel', className)
  }, rest), {}, {
    children: children
  }));
};
var Panel2 = function Panel2(props) {
  var className = props.className,
      children = props.children,
      rest = _objectWithoutProperties(props, _excluded7);

  return /*#__PURE__*/jsxRuntime.jsx(Box, _objectSpread2(_objectSpread2({
    className: clsx__default['default']('panel', className)
  }, rest), {}, {
    children: children
  }));
};
var FlexPanel2 = function FlexPanel2(props) {
  var className = props.className,
      children = props.children,
      rest = _objectWithoutProperties(props, _excluded8);

  return /*#__PURE__*/jsxRuntime.jsx(Col2, _objectSpread2(_objectSpread2({
    className: clsx__default['default']('flex-panel', className)
  }, rest), {}, {
    children: children
  }));
};
var PanelBody2 = function PanelBody2(props) {
  var children = props.children,
      _props$scroll = props.scroll,
      scroll = _props$scroll === void 0 ? {
    scrollX: false
  } : _props$scroll,
      rest = _objectWithoutProperties(props, _excluded9);

  return /*#__PURE__*/jsxRuntime.jsx(Col2, _objectSpread2(_objectSpread2({
    scroll: scroll
  }, rest), {}, {
    children: children
  }));
};
var ContainerPanel2 = function ContainerPanel2(props) {
  var className = props.className,
      children = props.children,
      rest = _objectWithoutProperties(props, _excluded10);

  return /*#__PURE__*/jsxRuntime.jsx(Flex, _objectSpread2(_objectSpread2({
    className: clsx__default['default']('h-screen overflow-hidden', className)
  }, rest), {}, {
    children: children
  }));
};

var AppBody = function AppBody(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/jsxRuntime.jsx(BorderPanel, {
    className: 'app-body',
    flex: 1,
    children: children
  });
};

var AutoLogout = /*#__PURE__*/function (_Component) {
  _inherits(AutoLogout, _Component);

  var _super = _createSuper(AutoLogout);

  function AutoLogout() {
    var _this;

    _classCallCheck(this, AutoLogout);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "logoutTimeout", null);

    _defineProperty$1(_assertThisInitialized(_this), "events", ['load', 'mousemove', 'mousedown', 'click', 'scroll', 'keypress']);

    _defineProperty$1(_assertThisInitialized(_this), "timeout", _this.props.minutes * 60 * 1000);

    _defineProperty$1(_assertThisInitialized(_this), "onClearInActiveTimeOut", function () {
      if (_this.logoutTimeout) {
        clearTimeout(_this.logoutTimeout);
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "onLogout", function () {
      _this.events.forEach(function (event) {
        document.removeEventListener(event, _this.resetUserActivityTimeout);
      });

      _this.onClearInActiveTimeOut();

      if (_this.props.onLogout) {
        _this.props.onLogout();
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "resetUserActivityTimeout", function () {
      _this.onClearInActiveTimeOut();

      _this.logoutTimeout = setTimeout(_this.onLogout, _this.timeout);
    });

    return _this;
  }

  _createClass(AutoLogout, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      this.events.forEach(function (event) {
        document.addEventListener(event, _this2.resetUserActivityTimeout);
      }); // init logout timeout

      this.logoutTimeout = setTimeout(this.onLogout, this.timeout);
    }
  }, {
    key: "render",
    value: function render() {
      return this.props.children;
    }
  }]);

  return AutoLogout;
}(React.Component);

AutoLogout.propTypes = {
  minutes: PropTypes__default['default'].number,
  onLogout: PropTypes__default['default'].func.isRequired
};
AutoLogout.defaultProps = {
  minutes: 30 // minutes

};

var _excluded$r = ["className", "pressed", "onClick"];
var ToggleButton = /*#__PURE__*/function (_Component) {
  _inherits(ToggleButton, _Component);

  var _super = _createSuper(ToggleButton);

  function ToggleButton() {
    var _this;

    _classCallCheck(this, ToggleButton);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      pressed: false
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleClick", function () {
      _this.setState({
        pressed: !_this.state.pressed
      });

      if (_this.props.onClick) {
        _this.props.onClick({
          pressed: _this.state.pressed
        });
      }
    });

    return _this;
  }

  _createClass(ToggleButton, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          className = _this$props.className;
          _this$props.pressed;
          _this$props.onClick;
          var rest = _objectWithoutProperties(_this$props, _excluded$r);

      return /*#__PURE__*/jsxRuntime.jsx(EmptyButton, _objectSpread2({
        className: "btn-toggle ".concat(this.state.pressed ? 'btn-active' : '', " ").concat(className),
        onClick: this.handleClick
      }, rest));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.pressed !== prevState.pressed) {
        return {
          pressed: nextProps.pressed
        }; // return new state
      }

      return null; // don't change state
    }
  }]);

  return ToggleButton;
}(React.Component);
ToggleButton.propTypes = EmptyButton.propTypes;

var MapButtonGroup = function MapButtonGroup(_ref) {
  var children = _ref.children,
      className = _ref.className;
  return /*#__PURE__*/jsxRuntime.jsx(Row2, {
    className: clsx__default['default']('map-group-button', 'map-control', className),
    children: children
  });
};

var _excluded$q = ["icon", "title", "tooltip", "disabled", "innerRef"];
var DEFAULT_ICON_TOOLTIPS = {
  'times': 'Tắt',
  'trash-alt': 'Xóa',
  'plus': 'Thêm mới'
};
var PanelHeader = function PanelHeader(props) {
  var children = props.children,
      _props$actions = props.actions,
      actions = _props$actions === void 0 ? [] : _props$actions;
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: 'panel-header',
    children: [children && /*#__PURE__*/jsxRuntime.jsx("h3", {
      children: /*#__PURE__*/jsxRuntime.jsx(T, {
        children: children
      })
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'panel-header-actions',
      children: actions.map(function (_ref) {
        var icon = _ref.icon,
            title = _ref.title,
            tooltip = _ref.tooltip,
            disabled = _ref.disabled,
            innerRef = _ref.innerRef,
            restButtonProps = _objectWithoutProperties(_ref, _excluded$q);

        return !disabled && /*#__PURE__*/React.createElement("button", _objectSpread2(_objectSpread2({}, restButtonProps), {}, {
          key: icon,
          ref: innerRef
        }), /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          icon: icon,
          size: '1rem',
          type: 'light' // Todo: title => tooltip when migrate to newer vbd/vicon version
          ,
          title: tooltip || DEFAULT_ICON_TOOLTIPS[icon] || ''
        }), /*#__PURE__*/jsxRuntime.jsx("span", {
          children: /*#__PURE__*/jsxRuntime.jsx(T, {
            children: title
          })
        }));
      })
    })]
  });
};

function ChatBoxHeader(props) {
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: "chat-box-header",
    children: /*#__PURE__*/jsxRuntime.jsx("p", {
      children: props.groupInfo && props.groupInfo.groupName
    })
  });
}
ChatBoxHeader.propTypes = {
  groupInfo: PropTypes__default['default'].object
};

function UserAvatar(props) {
  var isOnline = props.lastActiveAt && moment__default['default']().diff(moment__default['default'](props.lastActiveAt), 'm') < 5;
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: "user-avatar",
    children: [/*#__PURE__*/jsxRuntime.jsx("img", {
      src: props.src,
      className: "chat-avatar"
    }), props.showOnlineStatus && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: ['user-status', isOnline ? 'online' : 'offline'].join(' ')
    })]
  });
}
UserAvatar.propTypes = {
  src: PropTypes__default['default'].string,
  showOnlineStatus: PropTypes__default['default'].bool,
  lastActiveAt: PropTypes__default['default'].any
};

var ChatRoles = {
  Admin: 'group_admin',
  Member: 'group_member'
};
var MessageTypes = {
  Group: 'group',
  Member: 'member',
  Message: 'message'
};

var getDateTimeDisplay = function getDateTimeDisplay(createdAt, showDate, showTime) {
  if (!showDate && !showTime) {
    return '';
  }

  var current = moment__default['default'](createdAt);
  var textArr = [];

  if (showDate) {
    textArr.push(current.format('L'));
  }

  if (showTime) {
    textArr.push(current.format('LT'));
  }

  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: "post-header",
    children: textArr.join(' - ')
  });
};

function Post(props) {
  var _props$readMembers;

  var ref = React.useRef();
  React.useEffect(function () {
    props.setRef && props.setRef(ref);
  }, []);
  var _props$message = props.message,
      id = _props$message.id,
      textContent = _props$message.textContent,
      createdAt = _props$message.createdAt,
      type = _props$message.type;
  var isSystem = [MessageTypes.Group, MessageTypes.Member].includes(type);
  var user = props.user || {};
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    ref: ref,
    className: "post ".concat(isSystem ? 'system' : props.fromMe ? 'from-me' : ''),
    children: [/*#__PURE__*/jsxRuntime.jsx(Row2, {
      justify: "center",
      children: getDateTimeDisplay(createdAt, props.showDetails || props.showDate, props.showDetails || props.showTime)
    }), /*#__PURE__*/jsxRuntime.jsx(Row2, {
      children: /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "post-content",
        onClick: function onClick() {
          return props.onClick && props.onClick(id);
        },
        children: [/*#__PURE__*/jsxRuntime.jsx("div", {
          className: "post-avatar",
          children: props.showAvatar && user && /*#__PURE__*/jsxRuntime.jsx(UserAvatar, {
            src: user.avatar,
            status: user.status
          })
        }), /*#__PURE__*/jsxRuntime.jsxs("div", {
          className: "post-content-body",
          style: {
            maxWidth: props.fullWidth ? '100%' : '80%'
          },
          children: [props.showSender && !isSystem && /*#__PURE__*/jsxRuntime.jsx("div", {
            className: "post-sender",
            children: /*#__PURE__*/jsxRuntime.jsx("a", {
              children: user && user.displayName
            })
          }), /*#__PURE__*/jsxRuntime.jsx("p", {
            children: textContent
          })]
        }), !props.fullWidth && /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "post-avatar"
        })]
      })
    }), /*#__PURE__*/jsxRuntime.jsx(Row2, {
      justify: "end",
      children: /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "post-footer",
        children: (_props$readMembers = props.readMembers) === null || _props$readMembers === void 0 ? void 0 : _props$readMembers.map(function (user) {
          return /*#__PURE__*/jsxRuntime.jsx(UserAvatar, {
            className: "tracking-item",
            src: user.avatar
          }, user.userId);
        })
      })
    })]
  });
}
Post.propTypes = {
  fromMe: PropTypes__default['default'].bool,
  message: PropTypes__default['default'].object,
  user: PropTypes__default['default'].object,
  showDetails: PropTypes__default['default'].bool,
  onClick: PropTypes__default['default'].func,
  setRef: PropTypes__default['default'].func,
  showAvatar: PropTypes__default['default'].bool,
  showSender: PropTypes__default['default'].bool,
  showDate: PropTypes__default['default'].bool,
  showTime: PropTypes__default['default'].bool,
  readMembers: PropTypes__default['default'].array,
  fullWidth: PropTypes__default['default'].bool
};

function ChatView(props) {
  var _props$group;

  // refs
  var _useState = React.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      scrollRef = _useState2[0],
      setScrollRef = _useState2[1];

  var _useState3 = React.useState(0),
      _useState4 = _slicedToArray(_useState3, 2),
      containerRef = _useState4[0],
      setContainerRef = _useState4[1]; // flags


  var _useState5 = React.useState(false),
      _useState6 = _slicedToArray(_useState5, 2),
      offTrack = _useState6[0],
      setOffTrack = _useState6[1];

  var _useState7 = React.useState(false),
      _useState8 = _slicedToArray(_useState7, 2),
      unreadSeen = _useState8[0],
      setUnreadSeen = _useState8[1];

  var _useState9 = React.useState(false),
      _useState10 = _slicedToArray(_useState9, 2),
      messageShowingDetails = _useState10[0],
      setMessageShowingDetails = _useState10[1];

  var _useState11 = React.useState(0),
      _useState12 = _slicedToArray(_useState11, 2),
      contentHeight = _useState12[0],
      setContentHeight = _useState12[1];

  var _useState13 = React.useState(),
      _useState14 = _slicedToArray(_useState13, 2),
      lastReadMessage = _useState14[0],
      setLastReadMessage = _useState14[1];

  var _useState15 = React.useState(false),
      _useState16 = _slicedToArray(_useState15, 2),
      isLoading = _useState16[0],
      setIsLoading = _useState16[1];

  React.useEffect(function () {
    if (!offTrack) {
      if (!unreadSeen && props.latestReadMessageId) {
        var mIndex = messages.findIndex(function (m) {
          return m.messageId === props.latestReadMessageId;
        }) + 1;
        setUnreadSeen(true);
        setOffTrack(true);
        messages[mIndex] && messages[mIndex].ref && messages[mIndex].ref.current.scrollIntoView();
      } else {
        scrollBottom();
      }
    }
  }, [props.messages]);
  React.useEffect(function () {
    props.setScrollRef(scrollRef);
  }, [scrollRef]);

  var handleScrollUp = function handleScrollUp() {
    setOffTrack(true);

    if (containerRef.scrollTop < scrollRef._ps.containerHeight * 0.3) {
      setIsLoading(true);
      !isLoading && props.onLoadMoreMessage && props.onLoadMoreMessage().then(function () {
        setIsLoading(false);
      });
    }
  };

  var handleYReachStart = function handleYReachStart() {// Placeholder
  };

  var handleYReachEnd = function handleYReachEnd() {
    setOffTrack(false);
    handleTrackReadMessage();
  };

  var handleTrackReadMessage = function handleTrackReadMessage() {
    if (!props.messages || props.messages.length === 0) {
      return;
    }

    var lastMessage = props.messages[props.messages.length - 1];

    if (lastMessage.id !== (lastReadMessage === null || lastReadMessage === void 0 ? void 0 : lastReadMessage.id) && props.group.currentMember.latestReadMessageId !== lastMessage.id) {
      setLastReadMessage(lastMessage);
      props.trackingReadLatestMessage(lastMessage);
    }
  };

  var handleClickDownBtn = function handleClickDownBtn() {
    scrollBottom();
  };

  var handleClickPostContent = function handleClickPostContent(mId) {
    setMessageShowingDetails(mId);
  };

  var handleSync = function handleSync(ps) {
    var change = ps.contentHeight - contentHeight; // keep the position when append scroll content

    if (change > 0) {
      ps.element.scrollTop = ps.lastScrollTop + change;
    }

    setContentHeight(ps.contentHeight);
    ps.update();
  };

  var scrollBottom = function scrollBottom() {
    if (!scrollRef) {
      return;
    }

    containerRef.scrollTop = scrollRef._ps.contentHeight;
  }; // Validate createdAt and sender of 2 message


  var isSameSender = function isSameSender(m1, m2) {
    return m1.userId === m2.userId;
  };

  var isSameDate = function isSameDate(m1, m2) {
    return moment__default['default'](m1.createdAt).diff(m2.createdAt, 'days') === 0;
  };

  var isSameTime = function isSameTime(m1, m2) {
    return moment__default['default'](m2.createdAt).diff(m1.createdAt, 'm') < 5;
  };

  var messages = props.messages || [];
  var members = (_props$group = props.group) === null || _props$group === void 0 ? void 0 : _props$group.members;
  var allUserProfiles = [].concat(_toConsumableArray(members.map(function (mem) {
    return mem.user;
  })), [props.profile]);
  var lastReadMap = {};
  members.forEach(function (mem) {
    lastReadMap[mem.lastReadMessageId] = [].concat(_toConsumableArray(lastReadMap[mem.lastReadMessageId] || []), [mem.userId]);
  });
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: "chat-view",
    children: [offTrack && /*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
      className: "down-btn",
      icon: 'angle-down',
      iconSize: 'lg',
      onlyIcon: true,
      onClick: handleClickDownBtn
    }), /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
      ref: function ref(_ref) {
        return setScrollRef(_ref);
      },
      className: "post-scrollbar",
      containerRef: function containerRef(ref) {
        return setContainerRef(ref);
      },
      onScrollUp: handleScrollUp,
      onYReachEnd: handleYReachEnd,
      onYReachStart: handleYReachStart,
      onSync: handleSync,
      children: /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "post-list",
        children: [/*#__PURE__*/jsxRuntime.jsx("div", {
          className: "post-loading-icon",
          children: isLoading && !props.noMoreMessage && /*#__PURE__*/jsxRuntime.jsx("div", {
            children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
              icon: "spinner",
              className: "fa-pulse",
              type: "solid",
              size: "1rem"
            })
          })
        }), messages === null || messages === void 0 ? void 0 : messages.map(function (m, i) {
          var fromMe = !m.userId || props.profile && props.profile.userId === m.userId;
          var user = allUserProfiles.find(function (user) {
            return user.userId === m.userId;
          });
          var nextMess = i + 1 < messages.length ? messages[i + 1] : null;
          var prevMess = i - 1 >= 0 ? messages[i - 1] : null;
          var showAvatar = !nextMess || !isSameSender(m, nextMess);
          var showSender = !prevMess || !isSameSender(prevMess, m);
          var showDate = !prevMess || !isSameDate(prevMess, m);
          var showTime = !prevMess || !isSameTime(prevMess, m);
          var readMembers = allUserProfiles.filter(function (user) {
            var _lastReadMap$m$id;

            return (_lastReadMap$m$id = lastReadMap[m.id]) === null || _lastReadMap$m$id === void 0 ? void 0 : _lastReadMap$m$id.includes(user.userId);
          });
          m.textContent = m.textContent.replace(/@[\w.]+/g, function (match) {
            var user = allUserProfiles.find(function (user) {
              return user.userName === match.slice(1);
            });
            return user && user.displayName ? "@".concat(user.displayName) : match;
          });
          return /*#__PURE__*/jsxRuntime.jsx(Post, {
            fromMe: fromMe,
            message: m,
            user: user,
            showDetails: messageShowingDetails === (m.id || m.localId),
            showAvatar: !fromMe && showAvatar,
            showSender: !fromMe && showSender,
            showDate: showDate,
            showTime: showTime,
            readMembers: readMembers,
            setRef: function setRef(ref) {
              m.ref = ref;
            },
            onClick: handleClickPostContent
          }, m.id || m.localId);
        })]
      })
    })]
  });
}
ChatView.propTypes = {
  profile: PropTypes__default['default'].object,
  messages: PropTypes__default['default'].array,
  noMoreMessage: PropTypes__default['default'].bool,
  group: PropTypes__default['default'].object,
  latestReadMessageId: PropTypes__default['default'].string,
  setScrollRef: PropTypes__default['default'].func,
  onLoadMoreMessage: PropTypes__default['default'].func,
  trackingReadLatestMessage: PropTypes__default['default'].func
};

function ChatActions(props) {
  var inputRef = React.useRef();

  var _useState = React.useState({}),
      _useState2 = _slicedToArray(_useState, 2),
      draft = _useState2[0],
      setDraft = _useState2[1];

  var textValue = draft[props.groupId] || '';

  var setTextValue = function setTextValue(value) {
    setDraft(_objectSpread2(_objectSpread2({}, draft), {}, _defineProperty$1({}, props.groupId, value)));
  };

  React.useEffect(function () {
    inputRef.current.focus();
  }, []);
  React.useEffect(function () {
    updateInputHeight();
  }, [textValue]);

  var handleKeyPress = function handleKeyPress(e) {
    if (!e.shiftKey && e.key === 'Enter') {
      e.preventDefault();
      handleClickSend();
    }
  };

  React.useEffect(function () {
    updateInputHeight();
  }, [draft[props.groupId]]);

  var handleClickSend = function handleClickSend() {
    if (textValue) {
      props.onSendMessage && props.onSendMessage(textValue);
      setTextValue('');
      inputRef.current.focus();
    }
  };

  var handleOnChange = function handleOnChange(e) {
    setTextValue(e.currentTarget.value);
  };

  var updateInputHeight = function updateInputHeight() {
    if (!inputRef.current) {
      return;
    }

    inputRef.current.style.height = 'auto';
    inputRef.current.style.height = inputRef.current.scrollHeight + 'px'; // Update scroll position

    props.scrollToBottom && props.scrollToBottom();
  };

  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: "chat-actions ".concat(props.className ? props.className : ''),
    style: {
      maxHeight: props.maxTextareaHeight
    },
    children: /*#__PURE__*/jsxRuntime.jsxs(Row2, {
      children: [/*#__PURE__*/jsxRuntime.jsx(Col2, {
        children: /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
          children: /*#__PURE__*/jsxRuntime.jsx("form", {
            className: "post-form",
            children: /*#__PURE__*/jsxRuntime.jsx("textarea", {
              ref: inputRef,
              placeholder: 'Reply...',
              className: "post-textarea",
              id: "post-textarea",
              autoComplete: "off",
              value: textValue,
              rows: "1",
              onChange: handleOnChange,
              onKeyDown: handleKeyPress
            })
          })
        })
      }), /*#__PURE__*/jsxRuntime.jsx(Col2, {
        justify: "center",
        items: "center",
        children: /*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
          icon: 'paper-plane',
          onlyIcon: true,
          onClick: handleClickSend
        })
      })]
    })
  });
}
ChatActions.propTypes = {
  className: PropTypes__default['default'].string,
  onSendMessage: PropTypes__default['default'].func,
  maxTextareaHeight: PropTypes__default['default'].string,
  scrollToBottom: PropTypes__default['default'].func,
  groupId: PropTypes__default['default'].string
};
ChatActions.defaultProps = {
  maxTextareaHeight: '10rem'
};

var ChatBoxComponent = function ChatBoxComponent(props) {
  var _group$currentMember, _group$currentMember$, _group$currentMember2, _group$currentMember3, _group$currentMember4, _group$currentMember5, _group$currentMember6;

  var _useState = React.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      scrollRef = _useState2[0],
      setScrollRef = _useState2[1];

  var group = props.group || {};

  function handleSendMessage(content) {
    props.onSendMessage && props.onSendMessage(content);
  }

  var scrollToBottom = function scrollToBottom() {
    // Update scroll position
    if (scrollRef) {
      scrollRef._container.scrollTop = scrollRef._ps.contentHeight;
    }
  };

  var isMuted = (_group$currentMember = group.currentMember) === null || _group$currentMember === void 0 ? void 0 : (_group$currentMember$ = _group$currentMember.config) === null || _group$currentMember$ === void 0 ? void 0 : _group$currentMember$.notification;
  var panelHeaderActions = [{
    icon: 'plus',
    onClick: props.onAddMember,
    disabled: ((_group$currentMember2 = group.currentMember) === null || _group$currentMember2 === void 0 ? void 0 : _group$currentMember2.roleName) !== ChatRoles.Admin || ((_group$currentMember3 = group.currentMember) === null || _group$currentMember3 === void 0 ? void 0 : _group$currentMember3.kickedAt)
  }, {
    icon: 'cog',
    onClick: props.onSetting,
    disabled: (_group$currentMember4 = group.currentMember) === null || _group$currentMember4 === void 0 ? void 0 : _group$currentMember4.kickedAt
  }, {
    icon: isMuted ? 'bell-slash' : 'bell',
    onClick: props.onMute,
    disabled: (_group$currentMember5 = group.currentMember) === null || _group$currentMember5 === void 0 ? void 0 : _group$currentMember5.kickedAt
  }, {
    icon: 'times',
    onClick: props.onClose
  }];
  var isKickedAt = (_group$currentMember6 = group.currentMember) === null || _group$currentMember6 === void 0 ? void 0 : _group$currentMember6.kickedAt;
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: "chat-box",
    style: {
      width: "".concat(props.width)
    },
    children: [/*#__PURE__*/jsxRuntime.jsx(PanelHeader, {
      actions: panelHeaderActions,
      children: /*#__PURE__*/jsxRuntime.jsx(ChatBoxHeader, {
        groupInfo: group.info
      })
    }), /*#__PURE__*/jsxRuntime.jsxs(PanelBody2, {
      children: [/*#__PURE__*/jsxRuntime.jsx(ChatView, {
        profile: props.profile,
        group: group,
        messages: props.messages,
        latestReadMessageId: group.lastReadMessage,
        noMoreMessage: props.noMoreMessage,
        setScrollRef: setScrollRef,
        trackingReadLatestMessage: props.trackingReadLatestMessage,
        onLoadMoreMessage: props.onLoadMoreMessage
      }), !isKickedAt && /*#__PURE__*/jsxRuntime.jsx(ChatActions, {
        scrollToBottom: scrollToBottom,
        groupId: group.info.id,
        onSendMessage: handleSendMessage
      })]
    })]
  });
};
ChatBoxComponent.propTypes = {
  profile: PropTypes__default['default'].object,
  group: PropTypes__default['default'].object,
  messages: PropTypes__default['default'].array,
  noMoreMessage: PropTypes__default['default'].bool,
  onSendMessage: PropTypes__default['default'].func,
  onClickUser: PropTypes__default['default'].func,
  onClose: PropTypes__default['default'].func,
  onAddMember: PropTypes__default['default'].func,
  onLoadMoreMessage: PropTypes__default['default'].func,
  onSetting: PropTypes__default['default'].func,
  onMute: PropTypes__default['default'].func,
  trackingReadLatestMessage: PropTypes__default['default'].func,
  draft: PropTypes__default['default'].string,
  setDraft: PropTypes__default['default'].func,
  width: PropTypes__default['default'].string
};

function GroupAvatar(props) {
  var members = props.members || [];
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: "group-avatar",
    children: members.map(function (mem, i) {
      var _mem$user;

      if (i >= 4) {
        return;
      }

      return /*#__PURE__*/jsxRuntime.jsx(UserAvatar, {
        src: mem.user.avatar,
        lastActiveAt: (_mem$user = mem.user) === null || _mem$user === void 0 ? void 0 : _mem$user.lastActiveAt,
        showOnlineStatus: true
      }, i);
    })
  });
}
GroupAvatar.propTypes = {
  members: PropTypes__default['default'].array,
  lastActiveAt: PropTypes__default['default'].string
};

var FeatureItem = /*#__PURE__*/function (_Component) {
  _inherits(FeatureItem, _Component);

  var _super = _createSuper(FeatureItem);

  function FeatureItem() {
    var _this;

    _classCallCheck(this, FeatureItem);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "handleClick", function (e) {
      _this.props.onClick(_this.props, e);
    });

    return _this;
  }

  _createClass(FeatureItem, [{
    key: "render",
    value: function render() {
      var badge = this.props.badgeCount === 0 ? null : this.props.badgeCount;
      return /*#__PURE__*/jsxRuntime.jsx("button", {
        className: "feature-item ".concat(this.props.active ? 'active' : '', " ").concat(this.props.className),
        "badge-count": badge,
        title: this.props.tooltip,
        onClick: this.handleClick,
        children: this.props.content || /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          icon: this.props.icon,
          size: '1.25rem'
        })
      });
    }
  }]);

  return FeatureItem;
}(React.Component);
FeatureItem.propTypes = {
  id: PropTypes__default['default'].string,
  className: PropTypes__default['default'].string,
  icon: PropTypes__default['default'].string.isRequired,
  content: PropTypes__default['default'].node,
  active: PropTypes__default['default'].bool,
  badgeCount: PropTypes__default['default'].number,
  tooltip: PropTypes__default['default'].string,
  onClick: PropTypes__default['default'].func
};
FeatureItem.defaultProps = {
  id: '',
  className: '',
  badgeCount: null,
  active: false,
  icon: '',
  onClick: function onClick() {}
};

function ChatListItem(props) {
  var _members$, _members$0$user;

  var group = props.group || {};
  var members = props.group.members;
  var currentMember = group.currentMember || {};
  var groupItemRef = React.useRef();

  var content = /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: members.length > 0 && members.length < 2 ? /*#__PURE__*/jsxRuntime.jsx(UserAvatar, {
      src: (_members$ = members[0]) === null || _members$ === void 0 ? void 0 : _members$.user.avatar,
      lastActiveAt: (_members$0$user = members[0].user) === null || _members$0$user === void 0 ? void 0 : _members$0$user.lastActiveAt,
      showOnlineStatus: true
    }) : /*#__PURE__*/jsxRuntime.jsx(GroupAvatar, {
      members: members
    })
  });

  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: /*#__PURE__*/jsxRuntime.jsx("div", {
      ref: groupItemRef,
      className: "group-item",
      onMouseEnter: function onMouseEnter() {
        return props.setShowTooltip && props.setShowTooltip(groupItemRef, group.info.groupName);
      },
      onMouseLeave: function onMouseLeave() {
        return props.setShowTooltip && props.setShowTooltip(null);
      },
      children: /*#__PURE__*/jsxRuntime.jsx(FeatureItem, {
        badgeCount: currentMember === null || currentMember === void 0 ? void 0 : currentMember.unreadCount,
        content: content,
        active: props.active
      })
    })
  });
}
ChatListItem.propTypes = {
  group: PropTypes__default['default'].object,
  setShowTooltip: PropTypes__default['default'].func,
  active: PropTypes__default['default'].bool
};

function ChatListComponent(props) {
  var _props$groups;

  var _useState = React.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      tooltip = _useState2[0],
      setTooltip = _useState2[1];

  var _useState3 = React.useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      offsetTop = _useState4[0],
      setOffsetTop = _useState4[1];

  var groupListRef = React.useRef();
  var psRef = React.useRef();

  var setShowTooltip = function setShowTooltip(ref, value) {
    var _ref$current, _psRef$current, _psRef$current$_ps;

    setTooltip(value);
    setOffsetTop((ref === null || ref === void 0 ? void 0 : (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.offsetTop) + 55 - ((_psRef$current = psRef.current) === null || _psRef$current === void 0 ? void 0 : (_psRef$current$_ps = _psRef$current._ps) === null || _psRef$current$_ps === void 0 ? void 0 : _psRef$current$_ps.scrollbarYTop));
  };

  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: /*#__PURE__*/jsxRuntime.jsxs("div", {
      ref: groupListRef,
      className: "group-list",
      children: [tooltip && offsetTop && /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'tooltip',
        style: {
          top: offsetTop
        },
        children: tooltip
      }), /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "group-add-button",
        onClick: props.onAddGroup,
        children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          size: '1.5rem',
          icon: 'plus-circle'
        })
      }), /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
        ref: psRef,
        scrollX: false,
        children: /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "group-scroll",
          children: (_props$groups = props.groups) === null || _props$groups === void 0 ? void 0 : _props$groups.map(function (chat) {
            return /*#__PURE__*/jsxRuntime.jsx("div", {
              onClick: function onClick() {
                return props.onClickItem && props.onClickItem(chat.info.id);
              },
              children: /*#__PURE__*/jsxRuntime.jsx(ChatListItem, {
                group: chat,
                setShowTooltip: setShowTooltip,
                active: chat.info.id === props.displayingGroupId
              })
            }, chat.info.id);
          })
        })
      })]
    })
  });
}
ChatListComponent.propTypes = {
  groups: PropTypes__default['default'].array,
  onClickItem: PropTypes__default['default'].func,
  onAddGroup: PropTypes__default['default'].func,
  displayingGroupId: PropTypes__default['default'].string
};
ChatListComponent.defaultProps = {
  groups: []
};

var _excluded$p = ["customOnChange", "placeholder", "step", "width", "height", "className", "border", "onChange", "errorText", "type", "checked", "id", "style"];
var Input = /*#__PURE__*/React.forwardRef(function (props, _ref) {
  var customOnChange = props.customOnChange,
      placeholder = props.placeholder,
      step = props.step,
      width = props.width,
      height = props.height,
      className = props.className,
      border = props.border,
      onChange = props.onChange,
      errorText = props.errorText,
      type = props.type,
      checked = props.checked,
      id = props.id,
      style = props.style,
      inputProps = _objectWithoutProperties(props, _excluded$p);

  var inputRef = React.useRef(null);

  var _useI18n = useI18n(),
      t = _useI18n.t;

  var _useState = React.useState(true),
      _useState2 = _slicedToArray(_useState, 2),
      hidden = _useState2[0],
      setHidden = _useState2[1];

  var handleChange = function handleChange(event) {
    customOnChange && customOnChange(event);
    !customOnChange && onChange && (type === 'checkbox' || type === 'radio' ? onChange(event) : onChange(event.target.value));
  };

  var stepUp = function stepUp() {
    if (!inputRef.current) {
      return;
    }

    inputRef.current.stepUp();
    inputRef.current.focus();
    props.onChange && props.onChange(inputRef.current.value);
  };

  var stepDown = function stepDown() {
    if (!inputRef.current) {
      return;
    }

    inputRef.current.stepDown();
    inputRef.current.focus();
    props.onChange && props.onChange(inputRef.current.value);
  };

  var inputClasses = clsx__default['default'](className, {
    'slider': props.type === 'range',
    'input-password': props.type === 'password',
    'input-number': props.type === 'number'
  });
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx("input", _objectSpread2(_objectSpread2({
      ref: function ref(e) {
        !!_ref && (isCallBackRef$4(_ref) ? _ref(e) : _ref.current = e);
        inputRef.current = e;
      }
    }, inputProps), {}, {
      id: id,
      className: inputClasses,
      type: type === 'password' ? hidden ? 'password' : 'text' : type,
      placeholder: t(placeholder),
      step: type === 'date' ? undefined : step,
      style: _objectSpread2(_objectSpread2({}, style), {}, {
        width: width,
        border: border,
        height: height
      }),
      checked: (type === 'checkbox' || type === 'radio') && checked,
      "data-autofocus": true,
      onChange: handleChange
    })), errorText && (typeof errorText === 'string' ? /*#__PURE__*/jsxRuntime.jsx(Sub1, {
      color: 'danger',
      children: errorText
    }) : errorText.map(function (text, index) {
      return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [/*#__PURE__*/jsxRuntime.jsx(Sub1, {
          color: 'danger',
          children: text
        }, "error-".concat(index)), /*#__PURE__*/jsxRuntime.jsx("br", {})]
      });
    })), type === 'password' && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "input-password-icon",
      children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
        icon: hidden ? 'eye-slash' : 'eye',
        type: "light",
        size: '1rem',
        onClick: function onClick() {
          return setHidden(function (hidden) {
            return !hidden;
          });
        }
      })
    }), type === 'number' && !props.disabled && !props.readOnly && /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: 'step-control',
      children: [/*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
        icon: 'angle-up',
        type: 'light',
        size: '1rem',
        onClick: stepUp
      }), /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
        icon: 'angle-down',
        type: 'light',
        size: '1rem',
        onClick: stepDown
      })]
    })]
  });
});
Input.displayName = 'Input';

var _excluded$o = ["className", "label", "checked", "onChange", "disabled", "displayAs", "indeterminate", "id", "checkBoxSize"];
var CheckBox = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _clsx;

  var className = props.className,
      label = props.label,
      checked = props.checked,
      onChange = props.onChange,
      disabled = props.disabled,
      _props$displayAs = props.displayAs,
      displayAs = _props$displayAs === void 0 ? 'checkbox' : _props$displayAs,
      _props$indeterminate = props.indeterminate,
      indeterminate = _props$indeterminate === void 0 ? false : _props$indeterminate,
      id = props.id,
      _props$checkBoxSize = props.checkBoxSize,
      checkBoxSize = _props$checkBoxSize === void 0 ? 'md' : _props$checkBoxSize,
      checkboxProps = _objectWithoutProperties(props, _excluded$o);

  var handleChange = function handleChange(e) {
    e.stopPropagation();
    !disabled && onChange && onChange(!checked);
  };

  var uniqueId = createUniqueId();
  var wrapperClassName = clsx__default['default'](className, 'checkbox-form', disabled && 'disabled');
  var checkBoxClassName = clsx__default['default']((_clsx = {}, _defineProperty$1(_clsx, 'checkbox-input', displayAs === 'checkbox'), _defineProperty$1(_clsx, 'radio-input', displayAs !== 'checkbox'), _defineProperty$1(_clsx, 'checked', checked), _defineProperty$1(_clsx, 'disabled', disabled), _defineProperty$1(_clsx, 'indeterminate', indeterminate && displayAs === 'checkbox'), _defineProperty$1(_clsx, "checkbox--icon-".concat(checkBoxSize), checkBoxSize), _clsx));
  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: /*#__PURE__*/jsxRuntime.jsx("div", {
      className: wrapperClassName,
      children: /*#__PURE__*/jsxRuntime.jsxs("label", {
        className: "checkbox-item",
        htmlFor: id ? id : "checkbox-".concat(uniqueId),
        onClick: function onClick(e) {
          return e.stopPropagation();
        },
        children: [/*#__PURE__*/jsxRuntime.jsx(Input, _objectSpread2({
          ref: ref,
          id: id ? id : "checkbox-".concat(uniqueId),
          type: displayAs === 'checkbox' ? 'checkbox' : 'radio',
          disabled: disabled,
          checked: checked,
          onChange: handleChange
        }, checkboxProps)), /*#__PURE__*/jsxRuntime.jsx("span", {
          className: checkBoxClassName
        }), /*#__PURE__*/jsxRuntime.jsx("span", {
          className: "checkbox-label",
          children: /*#__PURE__*/jsxRuntime.jsx(T, {
            children: label
          })
        })]
      })
    })
  });
});
CheckBox.displayName = 'CheckBox';

function UserListItem(props) {
  var user = props.user;
  var info = user.info,
      actions = user.actions;

  var handleAction = function handleAction(e, action, user) {
    e.stopPropagation();
    action.onClick && action.onClick(user.userId);
  };

  return /*#__PURE__*/jsxRuntime.jsxs(Row2, {
    className: "user-list-item",
    justify: "between",
    items: "center",
    children: [/*#__PURE__*/jsxRuntime.jsx(Col2, {
      component: "a",
      tabIndex: 0,
      onClick: function onClick(_) {
        return props.onClick && props.onClick(user);
      },
      children: /*#__PURE__*/jsxRuntime.jsxs(Row2, {
        children: [!props.hideCheckbox && /*#__PURE__*/jsxRuntime.jsx(CheckBox, {
          checked: props.value
        }), /*#__PURE__*/jsxRuntime.jsx(UserAvatar, {
          src: user.avatar,
          lastActiveAt: user.lastActiveAt
        }), /*#__PURE__*/jsxRuntime.jsxs(Col2, {
          children: [/*#__PURE__*/jsxRuntime.jsx("div", {
            className: "user-name",
            children: user.displayName
          }), info && /*#__PURE__*/jsxRuntime.jsx("span", {
            className: "info",
            children: info
          })]
        })]
      })
    }), actions && /*#__PURE__*/jsxRuntime.jsx(Col2, {
      items: "end",
      className: "actions",
      children: /*#__PURE__*/jsxRuntime.jsx(Row2, {
        children: actions.map(function (action, index) {
          if (!action.disabled) {
            return /*#__PURE__*/jsxRuntime.jsx(Col2, {
              className: "item",
              justify: "center",
              children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                size: "1rem",
                icon: action.icon,
                type: "solid",
                onClick: function onClick(e) {
                  return handleAction(e, action, user);
                }
              })
            }, index);
          }
        })
      })
    })]
  });
}
UserListItem.propTypes = {
  hideCheckbox: PropTypes__default['default'].bool,
  user: PropTypes__default['default'].object,
  value: PropTypes__default['default'].bool,
  info: PropTypes__default['default'].any
};

function UserListComponent(props) {
  var _props$userList;

  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: "user-list",
    children: (_props$userList = props.userList) === null || _props$userList === void 0 ? void 0 : _props$userList.map(function (user) {
      return /*#__PURE__*/jsxRuntime.jsx(UserListItem, {
        user: user,
        value: props.userSelectedList.includes(user.userId),
        hideCheckbox: props.hideCheckbox,
        onClick: props.onClickUser
      }, user.userId);
    })
  });
}
UserListComponent.propTypes = {
  userList: PropTypes__default['default'].array,
  userSelectedList: PropTypes__default['default'].array,
  onClickUser: PropTypes__default['default'].func,
  getAction: PropTypes__default['default'].func,
  getInfo: PropTypes__default['default'].func,
  hideCheckbox: PropTypes__default['default'].bool
};
UserListComponent.defaultProps = {
  userList: [],
  userSelectedList: []
};

function GroupSettingPopup(props) {
  var _group$members, _group$currentMember;

  var _useModal = useModal(),
      confirm = _useModal.confirm;

  var group = props.group || {};
  var members = ((_group$members = group.members) === null || _group$members === void 0 ? void 0 : _group$members.filter(function (mem) {
    return !mem.kickedAt;
  })) || [];
  var currentMember = group.currentMember || {};
  var profile = props.profile || {};

  var handleKickMember = function handleKickMember(userId) {
    confirm({
      title: 'Xác nhận',
      message: /*#__PURE__*/jsxRuntime.jsx("div", {
        style: {
          padding: '1rem'
        },
        children: "X\xE1c nh\u1EADn x\xF3a th\xE0nh vi\xEAn kh\u1ECFi nh\xF3m?"
      }),
      width: '400px',
      onOk: function onOk() {
        var _members$find;

        props.onLeaveGroup && props.onLeaveGroup({
          memberId: (_members$find = members.find(function (mem) {
            return mem.userId === userId;
          })) === null || _members$find === void 0 ? void 0 : _members$find.id,
          isKick: true
        });
      }
    });
  };

  var handleLeaveGroup = function handleLeaveGroup() {
    confirm({
      title: 'Xác nhận',
      message: /*#__PURE__*/jsxRuntime.jsx("div", {
        style: {
          padding: '1rem'
        },
        children: "X\xE1c nh\u1EADn r\u1EDDi kh\u1ECFi nh\xF3m?"
      }),
      width: '400px',
      onOk: function onOk() {
        props.onLeaveGroup && props.onLeaveGroup({
          memberId: group.currentMember.id
        });
        props.onClose && props.onClose();
      }
    });
  };

  var isAdmin = ((_group$currentMember = group.currentMember) === null || _group$currentMember === void 0 ? void 0 : _group$currentMember.roleName) === ChatRoles.Admin;

  var getActions = function getActions(userId) {
    return [{
      icon: 'user-times',
      onClick: handleKickMember,
      disabled: !isAdmin || userId === profile.userId
    }];
  };

  var getInfo = function getInfo(userId) {
    var roleDisplay = '';
    var member = [].concat(_toConsumableArray(members), [currentMember]).find(function (mem) {
      return mem.userId === userId;
    }) || {};

    if ((member === null || member === void 0 ? void 0 : member.roleName) === ChatRoles.Admin) {
      roleDisplay = 'Administrator';
    } else if ((member === null || member === void 0 ? void 0 : member.roleName) === ChatRoles.Member) {
      roleDisplay = 'Member';
    }

    return roleDisplay;
  };

  var userList = [profile].concat(_toConsumableArray(members.map(function (mem) {
    return mem.user;
  }))).map(function (user) {
    return _objectSpread2(_objectSpread2({}, user), {}, {
      info: getInfo(user.userId),
      actions: getActions(user.userId)
    });
  });
  profile.name = profile.displayName || '';
  return /*#__PURE__*/jsxRuntime.jsxs(Popup, {
    title: 'Tùy chỉnh',
    width: '400px',
    height: '600px',
    onClose: props.onClose,
    children: [/*#__PURE__*/jsxRuntime.jsx(UserListComponent, {
      userList: userList,
      hideCheckbox: true
    }), /*#__PURE__*/jsxRuntime.jsx(PopupFooter, {
      children: /*#__PURE__*/jsxRuntime.jsx(Button, {
        color: 'primary',
        icon: 'sign-out-alt',
        text: 'Rời nhóm',
        onClick: handleLeaveGroup
      })
    })]
  });
}
GroupSettingPopup.propTypes = {
  profile: PropTypes__default['default'].object,
  group: PropTypes__default['default'].object,
  onClose: PropTypes__default['default'].func,
  onLeaveGroup: PropTypes__default['default'].func
};

/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/

var classnames = createCommonjsModule(function (module) {
/* global define */

(function () {

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString === Object.prototype.toString) {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				} else {
					classes.push(arg.toString());
				}
			}
		}

		return classes.join(' ');
	}

	if (module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else {
		window.classNames = classNames;
	}
}());
});

var CheckBoxGroup = function CheckBoxGroup(props) {
  var label = props.label,
      className = props.className,
      children = props.children,
      isRequired = props.isRequired,
      isDisabled = props.isDisabled,
      _props$orientation = props.orientation,
      orientation = _props$orientation === void 0 ? 'horizontal' : _props$orientation,
      onChange = props.onChange;
  var classes = classnames('checkbox-group__form', className ? className : null, {
    'checkbox-group--vertical': orientation === 'vertical'
  });
  return /*#__PURE__*/jsxRuntime.jsxs("fieldset", {
    className: classes,
    onChange: onChange,
    children: [label && /*#__PURE__*/jsxRuntime.jsxs("legend", {
      className: "checkbox-group__label",
      children: [label, "\xA0", isRequired ? '(required)' : '(optional)']
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "checkbox-group__fields",
      children: React__default['default'].Children.map(children, function (child, i) {
        if ( /*#__PURE__*/React__default['default'].isValidElement(child)) {
          return /*#__PURE__*/React__default['default'].cloneElement(child, {
            disabled: isDisabled,
            index: i
          });
        }

        return undefined;
      })
    })]
  });
};

var Radio = function Radio(props) {
  return /*#__PURE__*/jsxRuntime.jsx(CheckBox, _objectSpread2(_objectSpread2({}, props), {}, {
    displayAs: 'radio'
  }));
};

var ColorPicker = /*#__PURE__*/function (_Component) {
  _inherits(ColorPicker, _Component);

  var _super = _createSuper(ColorPicker);

  function ColorPicker() {
    var _this;

    _classCallCheck(this, ColorPicker);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      displayColorPicker: false
    });

    _defineProperty$1(_assertThisInitialized(_this), "controlRef", /*#__PURE__*/React__default['default'].createRef(null));

    _defineProperty$1(_assertThisInitialized(_this), "handleClick", function () {
      _this.setState({
        displayColorPicker: !_this.state.displayColorPicker
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleClose", function () {
      _this.setState({
        displayColorPicker: false
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleChange", function (color) {
      if (typeof _this.props.onChange === 'function') {
        _this.props.onChange(color[_this.props.changeType]);
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleClosePopup", function () {
      _this.setState({
        displayColorPicker: false
      });
    });

    return _this;
  }

  _createClass(ColorPicker, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: 'custom-color-picker',
        children: [/*#__PURE__*/jsxRuntime.jsx("div", {
          ref: this.controlRef,
          className: 'color-container',
          onClick: this.handleClick,
          children: /*#__PURE__*/jsxRuntime.jsx("div", {
            className: 'color-content',
            style: {
              backgroundColor: this.props.value
            }
          })
        }), this.state.displayColorPicker && /*#__PURE__*/jsxRuntime.jsx(AnchorOverlay, {
          anchorEl: this.controlRef,
          onBackgroundClick: this.handleClosePopup,
          children: /*#__PURE__*/jsxRuntime.jsxs("div", {
            className: 'color-popup',
            children: [/*#__PURE__*/jsxRuntime.jsx("div", {
              className: 'color-popup-cover',
              onClick: this.handleClose
            }), /*#__PURE__*/jsxRuntime.jsx(reactColor.SketchPicker, {
              color: this.props.value,
              onChange: this.handleChange
            })]
          })
        })]
      });
    }
  }]);

  return ColorPicker;
}(React.Component);
ColorPicker.propTypes = {
  className: PropTypes__default['default'].string,
  value: PropTypes__default['default'].string,
  changeType: PropTypes__default['default'].oneOf(['hex', 'hsl', 'hsv', 'rgb']),
  onChange: PropTypes__default['default'].func
};
ColorPicker.defaultProps = {
  className: '',
  value: 'black',
  changeType: 'hex',
  onChange: function onChange() {}
};

var NotFoundPage = function NotFoundPage() {
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: 'not-found-page',
    children: [/*#__PURE__*/jsxRuntime.jsxs(Col2, {
      grow: 0,
      items: "center",
      item: true,
      children: [/*#__PURE__*/jsxRuntime.jsx(HD1, {
        style: {
          marginBottom: 0
        },
        children: "404"
      }), /*#__PURE__*/jsxRuntime.jsx(Sub1, {
        children: "Kh\xF4ng t\xECm th\u1EA5y trang"
      })]
    }), /*#__PURE__*/jsxRuntime.jsx(Box, {
      sx: {
        mt: 10
      },
      children: /*#__PURE__*/jsxRuntime.jsx(Button, {
        text: 'Trang chủ',
        color: 'primary',
        size: "lg",
        onClick: function onClick() {
          window.location.href = '/';
        }
      })
    })]
  });
};

var Collapse = function Collapse(props) {
  var _useState = React.useState(props.expanded),
      _useState2 = _slicedToArray(_useState, 2),
      expanded = _useState2[0],
      setExpanded = _useState2[1];

  var toggle = function toggle() {
    setExpanded(!expanded);
  };

  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: "collapse-container ".concat(props.disable ? 'disable' : ''),
    children: [/*#__PURE__*/jsxRuntime.jsxs(Row2, {
      className: 'collapse-header',
      justify: "start",
      children: [/*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'collapse-header-leading-container',
        children: props.leading
      }), /*#__PURE__*/jsxRuntime.jsxs(Row2, {
        justify: "between",
        children: [/*#__PURE__*/jsxRuntime.jsx("span", {
          className: 'collapse-header-title',
          onClick: toggle,
          children: /*#__PURE__*/jsxRuntime.jsx(T, {
            children: props.title
          })
        }), /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          className: 'collapse-header-arrow-icon',
          type: "solid",
          icon: expanded ? 'chevron-up' : 'chevron-down',
          size: "1rem",
          color: 'var(--contrast)',
          onClick: toggle
        })]
      })]
    }), expanded && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "collapse-body ".concat(expanded ? 'expanded' : ''),
      children: props.children
    })]
  });
};

var Ratio = function Ratio(props) {
  var width = props.width,
      height = props.height,
      className = props.className,
      children = props.children;
  var ratioVariable = {
    '--height-ratio': "calc(".concat(height, " / ").concat(width, " * 100%)")
  };
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: "ratio ".concat(className || ''),
    style: ratioVariable,
    children: children
  });
};

var ResizableSinglePanel = /*#__PURE__*/React.forwardRef(function (props, _ref) {
  var _props$type = props.type,
      type = _props$type === void 0 ? 'horizontal' : _props$type,
      _props$resizable = props.resizable,
      resizable = _props$resizable === void 0 ? true : _props$resizable,
      _props$defaultSizes = props.defaultSizes,
      defaultSizes = _props$defaultSizes === void 0 ? Array(props.children.length).fill("".concat(100 / props.children.length, "%")) : _props$defaultSizes,
      onResize = props.onResize,
      onResizeEnd = props.onResizeEnd;
  var resizeRef = React.useRef(null);
  var timeoutRef = React.useRef();
  var loadedRef = React.useRef(true);
  var resizeObRef = React.useRef();
  var deltaStart = React.useRef(0);
  var sizes = React.useRef([]);
  var draggingIndex = React.useRef(null);
  var minSizes = React.useRef([]);

  var _useState = React.useState(true),
      _useState2 = _slicedToArray(_useState, 2),
      outsideResize = _useState2[0],
      setOutsideResize = _useState2[1];

  var _useState3 = React.useState([]),
      _useState4 = _slicedToArray(_useState3, 2),
      prevSizes = _useState4[0],
      setPrevSizes = _useState4[1];

  var clientSize = type === 'horizontal' ? 'clientWidth' : 'clientHeight';
  var direction = type === 'horizontal' ? 'clientX' : 'clientY';
  var classType = type === 'horizontal' ? 'resizable-h' : 'resizable-v';
  var minType = type === 'horizontal' ? 'minWidth' : 'minHeight';
  var sizeType = type === 'horizontal' ? 'width' : 'height';
  React.useLayoutEffect(function () {
    // Check previous and current minSizes because of multi rendering
    if (resizeRef.current && JSON.stringify(minSizes.current) !== JSON.stringify(props.minSizes)) {
      var newMinSizes = [];
      var childrenList = Array.from(resizeRef.current.children);
      childrenList.map(function (child, index) {
        var _props$minSizes;

        if (index % 2 !== 0) {
          return;
        }

        var style = window.getComputedStyle(child);
        var padding = 0;

        if (sizeType === 'width') {
          var left = style.paddingLeft.includes('rem') ? convertRemToPx(style.paddingLeft) : convertStringToNumber(style.paddingLeft);
          var right = style.paddingRight.includes('rem') ? convertRemToPx(style.paddingRight) : convertStringToNumber(style.paddingRight);
          padding = left + right;
        }

        if (sizeType === 'height') {
          var top = style.paddingTop.includes('rem') ? convertRemToPx(style.paddingTop) : convertStringToNumber(style.paddingTop);
          var bottom = style.paddingBottom.includes('rem') ? convertRemToPx(style.paddingBottom) : convertStringToNumber(style.paddingBottom);
          padding = top + bottom;
        }

        var minSize = Math.max(((_props$minSizes = props.minSizes) === null || _props$minSizes === void 0 ? void 0 : _props$minSizes[index / 2]) || 0, padding);
        newMinSizes[index / 2] = minSize;
        child.style[minType] = "".concat(minSize, "px");
      });
      minSizes.current = newMinSizes;
    }
  }, [props.minSizes]);
  React.useLayoutEffect(function () {
    if (resizeRef.current) {
      var childrenList = Array.from(resizeRef.current.children);
      var initSizes = [];
      childrenList.map(function (child, index) {
        if (index % 2 === 0) {
          if (defaultSizes.length) {
            var defaultSize = defaultSizes[index / 2];

            if (defaultSize) {
              if (typeof defaultSize === 'number') {
                child.style[sizeType] = "".concat(defaultSize, "px");
              } else if (typeof defaultSize === 'string') {
                child.style[sizeType] = defaultSize;
              }

              child.style.flex = '0 auto';
            } else {
              child.style.flex = '1 auto';
            }
          } else {
            child.style.flex = '1 auto';
          }

          initSizes.push(child[clientSize]);
        }

        return child;
      });
      sizes.current = initSizes;
      setPrevSizes(initSizes);
    }
  }, [resizeRef]);
  React.useLayoutEffect(function () {
    if (!resizeRef.current) {
      return;
    }

    var childrenList = Array.from(resizeRef.current.children);
    var resize = new ResizeObserver(function () {
      resizeObRef.current && clearTimeout(resizeObRef.current);
      resizeObRef.current = setTimeout(function () {
        var _childrenList$resizab;

        var resizableIndex = childrenList.length - 1 - childrenList.slice().reverse().findIndex(function (child, index) {
          return index % 2 === 0 && child[clientSize] >= prevSizes.slice().reverse()[index / 2] && child[clientSize] >= Math.round(+child.style[sizeType].replace(/[^0-9.]/g, ''));
        });

        if (((_childrenList$resizab = childrenList[resizableIndex]) === null || _childrenList$resizab === void 0 ? void 0 : _childrenList$resizab.style.flex) === '1 1 auto') {
          return;
        }

        childrenList.map(function (child, index) {
          if (index % 2 === 0) {
            child.style.flex = index === resizableIndex ? '1 auto' : '0 auto';
          }

          return child;
        });
        var newPrevSizes = sizes.current.map(function (sizes, index) {
          return childrenList[index * 2][clientSize];
        });
        JSON.stringify(newPrevSizes) !== JSON.stringify(prevSizes) && setPrevSizes(newPrevSizes);
      }, 10);

      if (onResize) {
        var newSizes = [];
        childrenList.forEach(function (child, index) {
          return index % 2 === 0 && newSizes.push({
            width: child.clientWidth,
            height: child.clientHeight
          });
        });
        onResize(newSizes);
      }
    });

    try {
      prevSizes.length && outsideResize && sizes.current.length && childrenList.forEach(function (ele, index) {
        return index % 2 === 0 && resize.observe(ele);
      });
    } catch (error) {
      console.log(error);
    }

    return function () {
      return resize.disconnect();
    };
  }, [outsideResize, prevSizes]);

  var resizeChild = function resizeChild() {
    if (resizeRef.current && !loadedRef.current && sizes.current.length) {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      var childrenList = Array.from(resizeRef.current.children);
      timeoutRef.current = setTimeout(function () {
        if (!resizeRef.current) {
          return;
        }

        childrenList.map(function (child, index) {
          if (index % 2 === 0) {
            child.style[sizeType] = "".concat(sizes.current[index / 2], "px");
            child.style.flex = '0 auto';
          }

          return child;
        });
      }, 0);

      if (onResize) {
        var fullSizes = [];
        childrenList.map(function (child, index) {
          return index % 2 === 0 && fullSizes.push({
            width: child.clientWidth,
            height: child.clientHeight
          });
        });
        onResize(fullSizes);
      }

      return;
    }

    if (sizes.current.length) {
      loadedRef.current = false;
    }
  };

  var convertStringToNumber = function convertStringToNumber(value) {
    return +value.replace(/[^0-9.]/g, '');
  };

  var convertRemToPx = function convertRemToPx(value) {
    return convertStringToNumber(value) * parseFloat(getComputedStyle(document.documentElement).fontSize);
  };

  var dragStartHandler = function dragStartHandler(e, index) {
    if (!resizeRef.current || !resizable) {
      return;
    }

    if (_typeof(resizable) === 'object') {
      var data = resizable.find(function (data) {
        return data.index === index;
      });

      if (data && !data.resizable) {
        return;
      }
    }

    var children = Array.from(resizeRef.current.children).filter(function (child, index) {
      return index % 2 === 0;
    });
    children.map(function (child) {
      return child.style.transition = 'unset';
    });
    var newSizes = children.map(function (child) {
      return child[clientSize];
    });
    loadedRef.current = true;
    setOutsideResize(false);
    sizes.current = newSizes;
    deltaStart.current = e[direction] - newSizes[index];
    draggingIndex.current = index;
    window.addEventListener('pointerup', dragEndHandler);
    window.addEventListener('pointermove', dragHandler);
  };

  var dragHandler = function dragHandler(e) {
    var index = draggingIndex.current;

    if (index === null) {
      return;
    }

    e.preventDefault();

    if (e[direction] <= 0) {
      return;
    }

    var newSizes = _toConsumableArray(sizes.current);

    var delta = e[direction] - newSizes[index] - deltaStart.current;

    if (Math.abs(newSizes[index] - (newSizes[index] + delta)) > 1) {
      if (delta < 0) {
        var n = index;

        while (n >= 0) {
          newSizes[n] += delta;
          newSizes[index + 1] -= delta;
          var prevPx = newSizes[n];
          var min = minSizes.current[n] || 0;

          if (prevPx + delta <= min) {
            newSizes[n] = min;
            newSizes[index + 1] += prevPx - min;
            n--;
            continue;
          }

          deltaStart.current = e[direction] - newSizes[index];
          break;
        }
      }

      if (delta > 0) {
        var _n = index;

        while (_n < newSizes.length - 1) {
          newSizes[index] += delta;
          newSizes[_n + 1] -= delta;
          var pxNextStart = newSizes[_n + 1];

          var _min = minSizes.current[_n + 1] || 0;

          if (newSizes[_n + 1] <= _min) {
            newSizes[_n + 1] = _min;
            newSizes[index] += pxNextStart - _min;
            _n++;
            continue;
          }

          break;
        }
      }

      sizes.current = newSizes;
      resizeChild();
    }
  };

  var dragEndHandler = function dragEndHandler() {
    draggingIndex.current = null;
    window.removeEventListener('pointerup', dragEndHandler);
    window.removeEventListener('pointermove', dragHandler);
    setOutsideResize(true);
    setPrevSizes(sizes.current);

    if (!resizeRef.current) {
      return;
    }

    var children = Array.from(resizeRef.current.children).filter(function (child, index) {
      return index % 2 === 0;
    });
    children.forEach(function (child) {
      return child.style.transition = '';
    });

    if (onResizeEnd) {
      var fullSizes = [];
      children.map(function (child) {
        return fullSizes.push({
          width: child.clientWidth,
          height: child.clientHeight
        });
      });
      onResizeEnd(fullSizes);
    }
  };

  var renderChild = function renderChild(reactNode, index) {
    var child = _objectSpread2({}, reactNode);

    child.props = _objectSpread2(_objectSpread2({}, child.props), {}, {
      flex: 0
    });
    return /*#__PURE__*/jsxRuntime.jsxs(React__default['default'].Fragment, {
      children: [child, index < props.children.length - 1 && props.children[index + 1] && /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'draggable',
        onPointerDown: function onPointerDown(event) {
          return dragStartHandler(event, index);
        },
        children: /*#__PURE__*/jsxRuntime.jsx("div", {
          tabIndex: 1,
          className: "line"
        })
      })]
    }, 'resizable-children ' + index);
  };

  return /*#__PURE__*/jsxRuntime.jsx("div", {
    ref: function ref(elm) {
      !!_ref && (isCallBackRef$2(_ref) ? _ref(elm) : _ref.current = elm);
      resizeRef.current = elm;
    },
    className: "".concat(props.className, " resizable-container ").concat(classType),
    children: props.children.map(function (reactNode, index) {
      return renderChild(reactNode, index);
    })
  });
});
ResizableSinglePanel.displayName = 'ResizableSinglePanel';

var isCallBackRef$2 = function isCallBackRef(ref) {
  return !('current' in ref);
};

var ResizableMultiPanel = /*#__PURE__*/React.forwardRef(function (props, _ref) {
  var children = props.children,
      initialSizes = props.initialSizes,
      numOfItemPerLine = props.numOfItemPerLine,
      _props$resizable = props.resizable,
      resizable = _props$resizable === void 0 ? true : _props$resizable;
  var onResize = props.onResize,
      onResizeEnd = props.onResizeEnd;
  var resizeRef = React.useRef(null);
  var dragX = React.useRef([]);
  var dragY = React.useRef([]);
  var start = React.useRef({
    x: 0,
    y: 0
  });
  var draggableDirection = React.useRef(null);
  var dragPosition = React.useRef({
    left: 0,
    top: 0
  });
  var draggingIndex = React.useRef({});
  var prevActiveIndex = React.useRef({
    x: -1,
    y: -1
  });
  var sizes = React.useRef([]);

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      autoReposition = _useState2[0],
      setAutoReposition = _useState2[1];

  var numOfItemPerRow = numOfItemPerLine || (children.length === 1 || children.length === 2 ? children.length : Math.ceil(Math.sqrt(children.length)));
  var virtualGroup = Array(Math.ceil(children.length / numOfItemPerRow)).fill(1);
  React.useLayoutEffect(function () {
    autoReposition && handlePosition();
  });
  React.useLayoutEffect(function () {
    if (!resizeRef.current || dragX.current.length === 0 || dragY.current.length === 0) {
      return;
    }

    var width = resizeRef.current.clientWidth;
    var height = resizeRef.current.clientHeight;
    var ratioX = dragX.current.map(function (el) {
      if (!el) {
        return;
      }

      return getPosition(el, 'top') / height;
    });
    var ratioY = dragY.current.map(function (el) {
      if (!el) {
        return;
      }

      return getPosition(el, 'left') / width;
    });
    var resize = new ResizeObserver(function (entries) {
      var rect = entries[0].contentRect;
      dragX.current.map(function (el, index) {
        var ratio = ratioX[index];

        if (!el || !ratio) {
          return;
        }

        el.style.top = "".concat(rect.height * ratio, "px");
      });
      dragY.current.map(function (el, index) {
        var ratio = ratioY[index];

        if (!el || !ratio) {
          return;
        }

        el.style.left = "".concat(rect.width * ratio, "px");
      });
      handlePosition();
    });
    autoReposition && resize.observe(resizeRef.current);
    return function () {
      return resize.disconnect();
    };
  }, [resizeRef, autoReposition]);
  React.useLayoutEffect(function () {
    if (!resizeRef.current) {
      setAutoReposition(true);
      return;
    }

    var clientWidth = resizeRef.current.clientWidth;
    var clientHeight = resizeRef.current.clientHeight;
    dragX.current.map(function (el, index) {
      if (!el) {
        return;
      }

      el.style.top = "".concat(clientHeight / Math.ceil(children.length / numOfItemPerRow) * (index + 1), "px");
    });
    dragY.current.map(function (el, index) {
      if (!el) {
        return;
      }

      el.style.left = "".concat(clientWidth / numOfItemPerRow * (index + 1), "px");
    });

    if (initialSizes && initialSizes.length) {
      initialSizes.map(function (size, index) {
        if (!size) {
          return;
        }

        var width = size.width,
            height = size.height;
        index = size.index || index;

        if (typeof width === 'number') {
          var yIndex = index % numOfItemPerRow;
          var el = dragY.current[yIndex];
          var prevEl = dragY.current[yIndex - 1];
          var prevLeft = prevEl ? getPosition(prevEl, 'left') : 0;
          handleInitialSize(index, el, width, prevLeft, clientWidth, 'left');
        }

        if (typeof height === 'number') {
          var xIndex = Math.floor(index / numOfItemPerRow);
          var _el = dragX.current[xIndex];
          var _prevEl = dragX.current[xIndex - 1];
          var prevTop = _prevEl ? getPosition(_prevEl, 'top') : 0;
          handleInitialSize(index, _el, height, prevTop, clientHeight, 'top');
        }
      });
    }

    handlePosition();
    setAutoReposition(true);
  }, [dragX, dragY]);

  var handleInitialSize = function handleInitialSize(index, el, initialSize, prevPosition, clientSize, position) {
    if (!el) {
      return;
    }

    if (typeof initialSize === 'string') {
      var sizeByPercent = +initialSize.replace(/[^0-9.]/g, '') / 100 * clientSize;
      el.style[position] = "".concat(prevPosition + sizeByPercent, "px");
      return;
    }

    el.style[position] = "".concat(prevPosition + initialSize, "px");
  };

  var handleDraggingPosition = function handleDraggingPosition(x, y) {
    var _dragX$current$prevAc, _dragY$current$prevAc;

    if (dragX.current.length === 0 && dragY.current.length === 0) {
      return;
    }

    var xIndex = dragX.current.findIndex(function (el) {
      if (!el) {
        return;
      }

      var rect = el.children[0].getBoundingClientRect();
      return y >= rect.top && y <= rect.bottom;
    });
    var yIndex = dragY.current.findIndex(function (el) {
      if (!el) {
        return;
      }

      var rect = el.children[0].getBoundingClientRect();
      return x >= rect.left && x <= rect.right;
    });
    prevActiveIndex.current.x >= 0 && prevActiveIndex.current.x !== xIndex && ((_dragX$current$prevAc = dragX.current[prevActiveIndex.current.x]) === null || _dragX$current$prevAc === void 0 ? void 0 : _dragX$current$prevAc.classList.remove('dragging', 'multi-dragging'));
    prevActiveIndex.current.y >= 0 && prevActiveIndex.current.y !== yIndex && ((_dragY$current$prevAc = dragY.current[prevActiveIndex.current.y]) === null || _dragY$current$prevAc === void 0 ? void 0 : _dragY$current$prevAc.classList.remove('dragging', 'multi-dragging'));

    if (yIndex >= 0 && xIndex >= 0) {
      var _dragX$current$xIndex, _dragY$current$yIndex;

      draggableDirection.current = 'both';
      (_dragX$current$xIndex = dragX.current[xIndex]) === null || _dragX$current$xIndex === void 0 ? void 0 : _dragX$current$xIndex.classList.add('dragging', 'multi-dragging');
      (_dragY$current$yIndex = dragY.current[yIndex]) === null || _dragY$current$yIndex === void 0 ? void 0 : _dragY$current$yIndex.classList.add('dragging', 'multi-dragging');
    } else if (xIndex >= 0) {
      var _dragX$current$xIndex2, _dragX$current$xIndex3, _dragY$current$yIndex2;

      draggableDirection.current = 'x';
      (_dragX$current$xIndex2 = dragX.current[xIndex]) === null || _dragX$current$xIndex2 === void 0 ? void 0 : _dragX$current$xIndex2.classList.add('dragging');
      (_dragX$current$xIndex3 = dragX.current[xIndex]) === null || _dragX$current$xIndex3 === void 0 ? void 0 : _dragX$current$xIndex3.classList.remove('multi-dragging');
      (_dragY$current$yIndex2 = dragY.current[yIndex]) === null || _dragY$current$yIndex2 === void 0 ? void 0 : _dragY$current$yIndex2.classList.remove('dragging', 'multi-dragging');
    } else if (yIndex >= 0) {
      var _dragX$current$xIndex4, _dragY$current$yIndex3, _dragY$current$yIndex4;

      draggableDirection.current = 'y';
      (_dragX$current$xIndex4 = dragX.current[xIndex]) === null || _dragX$current$xIndex4 === void 0 ? void 0 : _dragX$current$xIndex4.classList.remove('dragging', ' multi-dragging');
      (_dragY$current$yIndex3 = dragY.current[yIndex]) === null || _dragY$current$yIndex3 === void 0 ? void 0 : _dragY$current$yIndex3.classList.remove('multi-dragging');
      (_dragY$current$yIndex4 = dragY.current[yIndex]) === null || _dragY$current$yIndex4 === void 0 ? void 0 : _dragY$current$yIndex4.classList.add('dragging');
    } else {
      var _dragX$current$find, _dragY$current$find;

      draggableDirection.current = null;
      (_dragX$current$find = dragX.current.find(function (xEl) {
        var _xEl$classList$value;

        return xEl === null || xEl === void 0 ? void 0 : (_xEl$classList$value = xEl.classList.value) === null || _xEl$classList$value === void 0 ? void 0 : _xEl$classList$value.includes('dragging');
      })) === null || _dragX$current$find === void 0 ? void 0 : _dragX$current$find.classList.remove('dragging', 'multi-dragging');
      (_dragY$current$find = dragY.current.find(function (yEl) {
        var _yEl$classList$value;

        return yEl === null || yEl === void 0 ? void 0 : (_yEl$classList$value = yEl.classList.value) === null || _yEl$classList$value === void 0 ? void 0 : _yEl$classList$value.includes('dragging');
      })) === null || _dragY$current$find === void 0 ? void 0 : _dragY$current$find.classList.remove('dragging', 'multi-dragging');
    }

    prevActiveIndex.current = {
      x: xIndex,
      y: yIndex
    };
    return {
      x: xIndex,
      y: yIndex
    };
  };

  var handleStart = function handleStart(event) {
    var indexes = handleDraggingPosition(event.clientX, event.clientY);

    if (!indexes || !resizable) {
      return;
    }

    var xEl = dragX.current[indexes.x];
    var yEl = dragY.current[indexes.y];

    if (!xEl && !yEl) {
      return;
    }

    draggingIndex.current = {
      x: indexes.x,
      y: indexes.y
    };
    start.current = {
      x: event.clientY,
      y: event.clientX
    };
    dragPosition.current = {
      left: yEl ? getPosition(yEl, 'left') : 0,
      top: xEl ? getPosition(xEl, 'top') : 0
    };
    setAutoReposition(false);
    window.addEventListener('pointerup', handleEnd);
    window.addEventListener('pointermove', handleMove);
  };

  var handleMove = function handleMove(event) {
    var xIndex = draggingIndex.current.x;
    var yIndex = draggingIndex.current.y;

    if (typeof xIndex === 'undefined' || typeof yIndex === 'undefined' || !resizable) {
      return;
    }

    var hasX = typeof xIndex === 'number' && xIndex >= 0;
    var hasY = typeof yIndex === 'number' && yIndex >= 0;
    var xEl = hasX && dragX.current[xIndex];
    var yEl = hasY && dragY.current[yIndex];
    var direction = draggableDirection.current;

    if (!resizeRef.current || !direction) {
      return;
    }

    var isResizableX = true;
    var isResizableY = true;
    _typeof(resizable) === 'object' && resizable.map(function (data) {
      if ((data.direction === 'x' || data.direction === 'both') && data.index === xIndex && !data.resizable) {
        isResizableX = false;
      }

      if ((data.direction === 'y' || data.direction === 'both') && data.index === yIndex && !data.resizable) {
        isResizableY = false;
      }
    });

    if ((direction === 'x' || direction === 'both') && xEl && isResizableX) {
      var deltaX = event.clientY - start.current.x;
      var initTop = dragPosition.current.top;
      var prevXEl = dragX.current[xIndex - 1];
      var nextXEl = dragX.current[xIndex + 1];
      var prevTop = prevXEl ? getPosition(prevXEl, 'top') : 0;
      var nextTop = nextXEl ? getPosition(nextXEl, 'top') : resizeRef.current.clientHeight;
      var top = initTop + deltaX;

      if (top < prevTop) {
        top = prevTop;
      } else if (top > nextTop) {
        top = nextTop;
      } else if (top === prevTop || top === nextTop) {
        return;
      }

      xEl.style.top = "".concat(top, "px");
    }

    if ((direction === 'y' || direction === 'both') && yEl && isResizableY) {
      var deltaY = event.clientX - start.current.y;
      var initLeft = dragPosition.current.left;
      var prevYEl = dragY.current[yIndex - 1];
      var nextYEl = dragY.current[yIndex + 1];
      var prevLeft = prevYEl ? +prevYEl.style.left.replace(/[^0-9.]/g, '') : 0;
      var nextLeft = nextYEl ? +nextYEl.style.left.replace(/[^0-9.]/g, '') : resizeRef.current.clientWidth;
      var left = initLeft + deltaY;

      if (left < prevLeft) {
        left = prevLeft;
      } else if (left > nextLeft) {
        left = nextLeft;
      } else if (left === prevLeft || left === nextLeft) {
        return;
      }

      yEl.style.left = "".concat(left, "px");
    }

    handlePosition(onResize);
  };

  var handleEnd = function handleEnd(event) {
    draggingIndex.current = {};
    setAutoReposition(true);
    onResizeEnd && onResizeEnd(sizes.current);
    window.removeEventListener('pointerup', handleEnd);
    window.removeEventListener('pointermove', handleMove);
  };

  var getPosition = function getPosition(el, position) {
    return +el.style[position].replace(/[^0-9.]/g, '');
  };

  var handlePosition = function handlePosition(callBack) {
    if (!resizeRef.current) {
      return;
    }

    var childrenList = Array.from(resizeRef.current.children);
    var clientWidth = resizeRef.current.clientWidth;
    var clientHeight = resizeRef.current.clientHeight;
    var curSizes = [];
    virtualGroup.map(function (v, rowIndex) {
      childrenList.slice(rowIndex * numOfItemPerRow, rowIndex * numOfItemPerRow + numOfItemPerRow).map(function (child, childIndex) {
        if (child.classList.value.includes('draggable')) {
          return child;
        }

        if (!child.classList.value.includes('resizable-item')) {
          child.classList.add('resizable-item');
        }

        var xEl = dragX.current[rowIndex];
        var yEl = dragY.current[childIndex];
        var prevXEl = dragX.current[rowIndex - 1];
        var prevYEl = dragY.current[childIndex - 1];
        var top = xEl ? getPosition(xEl, 'top') : clientHeight;
        var left = yEl ? getPosition(yEl, 'left') : clientWidth;
        var prevTop = prevXEl ? getPosition(prevXEl, 'top') : 0;
        var prevLeft = prevYEl ? getPosition(prevYEl, 'left') : 0;
        var width = left - prevLeft;
        var height = top - prevTop;
        child.style.top = "".concat(prevTop, "px");
        child.style.left = "".concat(prevLeft, "px");
        child.style.width = "".concat(width, "px");
        child.style.height = "".concat(height, "px");
        curSizes.push({
          width: width,
          height: height
        });
        return child;
      });
    });
    callBack && callBack(curSizes);
    sizes.current = curSizes;
  };

  var renderChild = function renderChild(reactNode, index) {
    var child = _objectSpread2({}, reactNode);

    child.props = _objectSpread2({}, child.props);
    return /*#__PURE__*/jsxRuntime.jsx(React.Fragment, {
      children: child
    }, 'resizable-children ' + index);
  };

  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    ref: function ref(elm) {
      !!_ref && (isCallBackRef$1(_ref) ? _ref(elm) : _ref.current = elm);
      resizeRef.current = elm;
    },
    className: "resizable-v2-container",
    children: [children.map(function (reactNode, index) {
      return renderChild(reactNode, index);
    }), Array(Math.ceil(children.length / numOfItemPerRow) - 1).fill(1).map(function (v, index) {
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        ref: function ref(el) {
          return dragX.current[index] = el;
        },
        className: 'draggable x',
        onPointerDown: handleStart,
        children: /*#__PURE__*/jsxRuntime.jsx("div", _objectSpread2({
          tabIndex: 1,
          className: "line"
        }, autoReposition && {
          onPointerMove: function onPointerMove(event) {
            return handleDraggingPosition(event.clientX, event.clientY);
          },
          onPointerOut: function onPointerOut(event) {
            return handleDraggingPosition(event.clientX, event.clientY);
          }
        }))
      }, 'drag-x-' + index);
    }), Array(numOfItemPerRow - 1).fill(1).map(function (v, index) {
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        ref: function ref(el) {
          return dragY.current[index] = el;
        },
        className: 'draggable y',
        onPointerDown: handleStart,
        children: /*#__PURE__*/jsxRuntime.jsx("div", _objectSpread2({
          tabIndex: 1,
          className: "line"
        }, autoReposition && {
          onPointerMove: function onPointerMove(event) {
            return handleDraggingPosition(event.clientX, event.clientY);
          },
          onPointerOut: function onPointerOut(event) {
            return handleDraggingPosition(event.clientX, event.clientY);
          }
        }))
      }, 'drag-y-' + index);
    })]
  });
});

var isCallBackRef$1 = function isCallBackRef(ref) {
  return !('current' in ref);
};

var _excluded$n = ["mode"];
var Resizable = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _props$mode = props.mode,
      mode = _props$mode === void 0 ? 'single' : _props$mode,
      resizeProps = _objectWithoutProperties(props, _excluded$n);

  return mode === 'multi' ? /*#__PURE__*/jsxRuntime.jsx(ResizableMultiPanel, _objectSpread2({
    ref: ref
  }, resizeProps)) : /*#__PURE__*/jsxRuntime.jsx(ResizableSinglePanel, _objectSpread2({
    ref: ref
  }, resizeProps));
});
Resizable.displayName = 'Resizable';

var useResizeMap = function useResizeMap() {
  var timeoutRef = React.useRef();
  var delayRef = React.useRef(0);

  var _useState = React.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      map = _useState2[0],
      setMap = _useState2[1];

  React.useEffect(function () {
    return function () {
      return timeoutRef.current && clearTimeout(timeoutRef.current);
    };
  }, []);

  var run = function run() {
    if (!map) {
      return;
    }

    timeoutRef.current && clearTimeout(timeoutRef.current);
    timeoutRef.current = setTimeout(function () {
      return map.resize();
    }, delayRef.current);
  };

  var onMap = function onMap(map) {
    return setMap(map);
  };

  var onDelay = function onDelay(delay) {
    return delayRef.current = delay;
  };

  return {
    onMap: onMap,
    onDelay: onDelay,
    run: run,
    map: map
  };
};

var withResizeMap = function withResizeMap(Component) {
  return function (props) {
    var resizeMap = useResizeMap();
    return /*#__PURE__*/jsxRuntime.jsx(Component, _objectSpread2(_objectSpread2({}, resizeMap), props));
  };
};

var useWindowSize = function useWindowSize() {
  var originalWidth = window.innerWidth;
  var originalHeight = window.innerHeight;

  var _useState = React.useState([originalWidth, originalHeight]),
      _useState2 = _slicedToArray(_useState, 2),
      size = _useState2[0],
      setSize = _useState2[1];

  React.useLayoutEffect(function () {
    function updateSize() {
      if (originalWidth === window.innerWidth && originalHeight === window.innerHeight) {
        return;
      }

      setSize([window.innerWidth, window.innerHeight]);
    }

    window.addEventListener('resize', updateSize);
    updateSize();
    return function () {
      return window.removeEventListener('resize', updateSize);
    };
  }, [window.innerWidth]);
  return size;
};

var useMergeState = function useMergeState(initialState) {
  var _useReducer = React.useReducer(function (state, newState) {
    return _objectSpread2(_objectSpread2({}, state), newState);
  }, initialState),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      state = _useReducer2[0],
      setMergedState = _useReducer2[1];

  return [state, setMergedState];
};

var useOutsideClick = function useOutsideClick(ref, callback) {
  var handleClick = function handleClick(e) {
    if (ref && ref.current && !ref.current.contains(e.target)) {
      callback();
    }
  };

  React.useEffect(function () {
    var eventName = reactDeviceDetect.isMobile ? 'touchstart' : 'mousedown';
    document.addEventListener(eventName, handleClick);
    return function () {
      document.removeEventListener(eventName, handleClick);
    };
  });
};

var useSubMenuOption = function useSubMenuOption(params) {
  var isResponsive = params.isResponsive;
  var subMenuStyle = [];
  var transformStyle = {
    x: 0,
    y: 0
  };
  var refs = React.useRef([]);

  for (var i = 0; i < refs.current.length; i++) {
    var rect = refs.current[i].getBoundingClientRect();

    if (!isResponsive) {
      transformStyle.x = window.innerWidth - (rect.left || 0) >= (rect.width || 0) ? 0 : '-100%', transformStyle.y = window.innerHeight - (rect.top || 0) >= (rect.height || 0) ? 0 : 'calc(-100% + 2.25rem)', subMenuStyle.push({
        left: window.innerWidth - (rect.left || 0) >= (rect.width || 0) ? '100%' : 0,
        top: 0,
        transform: "translate(".concat(transformStyle.x, ", ").concat(transformStyle.y, ")")
      });
    } else {
      subMenuStyle.push({
        minWidth: 150
      });
    }
  }

  var handleSubMenuInnerSize = function handleSubMenuInnerSize(el) {
    if (el) {
      refs.current.push(el);
    }
  };

  return {
    subMenuStyle: subMenuStyle,
    handleSubMenuInnerSize: handleSubMenuInnerSize
  };
};

var uniqueId = createUniqueId();
var ResizableGrid = function ResizableGrid(props) {
  var className = props.className,
      lineSizes = props.lineSizes,
      numOfItemPerLine = props.numOfItemPerLine,
      children = props.children,
      _props$gridTemplates = props.gridTemplates,
      gridTemplates = _props$gridTemplates === void 0 ? [] : _props$gridTemplates,
      onResize = props.onResize,
      onResizeEnd = props.onResizeEnd;
  var resizeRef = React.useRef(null);
  var templateRows = React.useRef([]);
  var templateColumns = React.useRef([]);
  var draggableDirection = React.useRef(null);
  var start = React.useRef({
    x: 0,
    y: 0
  });
  var dragPosition = React.useRef({
    left: 0,
    top: 0
  });
  var draggingIndex = React.useRef({});
  var prevRatio = React.useRef({
    x: [],
    y: []
  });
  var timeout = React.useRef();

  var _useStateCallback = useStateCallback(false),
      _useStateCallback2 = _slicedToArray(_useStateCallback, 2),
      autoReposition = _useStateCallback2[0],
      setAutoReposition = _useStateCallback2[1];

  var cols = numOfItemPerLine || (children.length === 1 || children.length === 2 ? children.length : Math.ceil(Math.sqrt(children.length)));
  React.useLayoutEffect(function () {
    if (!lineSizes) {
      return;
    }

    var callBack = function callBack() {
      var _lineSizes$rows, _lineSizes$columns;

      if (!resizeRef.current) {
        return;
      }

      var gridTemplateColumns = '';
      var gridTemplateRows = '';
      var colsAsArray = [];
      var rowsAsArray = [];
      var countCol = 0;
      Array(children.length).fill(1).map(function (item, index) {
        var template = gridTemplates.find(function (item) {
          return item.index === index;
        }) || gridTemplates[index];
        countCol += ((template === null || template === void 0 ? void 0 : template.colSpan) || 1) * ((template === null || template === void 0 ? void 0 : template.rowSpan) || 1);
      });
      var rows = Math.ceil(countCol / cols);

      if ((lineSizes === null || lineSizes === void 0 ? void 0 : (_lineSizes$rows = lineSizes.rows) === null || _lineSizes$rows === void 0 ? void 0 : _lineSizes$rows.length) === rows) {
        lineSizes.rows.map(function (size) {
          rowsAsArray.push(size);
          gridTemplateRows += "".concat(size, "px ");
        });
      } else {
        var _rows = Math.ceil(countCol / cols);

        var rowSize = resizeRef.current.offsetHeight / (_rows || 1);
        var i = 1;

        while (i <= _rows) {
          rowsAsArray.push(rowSize);
          gridTemplateRows += "".concat(rowSize, "px ");
          i++;
        }
      }

      if (lineSizes !== null && lineSizes !== void 0 && (_lineSizes$columns = lineSizes.columns) !== null && _lineSizes$columns !== void 0 && _lineSizes$columns.length) {
        lineSizes.columns.map(function (size) {
          colsAsArray.push(size);
          gridTemplateColumns += "".concat(size, "px ");
        });
      } else {
        var colSize = resizeRef.current.offsetWidth / (cols || 1);
        var _i = 1;

        while (_i <= cols) {
          colsAsArray.push(colSize);
          gridTemplateColumns += "".concat(colSize, "px ");
          _i++;
        }
      }

      templateColumns.current = colsAsArray;
      templateRows.current = rowsAsArray;
      onResizeEnd && onResizeEnd({
        rows: rowsAsArray,
        columns: colsAsArray
      });
      resizeRef.current.style.gridTemplateColumns = gridTemplateColumns;
      resizeRef.current.style.gridTemplateRows = gridTemplateRows;
      setAutoReposition(true);
    };

    autoReposition ? setAutoReposition(false, callBack) : callBack();
  }, [children.length, JSON.stringify(lineSizes)]);
  React.useLayoutEffect(function () {
    if (!resizeRef.current) {
      return;
    }

    var offsetWidth = resizeRef.current.offsetWidth;
    var offsetHeight = resizeRef.current.offsetHeight;
    var x = Array.from(document.querySelectorAll("#".concat(uniqueId, " .draggable.x:not(.display)")));
    var y = Array.from(document.querySelectorAll("#".concat(uniqueId, " .draggable.y:not(.display)")));
    var ratioX = x.map(function (el, index) {
      var _lineSizes$rows2;

      var size = (templateRows.current.slice(0, index + 1).reduce(function (prev, cur) {
        return prev += cur;
      }) || (lineSizes === null || lineSizes === void 0 ? void 0 : (_lineSizes$rows2 = lineSizes.rows) === null || _lineSizes$rows2 === void 0 ? void 0 : _lineSizes$rows2.slice(0, index + 1).reduce(function (prev, cur) {
        return prev += cur;
      })) || getPosition(el, 'top')) / offsetHeight;
      var roundedSize = Math.round(Math.floor(size * 10000) / 10) / 1000;
      return Math.abs(roundedSize - (prevRatio.current.x[index] || 0)) > 0.01 ? roundedSize : prevRatio.current.x[index];
    });
    var ratioY = y.map(function (el, index) {
      var size = getPosition(el, 'left') / offsetWidth;
      var roundedSize = Math.round(Math.floor(size * 10000) / 10) / 1000;
      return Math.abs(roundedSize - (prevRatio.current.y[index] || 0)) > 0.01 ? roundedSize : prevRatio.current.y[index];
    });
    prevRatio.current = {
      x: ratioX,
      y: ratioY
    };
    var resize = new ResizeObserver(function (entries) {
      var _resizeRef$current, _resizeRef$current2;

      var rect = entries[0].contentRect;
      var isSame = x.length > 0 || y.length > 0;

      if (!(lineSizes !== null && lineSizes !== void 0 && lineSizes.rows) || ((_resizeRef$current = resizeRef.current) === null || _resizeRef$current === void 0 ? void 0 : _resizeRef$current.offsetHeight) !== lineSizes.rows.reduce(function (prev, cur) {
        return prev += cur;
      }, 0)) {
        x.map(function (el, index) {
          var ratio = ratioX[index];

          if (!el || !ratio) {
            return;
          }

          var prevTop = getPosition(el, 'top');
          var curTop = Math.round(rect.height * ratio * 1000) / 1000;

          if (Math.abs(prevTop - curTop) > 0.5) {
            el.style.top = "".concat(curTop, "px");
            isSame = false;
          }
        });
      }

      if (!(lineSizes !== null && lineSizes !== void 0 && lineSizes.columns) || ((_resizeRef$current2 = resizeRef.current) === null || _resizeRef$current2 === void 0 ? void 0 : _resizeRef$current2.offsetWidth) !== lineSizes.columns.reduce(function (prev, cur) {
        return prev += cur;
      }, 0)) {
        y.map(function (el, index) {
          var ratio = ratioY[index];

          if (!el || !ratio) {
            return;
          }

          var prevLeft = getPosition(el, 'left');
          var curLeft = Math.round(rect.width * ratio * 1000) / 1000;

          if (Math.abs(prevLeft - curLeft) > 0.5) {
            el.style.left = "".concat(curLeft, "px");
            isSame = false;
          }
        });
      }

      if (isSame) {
        handleSizes();
        return;
      }

      handleSizes();
      timeout.current && clearTimeout(timeout.current);
      timeout.current = setTimeout(function () {
        return onResizeEnd && onResizeEnd({
          rows: templateRows.current,
          columns: templateColumns.current
        });
      }, 100);
    });
    autoReposition && resize.observe(resizeRef.current);
    return function () {
      return resize.disconnect();
    };
  }, [autoReposition]);
  React.useLayoutEffect(function () {
    if (!resizeRef.current) {
      return;
    }

    var childList = Array.from(resizeRef.current.children);
    childList.length = children.length;
    childList.map(function (child, childIndex) {
      var template = gridTemplates.find(function (t) {
        return t.index === childIndex;
      }) || gridTemplates[childIndex];
      child.style.gridArea = template ? "".concat(template.rowStart, " / ").concat(template.colStart, " / span ").concat(template.rowSpan, " / span ").concat(template.colSpan) : 'unset';
    });
  }, [JSON.stringify(gridTemplates)]);

  var handleDraggingPosition = function handleDraggingPosition(x, y) {
    var isOut = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var xLine = Array.from(document.querySelectorAll("#".concat(uniqueId, " .draggable.x:not(.display)")));
    var yLine = Array.from(document.querySelectorAll("#".concat(uniqueId, " .draggable.y:not(.display)")));

    if (!resizeRef.current || xLine.length === 0 && yLine.length === 0) {
      return;
    }

    if (isOut) {
      var dragged = Array.from(document.querySelectorAll('.dragging'));
      dragged.map(function (el) {
        return el.classList.remove('dragging', 'multi-dragging');
      });
      return;
    }

    var xIndex = xLine.findIndex(function (el) {
      if (!el) {
        return;
      }

      var rect = el.children[0].getBoundingClientRect();
      return y >= rect.top && y <= rect.bottom;
    });
    var yIndex = yLine.findIndex(function (el) {
      if (!el) {
        return;
      }

      var rect = el.children[0].getBoundingClientRect();
      return x >= rect.left && x <= rect.right;
    });
    var xList = Array.from(document.querySelectorAll('.draggable.x.display'));
    var yList = Array.from(document.querySelectorAll('.draggable.y.display'));
    var xDisplayIndexes = xList.filter(function (el) {
      if (!el) {
        return;
      }

      var rect = el.children[0].getBoundingClientRect();
      return y >= rect.top && y <= rect.bottom;
    }).map(function (el) {
      return xList.indexOf(el);
    });
    var yDisplayIndexes = yList.filter(function (el) {
      if (!el) {
        return;
      }

      var rect = el.children[0].getBoundingClientRect();
      return x >= rect.left && x <= rect.right;
    }).map(function (el) {
      return yList.indexOf(el);
    });

    if (yDisplayIndexes.length > 0 && xDisplayIndexes.length > 0) {
      draggableDirection.current = 'both';
      xIndex !== -1 && xDisplayIndexes.map(function (index) {
        var _el$classList, _el$classList$value, _el$classList2, _el$classList2$value;

        var el = xList[index];
        !((_el$classList = el.classList) !== null && _el$classList !== void 0 && (_el$classList$value = _el$classList.value) !== null && _el$classList$value !== void 0 && _el$classList$value.includes('dragging')) && el.classList.add('dragging');
        !((_el$classList2 = el.classList) !== null && _el$classList2 !== void 0 && (_el$classList2$value = _el$classList2.value) !== null && _el$classList2$value !== void 0 && _el$classList2$value.includes('multi-dragging')) && el.classList.add('multi-dragging');
      });
      yIndex !== -1 && yDisplayIndexes.map(function (index) {
        var _el$classList3, _el$classList3$value, _el$classList4, _el$classList4$value;

        var el = yList[index];
        !((_el$classList3 = el.classList) !== null && _el$classList3 !== void 0 && (_el$classList3$value = _el$classList3.value) !== null && _el$classList3$value !== void 0 && _el$classList3$value.includes('dragging')) && el.classList.add('dragging');
        !((_el$classList4 = el.classList) !== null && _el$classList4 !== void 0 && (_el$classList4$value = _el$classList4.value) !== null && _el$classList4$value !== void 0 && _el$classList4$value.includes('multi-dragging')) && el.classList.add('multi-dragging');
      });
    } else if (xDisplayIndexes.length > 0) {
      draggableDirection.current = 'x';
      xIndex !== -1 && xDisplayIndexes.map(function (index) {
        var _el$classList5, _el$classList5$value;

        var el = xList[index];
        !((_el$classList5 = el.classList) !== null && _el$classList5 !== void 0 && (_el$classList5$value = _el$classList5.value) !== null && _el$classList5$value !== void 0 && _el$classList5$value.includes('dragging')) && el.classList.add('dragging');
      });
      yList.map(function (el) {
        return el.classList.remove('dragging', 'multi-dragging');
      });
    } else if (yDisplayIndexes.length > 0) {
      draggableDirection.current = 'y';
      xList.map(function (el) {
        return el.classList.remove('dragging', 'multi-dragging');
      });
      yIndex !== -1 && yDisplayIndexes.map(function (index) {
        var _el$classList6, _el$classList6$value;

        var el = yList[index];
        el.classList.remove('multi-dragging');
        !((_el$classList6 = el.classList) !== null && _el$classList6 !== void 0 && (_el$classList6$value = _el$classList6.value) !== null && _el$classList6$value !== void 0 && _el$classList6$value.includes('dragging')) && el.classList.add('dragging');
      });
    } else {
      draggableDirection.current = null;
      xList.map(function (el) {
        return el.classList.remove('dragging', 'multi-dragging');
      });
      yList.map(function (el) {
        return el.classList.remove('dragging', 'multi-dragging');
      });
    }

    return {
      x: xDisplayIndexes.length > 0 ? xIndex : -1,
      y: yDisplayIndexes.length > 0 ? yIndex : -1
    };
  };

  var handleStart = function handleStart(event) {
    var x = Array.from(document.querySelectorAll("#".concat(uniqueId, " .draggable.x:not(.display)")));
    var y = Array.from(document.querySelectorAll("#".concat(uniqueId, " .draggable.y:not(.display)")));
    var indexes = handleDraggingPosition(event.clientX, event.clientY);

    if (!indexes) {
      return;
    }

    var xEl = x[indexes.x];
    var yEl = y[indexes.y];

    if (!xEl && !yEl) {
      return;
    }

    draggingIndex.current = {
      x: indexes.x,
      y: indexes.y
    };
    start.current = {
      x: event.clientY,
      y: event.clientX
    };
    dragPosition.current = {
      left: yEl ? getPosition(yEl, 'left') : 0,
      top: xEl ? getPosition(xEl, 'top') : 0
    };
    setAutoReposition(false);
    window.addEventListener('pointerup', handleEnd);
    window.addEventListener('pointermove', handleMove);
  };

  var handleMove = function handleMove(event) {
    var x = Array.from(document.querySelectorAll("#".concat(uniqueId, " .draggable.x:not(.display)")));
    var y = Array.from(document.querySelectorAll("#".concat(uniqueId, " .draggable.y:not(.display)")));
    var xIndex = draggingIndex.current.x;
    var yIndex = draggingIndex.current.y;

    if (typeof xIndex === 'undefined' || typeof yIndex === 'undefined') {
      return;
    }

    var hasX = typeof xIndex === 'number' && xIndex >= 0;
    var hasY = typeof yIndex === 'number' && yIndex >= 0;
    var xEl = hasX && x[xIndex];
    var yEl = hasY && y[yIndex];
    var direction = draggableDirection.current;

    if (!resizeRef.current || !direction) {
      return;
    }

    if ((direction === 'x' || direction === 'both') && xEl) {
      var deltaX = event.clientY - start.current.x;
      var initTop = dragPosition.current.top;
      var prevXEl = x[xIndex - 1];
      var nextXEl = x[xIndex + 1];
      var prevTop = prevXEl ? getPosition(prevXEl, 'top') : 0;
      var nextTop = nextXEl ? getPosition(nextXEl, 'top') : resizeRef.current.offsetHeight;
      var top = initTop + deltaX;

      if (top < prevTop) {
        top = prevTop;
      } else if (top > nextTop) {
        top = nextTop;
      } else if (top === prevTop || top === nextTop) {
        return;
      }

      xEl.style.top = "".concat(top, "px");
    }

    if ((direction === 'y' || direction === 'both') && yEl) {
      var deltaY = event.clientX - start.current.y;
      var initLeft = dragPosition.current.left;
      var prevYEl = y[yIndex - 1];
      var nextYEl = y[yIndex + 1];
      var prevLeft = prevYEl ? +prevYEl.style.left.replace(/[^0-9.]/g, '') : 0;
      var nextLeft = nextYEl ? +nextYEl.style.left.replace(/[^0-9.]/g, '') : resizeRef.current.offsetWidth;
      var left = initLeft + deltaY;

      if (left < prevLeft) {
        left = prevLeft;
      } else if (left > nextLeft) {
        left = nextLeft;
      } else if (left === prevLeft || left === nextLeft) {
        return;
      }

      yEl.style.left = "".concat(left, "px");
    }

    handleSizes();
  };

  var handleEnd = function handleEnd(event) {
    window.removeEventListener('pointerup', handleEnd);
    window.removeEventListener('pointermove', handleMove);
    draggingIndex.current = {};
    setAutoReposition(true);
    onResizeEnd && onResizeEnd({
      rows: templateRows.current,
      columns: templateColumns.current
    });
  };

  var handleSizes = function handleSizes() {
    if (!resizeRef.current) {
      return;
    }

    var x = Array.from(document.querySelectorAll("#".concat(uniqueId, " .draggable.x:not(.display)")));
    var y = Array.from(document.querySelectorAll("#".concat(uniqueId, " .draggable.y:not(.display)")));
    var offsetWidth = resizeRef.current.offsetWidth;
    var offsetHeight = resizeRef.current.offsetHeight;
    resizeRef.current.style.gridTemplateRows = getGridTemplate({
      list: x,
      offsetSize: offsetHeight,
      type: 'row'
    });
    resizeRef.current.style.gridTemplateColumns = getGridTemplate({
      list: y,
      offsetSize: offsetWidth,
      type: 'column'
    });
    templateRows.current = resizeRef.current.style.gridTemplateRows.split(' ').map(function (size) {
      return +size.replace(/[^0-9.]/g, '');
    });
    templateColumns.current = resizeRef.current.style.gridTemplateColumns.split(' ').map(function (size) {
      return +size.replace(/[^0-9.]/g, '');
    });
    onResize && onResize({
      rows: templateRows.current,
      columns: templateColumns.current
    });
  };

  var getGridTemplate = function getGridTemplate(data) {
    var list = data.list,
        offsetSize = data.offsetSize,
        type = data.type;
    var position = type === 'row' ? 'top' : 'left';
    var gridTemplate = '';
    list.map(function (el, index) {
      var prevEl = list[index - 1];
      var posi = el ? getPosition(el, position) : 0;
      var prevPosi = prevEl ? getPosition(prevEl, position) : 0;
      gridTemplate += "".concat(posi - prevPosi, "px ");
    });
    var lastEl = list[list.length - 1];
    var lastPosi = lastEl ? getPosition(lastEl, position) : 0;
    gridTemplate += "".concat(offsetSize - lastPosi, "px");
    return gridTemplate;
  };

  var getPosition = function getPosition(el, position) {
    return +el.style[position].replace(/[^0-9.]/g, '');
  };

  var draggableX = Array(templateRows.current.length > 1 ? templateRows.current.length - 1 : 0).fill(1);
  var draggableY = Array(templateColumns.current.length > 1 ? templateColumns.current.length - 1 : 0).fill(1);
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    ref: resizeRef,
    id: uniqueId,
    className: clsx__default['default']('resizable-grid', className),
    children: [children.map(function (node, index) {
      return /*#__PURE__*/jsxRuntime.jsx(ResizableGridItem, _objectSpread2(_objectSpread2({
        onPointerDown: handleStart
      }, autoReposition && {
        onPointerMove: function onPointerMove(event) {
          return handleDraggingPosition(event.clientX, event.clientY);
        },
        onPointerOut: function onPointerOut(event) {
          return handleDraggingPosition(event.clientX, event.clientY, true);
        }
      }), {}, {
        children: node
      }), node.key || "resizable-grid-item-".concat(index));
    }), draggableX.map(function (v, index) {
      var _lineSizes$rows3;

      var arr = lineSizes === null || lineSizes === void 0 ? void 0 : (_lineSizes$rows3 = lineSizes.rows) === null || _lineSizes$rows3 === void 0 ? void 0 : _lineSizes$rows3.slice(0, index + 1);
      var top = arr !== null && arr !== void 0 && arr.length ? arr.reduce(function (prev, cur) {
        return prev += cur;
      }, 0) : templateRows.current.slice(0, index + 1).reduce(function (prev, cur) {
        return prev += cur;
      }, 0);
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'draggable x',
        style: {
          top: top
        },
        children: /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "line"
        })
      }, 'drag-x-' + index);
    }), draggableY.map(function (v, index) {
      var _lineSizes$columns2;

      var arr = lineSizes === null || lineSizes === void 0 ? void 0 : (_lineSizes$columns2 = lineSizes.columns) === null || _lineSizes$columns2 === void 0 ? void 0 : _lineSizes$columns2.slice(0, index + 1);
      var left = arr !== null && arr !== void 0 && arr.length ? arr.reduce(function (prev, cur) {
        return prev += cur;
      }, 0) : templateColumns.current.slice(0, index + 1).reduce(function (prev, cur) {
        return prev += cur;
      }, 0);
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'draggable y',
        style: {
          left: left
        },
        children: /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "line"
        })
      }, 'drag-y-' + index);
    })]
  });
};

var ResizableGridItem = function ResizableGridItem(props) {
  var children = props.children,
      onPointerDown = props.onPointerDown,
      onPointerMove = props.onPointerMove,
      onPointerOut = props.onPointerOut;
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: "resizable-grid-item",
    children: [children, /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'draggable x display',
      onPointerDown: onPointerDown,
      onPointerMove: onPointerMove,
      onPointerOut: onPointerOut,
      children: /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "line"
      })
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'draggable y display',
      onPointerDown: onPointerDown,
      onPointerMove: onPointerMove,
      onPointerOut: onPointerOut,
      children: /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "line"
      })
    })]
  });
};

var _excluded$m = ["direction", "size", "divider", "style", "className"];
var Spacer = function Spacer(props) {
  var _clsx;

  var _props$direction = props.direction,
      direction = _props$direction === void 0 ? 'horizontal' : _props$direction,
      _props$size = props.size,
      size = _props$size === void 0 ? '1rem' : _props$size,
      divider = props.divider,
      style = props.style,
      className = props.className,
      rest = _objectWithoutProperties(props, _excluded$m);

  var spacerStyle = _objectSpread2({
    width: direction === 'horizontal' ? size : '100%',
    height: direction === 'vertical' ? size : '100%'
  }, style);

  var spacerClass = classnames('spacer-component', (_clsx = {}, _defineProperty$1(_clsx, 'spacer-with-horizontal-divider', divider && direction === 'vertical'), _defineProperty$1(_clsx, 'spacer-with-vertical-divider', divider && direction === 'horizontal'), _clsx), className);
  return /*#__PURE__*/jsxRuntime.jsx("div", _objectSpread2({
    className: spacerClass,
    style: spacerStyle
  }, rest));
};

var Breadcrumb = function Breadcrumb(props) {
  var className = props.className,
      _props$nodes = props.nodes,
      nodes = _props$nodes === void 0 ? [] : _props$nodes,
      separator = props.separator,
      onCommonClick = props.onCommonClick,
      maxHeightOfChildNodes = props.maxHeightOfChildNodes;

  var _useModal = useModal(),
      menu = _useModal.menu;

  var handleClick = function handleClick(event, node) {
    event.preventDefault();

    if (node.onClick) {
      node.onClick();
      return;
    }

    onCommonClick && onCommonClick(node);
  };

  var showChildNodes = function showChildNodes(_ref) {
    var _event$currentTarget$;

    var childNodes = _ref.childNodes,
        id = _ref.id,
        event = _ref.event,
        index = _ref.index;

    if (!childNodes) {
      return;
    }

    event.preventDefault();
    var actions = childNodes.map(function (node) {
      return _objectSpread2(_objectSpread2({}, node), {}, {
        onClick: function onClick() {
          return handleClick(event, node);
        }
      });
    });
    var position = (_event$currentTarget$ = event.currentTarget.parentElement) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.getBoundingClientRect();
    var settings = {
      id: "child-nodes--".concat(id),
      actions: actions,
      width: 'min-content',
      isTopLeft: true,
      position: {
        x: position === null || position === void 0 ? void 0 : position.left,
        y: (position === null || position === void 0 ? void 0 : position.bottom) && (position === null || position === void 0 ? void 0 : position.bottom) + 8
      },
      maxHeight: maxHeightOfChildNodes || 'unset',
      className: clsx__default['default']('child-nodes--transform', index !== 0 && 'not-first-child')
    };
    menu(settings);
  };

  return /*#__PURE__*/jsxRuntime.jsx("nav", {
    className: clsx__default['default']('breadcrumb', className),
    "aria-label": "Breadcrumb",
    children: /*#__PURE__*/jsxRuntime.jsx("ol", {
      children: nodes.map(function (node, index) {
        var id = node.id,
            label = node.label,
            childNodes = node.childNodes;
        return /*#__PURE__*/jsxRuntime.jsxs(React__default['default'].Fragment, {
          children: [separator && index !== 0 && /*#__PURE__*/jsxRuntime.jsx("span", {
            className: "breadcrumb__separator",
            "aria-hidden": "true",
            children: separator
          }), /*#__PURE__*/jsxRuntime.jsxs("li", {
            className: clsx__default['default']('breadcrumb__node', separator && 'breadcrumb__node--has-separator'),
            "aria-current": index === nodes.length - 1 ? 'page' : undefined,
            children: [index !== nodes.length - 1 ? /*#__PURE__*/jsxRuntime.jsx("a", {
              href: "#",
              onClick: function onClick(e) {
                return handleClick(e, node);
              },
              children: label
            }) : label, childNodes && childNodes.length && /*#__PURE__*/jsxRuntime.jsx(IconButton, {
              className: 'breadcrumb__node--show-child',
              size: "xs",
              icon: "angle-down",
              iconSize: "lg" // TODO: ignore typescript check for event of onClick until the EmptyButton is applied typescript
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-ignore
              ,
              onClick: function onClick(event) {
                return showChildNodes({
                  childNodes: childNodes,
                  id: id,
                  event: event,
                  index: index
                });
              }
            })]
          }, node.id)]
        }, id);
      })
    })
  });
};

var EmptyData = function EmptyData() {
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: 'empty-data',
    children: /*#__PURE__*/jsxRuntime.jsx(T, {
      children: "Kh\xF4ng t\xECm th\u1EA5y d\u1EEF li\u1EC7u"
    })
  });
};

var ColumnSelector = function ColumnSelector(_ref) {
  var columns = _ref.columns,
      setColumns = _ref.setColumns,
      onClick = _ref.onClick,
      className = _ref.className,
      hideAllColumns = _ref.hideAllColumns,
      showAllColumns = _ref.showAllColumns,
      defaultColumns = _ref.defaultColumns;

  var _useState = React.useState(columns || []),
      _useState2 = _slicedToArray(_useState, 2),
      items = _useState2[0],
      setItems = _useState2[1];

  React.useEffect(function () {
    setItems(columns);
  }, [columns]);

  var _useDrop = reactDnd.useDrop({
    accept: 'column'
  }),
      _useDrop2 = _slicedToArray(_useDrop, 2),
      drop = _useDrop2[1];

  var cards = items === null || items === void 0 ? void 0 : items.map(function (card, index) {
    return /*#__PURE__*/jsxRuntime.jsx(Card$1, {
      id: "".concat(card.id),
      moveCard: moveCard,
      findCard: findCard,
      children: /*#__PURE__*/jsxRuntime.jsxs(Row2, {
        className: 'row',
        gap: 1,
        sx: {
          p: 1
        },
        children: [/*#__PURE__*/jsxRuntime.jsx(Switch__default['default'], {
          checked: !card.hidden,
          width: 28,
          height: 14,
          uncheckedIcon: false,
          checkedIcon: false,
          onChange: function onChange() {
            return onClick(card.id);
          },
          onColor: "#86d3ff",
          onHandleColor: "#2693e6"
        }), /*#__PURE__*/jsxRuntime.jsx("span", {
          className: 'text',
          children: /*#__PURE__*/jsxRuntime.jsx(T, {
            children: card.displayAsText || card.display
          })
        }), /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          icon: 'grip-vertical',
          type: 'solid',
          size: '0.75rem'
        })]
      })
    }, card.id || index);
  });
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    ref: drop,
    className: 'cs-container ' + className,
    onDrop: function onDrop() {
      return setColumns(items);
    },
    children: [/*#__PURE__*/jsxRuntime.jsx(ScrollView, {
      scrollX: false,
      className: 'cs-cards',
      children: cards
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: 'cs-buttons',
      children: [/*#__PURE__*/jsxRuntime.jsx(Button, {
        text: 'Ẩn tất cả',
        onClick: hideAllColumns
      }), /*#__PURE__*/jsxRuntime.jsx(Button, {
        text: 'Hiện tất cả',
        onClick: showAllColumns
      }), /*#__PURE__*/jsxRuntime.jsx(Button, {
        text: 'Mặc định',
        onClick: defaultColumns
      })]
    })]
  });

  function moveCard(id, atIndex) {
    var _findCard = findCard(id),
        card = _findCard.card,
        index = _findCard.index;

    setItems(update__default['default'](items, {
      $splice: [[index, 1], [atIndex, 0, card]]
    }));
  }

  function findCard(id) {
    for (var index = 0; index < items.length; index++) {
      if (items[index].id === id) {
        return {
          card: items[index],
          index: index
        };
      }
    }
  }
};

var Card$1 = function Card(_ref2) {
  var key = _ref2.key,
      id = _ref2.id,
      moveCard = _ref2.moveCard,
      findCard = _ref2.findCard,
      children = _ref2.children;
  var originalIndex = findCard(id).index;

  var _useDrag = reactDnd.useDrag({
    item: {
      type: 'column',
      id: id,
      originalIndex: originalIndex
    },
    collect: function collect(monitor) {
      return {
        isDragging: monitor.isDragging()
      };
    },
    end: function end(dropResult, monitor) {
      if (!monitor.didDrop()) {
        var _monitor$getItem = monitor.getItem(),
            droppedId = _monitor$getItem.id,
            _originalIndex = _monitor$getItem.originalIndex;

        moveCard(droppedId, _originalIndex);
      }
    }
  }),
      _useDrag2 = _slicedToArray(_useDrag, 2),
      isDragging = _useDrag2[0].isDragging,
      drag = _useDrag2[1];

  var _useDrop3 = reactDnd.useDrop({
    accept: 'column',
    canDrop: function canDrop() {
      return false;
    },
    hover: function hover(_ref3) {
      var draggedId = _ref3.id;

      if (draggedId !== id) {
        var _findCard2 = findCard(id),
            overIndex = _findCard2.index;

        moveCard(draggedId, overIndex);
      }
    }
  }),
      _useDrop4 = _slicedToArray(_useDrop3, 2),
      drop = _useDrop4[1];

  return /*#__PURE__*/jsxRuntime.jsx("div", {
    ref: function ref(node) {
      return drag(drop(node));
    },
    style: {
      opacity: isDragging ? 0 : 1
    },
    children: children
  }, key);
};

var FormControl = function FormControl(_ref) {
  var children = _ref.children,
      className = _ref.className;
  var classes = clsx__default['default']('form-control', className);
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: classes,
    children: children
  });
};

var _excluded$l = ["value", "onChange", "className", "flex", "style"];
var SearchBox = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var value = props.value,
      onChange = props.onChange,
      className = props.className,
      flex = props.flex,
      style = props.style,
      rest = _objectWithoutProperties(props, _excluded$l);

  var handleClearText = function handleClearText() {
    onChange && onChange('');
  };

  var handleChangeValue = function handleChangeValue(value) {
    onChange && onChange(value);
  };

  return /*#__PURE__*/jsxRuntime.jsx(Container, {
    className: className,
    flex: flex,
    children: /*#__PURE__*/jsxRuntime.jsxs(FormControl, {
      className: 'search-box-container',
      children: [/*#__PURE__*/jsxRuntime.jsx(Input, _objectSpread2(_objectSpread2({}, rest), {}, {
        ref: ref,
        className: 'search-box-control',
        type: 'text',
        autoComplete: "off",
        spellCheck: "false",
        value: value,
        style: _objectSpread2(_objectSpread2({}, style), {}, {
          flex: flex
        }),
        onChange: handleChangeValue
      })), /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "search-box-icon-cover",
        children: value ? /*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
          className: "search-box-close-icon",
          icon: 'times',
          size: "xs",
          iconSize: "md",
          onlyIcon: true,
          onClick: handleClearText
        }) : /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          className: "search-box-icon",
          icon: 'search'
        })
      })]
    })
  });
});
SearchBox.displayName = 'SearchBox';

var DataGridToolbar = function DataGridToolbar(props) {
  var _props$searching;

  // const { showFullScreenSelector, showSortSelector, showStyleSelector } = props.toolbarVisibility;
  var cols = props.cols,
      setCols = props.setCols,
      _props$toolbarActions = props.toolbarActions,
      toolbarActions = _props$toolbarActions === void 0 ? [] : _props$toolbarActions,
      toolbarVisibility = props.toolbarVisibility;

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      columnSelectorVisibility = _useState2[0],
      setColumnSelectorVisibility = _useState2[1];

  var columnSelectorButtonRef = React.useRef();

  var _useState3 = React.useState((_props$searching = props.searching) === null || _props$searching === void 0 ? void 0 : _props$searching.searchKey),
      _useState4 = _slicedToArray(_useState3, 2),
      searchValue = _useState4[0],
      setSearchValue = _useState4[1];

  var searchDebounce = AwesomeDebouncePromise__default['default'](function (value) {
    return props.searching.onSearch(value);
  }, 200);

  var handleSearch = function handleSearch(value) {
    var _props$searching2;

    setSearchValue(value);
    ((_props$searching2 = props.searching) === null || _props$searching2 === void 0 ? void 0 : _props$searching2.onSearch) && searchDebounce(value);
  };

  if (!toolbarVisibility && !toolbarActions) {
    return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {});
  }

  if (_typeof(toolbarVisibility) === 'object' || toolbarActions) {
    var _props$toolbarVisibil, _props$toolbarVisibil2;

    return /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'toolbar',
      children: /*#__PURE__*/jsxRuntime.jsxs(Row2, {
        children: [/*#__PURE__*/jsxRuntime.jsxs(Row2, {
          gap: 2,
          sx: {
            p: 2
          },
          children: [((_props$toolbarVisibil = props.toolbarVisibility) === null || _props$toolbarVisibil === void 0 ? void 0 : _props$toolbarVisibil.showColumnSelector) && /*#__PURE__*/jsxRuntime.jsx(Button, {
            innerRef: columnSelectorButtonRef,
            tooltip: 'Cột hiển thị',
            icon: 'line-columns',
            onlyIcon: true,
            onClick: function onClick() {
              return setColumnSelectorVisibility(!columnSelectorVisibility);
            }
          }), columnSelectorVisibility && /*#__PURE__*/jsxRuntime.jsx(PopOver, {
            anchorEl: columnSelectorButtonRef,
            onBackgroundClick: function onBackgroundClick() {
              return setColumnSelectorVisibility(!columnSelectorVisibility);
            },
            children: /*#__PURE__*/jsxRuntime.jsx(reactDnd.DndProvider, {
              backend: reactDndHtml5Backend.HTML5Backend,
              children: /*#__PURE__*/jsxRuntime.jsx(ColumnSelector, {
                columns: cols,
                setColumns: setCols,
                hideAllColumns: props.hideAllColumns,
                showAllColumns: props.showAllColumns,
                defaultColumns: props.defaultColumns,
                onClick: props.toggleColumnVisibility
              })
            })
          }), ((_props$toolbarVisibil2 = props.toolbarVisibility) === null || _props$toolbarVisibil2 === void 0 ? void 0 : _props$toolbarVisibil2.showReloadButton) && /*#__PURE__*/jsxRuntime.jsx(Button, {
            icon: 'redo-alt',
            tooltip: 'Tải lại danh sách',
            isLoading: props.loading,
            onlyIcon: true,
            onClick: props.onReload
          }), toolbarActions]
        }), props.searching && /*#__PURE__*/jsxRuntime.jsx(Row2, {
          panel: false,
          gap: 2,
          sx: {
            p: 2
          },
          children: /*#__PURE__*/jsxRuntime.jsx(SearchBox, {
            width: '18rem',
            placeholder: "Nh\u1EADp t\u1EEB kh\xF3a \u0111\u1EC3 t\xECm ki\u1EBFm",
            value: searchValue,
            onChange: handleSearch
          })
        })]
      })
    });
  }
};
DataGridToolbar.propTypes = {
  items: PropTypes__default['default'].arrayOf(PropTypes__default['default'].object),
  searching: PropTypes__default['default'].object,
  loading: PropTypes__default['default'].bool,
  cols: PropTypes__default['default'].array,
  setCols: PropTypes__default['default'].func,
  // not implement yet - nice to have
  toolbarVisibility: PropTypes__default['default'].oneOfType([PropTypes__default['default'].bool, PropTypes__default['default'].shape({
    showColumnSelector: PropTypes__default['default'].bool,
    showStyleSelector: PropTypes__default['default'].bool,
    showSortSelector: PropTypes__default['default'].bool,
    showFullScreenSelector: PropTypes__default['default'].bool,
    showReloadButton: PropTypes__default['default'].bool
  })]),
  toggleColumnVisibility: PropTypes__default['default'].func,
  // Button click handler
  defaultColumns: PropTypes__default['default'].func,
  hideAllColumns: PropTypes__default['default'].func,
  showAllColumns: PropTypes__default['default'].func,
  // ADD
  toolbarActions: PropTypes__default['default'].node
};

var Paging = /*#__PURE__*/function (_Component) {
  _inherits(Paging, _Component);

  var _super = _createSuper(Paging);

  function Paging() {
    var _this;

    _classCallCheck(this, Paging);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "getPager", function (totalItems) {
      var currentPage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      var _pageSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;

      // calculate total pages
      var totalPages = _pageSize <= 0 ? 1 : Math.ceil(totalItems / _pageSize);
      var startPage, endPage;

      if (totalPages <= 3) {
        startPage = 1;
        endPage = totalPages;
      } else {
        if (currentPage <= 2) {
          startPage = 1;
          endPage = 3;
        } else if (currentPage + 1 >= totalPages) {
          startPage = totalPages - 2;
          endPage = totalPages;
        } else {
          startPage = currentPage - 1;
          endPage = currentPage + 1;
        }
      } // calculate start and end item indexes


      var startIndex = (currentPage - 1) * _pageSize;
      var endIndex = Math.min(startIndex + _pageSize - 1, totalItems - 1); // create an array of pages to ng-repeat in the pager control

      var pages = [];

      for (var i = startPage; i < endPage + 1; i++) {
        pages.push(i);
      }

      return {
        totalItems: totalItems,
        currentPage: currentPage,
        pageSize: _pageSize,
        totalPages: totalPages,
        startPage: startPage,
        endPage: endPage,
        startIndex: startIndex,
        endIndex: endIndex,
        pages: pages
      };
    });

    _defineProperty$1(_assertThisInitialized(_this), "changePage", function (page, isChange) {
      if (isChange && typeof _this.props.onChange === 'function') {
        _this.props.onChange(page);
      }
    });

    return _this;
  }

  _createClass(Paging, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          total = _this$props.total,
          currentPage = _this$props.currentPage,
          pageSize = _this$props.pageSize;
      var pager = this.getPager(total, currentPage, pageSize);
      return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
        children: pager && pager.pages && pager.pages.length > 0 && /*#__PURE__*/jsxRuntime.jsxs("ul", {
          className: "pagination ".concat(this.props.className),
          children: [this.props.showFirstLast && /*#__PURE__*/jsxRuntime.jsx("li", {
            className: pager.currentPage === 1 ? 'disabled' : '',
            children: /*#__PURE__*/jsxRuntime.jsx("a", {
              onClick: function onClick() {
                return _this2.changePage(1, pager.currentPage !== 1);
              },
              children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                icon: 'angle-double-left',
                size: '0.875rem'
              })
            })
          }), /*#__PURE__*/jsxRuntime.jsx("li", {
            className: pager.currentPage === 1 ? 'disabled' : '',
            children: /*#__PURE__*/jsxRuntime.jsx("a", {
              onClick: function onClick() {
                return _this2.changePage(pager.currentPage - 1, pager.currentPage !== 1);
              },
              children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                icon: 'angle-left',
                size: '0.875rem'
              })
            })
          }), pager.pages.map(function (p, index) {
            return /*#__PURE__*/jsxRuntime.jsx("li", {
              className: pager.currentPage === p ? 'active' : '',
              children: /*#__PURE__*/jsxRuntime.jsx("a", {
                onClick: function onClick() {
                  return _this2.changePage(p, true);
                },
                children: p
              })
            }, index);
          }), /*#__PURE__*/jsxRuntime.jsx("li", {
            className: pager.currentPage === pager.totalPages ? 'disabled' : '',
            children: /*#__PURE__*/jsxRuntime.jsx("a", {
              onClick: function onClick() {
                return _this2.changePage(pager.currentPage + 1, pager.currentPage !== pager.totalPages);
              },
              children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                icon: 'angle-right',
                size: '0.875rem'
              })
            })
          }), this.props.showFirstLast && /*#__PURE__*/jsxRuntime.jsx("li", {
            className: pager.currentPage === pager.totalPages ? 'disabled' : '',
            children: /*#__PURE__*/jsxRuntime.jsx("a", {
              onClick: function onClick() {
                return _this2.changePage(pager.totalPages, pager.currentPage !== pager.totalPages);
              },
              children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                icon: 'angle-double-right',
                size: '0.875rem'
              })
            })
          })]
        })
      });
    }
  }]);

  return Paging;
}(React.Component);

Paging.propTypes = {
  className: PropTypes__default['default'].string,
  total: PropTypes__default['default'].number,
  currentPage: PropTypes__default['default'].number,
  pageSize: PropTypes__default['default'].number,
  showFirstLast: PropTypes__default['default'].bool,
  onChange: PropTypes__default['default'].func
};
Paging.defaultProps = {
  className: '',
  total: 0,
  currentPage: 1,
  pageSize: 10,
  showFirstLast: true,
  onChange: function onChange() {}
};

var PaginationRow = function PaginationRow(props) {
  var total = props.total,
      pageIndex = props.pageIndex,
      pageSize = props.pageSize,
      pageSizeOptions = props.pageSizeOptions,
      onChangePage = props.onChangePage,
      onChangeItemsPerPage = props.onChangeItemsPerPage;
  var selectOptions = (pageSizeOptions === null || pageSizeOptions === void 0 ? void 0 : pageSizeOptions.map(function (pageSize) {
    return {
      id: pageSize,
      label: /*#__PURE__*/jsxRuntime.jsx(T, {
        params: [pageSize],
        children: "%0% d\xF2ng"
      })
    };
  })) || [];
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(Paging, {
      total: total,
      pageSize: pageSize,
      currentPage: pageIndex,
      onChange: onChangePage
    }), /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
      searchable: false,
      options: selectOptions,
      width: '8rem',
      value: pageSize,
      onChange: onChangeItemsPerPage
    })]
  });
};

PaginationRow.propTypes = {
  total: PropTypes__default['default'].number,
  pageIndex: PropTypes__default['default'].number,
  pageSize: PropTypes__default['default'].number,
  pageSizeOptions: PropTypes__default['default'].arrayOf(PropTypes__default['default'].number),
  // [50, 100, 200] An array of page sizes the user can select from. Leave this prop undefined or use an empty array to hide "Rows per page" select button
  onChangePage: PropTypes__default['default'].func,
  // (itemsPerPage: number) => void
  onChangeItemsPerPage: PropTypes__default['default'].func // (pageIndex: number) => void

};

var usePagination = function usePagination(total) {
  var pagination = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _pagination$pageSizeO = pagination.pageSizeOptions,
      pageSizeOptions = _pagination$pageSizeO === void 0 ? [10, 20, 50, 100, 200] : _pagination$pageSizeO,
      onChangePage = pagination.onChangePage,
      onChangeItemsPerPage = pagination.onChangeItemsPerPage;

  var _useState = React.useState(pagination.pageIndex || 1),
      _useState2 = _slicedToArray(_useState, 2),
      pageIndex = _useState2[0],
      setPageIndex = _useState2[1];

  var _useState3 = React.useState(pagination.pageSize || 10),
      _useState4 = _slicedToArray(_useState3, 2),
      pageSize = _useState4[0],
      setPageSize = _useState4[1];

  React.useEffect(function () {
    if (onChangeItemsPerPage) {
      onChangeItemsPerPage(pageSize);
    }
  }, [pageSize]);
  React.useEffect(function () {
    if (onChangePage) {
      onChangePage(pageIndex);
    }
  }, [pageIndex]);
  var selectOptions = (pageSizeOptions === null || pageSizeOptions === void 0 ? void 0 : pageSizeOptions.map(function (pageSize) {
    return {
      id: pageSize,
      label: "".concat(pageSize, " rows")
    };
  })) || [];

  var SelectPageSize = function SelectPageSize() {
    return /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
      options: selectOptions,
      width: '200',
      value: pageSize,
      onChange: setPageSize
    });
  };

  var CurrentPaging = function CurrentPaging() {
    return /*#__PURE__*/jsxRuntime.jsx(Paging, {
      total: total,
      pageSize: pageSize,
      currentPage: pageIndex,
      onChange: setPageIndex
    });
  };

  var Row = function Row() {
    return /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: 'pagination-row',
      children: [/*#__PURE__*/jsxRuntime.jsx(SelectPageSize, {}), /*#__PURE__*/jsxRuntime.jsx(CurrentPaging, {})]
    });
  };

  var Pagination = {
    Select: SelectPageSize,
    Paging: CurrentPaging,
    Row: Row
  };
  return [pageIndex, pageSize, Pagination];
};

var PagingCount = /*#__PURE__*/function (_Component) {
  _inherits(PagingCount, _Component);

  var _super = _createSuper(PagingCount);

  function PagingCount() {
    _classCallCheck(this, PagingCount);

    return _super.apply(this, arguments);
  }

  _createClass(PagingCount, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          total = _this$props.total,
          currentPage = _this$props.currentPage,
          pageSize = _this$props.pageSize;
      var startIndex = 1 + pageSize * currentPage - pageSize;
      var endIndex = Math.min(total, pageSize * currentPage);
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'paging-count',
        children: total > 0 && /*#__PURE__*/jsxRuntime.jsx(T, {
          params: [startIndex, endIndex, total],
          children: "%0% - %1% / %2%"
        })
      });
    }
  }]);

  return PagingCount;
}(React.Component);

PagingCount.propTypes = {
  className: PropTypes__default['default'].string,
  total: PropTypes__default['default'].number,
  currentPage: PropTypes__default['default'].number,
  pageSize: PropTypes__default['default'].number
};
PagingCount.defaultProps = {
  className: '',
  total: 0,
  currentPage: 1,
  pageSize: 10
};

var DataGridBottomBar = function DataGridBottomBar(props) {
  var _props$items;

  var _props$total = props.total,
      total = _props$total === void 0 ? (_props$items = props.items) === null || _props$items === void 0 ? void 0 : _props$items.length : _props$total,
      pagination = props.pagination,
      externalPaginationRow = props.externalPaginationRow;

  if (!pagination) {
    return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {});
  }

  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: 'toolbar',
    children: /*#__PURE__*/jsxRuntime.jsxs(Row2, {
      justify: "end",
      items: "center",
      gap: 2,
      sx: {
        p: 2
      },
      children: [props.isLoading && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [/*#__PURE__*/jsxRuntime.jsx(T, {
          children: "Loading"
        }), /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          icon: 'spinner',
          size: '1rem',
          spin: true
        })]
      }), !(pagination !== null && pagination !== void 0 && pagination.useInfiniteScroll) && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [/*#__PURE__*/jsxRuntime.jsx(PagingCount, {
          total: total,
          pageSize: pagination === null || pagination === void 0 ? void 0 : pagination.pageSize,
          currentPage: pagination === null || pagination === void 0 ? void 0 : pagination.pageIndex
        }), pagination && !externalPaginationRow && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
          children: [/*#__PURE__*/jsxRuntime.jsx(Spacer, {
            style: {
              marginLeft: 'auto'
            },
            size: '1.5rem'
          }), /*#__PURE__*/jsxRuntime.jsx(PaginationRow, _objectSpread2({
            total: total
          }, pagination))]
        })]
      })]
    })
  });
};

DataGridBottomBar.propTypes = {
  isLoading: PropTypes.PropTypes.bool
};

var DataGridChartCell = function DataGridChartCell(props) {
  var options = props.options,
      content = props.content;
  var type = options.chartType,
      height = options.height;
      options.width;
      var isMiniStyle = options.isMiniStyle;
  var DEFAULT_OPTIONS = {
    plugins: {
      legend: {
        display: false
      },
      title: {
        display: false
      }
    },
    scales: {
      x: {
        grid: {
          display: !isMiniStyle
        },
        ticks: {
          display: !isMiniStyle
        }
      },
      y: {
        grid: {
          display: !isMiniStyle
        },
        ticks: {
          display: !isMiniStyle
        }
      }
    },
    layout: {
      padding: {
        left: 4,
        right: 4,
        top: 12,
        bottom: 12
      }
    }
  };
  var PRIMARY_COLOR = getComputedStyle(document.body).getPropertyValue('--primary-color');
  var DEFAULT_DATASETS_OPTIONS = {
    borderColor: PRIMARY_COLOR,
    borderWidth: type === 'line' ? 1 : 0,
    lineTension: 0,
    backgroundColor: type === 'doughnut' ? ['red', 'blue', 'yellow', 'green'] : type === 'bar' ? PRIMARY_COLOR : 'rgba(0,0,0,0)',
    pointRadius: 1
  };

  var data = _objectSpread2(_objectSpread2({}, content), {}, {
    datasets: content.datasets.map(function (e) {
      return _objectSpread2(_objectSpread2({}, DEFAULT_DATASETS_OPTIONS), e);
    })
  });

  switch (type) {
    case 'doughnut':
      return /*#__PURE__*/jsxRuntime.jsx(reactChartjs2.Doughnut, {
        height: height,
        data: data,
        options: _objectSpread2(_objectSpread2({}, DEFAULT_OPTIONS), options)
      });

    case 'line':
      return /*#__PURE__*/jsxRuntime.jsx(reactChartjs2.Line, {
        data: data,
        height: height,
        options: _objectSpread2(_objectSpread2({}, DEFAULT_OPTIONS), options)
      });

    case 'bar':
      return /*#__PURE__*/jsxRuntime.jsx(reactChartjs2.Bar, {
        data: data,
        height: height,
        options: _objectSpread2(_objectSpread2({}, DEFAULT_OPTIONS), options)
      });
  }
};
DataGridChartCell.propTypes = {
  content: PropTypes__default['default'].object,
  options: PropTypes__default['default'].object
};

var _excluded$k = ["target", "children", "className"];
var Link = function Link(props) {
  var _props$target = props.target,
      target = _props$target === void 0 ? '_self' : _props$target,
      children = props.children,
      className = props.className,
      anchorProps = _objectWithoutProperties(props, _excluded$k);

  return /*#__PURE__*/jsxRuntime.jsx("a", _objectSpread2(_objectSpread2({}, anchorProps), {}, {
    className: clsx__default['default']('link', className),
    target: target,
    rel: 'noopener noreferrer',
    children: /*#__PURE__*/jsxRuntime.jsx(T, {
      children: children
    })
  }));
};

var Image$1 = /*#__PURE__*/function (_Component) {
  _inherits(Image, _Component);

  var _super = _createSuper(Image);

  function Image(props) {
    var _this;

    _classCallCheck(this, Image);

    _this = _super.call(this, props);

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      imgSrcError: false,
      src: ''
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleClick", function (event) {
      if (_this.props.onClick) {
        _this.props.onClick(event);
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleDownloadImage", function () {
      var a = document.createElement('a');
      a.style.display = 'none';
      document.body.appendChild(a); // Set the HREF to a Blob representation of the data to be downloaded

      var src = _this.props.src[0] === '/' ? window.location.origin + _this.props.src : _this.props.src;
      a.href = _this.props.src.includes('data:image') || _this.props.src[0] === '/' ? src : '/api/download?url=' + src;
      var tzOffset = new Date().getTimezoneOffset() * 60000; // Use download attribute to set set desired file name

      a.setAttribute('download', new Date(Date.now() - tzOffset).toISOString().slice(0, -5)); // Trigger the download by simulating click

      a.click(); // Cleanup

      window.URL.revokeObjectURL(a.href);
      document.body.removeChild(a);
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleZoomClick", function (event) {
      _this.handleClick(event);

      if (_this.props.canEnlarge) {
        var containerId = 'image-view-container';
        var element = document.getElementById(containerId);

        if (!element) {
          element = document.createElement('div');
          element.setAttribute('id', containerId);
          var root = document.getElementById('root');
          root.appendChild(element);
        }

        ReactDOM__default['default'].render( /*#__PURE__*/jsxRuntime.jsx(Popup, {
          scroll: false,
          headerActions: [{
            icon: 'arrow-to-bottom',
            onClick: _this.handleDownloadImage
          }],
          isShowContentOnly: true,
          onClose: function onClose() {
            ReactDOM__default['default'].render(null, element);
          },
          children: /*#__PURE__*/jsxRuntime.jsx(reactZoomPanPinch.TransformWrapper, {
            wheel: {
              step: 4
            },
            enablePadding: false,
            enablePanPadding: false,
            children: /*#__PURE__*/jsxRuntime.jsx(reactZoomPanPinch.TransformComponent, {
              children: /*#__PURE__*/jsxRuntime.jsx("img", {
                style: {
                  maxWidth: '90vw',
                  maxHeight: '90vh',
                  minWidth: '400px',
                  minHeight: '400px'
                },
                src: _this.props.src,
                alt: _this.props.alt
              })
            })
          })
        }), element);
        event.stopPropagation();
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleImageChange", function (event) {
      if (typeof _this.props.onChange === 'function') {
        if (event.target.files && event.target.files[0]) {
          var fileName = event.target.files[0].name;
          var reader = new FileReader();

          reader.onload = function (e) {
            _this.props.onChange(_this.props.id, {
              fileName: fileName,
              data: e.target.result
            });
          };

          reader.readAsDataURL(event.target.files[0]);
        }
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleChangeClick", function (event) {
      _this.inputRef.current.click();

      event.stopPropagation();
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleDeleteClick", function (event) {
      if (typeof _this.props.onDelete === 'function') {
        _this.props.onDelete(_this.props.id);

        event.stopPropagation();
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleImgSrcError", function (_error) {
      _this.setState({
        imgSrcError: true
      });
    });

    _this.imageRef = /*#__PURE__*/React__default['default'].createRef();
    _this.inputRef = /*#__PURE__*/React__default['default'].createRef();
    return _this;
  }

  _createClass(Image, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      try {
        this.imageRef.current.src = '';
        delete this.imageRef.current.src;
      } catch (e) {
        console.error(e);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          width = _this$props.width,
          height = _this$props.height,
          background = _this$props.background,
          canEnlarge = _this$props.canEnlarge,
          src = _this$props.src,
          alt = _this$props.alt,
          className = _this$props.className,
          fitMode = _this$props.fitMode,
          label = _this$props.label,
          circle = _this$props.circle;
      var altSrc = this.props.altSrc;
      var imgSrcError = this.state.imgSrcError;
      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "image-container ".concat(className),
        style: {
          width: width,
          background: background
        },
        children: [/*#__PURE__*/jsxRuntime.jsx("img", {
          ref: this.imageRef,
          crossOrigin: "anonymous" // for load image from cors and canvas build from it not being tainted
          ,
          className: 'image-content',
          src: imgSrcError && altSrc ? altSrc : src,
          style: {
            height: height,
            objectFit: fitMode,
            borderRadius: circle ? '50%' : ''
          },
          alt: alt,
          onLoad: this.props.onLoad,
          onError: this.handleImgSrcError,
          onClick: this.handleClick
        }), canEnlarge && !imgSrcError && /*#__PURE__*/jsxRuntime.jsx("div", {
          className: 'image-zoom',
          onClick: this.handleZoomClick,
          children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
            className: "icon",
            icon: 'expand',
            size: '1.2rem'
          })
        }), label && /*#__PURE__*/jsxRuntime.jsx("div", {
          className: 'image-label',
          children: /*#__PURE__*/jsxRuntime.jsx(T, {
            children: label
          })
        })]
      });
    }
  }]);

  return Image;
}(React.Component);

_defineProperty$1(Image$1, "getDerivedStateFromProps", function (nextProps, prevState) {
  if (nextProps.src !== prevState.src) {
    return {
      src: nextProps.src,
      imgSrcError: false
    };
  }

  return false;
});

Image$1.propTypes = {
  className: PropTypes__default['default'].string,
  id: PropTypes__default['default'].any,
  canEnlarge: PropTypes__default['default'].bool,
  // set true when you want the image can be open large on click
  width: PropTypes__default['default'].string,
  height: PropTypes__default['default'].string,
  src: PropTypes__default['default'].string.isRequired,
  altSrc: PropTypes__default['default'].string,
  alt: PropTypes__default['default'].string,
  onClick: PropTypes__default['default'].func,
  background: PropTypes__default['default'].string,
  fitMode: PropTypes__default['default'].oneOf(['cover', 'contain', '']),
  onChange: PropTypes__default['default'].func,
  onDelete: PropTypes__default['default'].func,
  onLoad: PropTypes__default['default'].func,
  label: PropTypes__default['default'].any,
  circle: PropTypes__default['default'].bool
};
Image$1.defaultProps = {
  className: '',
  canEnlarge: false,
  width: '',
  height: '',
  src: '',
  alt: '',
  background: '',
  fitMode: 'cover',
  circle: false,
  onClick: function onClick() {},
  onChange: function onChange() {},
  onDelete: function onDelete() {}
};

var _MapVDMSDataTypesToDa, _MapDisplaySchemaToDi;

exports.DataTypes = void 0;

(function (DataTypes) {
  DataTypes[DataTypes["Boolean"] = 1] = "Boolean";
  DataTypes[DataTypes["Currency"] = 2] = "Currency";
  DataTypes[DataTypes["Datetime"] = 3] = "Datetime";
  DataTypes[DataTypes["Numeric"] = 4] = "Numeric";
  DataTypes[DataTypes["Real"] = 5] = "Real";
  DataTypes[DataTypes["Date"] = 6] = "Date";
  DataTypes[DataTypes["Select"] = 7] = "Select";
  DataTypes[DataTypes["MultiSelect"] = 8] = "MultiSelect";
  DataTypes[DataTypes["Image"] = 9] = "Image";
  DataTypes[DataTypes["Link"] = 10] = "Link";
  DataTypes[DataTypes["JSON"] = 11] = "JSON";
  DataTypes[DataTypes["Chart"] = 12] = "Chart";
  DataTypes[DataTypes["Text"] = 13] = "Text";
  DataTypes[DataTypes["Map"] = 14] = "Map";
  DataTypes[DataTypes["File"] = 15] = "File";
  DataTypes[DataTypes["List"] = 16] = "List";
  DataTypes[DataTypes["MapVN2000"] = 17] = "MapVN2000";
  DataTypes[DataTypes["ReactNode"] = 18] = "ReactNode";
  DataTypes[DataTypes["MultiLine"] = 19] = "MultiLine";
  DataTypes[DataTypes["RichText"] = 20] = "RichText";
})(exports.DataTypes || (exports.DataTypes = {}));

exports.VDMSDataTypes = void 0;

(function (VDMSDataTypes) {
  VDMSDataTypes[VDMSDataTypes["Boolean"] = 1] = "Boolean";
  VDMSDataTypes[VDMSDataTypes["Number"] = 2] = "Number";
  VDMSDataTypes[VDMSDataTypes["String"] = 3] = "String";
  VDMSDataTypes[VDMSDataTypes["Real"] = 4] = "Real";
  VDMSDataTypes[VDMSDataTypes["Datetime"] = 5] = "Datetime";
  VDMSDataTypes[VDMSDataTypes["BigString"] = 6] = "BigString";
  VDMSDataTypes[VDMSDataTypes["Map"] = 7] = "Map";
  VDMSDataTypes[VDMSDataTypes["Text"] = 8] = "Text";
  VDMSDataTypes[VDMSDataTypes["File"] = 9] = "File";
  VDMSDataTypes[VDMSDataTypes["List"] = 10] = "List";
  VDMSDataTypes[VDMSDataTypes["MapVN2000"] = 11] = "MapVN2000";
})(exports.VDMSDataTypes || (exports.VDMSDataTypes = {}));

var MapVDMSDataTypesToDataTypes = (_MapVDMSDataTypesToDa = {}, _defineProperty$1(_MapVDMSDataTypesToDa, exports.VDMSDataTypes.Boolean, exports.DataTypes.Boolean), _defineProperty$1(_MapVDMSDataTypesToDa, exports.VDMSDataTypes.Number, exports.DataTypes.Numeric), _defineProperty$1(_MapVDMSDataTypesToDa, exports.VDMSDataTypes.String, exports.DataTypes.Text), _defineProperty$1(_MapVDMSDataTypesToDa, exports.VDMSDataTypes.Real, exports.DataTypes.Real), _defineProperty$1(_MapVDMSDataTypesToDa, exports.VDMSDataTypes.Datetime, exports.DataTypes.Date), _defineProperty$1(_MapVDMSDataTypesToDa, exports.VDMSDataTypes.BigString, exports.DataTypes.MultiLine), _defineProperty$1(_MapVDMSDataTypesToDa, exports.VDMSDataTypes.Map, exports.DataTypes.Map), _defineProperty$1(_MapVDMSDataTypesToDa, exports.VDMSDataTypes.Text, exports.DataTypes.RichText), _defineProperty$1(_MapVDMSDataTypesToDa, exports.VDMSDataTypes.File, exports.DataTypes.File), _defineProperty$1(_MapVDMSDataTypesToDa, exports.VDMSDataTypes.List, exports.DataTypes.List), _defineProperty$1(_MapVDMSDataTypesToDa, exports.VDMSDataTypes.MapVN2000, exports.DataTypes.MapVN2000), _MapVDMSDataTypesToDa);
exports.DisplaySchema = void 0;

(function (DisplaySchema) {
  DisplaySchema["Boolean"] = "boolean";
  DisplaySchema["Currency"] = "currency";
  DisplaySchema["Datetime"] = "datetime";
  DisplaySchema["Date"] = "date";
  DisplaySchema["Numeric"] = "numeric";
  DisplaySchema["Select"] = "select";
  DisplaySchema["MultiSelect"] = "multi-select";
  DisplaySchema["Image"] = "image";
  DisplaySchema["Link"] = "link";
  DisplaySchema["JSON"] = "json";
  DisplaySchema["ReactNode"] = "react-node";
  DisplaySchema["RenderNode"] = "render-node";
})(exports.DisplaySchema || (exports.DisplaySchema = {}));

var MapDisplaySchemaToDisplayTypes = (_MapDisplaySchemaToDi = {}, _defineProperty$1(_MapDisplaySchemaToDi, exports.DisplaySchema.Boolean, exports.DataTypes.Boolean), _defineProperty$1(_MapDisplaySchemaToDi, exports.DisplaySchema.Currency, exports.DataTypes.Currency), _defineProperty$1(_MapDisplaySchemaToDi, exports.DisplaySchema.Date, exports.DataTypes.Date), _defineProperty$1(_MapDisplaySchemaToDi, exports.DisplaySchema.Datetime, exports.DataTypes.Datetime), _defineProperty$1(_MapDisplaySchemaToDi, exports.DisplaySchema.Numeric, exports.DataTypes.Numeric), _defineProperty$1(_MapDisplaySchemaToDi, exports.DisplaySchema.Select, exports.DataTypes.Select), _defineProperty$1(_MapDisplaySchemaToDi, exports.DisplaySchema.MultiSelect, exports.DataTypes.MultiSelect), _defineProperty$1(_MapDisplaySchemaToDi, exports.DisplaySchema.Image, exports.DataTypes.Image), _defineProperty$1(_MapDisplaySchemaToDi, exports.DisplaySchema.Link, exports.DataTypes.Link), _defineProperty$1(_MapDisplaySchemaToDi, exports.DisplaySchema.JSON, exports.DataTypes.JSON), _defineProperty$1(_MapDisplaySchemaToDi, exports.DisplaySchema.ReactNode, exports.DataTypes.ReactNode), _MapDisplaySchemaToDi);

var _excluded$j = ["type", "step", "width", "border", "value", "onChange", "clearable", "disabled", "className", "height"];
var ClearableInput = function ClearableInput(props) {
  var inputRef = React.useRef(null);

  var _props$type = props.type,
      type = _props$type === void 0 ? 'text' : _props$type,
      _props$step = props.step,
      step = _props$step === void 0 ? 1 : _props$step,
      _props$width = props.width,
      width = _props$width === void 0 ? '100%' : _props$width,
      _props$border = props.border,
      border = _props$border === void 0 ? 'block' : _props$border,
      value = props.value,
      onChange = props.onChange,
      clearable = props.clearable,
      disabled = props.disabled,
      className = props.className,
      height = props.height,
      restInputProps = _objectWithoutProperties(props, _excluded$j);

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      hasValue = _useState2[0],
      setHasValue = _useState2[1];

  React.useEffect(function () {
    if (hasValue === !!value) {
      return;
    }

    setHasValue(!!value);
  }, [value, hasValue]);

  var handleChange = function handleChange(value) {
    setHasValue(!!value);
    onChange && onChange(value);
  };

  var handleClearValueClick = function handleClearValueClick() {
    setHasValue(false);
    onChange && onChange('');
  };

  return /*#__PURE__*/jsxRuntime.jsx("div", {
    style: {
      width: '100%'
    },
    className: "ci-container",
    tabIndex: 0,
    children: /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: "ci-control-container",
      children: [/*#__PURE__*/jsxRuntime.jsx(Input, _objectSpread2(_objectSpread2({}, restInputProps), {}, {
        ref: inputRef,
        value: value,
        className: clsx__default['default']('input-text', className, type === 'range' && 'slider'),
        type: type,
        disabled: disabled,
        step: type === 'date' ? undefined : step,
        style: {
          width: width,
          border: border,
          height: height
        },
        onChange: handleChange
      })), clearable && !disabled && hasValue && /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "clear",
        children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          icon: 'times',
          size: '1rem',
          onClick: handleClearValueClick
        })
      })]
    })
  });
};

var ProfileImage = "data:image/png;base64,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";

var FormControlLabel = function FormControlLabel(props) {
  var _clsx;

  var _props$iconType = props.iconType,
      iconType = _props$iconType === void 0 ? 'solid' : _props$iconType,
      _props$iconSize = props.iconSize,
      iconSize = _props$iconSize === void 0 ? '1rem' : _props$iconSize,
      _props$labelWidth = props.labelWidth,
      labelWidth = _props$labelWidth === void 0 ? '70px' : _props$labelWidth,
      _props$labelLocation = props.labelLocation,
      labelLocation = _props$labelLocation === void 0 ? 'left' : _props$labelLocation,
      _props$direction = props.direction,
      direction = _props$direction === void 0 ? 'row' : _props$direction,
      _props$rules = props.rules,
      rules = _props$rules === void 0 ? [] : _props$rules;
  var required = props.required,
      dirty = props.dirty,
      className = props.className,
      control = props.control,
      iconClassName = props.iconClassName,
      icon = props.icon,
      label = props.label,
      errorText = props.errorText;
  var isInvalid = (rules === null || rules === void 0 ? void 0 : rules.length) > 0 || errorText;
  var wrapperClasses = clsx__default['default']('form-control-label', "form-control-".concat(direction), className);
  var labelClasses = clsx__default['default']('form-label', "form-label-align-".concat(labelLocation));
  var containerClasses = clsx__default['default']('form-control-container', (_clsx = {}, _defineProperty$1(_clsx, 'required', required), _defineProperty$1(_clsx, 'invalid', isInvalid), _defineProperty$1(_clsx, 'dirty', dirty), _defineProperty$1(_clsx, 'form-input-number', /*#__PURE__*/React__default['default'].isValidElement(control) && control.props.type === 'number'), _defineProperty$1(_clsx, 'form-input-number-group', /*#__PURE__*/React__default['default'].isValidElement(control) && Array.isArray(control.props.children) && control.props.children.find(function (c) {
    var _c$props;

    return ((_c$props = c.props) === null || _c$props === void 0 ? void 0 : _c$props.type) === 'number';
  })), _defineProperty$1(_clsx, 'invalid-error', isInvalid && errorText), _clsx));
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
      className: wrapperClasses,
      children: [icon && /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
        icon: icon,
        className: iconClassName,
        type: iconType,
        size: iconSize
      }), label && /*#__PURE__*/jsxRuntime.jsx("div", {
        className: labelClasses,
        style: {
          width: direction === 'row' ? labelWidth : ''
        },
        children: /*#__PURE__*/jsxRuntime.jsx(T, {
          children: label
        })
      }), /*#__PURE__*/jsxRuntime.jsx("div", {
        className: containerClasses,
        children: control && /*#__PURE__*/React__default['default'].isValidElement(control) ? /*#__PURE__*/React__default['default'].cloneElement(control, {
          className: clsx__default['default'](control.props.className, 'form-control')
        }) : control
      })]
    }), isInvalid && /*#__PURE__*/jsxRuntime.jsxs(Sub2, {
      color: 'danger',
      style: {
        marginLeft: labelWidth,
        paddingLeft: '10px',
        lineHeight: 'unset'
      },
      children: [/*#__PURE__*/jsxRuntime.jsx(T, {
        children: errorText
      }), "\xA0"]
    })]
  });
};

var InputGroup = function InputGroup(_ref) {
  var children = _ref.children,
      className = _ref.className;
  var classes = clsx__default['default']('form-input-group', className);
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: classes,
    children: children
  });
};

var InputAppend = function InputAppend(_ref) {
  var children = _ref.children,
      className = _ref.className;
  var classes = clsx__default['default']('input-append', className);
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: classes,
    children: typeof children === 'string' ? /*#__PURE__*/jsxRuntime.jsx("span", {
      children: /*#__PURE__*/jsxRuntime.jsx(T, {
        children: children
      })
    }) : children
  });
};

var ImageReader = function ImageReader() {
  var read = function read(file) {
    return new Promise(function (resolve, reject) {
      // Get Image base64 - Always run before array buffer
      var base64Reader = new FileReader();
      base64Reader.readAsDataURL(file);

      base64Reader.onload = function (e) {
        var image = e.target.result; // get Image width and height

        var img = new Image();
        img.src = e.target.result;

        img.onload = function () {
          var height = this.height;
          var width = this.width; // get Image Orientation

          var bufferReader = new FileReader();
          bufferReader.readAsArrayBuffer(file);

          bufferReader.onload = function (e) {
            var exif = EXIF__default['default'].readFromBinaryFile(e.target.result);
            var orientation = Number(exif === null || exif === void 0 ? void 0 : exif.Orientation) || 1;
            resolve({
              image: image,
              width: width,
              height: height,
              orientation: orientation
            });
          };
        };
      };
    });
  };

  return {
    read: read
  };
};

var imageReader = ImageReader();
var ImageInput = function ImageInput(props) {
  var value = props.value,
      onChange = props.onChange,
      label = props.label,
      imageSrc = props.imageSrc;
  var inputRef = React.useRef(null);

  var _useState = React.useState(value),
      _useState2 = _slicedToArray(_useState, 2),
      imagePath = _useState2[0],
      setImagePath = _useState2[1];

  var _useState3 = React.useState(imageSrc),
      _useState4 = _slicedToArray(_useState3, 2),
      imageData = _useState4[0],
      setImageData = _useState4[1];

  React.useEffect(function () {
    setImagePath(value);
    setImageData(imageSrc);
  }, [value, imageSrc]);

  var handleRemove = function handleRemove() {
    if (inputRef.current) {
      inputRef.current.value = '';
    }

    handleChange();
  };

  var handleChange = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var _inputRef$current;

      var files, _yield$imageReader$re, _image, _width, _height, _orientation;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              files = (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.files;

              if (!(files && files[0])) {
                _context.next = 14;
                break;
              }

              _context.next = 4;
              return imageReader.read(files[0]);

            case 4:
              _yield$imageReader$re = _context.sent;
              _image = _yield$imageReader$re.image;
              _width = _yield$imageReader$re.width;
              _height = _yield$imageReader$re.height;
              _orientation = _yield$imageReader$re.orientation;
              setImageData(_image);
              setImagePath(files[0].name);
              onChange && onChange(files[0], _image, _orientation, _width, _height);
              _context.next = 17;
              break;

            case 14:
              setImageData('');
              setImagePath('');
              onChange && onChange(null, '', 1, 0, 0);

            case 17:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function handleChange() {
      return _ref.apply(this, arguments);
    };
  }();

  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(FormControlLabel, {
      label: label,
      control: /*#__PURE__*/jsxRuntime.jsxs(InputGroup, {
        children: [/*#__PURE__*/jsxRuntime.jsx(Input, {
          placeholder: 'Chọn 1 ảnh...',
          value: imagePath,
          disabled: true
        }), /*#__PURE__*/jsxRuntime.jsx(InputAppend, {
          children: /*#__PURE__*/jsxRuntime.jsxs(Row2, {
            children: [/*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
              icon: 'trash-alt',
              size: "sm",
              onlyIcon: true,
              onClick: handleRemove
            }), /*#__PURE__*/jsxRuntime.jsx(Button, {
              icon: 'upload',
              size: "sm",
              onlyIcon: true,
              onClick: function onClick(e) {
                var _inputRef$current2;

                return inputRef === null || inputRef === void 0 ? void 0 : (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.click();
              }
            })]
          })
        })]
      })
    }), /*#__PURE__*/jsxRuntime.jsx(Input, {
      ref: inputRef,
      className: 'hide',
      type: 'file',
      accept: 'image/png, image/jpeg',
      onChange: handleChange
    }), /*#__PURE__*/jsxRuntime.jsx(Image$1, {
      width: '18rem',
      height: '18rem',
      className: 'face-reg-img',
      fitMode: 'contain',
      background: '#303030',
      src: imageData || ProfileImage,
      canEnlarge: true
    })]
  });
};

var DateTimePickerController = function DateTimePickerController(props) {
  var readOnly = props.readOnly,
      className = props.className,
      placeholder = props.placeholder,
      value = props.value,
      disabled = props.disabled,
      clearable = props.clearable,
      showTimeSelectOnly = props.showTimeSelectOnly,
      isVisible = props.isVisible,
      name = props.name,
      innerRef = props.innerRef,
      onChange = props.onChange,
      onClearValueClick = props.onClearValueClick,
      onControlClick = props.onControlClick,
      customOnChange = props.customOnChange;
  var containerRef = React.useRef(null);
  var inputRef = React.useRef(null);
  var calendarIconRef = React.useRef(null);
  React.useEffect(function () {
    var _inputRef$current;

    if (!isVisible) {
      return;
    }

    (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
  }, [isVisible]);
  React.useEffect(function () {
    isVisible && document.addEventListener('mousedown', handleClosePopup);
    isVisible && document.addEventListener('scroll', handleClosePopup, true);
    return function () {
      document.removeEventListener('mousedown', handleClosePopup);
      document.removeEventListener('scroll', handleClosePopup, true);
    };
  }, [isVisible]);

  var handleClosePopup = function handleClosePopup(event) {
    var _calendarIconRef$curr;

    event.target !== inputRef.current && event.target !== containerRef.current && !((_calendarIconRef$curr = calendarIconRef.current) !== null && _calendarIconRef$curr !== void 0 && _calendarIconRef$curr.contains(event.target)) && !event.composedPath().some(function (elm) {
      var _classList;

      return (_classList = elm.classList) === null || _classList === void 0 ? void 0 : _classList.value.includes('dtp-overlay');
    }) && isVisible && onControlClick();
    return;
  };

  var handleKeyDown = function handleKeyDown(event) {
    event.which === Constants.KEYS.ENTER && isVisible && onControlClick();
  };

  return /*#__PURE__*/jsxRuntime.jsxs(Container, {
    ref: containerRef,
    className: "dtp-control-container ".concat(readOnly ? 'cursor-default' : ''),
    children: [/*#__PURE__*/jsxRuntime.jsx(Input, {
      ref: function ref(elm) {
        innerRef && innerRef(elm);
        inputRef.current = elm;
      },
      name: name,
      className: clsx__default['default']('input-text', className),
      placeholder: placeholder,
      type: "text",
      value: value || placeholder,
      disabled: disabled,
      customOnChange: customOnChange,
      "data-autofocus": true,
      onChange: onChange,
      onKeyDown: handleKeyDown,
      onClick: function onClick() {
        return !isVisible && onControlClick();
      }
    }), clearable && !disabled && value && /*#__PURE__*/jsxRuntime.jsx(Container, {
      className: "clear",
      children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
        icon: 'times',
        size: '1rem',
        onClick: onClearValueClick
      })
    }), !showTimeSelectOnly && /*#__PURE__*/jsxRuntime.jsx(Container, {
      ref: calendarIconRef,
      className: "calendar",
      children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
        icon: 'calendar-alt',
        size: '1rem',
        onClick: function onClick() {
          return !isVisible && onControlClick();
        }
      })
    })]
  });
};
DateTimePickerController.displayName = 'DateTimePickerController';

var Track = function Track(props) {
  var className = props.className,
      trackRef = props.trackRef,
      style = props.style,
      disabled = props.disabled,
      _props$orientation = props.orientation,
      orientation = _props$orientation === void 0 ? 'horizontal' : _props$orientation,
      rangeColor = props.rangeColor;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    ref: trackRef,
    className: clsx__default['default'](orientation === 'vertical' ? 'track-vertical' : 'track', disabled && 'disabled', className),
    style: _objectSpread2(_objectSpread2({}, style), {}, {
      backgroundColor: rangeColor
    })
  });
};

var RangeThumb = function RangeThumb(props) {
  var className = props.className,
      value = props.value,
      _props$size = props.size,
      size = _props$size === void 0 ? '14px' : _props$size,
      color = props.color,
      style = props.style,
      rangeSize = props.rangeSize,
      disabled = props.disabled,
      custom = props.custom,
      displayMap = props.displayMap,
      isShowIndicator = props.isShowIndicator,
      setShowIndicator = props.setShowIndicator,
      isVertical = props.isVertical,
      children = props.children;
  var rangeSizeNumb = parseInt(rangeSize, 10);
  var sizeNumb = parseInt(size, 10);
  var thumbOffsetX = sizeNumb > rangeSizeNumb ? (sizeNumb - rangeSizeNumb) / 2 + 'px' : '0px';
  var customOffsetX = sizeNumb > rangeSizeNumb ? (sizeNumb - rangeSizeNumb) / 2 + 'px' : '0px';
  var thumbRef = React.useRef(null);
  var hasMouseOutListener = React.useRef(false);
  React.useEffect(function () {
    var _thumbRef$current, _thumbRef$current2;

    (_thumbRef$current = thumbRef.current) === null || _thumbRef$current === void 0 ? void 0 : _thumbRef$current.addEventListener('mouseover', handleMouseOver);
    (_thumbRef$current2 = thumbRef.current) === null || _thumbRef$current2 === void 0 ? void 0 : _thumbRef$current2.addEventListener('mouseout', handleMouseOut);
    document.addEventListener('mousedown', handleMouseDown, true);
    document.addEventListener('mouseup', handleMouseUp, true);
    return function () {
      var _thumbRef$current3, _thumbRef$current4;

      (_thumbRef$current3 = thumbRef.current) === null || _thumbRef$current3 === void 0 ? void 0 : _thumbRef$current3.removeEventListener('mouseover', handleMouseOver);
      (_thumbRef$current4 = thumbRef.current) === null || _thumbRef$current4 === void 0 ? void 0 : _thumbRef$current4.removeEventListener('mouseout', handleMouseOut);
      document.removeEventListener('mousedown', handleMouseDown, true);
      document.removeEventListener('mouseup', handleMouseUp, true);
    };
  }, []);

  var handleMouseOver = function handleMouseOver() {
    return setShowIndicator(true);
  };

  var handleMouseOut = function handleMouseOut() {
    setShowIndicator(false);
    hasMouseOutListener.current === true;
  };

  var handleMouseDown = function handleMouseDown(e) {
    var _e$target;

    if (((_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.closest('.slider__range-thumb')) === thumbRef.current) {
      var _thumbRef$current5;

      (_thumbRef$current5 = thumbRef.current) === null || _thumbRef$current5 === void 0 ? void 0 : _thumbRef$current5.removeEventListener('mouseout', handleMouseOut);
      hasMouseOutListener.current === false;
    }
  };

  var handleMouseUp = function handleMouseUp() {
    if (!hasMouseOutListener.current) {
      var _thumbRef$current6;

      setShowIndicator(false);
      (_thumbRef$current6 = thumbRef.current) === null || _thumbRef$current6 === void 0 ? void 0 : _thumbRef$current6.addEventListener('mouseout', handleMouseOut);
    }
  };

  var getDisplayValue = function getDisplayValue(position) {
    if (displayMap) {
      var nearestKey = Object.keys(displayMap).reduce(function (acc, val) {
        return Math.abs(parseFloat(val) - position) < Math.abs(acc - position) ? parseFloat(val) : acc;
      }, 0);
      return displayMap[nearestKey];
    }
  };

  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
      ref: thumbRef,
      className: clsx__default['default']('slider__range-thumb', className, disabled && 'disabled'),
      style: style,
      children: [custom ? custom : /*#__PURE__*/jsxRuntime.jsx("div", {
        style: _objectSpread2(_objectSpread2({
          width: size,
          height: size
        }, color && {
          border: "2px solid ".concat(disabled ? 'gray' : color)
        }), {}, {
          borderRadius: '50%',
          background: 'white'
        })
      }), children]
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      className: clsx__default['default']('slider__thumb-indicator', isShowIndicator && 'show'),
      style: _objectSpread2(_objectSpread2({}, style), {}, {
        left: isVertical ? '1rem' : value + '%',
        bottom: isVertical ? value + '%' : '',
        transform: isVertical ? "translate(".concat(custom ? customOffsetX : thumbOffsetX, ", ").concat(value - 2 < 0 ? Math.abs(value - 2) : value - 2, "%") : "translate(-".concat(value - 2 < 0 ? Math.abs(value - 2) : value - 2, "%, ").concat(custom ? customOffsetX : thumbOffsetX, ")")
      }),
      children: /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "slider__indicator-text",
        children: getDisplayValue(value)
      })
    })]
  });
};

var SliderMarks = function SliderMarks(props) {
  var _props$positions = props.positions,
      positions = _props$positions === void 0 ? [] : _props$positions,
      size = props.size,
      onClick = props.onClick,
      _props$type = props.type,
      type = _props$type === void 0 ? 'dot' : _props$type,
      isMarkStep = props.isMarkStep,
      color = props.color,
      disabled = props.disabled,
      isVertical = props.isVertical,
      reverse = props.reverse;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: 'slider-mark-container',
    children: /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'slider-marks-dot',
      children: positions.map(function (position) {
        return /*#__PURE__*/jsxRuntime.jsx(Mark, {
          position: position,
          size: isMarkStep && type !== 'line' ? "calc(".concat(size, " - 3px)") : size,
          type: type,
          color: color,
          disabled: disabled,
          isMarkStep: isMarkStep,
          isVertical: isVertical,
          reverse: reverse,
          onClick: onClick
        }, 'mark-' + position);
      })
    })
  });
};

var Mark = function Mark(_ref) {
  var position = _ref.position,
      size = _ref.size,
      _onClick = _ref.onClick,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? 'dot' : _ref$type,
      isMarkStep = _ref.isMarkStep,
      color = _ref.color,
      disabled = _ref.disabled,
      isVertical = _ref.isVertical,
      reverse = _ref.reverse;
  return /*#__PURE__*/jsxRuntime.jsx("div", _objectSpread2({
    className: 'slider-mark',
    style: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({
      left: reverse ? '' : isVertical ? '50%' : position + '%',
      right: reverse ? position + '%' : '',
      bottom: isVertical ? position + '%' : ''
    }, type !== 'line' && {
      width: size
    }), {}, {
      height: type === 'line' && size ? isVertical ? '0' : "".concat(parseInt(size, 10) * 1.5, "px") : size,
      width: type === 'line' && size ? isVertical ? "".concat(parseInt(size, 10) * 1.5, "px") : '0' : size,
      transform: reverse ? 'translateX(50%)' : isVertical ? 'translate(-50%, 50%)' : 'translateX(-50%)'
    }, type === 'dot' && {
      borderRadius: '50%'
    }), type === 'line' && {
      border: '1px solid #f0f0f0'
    }), isMarkStep && {
      border: '1px solid #f0f0f0',
      background: disabled ? 'gray' : color,
      maxWidth: '5px',
      maxHeight: '5px'
    })
  }, _onClick && {
    onClick: function onClick() {
      return _onClick(position);
    }
  }));
};

var SliderLabels = function SliderLabels(_ref2) {
  var _ref2$marks = _ref2.marks,
      marks = _ref2$marks === void 0 ? {} : _ref2$marks,
      isVertical = _ref2.isVertical,
      reverse = _ref2.reverse;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: 'slider-mark-label-container',
    children: Object.entries(marks).map(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          key = _ref4[0],
          val = _ref4[1];

      return /*#__PURE__*/jsxRuntime.jsx(Label$2, {
        position: parseFloat(key),
        label: typeof val !== 'string' ? val.label : val,
        style: typeof val !== 'string' ? val.style : {},
        isVertical: isVertical,
        reverse: reverse
      }, 'dots' + key);
    })
  });
};

var Label$2 = function Label(_ref5) {
  var position = _ref5.position,
      label = _ref5.label,
      _ref5$style = _ref5.style,
      style = _ref5$style === void 0 ? {} : _ref5$style,
      isVertical = _ref5.isVertical,
      reverse = _ref5.reverse;
  return /*#__PURE__*/jsxRuntime.jsx(TB1, {
    className: 'slider-label',
    style: _objectSpread2({
      position: 'absolute',
      left: reverse ? '' : isVertical ? '1rem' : position + '%',
      right: reverse ? position + '%' : '',
      bottom: isVertical ? position + '%' : '',
      transform: reverse ? 'translateX(50%)' : isVertical ? 'translateY(50%)' : 'translateX(-50%)'
    }, style),
    children: label
  });
};

var Rail = function Rail(props) {
  var style = props.style;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: 'slider__rail',
    style: style
  });
};

var setRef = function setRef(ref, value) {
  if (typeof ref === 'function') {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
};

var useForkRef = function useForkRef(refA, refB) {
  /**
  * This will create a new function if the ref props change and are defined.
  * This means react will call the old forkRef with `null` and the new forkRef
  * with the ref. Cleanup naturally emerges from this behavior.
  */
  return React__namespace.useMemo(function () {
    if (refA === null && refB === null) {
      return null;
    }

    return function (refValue) {
      setRef(refA, refValue);
      setRef(refB, refValue);
    };
  }, [refA, refB]);
};

// based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js
var hadKeyboardEvent = true;
var hadFocusVisibleRecently = false;
var hadFocusVisibleRecentlyTimeout;
var inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  'datetime-local': true
};
/**
 * Computes whether the given element should automatically trigger the
 * `focus-visible` class being added, i.e. whether it should always match
 * `:focus-visible` when focused.
 * @param {Element} node
 * @returns {boolean}
 */

var focusTriggersKeyboardModality = function focusTriggersKeyboardModality(node) {
  var _ref = node,
      type = _ref.type,
      tagName = _ref.tagName;

  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {
    return true;
  }

  if (tagName === 'TEXTAREA' && !node.readOnly) {
    return true;
  }

  if (node.isContentEditable) {
    return true;
  }

  return false;
};
/**
 * Keep track of our keyboard modality state with `hadKeyboardEvent`.
 * If the most recent user interaction was via the keyboard;
 * and the key press did not include a meta, alt/option, or control key;
 * then the modality is keyboard. Otherwise, the modality is not keyboard.
 * @param {KeyboardEvent} event
 */


var handleKeyDown = function handleKeyDown(event) {
  if (event.metaKey || event.altKey || event.ctrlKey) {
    return;
  }

  hadKeyboardEvent = true;
};
/**
 * If at any point a user clicks with a pointing device, ensure that we change
 * the modality away from keyboard.
 * This avoids the situation where a user presses a key on an already focused
 * element, and then clicks on a different element, focusing it with a
 * pointing device, while we still think we're in keyboard modality.
 */


var handlePointerDown = function handlePointerDown() {
  hadKeyboardEvent = false;
};

var handleVisibilityChange = function handleVisibilityChange(doc) {
  if (doc.visibilityState === 'hidden') {
    // If the tab becomes active again, the browser will handle calling focus
    // on the element (Safari actually calls it twice).
    // If this tab change caused a blur on an element with focus-visible,
    // re-apply the class when the user switches back to the tab.
    if (hadFocusVisibleRecently) {
      hadKeyboardEvent = true;
    }
  }
};

var prepare = function prepare(doc) {
  doc.addEventListener('keydown', handleKeyDown, true);
  doc.addEventListener('mousedown', handlePointerDown, true);
  doc.addEventListener('pointerdown', handlePointerDown, true);
  doc.addEventListener('touchstart', handlePointerDown, true);
  doc.addEventListener('visibilitychange', function () {
    return handleVisibilityChange(doc);
  }, true);
};

var isFocusVisible = function isFocusVisible(event) {
  var target = event.target;

  try {
    return target.matches(':focus-visible');
  } catch (error) {// Browsers not implementing :focus-visible will throw a SyntaxError.
    // We use our own heuristic for those browsers.
    // Rethrow might be better if it's not the expected error but do we really
    // want to crash if focus-visible malfunctioned?
  } // No need for validFocusTarget check. The user does that by attaching it to
  // focusable events only.


  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
};

var useIsFocusVisible = function useIsFocusVisible() {
  var ref = React__namespace.useCallback(function (node) {
    if (node !== null) {
      prepare(node.ownerDocument);
    }
  }, []);
  var isFocusVisibleRef = React__namespace.useRef(false);
  /**
  * Should be called if a blur event is fired
  */

  var handleBlurVisible = function handleBlurVisible() {
    // checking against potential state variable does not suffice if we focus and blur synchronously.
    // React wouldn't have time to trigger a re-render so `focusVisible` would be stale.
    // Ideally we would adjust `isFocusVisible(event)` to look at `relatedTarget` for blur events.
    // This doesn't work in IE11 due to https://github.com/facebook/react/issues/3751
    // TODO: check again if React releases their internal changes to focus event handling (https://github.com/facebook/react/pull/19186).
    if (isFocusVisibleRef.current) {
      // To detect a tab/window switch, we look for a blur event followed
      // rapidly by a visibility change.
      // If we don't see a visibility change within 100ms, it's probably a
      // regular focus change.
      hadFocusVisibleRecently = true;
      window.clearTimeout(hadFocusVisibleRecentlyTimeout);
      hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {
        hadFocusVisibleRecently = false;
      }, 100);
      isFocusVisibleRef.current = false;
      return true;
    }

    return false;
  };
  /**
  * Should be called if a blur event is fired
  */


  var handleFocusVisible = function handleFocusVisible(event) {
    if (isFocusVisible(event)) {
      isFocusVisibleRef.current = true;
      return true;
    }

    return false;
  };

  return {
    isFocusVisibleRef: isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: ref
  };
};

var useSlider = function useSlider(props) {
  var ref = props.ref,
      _props$disableSwap = props.disableSwap,
      disableSwap = _props$disableSwap === void 0 ? false : _props$disableSwap,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      _props$marks = props.marks,
      marksProp = _props$marks === void 0 ? false : _props$marks,
      _props$max = props.max,
      max = _props$max === void 0 ? 100 : _props$max,
      _props$min = props.min,
      min = _props$min === void 0 ? 0 : _props$min,
      onChange = props.onChange,
      onAfterChange = props.onAfterChange,
      _props$orientation = props.orientation,
      orientation = _props$orientation === void 0 ? 'horizontal' : _props$orientation,
      _props$step = props.step,
      step = _props$step === void 0 ? 1 : _props$step,
      valueProp = props.value,
      reverse = props.reverse;
  var touchId = React__default['default'].useRef(); // We can't use the :active browser pseudo-classes.
  // - The active state isn't triggered when clicking on the rail.
  // - The active state isn't transferred when inversing a range slider.

  var _React$useState = React__default['default'].useState(-1),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      active = _React$useState2[0],
      setActive = _React$useState2[1];

  var moveCount = React__default['default'].useRef(0);
  var range = Array.isArray(valueProp);

  var _useState = React.useState(range ? valueProp : [valueProp]),
      _useState2 = _slicedToArray(_useState, 2),
      valueDerived = _useState2[0],
      setValueState = _useState2[1];

  var values = range ? valueDerived.sort(asc) : valueDerived;
  values = values.map(function (value) {
    return clamp(value, min, max);
  });
  var marks = {};

  if (marksProp && typeof marksProp === 'boolean' && step !== null) {
    _toConsumableArray(Array(Math.floor((max - min) / step) + 1)).map(function (_, index) {
      var position = min + step * index;
      marks[position] = '';
    });
  } else {
    marks = marksProp || {};
  }

  var marksValues = Object.keys(marks).map(function (value) {
    return parseFloat(value);
  });
  var valuesRef = React__default['default'].useRef(values);
  React.useEffect(function () {
    setValueState(range ? valueProp : [valueProp]);
    valuesRef.current = values;
  }, [valueProp]);

  var handleChange = onChange && function (event, value, thumbIndex) {
    // Redefine target to allow name and value to be read.
    // This allows seamless integration with the most popular form libraries.
    // Clone the event to not override `target` of the original event.
    var nativeEvent = event.nativeEvent || event; // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore

    var clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
    Object.defineProperty(clonedEvent, 'target', {
      writable: true,
      value: {
        value: value
      }
    });
    onChange(value);
  };

  var handleAfterChange = onAfterChange && function (event, value, thumbIndex) {
    // Redefine target to allow name and value to be read.
    // This allows seamless integration with the most popular form libraries.
    // Clone the event to not override `target` of the original event.
    var nativeEvent = event.nativeEvent || event; // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore

    var clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
    Object.defineProperty(clonedEvent, 'target', {
      writable: true,
      value: {
        value: value
      }
    });
    onAfterChange && onAfterChange(value);
  };

  var _useIsFocusVisible = useIsFocusVisible(),
      isFocusVisibleRef = _useIsFocusVisible.isFocusVisibleRef,
      handleBlurVisible = _useIsFocusVisible.onBlur,
      handleFocusVisible = _useIsFocusVisible.onFocus,
      focusVisibleRef = _useIsFocusVisible.ref;

  var _React$useState3 = React__default['default'].useState(-1),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      focusVisible = _React$useState4[0],
      setFocusVisible = _React$useState4[1];

  var sliderRef = React__default['default'].useRef(null);
  var handleFocusRef = useForkRef(focusVisibleRef, sliderRef);
  var handleRef = useForkRef(ref, handleFocusRef);

  var createHandleHiddenInputFocus = function createHandleHiddenInputFocus(otherHandlers) {
    return function (event) {
      var _event$target, _otherHandlers$onFocu;

      var index = Number((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.getAttribute('data-index'));
      handleFocusVisible(event);

      if (isFocusVisibleRef.current === true) {
        setFocusVisible(index);
      }

      otherHandlers === null || otherHandlers === void 0 ? void 0 : (_otherHandlers$onFocu = otherHandlers.onFocus) === null || _otherHandlers$onFocu === void 0 ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);
    };
  };

  var createHandleHiddenInputBlur = function createHandleHiddenInputBlur(otherHandlers) {
    return function (event) {
      var _otherHandlers$onBlur;

      handleBlurVisible(event);

      if (isFocusVisibleRef.current === false) {
        setFocusVisible(-1);
      }

      otherHandlers === null || otherHandlers === void 0 ? void 0 : (_otherHandlers$onBlur = otherHandlers.onBlur) === null || _otherHandlers$onBlur === void 0 ? void 0 : _otherHandlers$onBlur.call(otherHandlers, event);
    };
  };

  React.useEffect(function () {
    if (disabled && sliderRef.current.contains(document.activeElement)) {
      var _document$activeEleme;

      // This is necessary because Firefox and Safari will keep focus
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      (_document$activeEleme = document.activeElement) === null || _document$activeEleme === void 0 ? void 0 : _document$activeEleme.blur();
    }
  }, [disabled]);

  if (disabled && active !== -1) {
    setActive(-1);
  }

  if (disabled && focusVisible !== -1) {
    setFocusVisible(-1);
  }

  var previousIndex = React__default['default'].useRef();
  var axis = orientation;

  if (reverse && orientation === 'horizontal') {
    axis += '-reverse';
  }

  var getFingerNewValue = function getFingerNewValue(_ref) {
    var finger = _ref.finger,
        _ref$move = _ref.move,
        move = _ref$move === void 0 ? false : _ref$move,
        values2 = _ref.values;
    var slider = sliderRef.current;

    var _getBoundingClientRec = slider.getBoundingClientRect(),
        width = _getBoundingClientRec.width,
        height = _getBoundingClientRec.height,
        bottom = _getBoundingClientRec.bottom,
        left = _getBoundingClientRec.left;

    var percent, newValue;

    if (axis.indexOf('vertical') === 0) {
      percent = (bottom - finger.y) / height;
    } else {
      percent = (finger.x - left) / width;
    }

    if (axis.indexOf('-reverse') !== -1) {
      percent = 1 - percent;
    }

    newValue = percentToValue(percent, min, max);

    if (step) {
      newValue = roundValueToStep(newValue, step, min);
    } else {
      var closestIndex = findClosest(marksValues, newValue);
      newValue = marksValues[closestIndex];
    }

    newValue = clamp(newValue, min, max);
    var activeIndex = 0;

    if (range) {
      if (!move) {
        activeIndex = findClosest(values2, newValue);
      } else {
        activeIndex = previousIndex.current;
      } // Bound the new value to the thumb's neighbours.


      if (disableSwap) {
        newValue = clamp(newValue, values2[activeIndex - 1] || -Infinity, values2[activeIndex + 1] || Infinity);
      }

      var previousValue = newValue;
      newValue = setValueIndex({
        values: values2,
        newValue: newValue,
        index: activeIndex
      }); // Potentially swap the index if needed.

      if (!(disableSwap && move)) {
        activeIndex = newValue.indexOf(previousValue);
        previousIndex.current = activeIndex;
      }
    }

    return {
      newValue: newValue,
      activeIndex: activeIndex
    };
  };

  var handleTouchMove = React.useCallback(function (nativeEvent) {
    var finger = trackFinger(nativeEvent, touchId);

    if (!finger) {
      return;
    }

    moveCount.current += 1; // Cancel move in case some other element consumed a mouseup event and it was not fired.
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore

    if (nativeEvent.type === 'mousemove' && nativeEvent.buttons === 0) {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      handleTouchEnd(nativeEvent);
      return;
    }

    var _getFingerNewValue = getFingerNewValue({
      finger: finger,
      move: true,
      values: valuesRef.current
    }),
        newValue = _getFingerNewValue.newValue,
        activeIndex = _getFingerNewValue.activeIndex;

    focusThumb({
      sliderRef: sliderRef,
      activeIndex: activeIndex,
      setActive: setActive
    });
    setValueState(range ? newValue : [newValue]);
    valuesRef.current = range ? newValue : [newValue];
    handleChange && handleChange(nativeEvent, newValue, activeIndex);
  }, []);
  var handleTouchEnd = React.useCallback(function (nativeEvent) {
    var finger = trackFinger(nativeEvent, touchId);

    if (!finger) {
      return;
    }

    setActive(-1);
    touchId.current = undefined;

    var _getFingerNewValue2 = getFingerNewValue({
      finger: finger,
      move: true,
      values: valuesRef.current
    }),
        newValue = _getFingerNewValue2.newValue,
        activeIndex = _getFingerNewValue2.activeIndex;

    handleChange && handleChange(nativeEvent, newValue, activeIndex);
    handleAfterChange && handleAfterChange(nativeEvent, newValue, activeIndex); // eslint-disable-next-line @typescript-eslint/no-use-before-define

    stopListening();
  }, []);
  var handleTouchStart = React.useCallback(function (nativeEvent) {
    // If touch-action: none; is not supported we need to prevent the scroll manually.
    if (!doesSupportTouchActionNone()) {
      nativeEvent.preventDefault();
    }

    var touch = nativeEvent.changedTouches[0];

    if (touch !== null) {
      // A number that uniquely identifies the current finger in the touch session.
      touchId.current = touch.identifier;
    }

    var finger = trackFinger(nativeEvent, touchId);

    if (finger !== false) {
      var _getFingerNewValue3 = getFingerNewValue({
        finger: finger,
        values: valuesRef.current
      }),
          newValue = _getFingerNewValue3.newValue,
          activeIndex = _getFingerNewValue3.activeIndex;

      focusThumb({
        sliderRef: sliderRef,
        activeIndex: activeIndex,
        setActive: setActive
      });
      setValueState(range ? newValue : [newValue]);
      valuesRef.current = range ? newValue : [newValue];
    }

    moveCount.current = 0;
    document.addEventListener('touchmove', handleTouchMove);
    document.addEventListener('touchend', handleTouchEnd);
  }, []);
  var stopListening = React__default['default'].useCallback(function () {
    document.removeEventListener('mousemove', handleTouchMove);
    document.removeEventListener('mouseup', handleTouchEnd);
    document.removeEventListener('touchmove', handleTouchMove);
    document.removeEventListener('touchend', handleTouchEnd);
  }, [handleTouchEnd, handleTouchMove]);
  React.useEffect(function () {
    var slider = sliderRef.current;
    !disabled && (slider === null || slider === void 0 ? void 0 : slider.addEventListener('touchstart', handleTouchStart, {
      passive: doesSupportTouchActionNone()
    }));
    return function () {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      slider === null || slider === void 0 ? void 0 : slider.removeEventListener('touchstart', handleTouchStart, {
        passive: doesSupportTouchActionNone()
      });
      stopListening();
    };
  }, [stopListening, handleTouchStart]);
  React.useEffect(function () {
    if (disabled) {
      stopListening();
    }
  }, [disabled, stopListening]);

  var getContainerProps = function getContainerProps(otherHandlers) {
    var ownEventHandlers = !disabled && {
      onMouseDown: createHandleMouseDown(otherHandlers || {})
    };

    var mergedEventHandlers = _objectSpread2(_objectSpread2({}, otherHandlers), ownEventHandlers);

    return _objectSpread2({
      ref: handleRef
    }, mergedEventHandlers);
  };

  var createHandleMouseDown = function createHandleMouseDown(otherHandlers) {
    return function (event) {
      var _otherHandlers$onMous;

      (_otherHandlers$onMous = otherHandlers.onMouseDown) === null || _otherHandlers$onMous === void 0 ? void 0 : _otherHandlers$onMous.call(otherHandlers, event);

      if (event.defaultPrevented) {
        return;
      } // Only handle left clicks


      if (event.button !== 0) {
        return;
      } // Avoid text selection


      event.preventDefault();
      var finger = trackFinger(event, touchId);

      if (finger !== false) {
        var _getFingerNewValue4 = getFingerNewValue({
          finger: finger,
          values: valuesRef.current
        }),
            newValue = _getFingerNewValue4.newValue,
            activeIndex = _getFingerNewValue4.activeIndex;

        focusThumb({
          sliderRef: sliderRef,
          activeIndex: activeIndex,
          setActive: setActive
        });
        setValueState(range ? newValue : [newValue]);
        valuesRef.current = range ? newValue : [newValue];
      }

      moveCount.current = 0;
      document.addEventListener('mousemove', handleTouchMove);
      document.addEventListener('mouseup', handleTouchEnd);
    };
  };

  var trackOffset = valueToPercent(range ? valueDerived[0] : min, min, max);
  var trackLeap = valueToPercent(valueDerived[valueDerived.length - 1], min, max) - trackOffset;

  var createHandleMouseOver = function createHandleMouseOver(otherHandlers) {
    return function (event) {
      var _otherHandlers$onMous2;

      (_otherHandlers$onMous2 = otherHandlers.onMouseOver) === null || _otherHandlers$onMous2 === void 0 ? void 0 : _otherHandlers$onMous2.call(otherHandlers, event);
    };
  };

  var createHandleMouseLeave = function createHandleMouseLeave(otherHandlers) {
    return function (event) {
      var _otherHandlers$onMous3;

      (_otherHandlers$onMous3 = otherHandlers.onMouseLeave) === null || _otherHandlers$onMous3 === void 0 ? void 0 : _otherHandlers$onMous3.call(otherHandlers, event);
    };
  };

  var getThumbProps = function getThumbProps(otherHandlers) {
    var ownEventHandlers = {
      onMouseOver: createHandleMouseOver(otherHandlers || {}),
      onMouseLeave: createHandleMouseLeave(otherHandlers || {})
    };

    var mergedEventHandlers = _objectSpread2(_objectSpread2({}, otherHandlers), ownEventHandlers);

    return _objectSpread2({}, mergedEventHandlers);
  };

  var getHiddenInputProps = function getHiddenInputProps(otherHandlers) {
    var ownEventHandlers = {
      onFocus: createHandleHiddenInputFocus(otherHandlers || {}),
      onBlur: createHandleHiddenInputBlur(otherHandlers || {})
    };

    var mergedEventHandlers = _objectSpread2(_objectSpread2({}, otherHandlers), ownEventHandlers);

    return _objectSpread2({
      type: 'range',
      min: props.min,
      max: props.max,
      step: props.step,
      disabled: disabled
    }, mergedEventHandlers);
  };

  return {
    axis: axis,
    axisProps: axisProps,
    getContainerProps: getContainerProps,
    getHiddenInputProps: getHiddenInputProps,
    getThumbProps: getThumbProps,
    values: valueDerived,
    active: active,
    focusVisible: focusVisible,
    range: range,
    trackOffset: trackOffset,
    trackLeap: trackLeap,
    marks: marks
  };
};

var asc = function asc(a, b) {
  return a - b;
};

var clamp = function clamp(value, min, max) {
  if (value === null) {
    return min;
  }

  return Math.min(Math.max(min, value), max);
};

var findClosest = function findClosest(values, currentValue) {
  var _values$reduce;

  var _ref2 = (_values$reduce = values.reduce(function (acc, value, index) {
    var distance = Math.abs(currentValue - value);

    if (acc === null || distance < acc.distance || distance === acc.distance) {
      return {
        distance: distance,
        index: index
      };
    }

    return acc;
  }, null)) !== null && _values$reduce !== void 0 ? _values$reduce : {},
      closestIndex = _ref2.index;

  return closestIndex;
};

var trackFinger = function trackFinger(event, touchId) {
  // The event is TouchEvent
  if (touchId.current !== undefined && event.changedTouches) {
    var touchEvent = event;

    for (var i = 0; i < touchEvent.changedTouches.length; i += 1) {
      var touch = touchEvent.changedTouches[i];

      if (touch.identifier === touchId.current) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }

    return false;
  } // The event is MouseEvent


  return {
    x: event.clientX,
    y: event.clientY
  };
};

var valueToPercent = function valueToPercent(value, min, max) {
  return (value - min) * 100 / (max - min);
};

var percentToValue = function percentToValue(percent, min, max) {
  return (max - min) * percent + min;
};

var getDecimalPrecision = function getDecimalPrecision(num) {
  // This handles the case when num is very small (0.00000001), js will turn this into 1e-8.
  // When num is bigger than 1 or less than -1 it won't get converted to this notation so it's fine.
  if (Math.abs(num) < 1) {
    var parts = num.toExponential().split('e-');
    var matissaDecimalPart = parts[0].split('.')[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }

  var decimalPart = num.toString().split('.')[1];
  return decimalPart ? decimalPart.length : 0;
};

var roundValueToStep = function roundValueToStep(value, step, min) {
  var nearest = Math.round((value - min) / step) * step + min;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
};

var setValueIndex = function setValueIndex(_ref3) {
  var values = _ref3.values,
      newValue = _ref3.newValue,
      index = _ref3.index;
  var output = values.slice();
  output[index] = newValue;
  return output.sort(asc);
};

var focusThumb = function focusThumb(_ref4) {
  var _sliderRef$current, _doc$activeElement;

  var sliderRef = _ref4.sliderRef,
      activeIndex = _ref4.activeIndex,
      setActive = _ref4.setActive;
  var doc = sliderRef.current || document;

  if (!((_sliderRef$current = sliderRef.current) !== null && _sliderRef$current !== void 0 && _sliderRef$current.contains(doc.activeElement)) || Number((_doc$activeElement = doc.activeElement) === null || _doc$activeElement === void 0 ? void 0 : _doc$activeElement.getAttribute('data-index')) !== activeIndex) {
    var _sliderRef$current2;

    (_sliderRef$current2 = sliderRef.current) === null || _sliderRef$current2 === void 0 ? void 0 : _sliderRef$current2.querySelector("[type=\"range\"][data-index=\"".concat(activeIndex, "\"]")).focus();
  }

  setActive && setActive(activeIndex);
};

var axisProps = {
  'horizontal': {
    offset: function offset(percent) {
      return {
        left: "".concat(percent, "%")
      };
    },
    leap: function leap(percent) {
      return {
        width: "".concat(percent, "%")
      };
    }
  },
  'horizontal-reverse': {
    offset: function offset(percent) {
      return {
        right: "".concat(percent, "%")
      };
    },
    leap: function leap(percent) {
      return {
        width: "".concat(percent, "%")
      };
    }
  },
  'vertical': {
    offset: function offset(percent) {
      return {
        top: 'unset',
        bottom: "".concat(percent, "%")
      };
    },
    leap: function leap(percent) {
      return {
        height: "".concat(percent, "%")
      };
    }
  }
};
var cachedSupportsTouchActionNone;

var doesSupportTouchActionNone = function doesSupportTouchActionNone() {
  if (cachedSupportsTouchActionNone === undefined) {
    if (typeof CSS !== 'undefined' && typeof CSS.supports === 'function') {
      cachedSupportsTouchActionNone = CSS.supports('touch-action', 'none');
    } else {
      cachedSupportsTouchActionNone = true;
    }
  }

  return cachedSupportsTouchActionNone;
};

var Slider = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _props$min = props.min,
      min = _props$min === void 0 ? 0 : _props$min,
      _props$max = props.max,
      max = _props$max === void 0 ? 30 : _props$max,
      _props$rangeSize = props.rangeSize,
      rangeSize = _props$rangeSize === void 0 ? '5px' : _props$rangeSize,
      railStyle = props.railStyle,
      _props$typeMark = props.typeMark,
      typeMark = _props$typeMark === void 0 ? 'dot' : _props$typeMark,
      _props$orientation = props.orientation,
      orientation = _props$orientation === void 0 ? 'horizontal' : _props$orientation,
      _props$rangeColor = props.rangeColor,
      rangeColor = _props$rangeColor === void 0 ? 'var(--v-primary-color)' : _props$rangeColor,
      wrapper = props.wrapper,
      _props$thumbSize = props.thumbSize,
      thumbSize = _props$thumbSize === void 0 ? '14px' : _props$thumbSize,
      thumbCustom = props.thumbCustom,
      _props$thumbColor = props.thumbColor,
      thumbColor = _props$thumbColor === void 0 ? 'var(--v-primary-color)' : _props$thumbColor,
      marksProps = props.marks,
      reverse = props.reverse,
      disabled = props.disabled,
      showIndicator = props.showIndicator,
      displayMap = props.displayMap;

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isShowIndicator = _useState2[0],
      setIsShowIndicator = _useState2[1];

  var _setTrackDimensions = React.useRef(null);

  var _useSlider = useSlider(_objectSpread2(_objectSpread2({}, props), {}, {
    ref: ref
  })),
      axisProps = _useSlider.axisProps,
      getContainerProps = _useSlider.getContainerProps,
      getHiddenInputProps = _useSlider.getHiddenInputProps,
      getThumbProps = _useSlider.getThumbProps,
      active = _useSlider.active,
      axis = _useSlider.axis,
      focusVisible = _useSlider.focusVisible,
      values = _useSlider.values,
      trackOffset = _useSlider.trackOffset,
      trackLeap = _useSlider.trackLeap,
      marks = _useSlider.marks;

  var hiddenInputProps = getHiddenInputProps();
  var containerProps = getContainerProps();

  var trackStyle = _objectSpread2(_objectSpread2({}, axisProps[axis].offset(trackOffset)), axisProps[axis].leap(trackLeap));

  var renderWrapper = function renderWrapper(data, type) {
    if (typeof data === 'string' || typeof data === 'number') {
      return /*#__PURE__*/jsxRuntime.jsx(TB1, {
        className: "wrapper-".concat(type),
        children: data
      });
    }

    return data;
  };

  var thumbSizeNumb = parseInt(thumbSize, 10) + 4;
  var isVertical = orientation === 'vertical';
  var containerClasses = clsx__default['default']('range-slider__container', reverse && 'range-slider__container--reverse', isVertical && 'range-slider__container--vertical', disabled && 'disabled');
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: 'range-slider__labels-container',
    style: isVertical ? {
      height: '100%',
      display: 'flex'
    } : undefined,
    children: [/*#__PURE__*/jsxRuntime.jsxs("div", _objectSpread2(_objectSpread2({
      className: containerClasses,
      style: {
        padding: !isVertical ? "calc((".concat(thumbSize, " / 2) + 0.5rem) 0") : 0
      }
    }, containerProps), {}, {
      children: [reverse ? (wrapper === null || wrapper === void 0 ? void 0 : wrapper.right) && renderWrapper(wrapper.right, 'left') : (wrapper === null || wrapper === void 0 ? void 0 : wrapper.left) && renderWrapper(wrapper.left, 'right'), /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "range-slider__content",
        children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
          style: {
            width: !isVertical ? '100%' : rangeSize,
            height: !isVertical ? rangeSize : '100%'
          },
          children: [/*#__PURE__*/jsxRuntime.jsx(Rail, {
            style: railStyle
          }), /*#__PURE__*/jsxRuntime.jsx(Track, {
            trackRef: _setTrackDimensions,
            style: _objectSpread2({}, trackStyle),
            rangeColor: rangeColor,
            disabled: disabled
          }), marks && /*#__PURE__*/jsxRuntime.jsx(SliderMarks, {
            positions: Object.keys(marks).map(function (mark) {
              return parseFloat(mark);
            }),
            size: rangeSize,
            type: typeMark,
            color: rangeColor,
            disabled: disabled,
            isMarkStep: marksProps && typeof marksProps === 'boolean',
            isVertical: isVertical,
            reverse: isVertical ? false : reverse
          })]
        }), values === null || values === void 0 ? void 0 : values.map(function (value, index) {
          var _clsx;

          var percent = valueToPercent(value, min, max);
          var style = axisProps[axis].offset(percent);
          return /*#__PURE__*/jsxRuntime.jsx(React__default['default'].Fragment, {
            children: /*#__PURE__*/jsxRuntime.jsx(RangeThumb, _objectSpread2(_objectSpread2({
              value: valueToPercent(value, min, max),
              "data-index": index
            }, getThumbProps()), {}, {
              className: clsx__default['default']((_clsx = {}, _defineProperty$1(_clsx, 'slider__thumb--active', active === index), _defineProperty$1(_clsx, 'slider__thumb--focus-visible', focusVisible === index), _clsx)),
              style: style,
              custom: isThumbCustomizedStartToEnd(thumbCustom) ? index === 0 ? thumbCustom.start : thumbCustom.end : thumbCustom,
              rangeSize: rangeSize,
              disabled: disabled,
              size: thumbSize,
              color: thumbColor,
              isShowIndicator: isShowIndicator,
              displayMap: displayMap,
              isVertical: isVertical,
              setShowIndicator: function setShowIndicator(isShowIndicator) {
                return showIndicator && !!displayMap && setIsShowIndicator(isShowIndicator);
              },
              children: /*#__PURE__*/jsxRuntime.jsx(Input, _objectSpread2(_objectSpread2({}, hiddenInputProps), {}, {
                "data-index": index,
                value: values[index],
                className: "slider__thumb-input thumb-real-size-".concat(thumbSizeNumb)
              }))
            }))
          }, index);
        })]
      }), reverse ? (wrapper === null || wrapper === void 0 ? void 0 : wrapper.left) && renderWrapper(wrapper.left, 'right') : (wrapper === null || wrapper === void 0 ? void 0 : wrapper.right) && renderWrapper(wrapper.right, 'right')]
    })), marksProps && /*#__PURE__*/jsxRuntime.jsx(SliderLabels, {
      marks: marks,
      isVertical: isVertical,
      reverse: isVertical ? false : reverse
    })]
  });
});

var isThumbCustomizedStartToEnd = function isThumbCustomizedStartToEnd(thumbCustom) {
  return _typeof(thumbCustom) === 'object' && !!thumbCustom && 'start' in thumbCustom && 'end' in thumbCustom;
};

var RangeDateTime = function RangeDateTime(props) {
  var _props$rangeTime = props.rangeTime,
      rangeTime = _props$rangeTime === void 0 ? [0, 24] : _props$rangeTime,
      onAfterChange = props.onAfterChange;
  var startTime = rangeTime && rangeTime.length === 2 ? rangeTime[0] : 0;
  var endTime = rangeTime && rangeTime.length === 2 ? rangeTime[1] : 24;

  var dateDisplay = function dateDisplay(time) {
    return time >= 24 ? 'Tomorrow' : time < 0 ? 'Yesterday' : 'Today';
  };

  var timeDisplay = function timeDisplay(time) {
    var adjustedTime = time > 24 ? time - 24 : time < 0 ? time + 24 : time;

    if (adjustedTime === 24 || adjustedTime === 0) {
      return '12 am';
    }

    if (adjustedTime === 12) {
      return '12 pm';
    }

    return adjustedTime < 12 ? adjustedTime + ' am' : adjustedTime - 12 + ' pm';
  };

  var displayMap = {};

  for (var i = 0; i <= 40; i++) {
    displayMap[i * 2.5] = "".concat(timeDisplay(i - 8));
  }

  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: 'range-date-time-container',
    children: [/*#__PURE__*/jsxRuntime.jsx(Slider, {
      max: 32,
      min: -8,
      value: rangeTime,
      thumbSize: '12px',
      rangeSize: '3px',
      step: 1,
      typeMark: 'line',
      displayMap: displayMap,
      range: true,
      showIndicator: true,
      onAfterChange: onAfterChange
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: 'range-date-time-display',
      children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
        children: [dateDisplay(startTime), " ", timeDisplay(startTime)]
      }), /*#__PURE__*/jsxRuntime.jsx("div", {
        children: "-"
      }), /*#__PURE__*/jsxRuntime.jsxs("div", {
        children: [dateDisplay(endTime), " ", timeDisplay(endTime)]
      })]
    })]
  });
};

var Time = function Time(props) {
  var moment = props.moment,
      onChange = props.onChange,
      minStep = props.minStep,
      hourStep = props.hourStep,
      minTime = props.minTime,
      maxTime = props.maxTime,
      className = props.className;

  var _useState = React.useState(moment === null || moment === void 0 ? void 0 : moment.clone()),
      _useState2 = _slicedToArray(_useState, 2),
      displayMoment = _useState2[0],
      setDisplayMoment = _useState2[1];

  var displayMomentRef = React.useRef(moment === null || moment === void 0 ? void 0 : moment.clone());
  React.useEffect(function () {
    setDisplayMoment(moment.clone());
    displayMomentRef.current = moment.clone();
  }, [moment]);

  var changeHours = function changeHours(hour) {
    var m = displayMomentRef.current.clone();
    m.hours(hour);
    setDisplayMoment(m);
    displayMomentRef.current = m;
  };

  var changeMinutes = function changeMinutes(minute) {
    var m = displayMomentRef.current.clone();
    m.minutes(minute);
    setDisplayMoment(m);
    displayMomentRef.current = m;
  };

  var onDragEnd = function onDragEnd() {
    onChange && onChange(displayMomentRef.current);
  };

  var m = displayMoment;
  var minHour = (minTime === null || minTime === void 0 ? void 0 : minTime.hour()) || 0;
  var minMin = 0;

  if (minTime && m.hour() === minHour) {
    minMin = minTime.minute();

    if (minMin > m.get('minute')) {
      changeMinutes(minMin);
    }
  }

  var maxHour = (maxTime === null || maxTime === void 0 ? void 0 : maxTime.hour()) || 23;
  var maxMin = 59;

  if (maxTime && m.hour() === maxHour) {
    maxMin = maxTime.minute();

    if (maxMin < m.get('minute')) {
      changeMinutes(maxMin);
    }
  }

  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: clsx__default['default']('m-time', className),
    children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
      className: "showtime",
      children: [/*#__PURE__*/jsxRuntime.jsx("span", {
        className: "time",
        children: m.format('HH')
      }), /*#__PURE__*/jsxRuntime.jsx("span", {
        className: "separater",
        children: ":"
      }), /*#__PURE__*/jsxRuntime.jsx("span", {
        className: "time",
        children: m.format('mm')
      })]
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: "sliders",
      children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "time-text",
        children: [/*#__PURE__*/jsxRuntime.jsx(T, {
          children: "Gi\u1EDD"
        }), ":"]
      }), /*#__PURE__*/jsxRuntime.jsx(Slider, {
        min: minHour,
        max: maxHour,
        step: hourStep,
        value: m.hour(),
        onChange: function onChange(x) {
          return changeHours(x);
        },
        onAfterChange: onDragEnd
      }), /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "time-text",
        children: [/*#__PURE__*/jsxRuntime.jsx(T, {
          children: "Ph\xFAt"
        }), ":"]
      }), /*#__PURE__*/jsxRuntime.jsx(Slider, {
        min: minMin,
        max: maxMin,
        step: minStep,
        value: m.minute(),
        onChange: function onChange(value) {
          return changeMinutes(value);
        },
        onAfterChange: onDragEnd
      })]
    })]
  });
};

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

var _baseSlice = baseSlice;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

var eq_1 = eq;

/** Detect free variable `global` from Node.js. */

var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal || freeSelf || Function('return this')();

var _root = root;

/** Built-in value references. */
var Symbol$1 = _root.Symbol;

var _Symbol = Symbol$1;

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$c.toString;

/** Built-in value references. */
var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$9.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

var _getRawTag = getRawTag;

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$b.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

var _objectToString = objectToString;

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}

var _baseGetTag = baseGetTag;

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject;

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$2 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject_1(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = _baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}

var isFunction_1 = isFunction;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}

var isLength_1 = isLength;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength_1(value.length) && !isFunction_1(value);
}

var isArrayLike_1 = isArrayLike;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

var _isIndex = isIndex;

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject_1(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike_1(object) && _isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq_1(object[index], value);
  }
  return false;
}

var _isIterateeCall = isIterateeCall;

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

var _trimmedEndIndex = trimmedEndIndex;

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

var _baseTrim = baseTrim;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike;

/** `Object#toString` result references. */
var symbolTag$2 = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag$2);
}

var isSymbol_1 = isSymbol;

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol_1(value)) {
    return NAN;
  }
  if (isObject_1(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject_1(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = _baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var toNumber_1 = toNumber;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_1(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

var toFinite_1 = toFinite;

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite_1(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

var toInteger_1 = toInteger;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil$1 = Math.ceil,
    nativeMax$1 = Math.max;

/**
 * Creates an array of elements split into groups the length of `size`.
 * If `array` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * _.chunk(['a', 'b', 'c', 'd'], 2);
 * // => [['a', 'b'], ['c', 'd']]
 *
 * _.chunk(['a', 'b', 'c', 'd'], 3);
 * // => [['a', 'b', 'c'], ['d']]
 */
function chunk(array, size, guard) {
  if ((guard ? _isIterateeCall(array, size, guard) : size === undefined)) {
    size = 1;
  } else {
    size = nativeMax$1(toInteger_1(size), 0);
  }
  var length = array == null ? 0 : array.length;
  if (!length || size < 1) {
    return [];
  }
  var index = 0,
      resIndex = 0,
      result = Array(nativeCeil$1(length / size));

  while (index < length) {
    result[resIndex++] = _baseSlice(array, index, (index += size));
  }
  return result;
}

var chunk_1 = chunk;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

var _baseRange = baseRange;

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && _isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite_1(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite_1(end);
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite_1(step);
    return _baseRange(start, end, step, fromRight);
  };
}

var _createRange = createRange;

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = _createRange();

var range_1 = range;

var Day = function Day(props) {
  var day = props.day,
      week = props.week,
      currentValue = props.currentValue,
      className = props.className,
      valid = props.valid,
      onClick = props.onClick;
  var prevMonth = week === 0 && day > 7;
  var nextMonth = week >= 4 && day <= 14;
  var tdClasses = clsx__default['default']({
    'prev-month': prevMonth,
    'next-month': nextMonth,
    'current-value': currentValue,
    'invalid': !valid
  });

  var handleClick = function handleClick() {
    valid && onClick && onClick();
  };

  return /*#__PURE__*/jsxRuntime.jsx("td", {
    className: tdClasses,
    onClick: handleClick,
    children: /*#__PURE__*/jsxRuntime.jsx("div", {
      className: clsx__default['default']('day-content', className),
      children: day
    })
  });
};

var Month = function Month(props) {
  var label = props.label,
      selected = props.selected,
      valid = props.valid,
      onClick = props.onClick;

  var handleClick = function handleClick() {
    return valid && onClick && onClick();
  };

  return /*#__PURE__*/jsxRuntime.jsx("td", {
    className: clsx__default['default']('month-item', selected && 'current-value', !valid && 'invalid'),
    onClick: handleClick,
    children: /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'month-content',
      children: label
    })
  });
};

var MonthPicker = function MonthPicker(props) {
  var className = props.className,
      value = props.value,
      onChange = props.onChange,
      minDate = props.minDate,
      maxDate = props.maxDate;
  var currentValue = (value === null || value === void 0 ? void 0 : value.clone()) || moment__default['default']();

  var handleClick = function handleClick(month_index) {
    var newMoment = currentValue.clone().set('month', month_index);
    onChange && onChange(newMoment);
  };

  var isMinValid = function isMinValid(m) {
    return !minDate || m && m.isSameOrAfter(minDate, 'month');
  };

  var isMaxValid = function isMaxValid(m) {
    return !maxDate || m && m.isSameOrBefore(maxDate, 'month');
  };

  var isCurrent = function isCurrent(m) {
    return m && m.isSame(currentValue, 'month');
  };

  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: clsx__default['default']('m-calendar', className),
    children: /*#__PURE__*/jsxRuntime.jsx("table", {
      children: /*#__PURE__*/jsxRuntime.jsx("tbody", {
        children: chunk_1(Array(12), 3).map(function (row, row_index) {
          return /*#__PURE__*/jsxRuntime.jsx("tr", {
            children: row.map(function (i, col_index) {
              var monthIndex = row_index * 3 + col_index;
              var current = currentValue.clone().set('month', monthIndex);
              return /*#__PURE__*/jsxRuntime.jsx(Month, {
                label: current.format('MMMM'),
                valid: isMinValid(current) && isMaxValid(current),
                selected: isCurrent(current),
                onClick: function onClick() {
                  return handleClick(monthIndex);
                }
              }, col_index);
            })
          }, row_index);
        })
      })
    })
  });
};

var YearPicker = function YearPicker(props) {
  var value = props.value,
      onChange = props.onChange,
      minDate = props.minDate,
      maxDate = props.maxDate;
  var currentValue = (value === null || value === void 0 ? void 0 : value.clone()) || moment__default['default']();

  var getYears = function getYears(currentYear) {
    return [].concat(range_1(currentYear - 7, currentYear), [currentYear], range_1(currentYear + 1, currentYear + 8));
  };

  var _useState = React.useState(currentValue.get('year')),
      _useState2 = _slicedToArray(_useState, 2),
      center = _useState2[0],
      setCenter = _useState2[1];

  var _useState3 = React.useState(getYears(center) || []),
      _useState4 = _slicedToArray(_useState3, 2),
      years = _useState4[0],
      setYears = _useState4[1];

  var handleClick = function handleClick(year) {
    var newMoment = currentValue.set('year', year);
    onChange && onChange(newMoment);
  };

  var prevBatch = function prevBatch() {
    setCenter(center - 15);
    setYears(getYears(center - 15));
  };

  var nextBatch = function nextBatch() {
    setCenter(center + 15);
    setYears(getYears(center + 15));
  };

  var isMinValid = function isMinValid(y) {
    return !minDate || minDate.get('year') <= y;
  };

  var isMaxValid = function isMaxValid(y) {
    return !maxDate || maxDate.get('year') >= y;
  };

  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: "m-calendar ".concat(props.className),
    children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
      className: "toolbar",
      children: [/*#__PURE__*/jsxRuntime.jsx("button", {
        type: "button",
        className: "prev-month",
        onClick: prevBatch,
        children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          type: "solid",
          icon: "angle-left"
        })
      }), /*#__PURE__*/jsxRuntime.jsx("button", {
        type: "button",
        className: "next-month",
        onClick: nextBatch,
        children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          type: "solid",
          icon: "angle-right"
        })
      })]
    }), /*#__PURE__*/jsxRuntime.jsx("table", {
      children: /*#__PURE__*/jsxRuntime.jsx("tbody", {
        children: chunk_1(years, 3).map(function (row, row_index) {
          return /*#__PURE__*/jsxRuntime.jsx("tr", {
            children: row.map(function (i) {
              return /*#__PURE__*/jsxRuntime.jsx(Year, {
                label: i,
                valid: isMinValid(i) && isMaxValid(i),
                selected: i === currentValue.get('year'),
                onClick: function onClick() {
                  return handleClick(i);
                }
              }, i);
            })
          }, row_index);
        })
      })
    })]
  });
};

var Year = function Year(props) {
  var label = props.label,
      valid = props.valid,
      selected = props.selected,
      onClick = props.onClick;

  var handleClick = function handleClick() {
    return valid && onClick();
  };

  return /*#__PURE__*/jsxRuntime.jsx("td", {
    className: clsx__default['default']('year-item', selected && 'current-value', !valid && 'invalid'),
    onClick: handleClick,
    children: /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'year-content',
      children: label
    })
  });
};

var Calendar = function Calendar(props) {
  var value = props.value,
      minDate = props.minDate,
      maxDate = props.maxDate,
      onChange = props.onChange,
      onMonthYearChange = props.onMonthYearChange,
      highlightDates = props.highlightDates;
  var currentValue = (value === null || value === void 0 ? void 0 : value.clone()) || moment__default['default']();

  var _useState = React.useState(currentValue),
      _useState2 = _slicedToArray(_useState, 2),
      display = _useState2[0],
      setDisplay = _useState2[1];

  var _useState3 = React.useState('date'),
      _useState4 = _slicedToArray(_useState3, 2),
      picker = _useState4[0],
      setPicker = _useState4[1];

  React.useEffect(function () {
    setDisplay(currentValue); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [value]);

  var getDate = function getDate(day, week) {
    var prevMonth = week === 0 && day > 7;
    var nextMonth = week >= 4 && day <= 14;
    var m = display.clone();

    if (prevMonth) {
      m.subtract(1, 'month');
    }

    if (nextMonth) {
      m.add(1, 'month');
    }

    m.date(day);
    return m;
  };

  var selectDate = function selectDate(day, week) {
    var m = getDate(day, week);
    onChange && onChange(m);
  };

  var prevMonth = function prevMonth(e) {
    e.preventDefault();
    var value = display.clone().subtract(1, 'month');
    setDisplay(value);
    onMonthYearChange && onMonthYearChange(value);
  };

  var nextMonth = function nextMonth(e) {
    e.preventDefault();
    var value = display.clone().add(1, 'month');
    setDisplay(value);
    onMonthYearChange && onMonthYearChange(value);
  };

  var nextYear = function nextYear() {
    var value = display.clone().add(1, 'year');
    setDisplay(value);
    props.onMonthYearChange && props.onMonthYearChange(value);
  };

  var prevYear = function prevYear() {
    var value = display.clone().subtract(1, 'year');
    setDisplay(value);
    props.onMonthYearChange && props.onMonthYearChange(value);
  };

  var handleChangeDisplay = function handleChangeDisplay(value) {
    setPicker('date');
    setDisplay(value);
    props.onMonthYearChange && props.onMonthYearChange(value);
  };

  var isMinValid = function isMinValid(m, minMoment) {
    return !minMoment || m && m.isSameOrAfter(minMoment, 'day');
  };

  var isMaxValid = function isMaxValid(m, maxMoment) {
    return !maxMoment || m && m.isSameOrBefore(maxMoment, 'day');
  };

  var d1 = display.clone().subtract(1, 'month').endOf('month').date();
  var d2 = display.clone().date(1).day();
  var d3 = display.clone().endOf('month').date();
  var days = [].concat(range_1(d1 - d2 + 1, d1 + 1), range_1(1, d3 + 1), range_1(1, 42 - d3 - d2 + 1));
  var weeks = ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'];
  var disabled = props.disabled;
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [picker === 'date' && /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: clsx__default['default']('m-calendar', props.className),
      children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "toolbar",
        children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
          className: "button-group",
          children: [/*#__PURE__*/jsxRuntime.jsx("button", {
            type: "button",
            className: "prev-month",
            disabled: disabled,
            onClick: prevYear,
            children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
              icon: "angle-double-left"
            })
          }), /*#__PURE__*/jsxRuntime.jsx("button", {
            type: "button",
            className: "prev-month",
            disabled: disabled,
            onClick: prevMonth,
            children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
              icon: "angle-left"
            })
          })]
        }), /*#__PURE__*/jsxRuntime.jsxs("span", {
          className: "current-date",
          children: [/*#__PURE__*/jsxRuntime.jsx("button", {
            onClick: function onClick() {
              return setPicker('month');
            },
            children: display.format('MMMM')
          }), /*#__PURE__*/jsxRuntime.jsx("button", {
            onClick: function onClick() {
              return setPicker('year');
            },
            children: display.format('YYYY')
          })]
        }), /*#__PURE__*/jsxRuntime.jsxs("div", {
          className: "button-group",
          children: [/*#__PURE__*/jsxRuntime.jsx("button", {
            type: "button",
            className: "next-month",
            disabled: disabled,
            onClick: nextMonth,
            children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
              icon: "angle-right"
            })
          }), /*#__PURE__*/jsxRuntime.jsx("button", {
            type: "button",
            className: "prev-month",
            disabled: disabled,
            onClick: nextYear,
            children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
              icon: "angle-double-right"
            })
          })]
        })]
      }), /*#__PURE__*/jsxRuntime.jsxs("table", {
        children: [/*#__PURE__*/jsxRuntime.jsx("thead", {
          children: /*#__PURE__*/jsxRuntime.jsx("tr", {
            children: weeks.map(function (w, i) {
              return /*#__PURE__*/jsxRuntime.jsx("td", {
                children: /*#__PURE__*/jsxRuntime.jsx(T, {
                  children: w
                })
              }, i);
            })
          })
        }), /*#__PURE__*/jsxRuntime.jsx("tbody", {
          children: chunk_1(days, 7).map(function (row, week) {
            return /*#__PURE__*/jsxRuntime.jsx("tr", {
              children: row.map(function (day) {
                var isHighlighted = false;
                var current = getDate(day, week);

                if (Array.isArray(highlightDates) && highlightDates.find(function (x) {
                  return moment__default['default'](x).format('DD/MM/YYYY') === current.format('DD/MM/YYYY');
                })) {
                  isHighlighted = true;
                }

                return /*#__PURE__*/jsxRuntime.jsx(Day, {
                  className: isHighlighted ? 'highlight' : "".concat(current.isSame(moment__default['default'](), 'date') ? 'today' : ''),
                  day: day,
                  week: week,
                  valid: isMaxValid(current, maxDate) && isMinValid(current, minDate),
                  currentValue: current.isSame(currentValue, 'day'),
                  onClick: function onClick() {
                    return !disabled && selectDate(day, week);
                  }
                }, current.format('DD-MM-YYYY'));
              })
            }, week);
          })
        })]
      })]
    }), picker === 'month' && /*#__PURE__*/jsxRuntime.jsx(MonthPicker, {
      value: display,
      minDate: minDate,
      maxDate: maxDate,
      onChange: handleChangeDisplay
    }), picker === 'year' && /*#__PURE__*/jsxRuntime.jsx(YearPicker, {
      value: display,
      minDate: minDate,
      maxDate: maxDate,
      onChange: handleChangeDisplay
    })]
  });
};

var InputMoment = function InputMoment(props) {
  var _props$rangeTime = props.rangeTime,
      rangeTime = _props$rangeTime === void 0 ? [0, 24] : _props$rangeTime,
      _props$minStep = props.minStep,
      minStep = _props$minStep === void 0 ? 1 : _props$minStep,
      _props$hourStep = props.hourStep,
      hourStep = _props$hourStep === void 0 ? 1 : _props$hourStep;
  var className = props.className,
      m = props.moment,
      onTab = props.onTab,
      onChange = props.onChange,
      showTimeSelect = props.showTimeSelect,
      showTimeSelectOnly = props.showTimeSelectOnly,
      showTimeRange = props.showTimeRange,
      disabled = props.disabled,
      minDate = props.minDate,
      maxDate = props.maxDate,
      minTime = props.minTime,
      maxTime = props.maxTime,
      tab = props.tab;

  var _useState = React.useState(rangeTime),
      _useState2 = _slicedToArray(_useState, 2),
      rangeTimeLocal = _useState2[0],
      setRangeTimeLocal = _useState2[1];

  React.useEffect(function () {
    document.addEventListener('wheel', preventScroll, {
      capture: true,
      passive: false
    });
    return function () {
      document.removeEventListener('wheel', preventScroll, {
        capture: true
      });
      onTab(0);
    };
  }, [onTab]);

  var preventScroll = function preventScroll(event) {
    event.preventDefault();
    event.stopPropagation();
  };

  var handleClickTab = function handleClickTab(e, tab) {
    e.preventDefault();
    onTab(tab);
  };

  var handleCalendarChange = function handleCalendarChange(value) {
    if (showTimeRange) {
      onChange && onChange(value, rangeTime);
    } else {
      onChange && onChange(value);
    }
  };

  var handleRangeTimeChange = function handleRangeTimeChange(rangeTime) {
    if (Array.isArray(rangeTime)) {
      onChange && m && onChange(m, rangeTime);
      setRangeTimeLocal(rangeTime);
    }
  };

  var handleChooseToday = function handleChooseToday() {
    var today = moment__default['default']();
    onChange && onChange(today);
  };

  var handleClearValue = function handleClearValue() {
    onChange && onChange(null);
  };

  var cls = classnames('m-input-moment', className);
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: cls,
    children: [showTimeSelect && !showTimeSelectOnly && /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: "options",
      children: [/*#__PURE__*/jsxRuntime.jsx("button", {
        type: "button",
        className: classnames('ion-calendar im-btn', {
          'active': tab === 0 || tab === 'month' || tab === 'year'
        }),
        disabled: disabled,
        onClick: function onClick(e) {
          return handleClickTab(e, 0);
        },
        children: /*#__PURE__*/jsxRuntime.jsx(T, {
          children: "Ng\xE0y"
        })
      }), /*#__PURE__*/jsxRuntime.jsx("button", {
        type: "button",
        className: classnames('ion-clock im-btn', {
          'active': tab === 1
        }),
        disabled: disabled,
        onClick: function onClick(e) {
          return handleClickTab(e, 1);
        },
        children: /*#__PURE__*/jsxRuntime.jsx(T, {
          children: "Gi\u1EDD"
        })
      })]
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: "tabs",
      children: [!showTimeSelectOnly && tab === 0 && /*#__PURE__*/jsxRuntime.jsx(Calendar, {
        className: 'tab',
        value: m,
        disabled: disabled,
        minDate: minDate,
        maxDate: maxDate,
        onChange: handleCalendarChange
      }), (showTimeSelectOnly || showTimeSelect && tab === 1) && /*#__PURE__*/jsxRuntime.jsx(Time, {
        className: 'tab',
        moment: m || moment__default['default'](new Date()),
        minStep: minStep,
        hourStep: hourStep,
        minTime: minTime,
        maxTime: maxTime,
        onChange: onChange
      }), showTimeRange && /*#__PURE__*/jsxRuntime.jsx(RangeDateTime, {
        rangeTime: rangeTimeLocal,
        onAfterChange: handleRangeTimeChange
      })]
    }), !showTimeRange && !showTimeSelectOnly && tab === 0 && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "footer",
      children: /*#__PURE__*/jsxRuntime.jsxs(Row2, {
        justify: "center",
        gap: 2,
        children: [/*#__PURE__*/jsxRuntime.jsx(Button, {
          color: "primary",
          text: "H\xF4m nay",
          onClick: handleChooseToday
        }), /*#__PURE__*/jsxRuntime.jsx(Button, {
          color: "primary",
          variant: "outline",
          text: "Xo\xE1",
          onClick: handleClearValue
        })]
      })
    })]
  });
};

var useFormat = function useFormat() {
  var onlyNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

  // to re-setSelectionRange. If using focusIndex as state, useEffect wont run when focusIndex is set same value
  var _useState = React.useState(true),
      _useState2 = _slicedToArray(_useState, 2),
      toggle = _useState2[0],
      setToggle = _useState2[1];

  var _useState3 = React.useState(''),
      _useState4 = _slicedToArray(_useState3, 2),
      prevValue = _useState4[0],
      setPreValue = _useState4[1];

  var inputRef = React.useRef(null);
  var format = React.useRef('');
  var indexOfSpec = React.useRef([]);
  var focusIndex = React.useRef();
  React.useEffect(function () {
    focusIndex.current && inputRef.current && inputRef.current.setSelectionRange(focusIndex.current, focusIndex.current);
  }, [toggle]);

  var formatValue = function formatValue(value) {
    if (!value || value.length > format.current.length) {
      return value;
    }

    if (onlyNumber) {
      value = value.replace(/[^0-9]/g, '');
    }

    var indexOfChange = value.length;

    if (inputRef.current) {
      indexOfChange = inputRef.current.selectionStart || indexOfChange;
    }

    if (prevValue.length >= value.length) {
      setPreValue(value);
      value = handleFormat(value, indexOfChange, true);
      return value;
    }

    setPreValue(value);
    value = handleFormat(value, indexOfChange);
    return value;
  };

  var handleFormat = function handleFormat(value, indexOfChange) {
    var isDecreased = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    // isDecreased means value.length is decreased
    var i = 0;
    var numOfSpecialChar = 0;

    while (i < indexOfSpec.current.length) {
      var number = indexOfSpec.current[i];

      if (number <= value.length) {
        value = value.slice(0, number) + format.current[number] + value.slice(number);
        number === indexOfChange && numOfSpecialChar++;
        i++;
        continue;
      }

      break;
    }

    var reFocusIndex = indexOfChange + numOfSpecialChar > value.length ? value.length : indexOfChange + numOfSpecialChar;
    focusIndex.current = indexOfSpec.current.includes(reFocusIndex - 1) ? isDecreased ? reFocusIndex - 1 : reFocusIndex + 1 : reFocusIndex;
    setToggle(!toggle);
    return value;
  };

  var setInput = function setInput(element) {
    return inputRef.current = element;
  };

  var setFormat = function setFormat(formatString) {
    format.current = formatString.replace(/[a-zA-Z0-9]/g, 'X');
    indexOfSpec.current = format.current.split('').map(function (_char, index) {
      return _char !== 'X' ? index : -1;
    }).filter(function (num) {
      return num >= 0;
    });
  };

  return {
    setInput: setInput,
    formatValue: formatValue,
    setFormat: setFormat
  };
};

// SmartForm
var DateTimePicker = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var className = props.className,
      onChange = props.onChange,
      customOnChange = props.customOnChange,
      rangeTime = props.rangeTime,
      minDate = props.minDate,
      maxDate = props.maxDate,
      minTime = props.minTime,
      maxTime = props.maxTime;
  var showTimeSelect = props.showTimeSelect,
      showTimeSelectOnly = props.showTimeSelectOnly,
      showTimeRange = props.showTimeRange,
      disabled = props.disabled,
      clearable = props.clearable,
      isVisible = props.isVisible,
      readOnly = props.readOnly;
  var value = props.value,
      placeholder = props.placeholder,
      name = props.name;

  var _useFormat = useFormat(),
      formatValue = _useFormat.formatValue,
      setFormat = _useFormat.setFormat,
      setInput = _useFormat.setInput;

  var _useI18n = useI18n(),
      t = _useI18n.t,
      language = _useI18n.language;

  var inputRef = React.useRef();
  var containerRef = React.useRef(null);

  var _useState = React.useState(isVisible),
      _useState2 = _slicedToArray(_useState, 2),
      visible = _useState2[0],
      setVisible = _useState2[1];

  var _useState3 = React.useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      localValue = _useState4[0],
      setLocalValue = _useState4[1];

  var _useState5 = React.useState([0, 24]),
      _useState6 = _slicedToArray(_useState5, 2),
      localRangeTime = _useState6[0],
      setLocalRangeTime = _useState6[1];

  var _useState7 = React.useState(null),
      _useState8 = _slicedToArray(_useState7, 2),
      inputValue = _useState8[0],
      setInputValue = _useState8[1];

  var _useState9 = React.useState(true),
      _useState10 = _slicedToArray(_useState9, 2),
      isFormat = _useState10[0],
      setIsFormat = _useState10[1];

  var _useState11 = React.useState(0),
      _useState12 = _slicedToArray(_useState11, 2),
      tab = _useState12[0],
      setTab = _useState12[1];

  React.useEffect(function () {
    if (rangeTime && rangeTime.length === 2) {
      var start = rangeTime[0];
      var end = rangeTime[1];

      if (start > end) {
        start = end;
        end = rangeTime[0];
      }

      if (start < 0 || start > 23) {
        start = 0;
      }

      if (end < 0 || end > 23) {
        end = 23;
      }

      setLocalRangeTime([start, end]);
    }

    value && setLocalValue(moment__default['default'](value));
  }, []); // DateTimePicker received a new date whenever Edit Form was called, but have no method to set the new date to the input box, so here it is

  React.useEffect(function () {
    if (!onChange && !value) {
      return;
    }

    if (!value) {
      return setLocalValue(null);
    }

    if (moment__default['default'](value).diff(localValue, 'minutes') !== 0 && value) {
      setLocalValue(moment__default['default'](value));
    }
  }, [onChange, value]);

  var closeControl = function closeControl() {
    return setVisible(false);
  };

  var handleControlClick = function handleControlClick() {
    return !disabled && !readOnly && setVisible(function (prev) {
      return !prev;
    });
  };

  var handleChange = function handleChange(val, rangeTime) {
    var _val;

    if (!showTimeSelect && !showTimeSelectOnly && val) {
      val = val.startOf('date');
    } // fake event, purpose to assign target for event, not to fire event, search for another approach later


    var event = new Event('input', {
      bubbles: true
    });
    inputRef.current && inputRef.current.dispatchEvent(event); // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error

    event.target.value = val;
    customOnChange && customOnChange(event);
    rangeTime && setLocalRangeTime(rangeTime);
    setLocalValue((_val = val) !== null && _val !== void 0 ? _val : null);
    setIsFormat(true);
    onChange && onChange(val, rangeTime);
    visible && !(showTimeSelectOnly || showTimeSelect && tab === 1) && closeControl();
    !isFormat && setIsFormat(true);
  };

  var formatValueControl = function formatValueControl() {
    if (!localValue) {
      return '';
    }

    var valueFormat = '';
    var localLocaleValue = localValue.clone().locale(language);

    if (showTimeSelectOnly) {
      valueFormat = localLocaleValue.format('LT');
    } else {
      if (showTimeRange) {
        var values = [];
        localRangeTime.forEach(function (time) {
          var dateAdjust = time > 24 ? localValue.get('date') + 1 : time < 0 ? localValue.get('date') - 1 : localValue.get('date');
          var timeAdjust = time > 24 ? time - 24 : time < 0 ? time + 24 : time;
          values.push(moment__default['default']().set('date', dateAdjust).hour(timeAdjust).minute(0).format('L hA'));
        });
        valueFormat = values.join(' - ');
      } else if (showTimeSelect) {
        valueFormat = localLocaleValue.format('L LT');
      } else {
        valueFormat = localLocaleValue.format('L');
      }
    }

    return valueFormat;
  };

  var handleClearValueClick = function handleClearValueClick(e) {
    e.stopPropagation();
    setLocalValue(null);
    onChange && onChange();
  };

  var handleValue = function handleValue(val) {
    customOnChange && customOnChange(val);
    setIsFormat(false);
    var longDateFormatL = moment__default['default'].localeData().longDateFormat('L');
    var longDateFormatLT = longDateFormatL + ' HH:mm';
    var timeFormat = 'HH:mm';
    var format = showTimeSelectOnly ? timeFormat : longDateFormatLT;
    setFormat(format);
    var defaultDate = props.value ? moment__default['default'](props.value) : moment__default['default']();
    var resultVal = formatValue(val);
    var cloneValue = resultVal;

    if (showTimeSelectOnly) {
      resultVal = defaultDate.format(longDateFormatL) + ' ' + resultVal;
    }

    var compareValue = moment__default['default'].utc(resultVal, longDateFormatLT);

    if (minDate) {
      var formattedMinDate = moment__default['default'].utc(moment__default['default'](minDate).format(longDateFormatLT), longDateFormatLT);
      var isBefore = moment__default['default'](compareValue).isBefore(formattedMinDate);
      resultVal = isBefore ? moment__default['default'](formattedMinDate).format(format) : resultVal;
    } else if (maxDate) {
      var formattedMaxDate = moment__default['default'].utc(maxDate, longDateFormatLT);
      var isAfter = moment__default['default'](compareValue).isAfter(formattedMaxDate);
      resultVal = isAfter ? moment__default['default'](formattedMaxDate).format(format) : resultVal;
    }

    var formattedValue = moment__default['default'].utc(resultVal, longDateFormatLT);
    onChange && (formattedValue.isValid() ? onChange(formattedValue) : onChange());
    setInputValue(cloneValue);
    setTab(cloneValue.length >= longDateFormatL.length ? 1 : 0);
  };

  var valueFormat = formatValueControl();
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    ref: containerRef,
    style: {
      width: '100%'
    },
    className: clsx__default['default']('dtp-container', disabled && 'dtp-container-disabled'),
    tabIndex: 0,
    children: [/*#__PURE__*/jsxRuntime.jsx(DateTimePickerController, {
      innerRef: function innerRef(el) {
        !!ref && isCallBackRef$4(ref) && ref(el);
        inputRef.current = el;
        el && setInput(el);
      },
      className: className,
      isVisible: visible,
      placeholder: t(placeholder),
      value: isFormat || inputValue && !visible ? valueFormat : typeof inputValue === 'string' ? inputValue : valueFormat,
      disabled: disabled,
      name: name,
      clearable: clearable,
      showTimeSelectOnly: showTimeSelectOnly,
      readOnly: readOnly,
      searchable: true // onSearch={val => setState({ searchKey: val })}
      ,
      onChange: handleValue,
      onClearValueClick: handleClearValueClick,
      onControlClick: handleControlClick
    }), visible && !disabled && /*#__PURE__*/jsxRuntime.jsx(AnchorOverlay, {
      anchorEl: containerRef,
      className: "dtp-overlay",
      width: '20rem',
      backdrop: false,
      children: /*#__PURE__*/jsxRuntime.jsx(InputMoment, _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({
        moment: localValue,
        rangeTime: localRangeTime,
        minStep: 1,
        hourStep: 1 // default
        ,
        showTimeSelect: showTimeSelect && !showTimeRange // default
        ,
        showTimeSelectOnly: showTimeSelectOnly && !showTimeRange,
        showTimeRange: showTimeRange
      }, minDate && {
        minDate: moment__default['default'](minDate)
      }), maxDate && {
        maxDate: moment__default['default'](maxDate)
      }), minTime && {
        minTime: moment__default['default'](minTime)
      }), maxTime && {
        minTime: moment__default['default'](maxTime)
      }), {}, {
        tab: tab,
        onTab: setTab,
        onChange: handleChange
      }))
    })]
  });
});

var FORM_GROUP_BASE_CLASSNAME = 'form-group';

/**
* Hook to control form's autofocus feature.
*/
var useFormAutoFocus = function useFormAutoFocus(_ref) {
  var autoFocus = _ref.autoFocus;
  React.useEffect(function () {
    if (!autoFocus || typeof window === 'undefined') {
      return;
    }

    var firstInputInsideFormGroup = document.querySelector("form.".concat(FORM_GROUP_BASE_CLASSNAME, " [data-autofocus=true]"));
    firstInputInsideFormGroup === null || firstInputInsideFormGroup === void 0 ? void 0 : firstInputInsideFormGroup.focus();
  }, [autoFocus]);
};

var _excluded$i = ["direction", "onSubmit", "children", "className", "autoFocus"];
var Form = function Form(props) {
  var _props$direction = props.direction,
      direction = _props$direction === void 0 ? 'column' : _props$direction,
      _props$onSubmit = props.onSubmit,
      onSubmit = _props$onSubmit === void 0 ? function () {
    return null;
  } : _props$onSubmit,
      children = props.children,
      className = props.className,
      autoFocus = props.autoFocus,
      restFormProps = _objectWithoutProperties(props, _excluded$i);

  useFormAutoFocus({
    autoFocus: autoFocus
  });
  var classes = clsx__default['default'](FORM_GROUP_BASE_CLASSNAME, "form-group-".concat(direction), className);
  return /*#__PURE__*/jsxRuntime.jsxs("form", _objectSpread2(_objectSpread2({}, restFormProps), {}, {
    className: classes,
    onSubmit: onSubmit,
    children: [children, /*#__PURE__*/jsxRuntime.jsx("input", {
      type: "submit",
      hidden: true
    })]
  }));
};

var _excluded$h = ["onChange", "customOnChange", "className", "color", "rows", "border"];
var RichText = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var onChange = props.onChange,
      customOnChange = props.customOnChange,
      className = props.className,
      color = props.color,
      _props$rows = props.rows,
      rows = _props$rows === void 0 ? 5 : _props$rows,
      _props$border = props.border,
      border = _props$border === void 0 ? 'block' : _props$border,
      restProps = _objectWithoutProperties(props, _excluded$h);

  var handleChange = function handleChange(event) {
    customOnChange && customOnChange(event);
    !customOnChange && typeof onChange === 'function' && onChange && onChange(event.target.value);
  };

  return /*#__PURE__*/jsxRuntime.jsx("textarea", _objectSpread2({
    ref: ref,
    className: className,
    style: {
      minHeight: rows * 17 + 'px',
      maxHeight: rows * 17 + 'px',
      color: color,
      padding: '5px',
      border: border
    },
    rows: rows,
    "data-autofocus": true,
    onChange: handleChange
  }, restProps));
});
RichText.displayName = 'RichText';

var InputPrepend = function InputPrepend(_ref) {
  var children = _ref.children,
      className = _ref.className;
  var classes = clsx__default['default']('input-prepend', className);
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: classes,
    children: typeof children === 'string' ? /*#__PURE__*/jsxRuntime.jsx("span", {
      children: /*#__PURE__*/jsxRuntime.jsx(T, {
        children: children
      })
    }) : children
  });
};

var _excluded$g = ["legendTypo", "align", "noBorder", "legend", "children"];
var FieldSet = function FieldSet(props) {
  var _props$legendTypo = props.legendTypo,
      legendTypo = _props$legendTypo === void 0 ? 'Sub1' : _props$legendTypo,
      _props$align = props.align,
      align = _props$align === void 0 ? 'center' : _props$align,
      _props$noBorder = props.noBorder,
      noBorder = _props$noBorder === void 0 ? true : _props$noBorder,
      legend = props.legend,
      children = props.children,
      restFieldSetProps = _objectWithoutProperties(props, _excluded$g);

  var fieldSetClasses = clsx__default['default'](noBorder && 'field-set__no-border');
  var legendClasses = clsx__default['default']('field-set-legend', "field-set-legend__".concat(align));
  return /*#__PURE__*/jsxRuntime.jsxs("fieldset", _objectSpread2(_objectSpread2({}, restFieldSetProps), {}, {
    className: fieldSetClasses,
    children: [noBorder && /*#__PURE__*/jsxRuntime.jsx(Typography, {
      variant: legendTypo,
      children: legend
    }), /*#__PURE__*/jsxRuntime.jsx("legend", {
      className: legendClasses,
      children: /*#__PURE__*/jsxRuntime.jsx(Typography, {
        variant: legendTypo,
        children: legend
      })
    }), children]
  }));
};

var _excluded$f = ["customOnChange", "onChange", "className", "autoFocus", "maxTextareaHeight", "rows", "defaultValue", "value", "id", "errorText"];
var MultilineInput = /*#__PURE__*/React.forwardRef(function (props, _ref) {
  var customOnChange = props.customOnChange,
      onChange = props.onChange,
      className = props.className,
      autoFocus = props.autoFocus,
      maxTextareaHeight = props.maxTextareaHeight,
      _props$rows = props.rows,
      rows = _props$rows === void 0 ? 2 : _props$rows,
      defaultValue = props.defaultValue,
      value = props.value,
      id = props.id,
      errorText = props.errorText,
      textareaProps = _objectWithoutProperties(props, _excluded$f);

  var inputRef = React.useRef(null);
  var scrollRef = React.useRef(null);

  var _containerRef = React.useRef(null);

  React.useEffect(function () {
    if (inputRef.current) {
      updateInputHeight();
    }
  }, []);
  React.useEffect(function () {
    updateInputHeight();
  }, [value]);

  var handleChange = function handleChange(event) {
    updateInputHeight();
    customOnChange && customOnChange(event);
    !customOnChange && onChange && onChange(event.target.value);
  };

  var updateInputHeight = function updateInputHeight() {
    var _scrollRef$current;

    if (!inputRef.current) {
      return;
    }

    inputRef.current.style.height = 'auto';
    inputRef.current.style.height = inputRef.current.scrollHeight + 'px';

    if (_containerRef.current) {
      _containerRef.current.scrollTop = inputRef.current.offsetHeight;
    }

    scrollRef === null || scrollRef === void 0 ? void 0 : (_scrollRef$current = scrollRef.current) === null || _scrollRef$current === void 0 ? void 0 : _scrollRef$current['updateScroll']();
  };

  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx("div", {
      className: "multiline_input".concat(className ? ' ' + className : ''),
      style: {
        height: maxTextareaHeight
      },
      children: /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
        ref: scrollRef,
        containerRef: function containerRef(element) {
          return _containerRef.current = element;
        },
        onSync: function onSync(_) {},
        children: /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "multiline_input",
          children: /*#__PURE__*/jsxRuntime.jsx("textarea", _objectSpread2(_objectSpread2({
            ref: function ref(e) {
              !!_ref && (isCallBackRef(_ref) ? _ref(e) : _ref.current = e);
              inputRef.current = e;
            }
          }, textareaProps), {}, {
            className: "post-textarea",
            id: id,
            autoComplete: "off",
            rows: rows,
            defaultValue: defaultValue,
            autoFocus: autoFocus,
            onChange: handleChange
          }))
        })
      })
    }), errorText && (typeof errorText === 'string' ? /*#__PURE__*/jsxRuntime.jsx(Sub1, {
      color: 'danger',
      children: errorText
    }) : errorText.map(function (text, index) {
      return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [/*#__PURE__*/jsxRuntime.jsx(Sub1, {
          color: 'danger',
          children: text
        }, "error-".concat(index)), /*#__PURE__*/jsxRuntime.jsx("br", {})]
      });
    }))]
  });
});
MultilineInput.displayName = 'MultilineInput';

var isCallBackRef = function isCallBackRef(ref) {
  return !('current' in ref);
};

var MAPPED_COMPONENTS = {
  Input: Input,
  FieldSet: FieldSet,
  FormControlLabel: FormControlLabel,
  Container: Container,
  Row: Row,
  Column: Column,
  Row2: Row2,
  Col2: Col2,
  Button: Button,
  EmptyButton: EmptyButton,
  InputGroup: InputGroup,
  InputAppend: InputAppend,
  InputPrepend: InputPrepend,
  RichText: RichText,
  CheckBox: CheckBox,
  AdvanceSelect: AdvanceSelect,
  DateTimePicker: DateTimePicker,
  MultilineInput: MultilineInput
};
var CUSTOMIZE_ONCHANGE_COMPONENTS = [Input, RichText, CheckBox, AdvanceSelect, DateTimePicker, MultilineInput]; // export const CONTROLLABLE_CHILDREN: (React.JSXElementConstructor<any> | string)[] = [ Input, RichText ];

var CONTROLLABLE_CHILDREN = [Input, RichText, CheckBox, AdvanceSelect, DateTimePicker, MultilineInput];
var WRAPPER_COMPONENTS = ['FieldSet', 'Container', 'Column', 'Row', 'Col2', 'Row2', 'InputGroup', 'InputAppend', 'InputPrepend'];
var CIRCULAR_OBJECT_IN_FORM_STATE = ['ref'];
var LOCAL_STORAGE_KEYS = {
  formState: 'formState'
};
var DEFAULT_ERROR_MESSAGE = {
  required: 'Trường này là bắt buộc.',
  min: 'Giá trị của trường nhỏ hơn giá trị tối thiểu.',
  max: 'Giá trị của trường lớn hơn giá trị tối đa.',
  minLength: 'số ký tự của trường nhỏ hơn giới hạn tối thiểu.',
  maxLength: 'Số ký tự của trường vượt quá giới hạn tối đa.',
  pattern: 'giá trị của trường sai mẫu.',
  validate: 'Giá trị của trường không hợp lệ.'
};

// Trigger an event when invoke localStorage.setItem
var originalSetItem = window.localStorage.setItem;

window.localStorage.setItem = function () {
  var event = new Event('storageChange');

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  originalSetItem.apply(this, args);
  document.dispatchEvent(event);
};
/**
* This hook responsibility is retrieve formSate collection from localStorage.
*
* Form state collection format: { [formId]: formState }
* @example const {formA: FormAState, formB: FormBState} = useFormStateCollectionTaker()
*
* Reference:
* {@link https://react-hook-form.com/api/useformstate react-hook-form formState}
*/


var useFormStateCollectionTaker = function useFormStateCollectionTaker() {
  var _useState = React.useState(getFormStateCollection),
      _useState2 = _slicedToArray(_useState, 2),
      collection = _useState2[0],
      setCollection = _useState2[1];

  React.useEffect(function () {
    document.addEventListener('storageChange', handleStorageChange);
    return function () {
      document.removeEventListener('storageChange', handleStorageChange);
    };
  }, []);

  var handleStorageChange = function handleStorageChange() {
    var collection = getFormStateCollection();
    var isEmptyObj = !Object.keys(collection).length;
    !isEmptyObj && setCollection(collection);
  };

  return collection;
};
var getFormStateCollection = function getFormStateCollection() {
  try {
    var collection = window.localStorage.getItem(LOCAL_STORAGE_KEYS.formState);
    return collection ? JSON.parse(collection) : {};
  } catch (error) {
    console.log(error);
    return {};
  }
};

/**
* This hook responsibility is retrieve formSate by formId from localStorage.
*
* Form state collection format: { [formId]: formState }
* @example const formState = useFormStateTaker({ formId: 'my-form })
*
* Reference:
* {@link https://react-hook-form.com/api/useformstate react-hook-form formState}
*/
var useFormStateTaker = function useFormStateTaker(_ref) {
  var formId = _ref.formId;
  var collection = useFormStateCollectionTaker();
  return collection[formId];
};

var useJsonToFormParser = function useJsonToFormParser(fields) {
  var generateFormChildren = function generateFormChildren(fields) {
    return fields.map(function (field) {
      return generateFormChild(field);
    });
  };

  var generateFormChild = function generateFormChild(field) {
    return isWrapperComponent(field) ? generateWrapperComponent(field) : generateFormFieldComponent(field);
  };

  var generateWrapperComponent = function generateWrapperComponent(field) {
    var props = field.props,
        component = field.component,
        fields = field.fields;
    var Component = MAPPED_COMPONENTS[component];
    return /*#__PURE__*/jsxRuntime.jsx(Component, _objectSpread2(_objectSpread2({}, props), {}, {
      children: generateFormChildren(fields)
    }), createUniqueId());
  };

  var generateFormFieldComponent = function generateFormFieldComponent(field) {
    var Component = MAPPED_COMPONENTS[field.component];
    var parsedProps = isFormControlLabelComponent(field) ? _objectSpread2(_objectSpread2({}, field.props), {}, {
      control: generateFormChild(field.props.control)
    }) : field.props;
    return /*#__PURE__*/jsxRuntime.jsx(Component, _objectSpread2({}, parsedProps), createUniqueId());
  };

  return {
    formChildren: generateFormChildren(fields)
  };
};

var isWrapperComponent = function isWrapperComponent(field) {
  return WRAPPER_COMPONENTS.includes(field.component);
};

var isFormControlLabelComponent = function isFormControlLabelComponent(field) {
  return field.component === 'FormControlLabel';
};

var _excluded$e = ["onChange"];

/**
* This hook responsibility is attach 'register' method and insert 'errors' object to wrapped controllable component.
*
* @return controlledChildren: children with 'register' and 'errors' attached
*/
var useSmartForm = function useSmartForm(_ref) {
  var children = _ref.children,
      register = _ref.register,
      errors = _ref.errors;

  var generateControlledChild = function generateControlledChild(children) {
    return reactChildrenUtilities.deepMap(children, controlChild);
  };

  var controlChild = function controlChild(child) {
    return isComponentAttachable(child) ? attachProps(child) : child;
  };

  var attachProps = function attachProps(child) {
    return isHaveControllableProps(child) ? attachControlProps(child) : attachChildProps(child);
  }; // This function only implement for component which received controllable component by it's 'control' props (exp: FormControlLabel)


  var attachControlProps = function attachControlProps(child) {
    var controlPropWithRegisterAttached = attachChildProps(child.props.control);
    return /*#__PURE__*/React.cloneElement(child, _objectSpread2(_objectSpread2({}, child.props), {}, {
      control: controlPropWithRegisterAttached
    }));
  };

  var attachChildProps = function attachChildProps(child) {
    var _ref2 = child.props,
        name = _ref2.name,
        rules = _ref2.rules;
    var formRegisterReturn = register(name, rules);
    var fieldWithRegisterAttached = isNeedCustomOnchange(child) ? attachRegisterWithCustomOnChange(child, formRegisterReturn) : attachRegisterToNormalField(child, formRegisterReturn);
    var errorText = errors && getErrorText(name, errors);
    return !errorText ? fieldWithRegisterAttached : attachErrorText(fieldWithRegisterAttached, errorText);
  };

  return {
    controlledChildren: generateControlledChild(children)
  };
};

var isComponentAttachable = function isComponentAttachable(child) {
  if (isReactElement(child)) {
    var _child$props;

    var isControllableChild = checkControllable(child) && !!((_child$props = child.props) !== null && _child$props !== void 0 && _child$props.name) && typeof child.props.name === 'string';
    return isControllableChild || isHaveControllableProps(child);
  }

  return false;
};

var isHaveControllableProps = function isHaveControllableProps(child) {
  var _child$props2;

  return !!((_child$props2 = child.props) !== null && _child$props2 !== void 0 && _child$props2.control) && isReactElement(child.props.control) && checkControllable(child.props.control);
};

var getErrorText = function getErrorText(name, errors) {
  var errorField = errors[name];
  return errorField === null || errorField === void 0 ? void 0 : errorField.message;
};

var isReactElement = function isReactElement(child) {
  var reactElementKeys = ['key', 'props', 'type'];
  return !isPrimitive(child) ? reactElementKeys.every(function (key) {
    return key in child;
  }) : false;
};

var isPrimitive = function isPrimitive(child) {
  var primitives = ['undefined', 'number', 'string', 'boolean'];
  return primitives.some(function (priv) {
    return _typeof(child) === priv;
  }) || child === null;
};

var isNeedCustomOnchange = function isNeedCustomOnchange(child) {
  return CUSTOMIZE_ONCHANGE_COMPONENTS.includes(child.type);
};

var checkControllable = function checkControllable(_ref3) {
  var type = _ref3.type;
  return CONTROLLABLE_CHILDREN.some(function (controllableType) {
    return controllableType === type;
  });
};

var attachRegisterToNormalField = function attachRegisterToNormalField(child, formRegisterReturn) {
  return /*#__PURE__*/React.cloneElement(child, _objectSpread2(_objectSpread2({}, child.props), formRegisterReturn));
};

var attachRegisterWithCustomOnChange = function attachRegisterWithCustomOnChange(child, formRegisterReturn) {
  var onChange = formRegisterReturn.onChange,
      rest = _objectWithoutProperties(formRegisterReturn, _excluded$e);

  return /*#__PURE__*/React.cloneElement(child, _objectSpread2(_objectSpread2(_objectSpread2({}, child.props), rest), {}, {
    customOnChange: onChange
  }));
};

var attachErrorText = function attachErrorText(child, errorText) {
  return /*#__PURE__*/React.cloneElement(child, _objectSpread2(_objectSpread2({}, child.props), {}, {
    errorText: child.props.errorText ? [child.props.errorText, errorText] : errorText
  }));
};

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

var _listCacheClear = listCacheClear;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

var _assocIndexOf = assocIndexOf;

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

var _listCacheDelete = listCacheDelete;

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

var _listCacheGet = listCacheGet;

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}

var _listCacheHas = listCacheHas;

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

var _listCacheSet = listCacheSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = _listCacheClear;
ListCache.prototype['delete'] = _listCacheDelete;
ListCache.prototype.get = _listCacheGet;
ListCache.prototype.has = _listCacheHas;
ListCache.prototype.set = _listCacheSet;

var _ListCache = ListCache;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new _ListCache;
  this.size = 0;
}

var _stackClear = stackClear;

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

var _stackDelete = stackDelete;

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

var _stackGet = stackGet;

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

var _stackHas = stackHas;

/** Used to detect overreaching core-js shims. */
var coreJsData = _root['__core-js_shared__'];

var _coreJsData = coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

var _isMasked = isMasked;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

var _toSource = toSource;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$a = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty$8).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject_1(value) || _isMasked(value)) {
    return false;
  }
  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource(value));
}

var _baseIsNative = baseIsNative;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

var _getValue = getValue;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = _getValue(object, key);
  return _baseIsNative(value) ? value : undefined;
}

var _getNative = getNative;

/* Built-in method references that are verified to be native. */
var Map$3 = _getNative(_root, 'Map');

var _Map = Map$3;

/* Built-in method references that are verified to be native. */
var nativeCreate = _getNative(Object, 'create');

var _nativeCreate = nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}

var _hashClear = hashClear;

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

var _hashDelete = hashDelete;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (_nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? undefined : result;
  }
  return hasOwnProperty$7.call(data, key) ? data[key] : undefined;
}

var _hashGet = hashGet;

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$6.call(data, key);
}

var _hashHas = hashHas;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

var _hashSet = hashSet;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = _hashClear;
Hash.prototype['delete'] = _hashDelete;
Hash.prototype.get = _hashGet;
Hash.prototype.has = _hashHas;
Hash.prototype.set = _hashSet;

var _Hash = Hash;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash,
    'map': new (_Map || _ListCache),
    'string': new _Hash
  };
}

var _mapCacheClear = mapCacheClear;

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

var _isKeyable = isKeyable;

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return _isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

var _getMapData = getMapData;

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = _getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

var _mapCacheDelete = mapCacheDelete;

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return _getMapData(this, key).get(key);
}

var _mapCacheGet = mapCacheGet;

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return _getMapData(this, key).has(key);
}

var _mapCacheHas = mapCacheHas;

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = _getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

var _mapCacheSet = mapCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = _mapCacheClear;
MapCache.prototype['delete'] = _mapCacheDelete;
MapCache.prototype.get = _mapCacheGet;
MapCache.prototype.has = _mapCacheHas;
MapCache.prototype.set = _mapCacheSet;

var _MapCache = MapCache;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache) {
    var pairs = data.__data__;
    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

var _stackSet = stackSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack$1(entries) {
  var data = this.__data__ = new _ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack$1.prototype.clear = _stackClear;
Stack$1.prototype['delete'] = _stackDelete;
Stack$1.prototype.get = _stackGet;
Stack$1.prototype.has = _stackHas;
Stack$1.prototype.set = _stackSet;

var _Stack = Stack$1;

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

var _arrayEach = arrayEach;

var defineProperty = (function() {
  try {
    var func = _getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

var _defineProperty = defineProperty;

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && _defineProperty) {
    _defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

var _baseAssignValue = baseAssignValue;

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$5.call(object, key) && eq_1(objValue, value)) ||
      (value === undefined && !(key in object))) {
    _baseAssignValue(object, key, value);
  }
}

var _assignValue = assignValue;

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      _baseAssignValue(object, key, newValue);
    } else {
      _assignValue(object, key, newValue);
    }
  }
  return object;
}

var _copyObject = copyObject;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

var _baseTimes = baseTimes;

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike_1(value) && _baseGetTag(value) == argsTag$2;
}

var _baseIsArguments = baseIsArguments;

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
  return isObjectLike_1(value) && hasOwnProperty$4.call(value, 'callee') &&
    !propertyIsEnumerable$1.call(value, 'callee');
};

var isArguments_1 = isArguments;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

var isArray_1 = isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

var stubFalse_1 = stubFalse;

var isBuffer_1 = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports = exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse_1;

module.exports = isBuffer;
});

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag$2 = '[object Boolean]',
    dateTag$2 = '[object Date]',
    errorTag$1 = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag$4 = '[object Map]',
    numberTag$2 = '[object Number]',
    objectTag$2 = '[object Object]',
    regexpTag$2 = '[object RegExp]',
    setTag$4 = '[object Set]',
    stringTag$2 = '[object String]',
    weakMapTag$2 = '[object WeakMap]';

var arrayBufferTag$2 = '[object ArrayBuffer]',
    dataViewTag$3 = '[object DataView]',
    float32Tag$2 = '[object Float32Array]',
    float64Tag$2 = '[object Float64Array]',
    int8Tag$2 = '[object Int8Array]',
    int16Tag$2 = '[object Int16Array]',
    int32Tag$2 = '[object Int32Array]',
    uint8Tag$2 = '[object Uint8Array]',
    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
    uint16Tag$2 = '[object Uint16Array]',
    uint32Tag$2 = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] =
typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] =
typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] =
typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] =
typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] =
typedArrayTags[weakMapTag$2] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike_1(value) &&
    isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
}

var _baseIsTypedArray = baseIsTypedArray;

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

var _baseUnary = baseUnary;

var _nodeUtil = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports = exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && _freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;
});

/* Node.js helper references. */
var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

var isTypedArray_1 = isTypedArray;

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_1(value),
      isArg = !isArr && isArguments_1(value),
      isBuff = !isArr && !isArg && isBuffer_1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? _baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$3.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           _isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

var _arrayLikeKeys = arrayLikeKeys;

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$4;

  return value === proto;
}

var _isPrototype = isPrototype;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

var _overArg = overArg;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = _overArg(Object.keys, Object);

var _nativeKeys = nativeKeys;

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!_isPrototype(object)) {
    return _nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$2.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

var _baseKeys = baseKeys;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
}

var keys_1 = keys;

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && _copyObject(source, keys_1(source), object);
}

var _baseAssign = baseAssign;

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

var _nativeKeysIn = nativeKeysIn;

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject_1(object)) {
    return _nativeKeysIn(object);
  }
  var isProto = _isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$1.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

var _baseKeysIn = baseKeysIn;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
}

var keysIn_1 = keysIn;

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && _copyObject(source, keysIn_1(source), object);
}

var _baseAssignIn = baseAssignIn;

var _cloneBuffer = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports = exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
});

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

var _copyArray = copyArray;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

var _arrayFilter = arrayFilter;

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

var stubArray_1 = stubArray;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols$1 ? stubArray_1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return _arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

var _getSymbols = getSymbols;

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return _copyObject(source, _getSymbols(source), object);
}

var _copySymbols = copySymbols;

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

var _arrayPush = arrayPush;

/** Built-in value references. */
var getPrototype = _overArg(Object.getPrototypeOf, Object);

var _getPrototype = getPrototype;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray_1 : function(object) {
  var result = [];
  while (object) {
    _arrayPush(result, _getSymbols(object));
    object = _getPrototype(object);
  }
  return result;
};

var _getSymbolsIn = getSymbolsIn;

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return _copyObject(source, _getSymbolsIn(source), object);
}

var _copySymbolsIn = copySymbolsIn;

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
}

var _baseGetAllKeys = baseGetAllKeys;

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return _baseGetAllKeys(object, keys_1, _getSymbols);
}

var _getAllKeys = getAllKeys;

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
}

var _getAllKeysIn = getAllKeysIn;

/* Built-in method references that are verified to be native. */
var DataView = _getNative(_root, 'DataView');

var _DataView = DataView;

/* Built-in method references that are verified to be native. */
var Promise$1 = _getNative(_root, 'Promise');

var _Promise = Promise$1;

/* Built-in method references that are verified to be native. */
var Set$2 = _getNative(_root, 'Set');

var _Set = Set$2;

/* Built-in method references that are verified to be native. */
var WeakMap$1 = _getNative(_root, 'WeakMap');

var _WeakMap = WeakMap$1;

/** `Object#toString` result references. */
var mapTag$3 = '[object Map]',
    objectTag$1 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$3 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';

var dataViewTag$2 = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = _toSource(_DataView),
    mapCtorString = _toSource(_Map),
    promiseCtorString = _toSource(_Promise),
    setCtorString = _toSource(_Set),
    weakMapCtorString = _toSource(_WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = _baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
    (_Map && getTag(new _Map) != mapTag$3) ||
    (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
    (_Set && getTag(new _Set) != setTag$3) ||
    (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
  getTag = function(value) {
    var result = _baseGetTag(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? _toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$2;
        case mapCtorString: return mapTag$3;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$3;
        case weakMapCtorString: return weakMapTag$1;
      }
    }
    return result;
  };
}

var _getTag = getTag;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

var _initCloneArray = initCloneArray;

/** Built-in value references. */
var Uint8Array$1 = _root.Uint8Array;

var _Uint8Array = Uint8Array$1;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
  return result;
}

var _cloneArrayBuffer = cloneArrayBuffer;

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

var _cloneDataView = cloneDataView;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

var _cloneRegExp = cloneRegExp;

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

var _cloneSymbol = cloneSymbol;

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

var _cloneTypedArray = cloneTypedArray;

/** `Object#toString` result references. */
var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    mapTag$2 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag$1 = '[object Symbol]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag$1 = '[object Float32Array]',
    float64Tag$1 = '[object Float64Array]',
    int8Tag$1 = '[object Int8Array]',
    int16Tag$1 = '[object Int16Array]',
    int32Tag$1 = '[object Int32Array]',
    uint8Tag$1 = '[object Uint8Array]',
    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
    uint16Tag$1 = '[object Uint16Array]',
    uint32Tag$1 = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return _cloneArrayBuffer(object);

    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);

    case dataViewTag$1:
      return _cloneDataView(object, isDeep);

    case float32Tag$1: case float64Tag$1:
    case int8Tag$1: case int16Tag$1: case int32Tag$1:
    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
      return _cloneTypedArray(object, isDeep);

    case mapTag$2:
      return new Ctor;

    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);

    case regexpTag$1:
      return _cloneRegExp(object);

    case setTag$2:
      return new Ctor;

    case symbolTag$1:
      return _cloneSymbol(object);
  }
}

var _initCloneByTag = initCloneByTag;

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject_1(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

var _baseCreate = baseCreate;

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !_isPrototype(object))
    ? _baseCreate(_getPrototype(object))
    : {};
}

var _initCloneObject = initCloneObject;

/** `Object#toString` result references. */
var mapTag$1 = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike_1(value) && _getTag(value) == mapTag$1;
}

var _baseIsMap = baseIsMap;

/* Node.js helper references. */
var nodeIsMap = _nodeUtil && _nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;

var isMap_1 = isMap;

/** `Object#toString` result references. */
var setTag$1 = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike_1(value) && _getTag(value) == setTag$1;
}

var _baseIsSet = baseIsSet;

/* Node.js helper references. */
var nodeIsSet = _nodeUtil && _nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;

var isSet_1 = isSet;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$1 = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG$1 = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG$1,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG$1;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject_1(value)) {
    return value;
  }
  var isArr = isArray_1(value);
  if (isArr) {
    result = _initCloneArray(value);
    if (!isDeep) {
      return _copyArray(value, result);
    }
  } else {
    var tag = _getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer_1(value)) {
      return _cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : _initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? _copySymbolsIn(value, _baseAssignIn(result, value))
          : _copySymbols(value, _baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = _initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new _Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet_1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_1(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? _getAllKeysIn : _getAllKeys)
    : (isFlat ? keysIn_1 : keys_1);

  var props = isArr ? undefined : keysFunc(value);
  _arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

var _baseClone = baseClone;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return _baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

var cloneDeep_1 = cloneDeep;

/**
* This hook responsibility is save form's state object to localStorage by id.
*
* Reference:
* {@link https://react-hook-form.com/api/useformstate react-hook-form formState}
*/
var useSmartFormSynchronizer = function useSmartFormSynchronizer(_ref) {
  var formId = _ref.formId,
      control = _ref.control;

  var _useI18n = useI18n(),
      t = _useI18n.t;

  var formStateProxy = reactHookForm.useFormState({
    control: control
  });
  var formState = cloneDeep_1(formStateProxy);
  var formStateWithErrorMessage = applyDefaultErrorMessage(formState, t);
  var synchronizableFormState = removeCircularObjectInFormState(formStateWithErrorMessage);
  useDeepCompareEffect__default['default'](function () {
    syncFormStateCollection(formId, synchronizableFormState);
  }, [formId, synchronizableFormState]);
};

var syncFormStateCollection = function syncFormStateCollection(formId, formState) {
  try {
    var newCollection = generateNewFormStateCollection(formId, formState);
    var isNeedCleanUp = checkCollectionCleanUpNeed(newCollection);
    !isNeedCleanUp && storeFormStateCollection(newCollection);
    isNeedCleanUp && storeFormStateCollection(cleanUpUnAvailableFormStateInCollection(newCollection));
  } catch (error) {
    console.log(error);
  }
};

var checkCollectionCleanUpNeed = function checkCollectionCleanUpNeed(collection) {
  var formIds = getAvailableFormIds();
  var collectionFormIds = Object.keys(collection);
  return !collectionFormIds.every(function (formId) {
    return formIds.includes(formId);
  });
};

var cleanUpUnAvailableFormStateInCollection = function cleanUpUnAvailableFormStateInCollection(collection) {
  var formIds = getAvailableFormIds();
  var collectionEntries = Object.entries(collection);
  var cleanedCollectionEntries = collectionEntries.filter(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 1),
        key = _ref3[0];

    return formIds.includes(key);
  });
  return Object.fromEntries(cleanedCollectionEntries);
};

var getAvailableFormIds = function getAvailableFormIds() {
  var formElements = Array.from(document.getElementsByTagName('form'));
  return formElements.map(function (_ref4) {
    var id = _ref4.id;
    return id;
  }).filter(function (id) {
    return typeof id === 'string';
  });
};

var generateNewFormStateCollection = function generateNewFormStateCollection(formId, formState) {
  var collection = getFormStateCollection();
  var isUpdating = (formId in collection);
  return _objectSpread2(_objectSpread2({}, collection), {}, _defineProperty$1({}, formId, isUpdating ? _objectSpread2(_objectSpread2({}, collection[formId]), formState) : formState));
};

var storeFormStateCollection = function storeFormStateCollection(collection) {
  // Remove circular object for JSON.stringify
  var stringifiedCollection = JSON.stringify(collection);
  window.localStorage.setItem(LOCAL_STORAGE_KEYS.formState, stringifiedCollection);
};

var removeCircularObjectInFormState = function removeCircularObjectInFormState(formState) {
  return mapValuesDeep__default['default'](formState, function (value, key, _, context) {
    var isCircularObj = CIRCULAR_OBJECT_IN_FORM_STATE.some(function (val) {
      return val === key;
    }); // @ts-expect-error: the skipChildren method is exist but not found in deepdash's type definition

    return isCircularObj ? context === null || context === void 0 ? void 0 : context.skipChildren(true) : value;
  }, {
    checkCircular: true
  });
};

var applyDefaultErrorMessage = function applyDefaultErrorMessage(formState, t) {
  try {
    var errors = formState.errors;
    var isEmptyObj = !Object.keys(errors).length;
    return isEmptyObj ? formState : _objectSpread2(_objectSpread2({}, formState), {}, {
      errors: appendDefaultErrorMessage(errors, t)
    });
  } catch (error) {
    console.log(error);
    return formState;
  }
};

var appendDefaultErrorMessage = function appendDefaultErrorMessage(errors, t) {
  var errorsEntries = Object.entries(errors);
  var messageAppended = errorsEntries.map(function (_ref5) {
    var _value$message, _DEFAULT_ERROR_MESSAG;

    var _ref6 = _slicedToArray(_ref5, 2),
        key = _ref6[0],
        value = _ref6[1];

    var isNeedDefaultMsg = !(value !== null && value !== void 0 && value.message) || !((_value$message = value.message) !== null && _value$message !== void 0 && _value$message.length);
    var defaultErrorMessage = (_DEFAULT_ERROR_MESSAG = DEFAULT_ERROR_MESSAGE[value.type]) !== null && _DEFAULT_ERROR_MESSAG !== void 0 ? _DEFAULT_ERROR_MESSAG : '';
    return [key, isNeedDefaultMsg ? _objectSpread2(_objectSpread2({}, value), {}, {
      message: t(defaultErrorMessage)
    }) : value];
  });
  return Object.fromEntries(messageAppended);
};

var _excluded$d = ["children", "id", "mode", "onSubmit", "defaultValues"];
var SmartForm = function SmartForm(props) {
  var children = props.children,
      id = props.id,
      _props$mode = props.mode,
      mode = _props$mode === void 0 ? 'onChange' : _props$mode,
      onSubmit = props.onSubmit,
      defaultValues = props.defaultValues,
      formGroupProps = _objectWithoutProperties(props, _excluded$d);

  var _useForm = reactHookForm.useForm({
    mode: mode,
    defaultValues: React.useMemo(function () {
      return defaultValues;
    }, [defaultValues])
  }),
      register = _useForm.register,
      handleSubmit = _useForm.handleSubmit,
      control = _useForm.control,
      setValue = _useForm.setValue,
      getValues = _useForm.getValues;

  var formState = useFormStateTaker({
    formId: id
  });
  useSmartFormSynchronizer({
    formId: id,
    control: control
  });

  var _useSmartForm = useSmartForm({
    children: children,
    register: register,
    errors: formState === null || formState === void 0 ? void 0 : formState.errors
  }),
      controlledChildren = _useSmartForm.controlledChildren;

  React.useEffect(function () {
    // Sync default values with formValue
    for (var _i = 0, _Object$entries = Object.entries(defaultValues !== null && defaultValues !== void 0 ? defaultValues : {}); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      var isUserChanges = getValues(key) !== value;
      !isUserChanges && setValue(key, value);
    }
  });
  return /*#__PURE__*/jsxRuntime.jsx(Form, _objectSpread2(_objectSpread2({}, formGroupProps), {}, {
    id: id,
    onSubmit: handleSubmit(onSubmit),
    children: controlledChildren
  }));
};

var SectionHeader = function SectionHeader(props) {
  var className = props.className,
      children = props.children,
      textAlign = props.textAlign,
      _props$actions = props.actions,
      actions = _props$actions === void 0 ? [] : _props$actions,
      onClick = props.onClick;
  var headerActions = actions.map(function (_ref) {
    var icon = _ref.icon,
        className = _ref.className,
        _onClick = _ref.onClick,
        title = _ref.title;
    return /*#__PURE__*/jsxRuntime.jsxs("button", {
      className: className,
      onClick: function onClick(e) {
        e.preventDefault();
        e.stopPropagation();
        _onClick && _onClick(e);
      },
      children: [/*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
        icon: icon,
        size: '1rem',
        type: 'light'
      }), /*#__PURE__*/jsxRuntime.jsx("span", {
        children: /*#__PURE__*/jsxRuntime.jsx(T, {
          children: title
        })
      })]
    }, icon);
  });
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: clsx__default['default']('section-header', onClick && 'clickable', className),
    style: {
      textAlign: textAlign
    },
    onClick: onClick,
    children: [/*#__PURE__*/jsxRuntime.jsx(T, {
      children: children
    }), headerActions]
  });
};

var Section = function Section(props) {
  var className = props.className,
      children = props.children,
      header = props.header,
      _props$actions = props.actions,
      actions = _props$actions === void 0 ? [] : _props$actions,
      onHeaderClick = props.onHeaderClick,
      innerRef = props.innerRef;
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    ref: innerRef,
    className: clsx__default['default']('section-panel', className),
    children: [header && /*#__PURE__*/jsxRuntime.jsx(SectionHeader, {
      actions: actions,
      onClick: onHeaderClick,
      children: /*#__PURE__*/jsxRuntime.jsx("h3", {
        children: /*#__PURE__*/jsxRuntime.jsx(T, {
          children: header
        })
      })
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'section-panel-body',
      children: children
    })]
  });
};

var _excluded$c = ["fields", "formName"];

/**
* JsonToFormParser is a form generator which create React Elements base on form definition props.
*
* @example
* <JsonToFormParser definition={definition} />
*/
var JsonToFormParser = /*#__PURE__*/React.memo(function JsonToFormParser(_ref) {
  var definition = _ref.definition;

  var fields = definition.fields,
      formName = definition.formName,
      smartFormProps = _objectWithoutProperties(definition, _excluded$c);

  var _useJsonToFormParser = useJsonToFormParser(fields),
      formChildren = _useJsonToFormParser.formChildren;

  return /*#__PURE__*/jsxRuntime.jsx(ConditionalWrapper, {
    condition: !!formName,
    wrapper: function wrapper(children) {
      return /*#__PURE__*/jsxRuntime.jsx(Section, {
        header: formName,
        children: children
      });
    },
    children: /*#__PURE__*/jsxRuntime.jsx(SmartForm, _objectSpread2(_objectSpread2({}, smartFormProps), {}, {
      children: formChildren
    }))
  });
});

var FormGroup = function FormGroup(props) {
  var _props$direction = props.direction,
      direction = _props$direction === void 0 ? 'column' : _props$direction,
      children = props.children,
      className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: clsx__default['default']('form-group', "form-group-".concat(direction), className),
    children: children
  });
};

var FileInput = function FileInput(_ref) {
  var onChangeFiles = _ref.onChangeFiles;
  var inputRef = React.useRef(null);

  var _useState = React.useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      files = _useState2[0],
      setFiles = _useState2[1];

  var handleChangeInput = function handleChangeInput() {
    var _inputRef$current;

    var fileList = (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.files;

    if (fileList && fileList.length > 0) {
      var _files = [];
      fileList.length > 0 && _files.push(fileList[0]);
      onChangeFiles && onChangeFiles(_files);
      setFiles(_files);
    }
  };

  var handleClearValue = function handleClearValue(e) {
    e.stopPropagation();

    if (files && files.length > 0) {
      onChangeFiles && onChangeFiles([]);
      setFiles([]);
    }
  };

  var displayValue = files.map(function (file) {
    return file.name;
  }).join(', ');
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: "file_input",
    onClick: function onClick() {
      return inputRef.current && inputRef.current.click();
    },
    children: /*#__PURE__*/jsxRuntime.jsxs(InputGroup, {
      children: [/*#__PURE__*/jsxRuntime.jsx(Input, {
        placeholder: 'Select file',
        value: displayValue,
        disabled: true
      }), /*#__PURE__*/jsxRuntime.jsx("input", {
        ref: inputRef,
        type: "file",
        style: {
          display: 'none'
        },
        onChange: handleChangeInput
      }), files && files.length > 0 && /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "file_input-button",
        children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          type: 'solid',
          icon: 'times',
          size: '14px',
          onClick: function onClick(e) {
            return handleClearValue(e);
          }
        })
      }), (!files || files.length < 1) && /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "file_input-button",
        children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          type: 'solid',
          icon: 'upload',
          size: '14px'
        })
      })]
    })
  });
};

var initValue = {
  map: null,
  open: false,
  drawObj: null,
  draw: new MapboxDraw__default['default']({
    clickBuffer: 3,
    displayControlsDefault: false,
    controls: {
      point: true,
      line_string: true,
      polygon: true,
      trash: true
    }
  }),
  value: '',
  getBounds: function getBounds(map) {
    return {
      north: map.getBounds().getNorth(),
      east: map.getBounds().getEast(),
      south: map.getBounds().getSouth(),
      west: map.getBounds().getWest()
    };
  }
};
var MapContext$1 = /*#__PURE__*/React.createContext(initValue);
var Provider = MapContext$1.Provider;

var MapStateProvider = function MapStateProvider(_ref) {
  var children = _ref.children,
      _ref$initState = _ref.initState,
      initState = _ref$initState === void 0 ? {} : _ref$initState;

  var _useReducer = React.useReducer(function (state, action) {
    switch (action.type) {
      case 'setMap':
        return _objectSpread2(_objectSpread2({}, state), {}, {
          map: action.data
        });

      case 'setDrawObj':
        return _objectSpread2(_objectSpread2({}, state), {}, {
          drawObj: action.data
        });

      case 'createDraw':
        if (state.drawObj) {
          state.draw["delete"]([state.drawObj.id]);
        }

        return _objectSpread2(_objectSpread2({}, state), {}, {
          drawObj: action.data
        });

      case 'setValue':
        return _objectSpread2(_objectSpread2({}, state), {}, {
          value: action.data
        });

      case 'closeMap':
        return _objectSpread2(_objectSpread2({}, state), {}, {
          open: false
        });

      case 'openMap':
        return _objectSpread2(_objectSpread2({}, state), {}, {
          open: true
        });

      default:
        throw new Error();
    }
  }, _objectSpread2(_objectSpread2({}, initValue), initState)),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      mapState = _useReducer2[0],
      dispatch = _useReducer2[1];

  return /*#__PURE__*/jsxRuntime.jsx(Provider, {
    value: {
      mapState: mapState,
      dispatch: dispatch
    },
    children: children
  });
};

var version$5 = 8;
var name$5 = "light";
var owner$5 = "vietbando";
var id$4 = "mapstylelight";
var sources$5 = {
	vietbando: {
		type: "vector",
		autoscale: true,
		bounds: [
			-180,
			-85,
			180,
			85
		],
		cacheControl: "max-age=43200,s-maxage=604800",
		center: [
			0,
			0,
			3
		],
		name: "Vietbando Vector Tile",
		description: "Vietbando Vector Tile",
		id: "vt_vbddefault.vectortile",
		vietbando_logo: true,
		attribution: "<a href=\"http://maps.vietbando.com/maps/\" target=\"_blank\">&copy; Vietbando</a>",
		minzoom: 0,
		maxzoom: 16,
		format: "pbf",
		"private": false,
		scheme: "xyz",
		tiles: [
			"https://developers.vietbando.com/V2/MapsSDKService.ashx?type=LoadVertorTile&z={z}&x={x}&y={y}&key=306ec9b5-8146-4a83-9271-bd7b343a574a"
		]
	},
	building: {
		type: "vector",
		autoscale: true,
		bounds: [
			-180,
			-85,
			180,
			85
		],
		cacheControl: "max-age=43200,s-maxage=604800",
		center: [
			0,
			0,
			3
		],
		name: "Vietbando Vector Tile",
		description: "Vietbando Vector Tile",
		id: "vt_building.vectortile",
		vietbando_logo: true,
		attribution: "<a href=\"http://maps.vietbando.com/maps/\" target=\"_blank\">&copy; Vietbando</a>",
		minzoom: 10,
		maxzoom: 16,
		format: "pbf",
		"private": false,
		scheme: "xyz",
		tiles: [
			"https://images.vietbando.com/building/tile/{z}/{x}/{y}.pbf/306ec9b5-8146-4a83-9271-bd7b343a574a"
		]
	},
	vt_background: {
		type: "vector",
		autoscale: true,
		bounds: [
			-180,
			-85,
			180,
			85
		],
		cacheControl: "max-age=43200,s-maxage=604800",
		center: [
			0,
			0,
			3
		],
		name: "Vietbando Vector Tile",
		description: "Vietbando Vector Tile",
		id: "vt_background.vectortile",
		vietbando_logo: true,
		attribution: "<a href=\"http://maps.vietbando.com/maps/\" target=\"_blank\">&copy; Vietbando</a>",
		minzoom: 0,
		maxzoom: 12,
		format: "pbf",
		"private": false,
		scheme: "xyz",
		tiles: [
			"https://images.vietbando.com/bg/tile/{z}/{x}/{y}.pbf/306ec9b5-8146-4a83-9271-bd7b343a574a"
		]
	}
};
var sprite$5 = "https://images.vietbando.com/Sprite/sprite";
var glyphs$5 = "https://images.vietbando.com/Font/{fontstack}/{range}";
var layers$6 = [
	{
		id: "background",
		type: "background",
		paint: {
			"background-color": "#F0F1F1"
		}
	},
	{
		id: "region_water_index",
		source: "vt_background",
		"source-layer": "region_water_index",
		type: "fill",
		paint: {
			"fill-color": "#73B6E6"
		}
	},
	{
		id: "region-bathymetry-index",
		source: "vt_background",
		"source-layer": "region_bathymetry_index",
		type: "fill",
		paint: {
			"fill-color": "#15659f",
			"fill-opacity": 0.15
		}
	},
	{
		id: "region_island_index",
		source: "vietbando",
		"source-layer": "region_island_index",
		type: "fill",
		paint: {
			"fill-color": "#F0F1F1"
		}
	},
	{
		id: "region-river-index",
		source: "vietbando",
		"source-layer": "region_river_index",
		type: "fill",
		paint: {
			"fill-color": "#73B6E6"
		}
	},
	{
		id: "fill-vnairport-index",
		source: "vietbando",
		"source-layer": "region_vnairport_index",
		minzoom: 4,
		type: "fill",
		paint: {
			"fill-color": "#d8e1ee"
		}
	},
	{
		id: "fill-vnbusstation-index",
		source: "vietbando",
		"source-layer": "region_vnbusstation_index",
		minzoom: 4,
		type: "fill",
		paint: {
			"fill-color": "#d8e1ee"
		}
	},
	{
		id: "fill-vnbuilding-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 12,
		type: "fill",
		filter: [
			"!in",
			"groupcode",
			4,
			5,
			6
		],
		paint: {
			"fill-color": "#E6E6E6"
		}
	},
	{
		id: "fill-vnbuilding-school-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 12,
		type: "fill",
		filter: [
			"==",
			"groupcode",
			4
		],
		paint: {
			"fill-color": "#e5dec9"
		}
	},
	{
		id: "fill-vnbuilding-hospital-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 12,
		type: "fill",
		filter: [
			"==",
			"groupcode",
			5
		],
		paint: {
			"fill-color": "#ffe2e2"
		}
	},
	{
		id: "fill-vnbuilding-park-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 12,
		type: "fill",
		filter: [
			"==",
			"groupcode",
			6
		],
		paint: {
			"fill-color": "#C8DF9F"
		}
	},
	{
		id: "fill-vnpark-index",
		source: "vietbando",
		"source-layer": "region_vnpark_index",
		minzoom: 3,
		type: "fill",
		paint: {
			"fill-color": "#C8DF9F"
		}
	},
	{
		id: "line-vntunnel-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 13,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						13,
						0.4
					],
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						5
					],
					[
						17,
						5
					],
					[
						18,
						7
					],
					[
						19,
						9
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.1
					],
					[
						11,
						0.5
					],
					[
						12,
						1.5
					],
					[
						13,
						2
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						8
					],
					[
						18,
						10
					],
					[
						19,
						15
					],
					[
						20,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#E6B100",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						3.2
					],
					[
						12,
						4
					],
					[
						13,
						4.5
					],
					[
						14,
						5
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"in",
			"level",
			-1,
			0
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#F2822C",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			-2
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#f28585",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 14,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "#999",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						7
					],
					[
						18,
						9
					],
					[
						19,
						11
					],
					[
						20,
						16
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 13,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "#999",
			"line-gap-width": {
				base: 0.1,
				stops: [
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						10
					],
					[
						18,
						12
					],
					[
						19,
						17
					],
					[
						20,
						22
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 12,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "hsl(46, 87%, 35%)",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						12,
						4.4
					],
					[
						13,
						5
					],
					[
						14,
						6
					],
					[
						15,
						7
					],
					[
						16,
						10
					],
					[
						17,
						15
					],
					[
						18,
						19
					],
					[
						19,
						29
					],
					[
						20,
						39
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"in",
			"level",
			-1,
			0
		],
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "hsl(26, 87%, 34%)",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			-2
		],
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "#f28585",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 13,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#FFF",
			"line-dasharray": [
				2,
				2
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						10,
						0.2
					],
					[
						11,
						0.4
					],
					[
						12,
						0.6
					],
					[
						13,
						0.8
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						7
					],
					[
						18,
						9
					],
					[
						19,
						12
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#FFF",
			"line-width": 1,
			"line-dasharray": [
				2,
				2
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						11,
						0.6
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#E6B100",
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						1.2
					],
					[
						12,
						2.4
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						5
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"in",
			"level",
			-1,
			0
		],
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#F2822C",
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						1.2
					],
					[
						10,
						1.6
					],
					[
						11,
						2
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						14
					],
					[
						18,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			-2
		],
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#943232",
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						1.2
					],
					[
						10,
						1.6
					],
					[
						11,
						2
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						14
					],
					[
						18,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 12,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#BBB"
					],
					[
						14,
						"#BBB"
					],
					[
						15,
						"#999"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						0.5
					],
					[
						13,
						1
					],
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						6
					],
					[
						17,
						8
					],
					[
						18,
						10
					],
					[
						19,
						12
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#BBB"
					],
					[
						13,
						"#BBB"
					],
					[
						14,
						"#999"
					]
				]
			},
			"line-width": {
				base: 0.1,
				stops: [
					[
						11,
						0.5
					],
					[
						12,
						1
					],
					[
						13,
						2
					],
					[
						14,
						4
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						10
					],
					[
						18,
						12
					],
					[
						19,
						14
					],
					[
						20,
						16
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						0.2
					],
					[
						13,
						0.5
					],
					[
						14,
						1
					],
					[
						15,
						3
					],
					[
						16,
						5
					],
					[
						17,
						7
					],
					[
						18,
						9
					],
					[
						19,
						11
					],
					[
						20,
						13
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			2
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						0.2
					],
					[
						12,
						0.5
					],
					[
						13,
						1
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						7
					],
					[
						17,
						9
					],
					[
						18,
						11
					],
					[
						19,
						13
					],
					[
						20,
						15
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#E6B100"
					],
					[
						12,
						"#E6B100"
					],
					[
						13,
						"hsl(46, 87%, 35%)"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						3.2
					],
					[
						12,
						4.4
					],
					[
						13,
						5
					],
					[
						14,
						6
					],
					[
						15,
						7
					],
					[
						16,
						10
					],
					[
						17,
						15
					],
					[
						18,
						19
					],
					[
						19,
						29
					],
					[
						20,
						39
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"in",
			"level",
			-1,
			0
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#F2822C"
					],
					[
						11,
						"#F2822C"
					],
					[
						12,
						"#A24D0B"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			-2
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#cc3737"
					],
					[
						11,
						"#cc3737"
					],
					[
						12,
						"#943232"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#E6B100",
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						4
					],
					[
						13,
						4.5
					],
					[
						14,
						5
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 11,
		filter: [
			"in",
			"level",
			-1,
			0
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#F2822C",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			-2
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#cc3737",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 13,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#BBB"
					],
					[
						14,
						"#BBB"
					],
					[
						15,
						"#999"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						13,
						0.4
					],
					[
						14,
						3
					],
					[
						15,
						7
					],
					[
						16,
						8
					],
					[
						17,
						9
					],
					[
						18,
						11
					],
					[
						19,
						13
					],
					[
						20,
						18
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#BBB"
					],
					[
						13,
						"#BBB"
					],
					[
						14,
						"#999"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.1
					],
					[
						11,
						0.5
					],
					[
						12,
						1.5
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						14
					],
					[
						19,
						19
					],
					[
						20,
						24
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 6.5,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#E6B100"
					],
					[
						12,
						"#E6B100"
					],
					[
						13,
						"hsl(46, 87%, 35%)"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						3.2
					],
					[
						12,
						4.4
					],
					[
						13,
						5
					],
					[
						14,
						6
					],
					[
						15,
						10
					],
					[
						16,
						13
					],
					[
						17,
						18
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 5,
		filter: [
			"in",
			"level",
			-1,
			0
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#F2822C"
					],
					[
						11,
						"#F2822C"
					],
					[
						12,
						"hsl(26, 87%, 34%)"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						14
					],
					[
						16,
						16
					],
					[
						17,
						20
					],
					[
						18,
						26
					],
					[
						19,
						36
					],
					[
						20,
						46
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 5,
		filter: [
			"==",
			"level",
			-2
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#cc3737"
					],
					[
						11,
						"#cc3737"
					],
					[
						12,
						"#943232"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						14
					],
					[
						16,
						16
					],
					[
						17,
						20
					],
					[
						18,
						26
					],
					[
						19,
						36
					],
					[
						20,
						46
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 14,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						5
					],
					[
						17,
						5
					],
					[
						18,
						7
					],
					[
						19,
						9
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 13,
		filter: [
			"==",
			"level",
			2
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						13,
						2
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						8
					],
					[
						18,
						10
					],
					[
						19,
						15
					],
					[
						20,
						20
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#E6B100",
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						4
					],
					[
						13,
						4.5
					],
					[
						14,
						5
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 11,
		filter: [
			"in",
			"level",
			-1,
			0
		],
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#F2822C",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			-2
		],
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#cc3737",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-halo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"==",
			"type",
			0
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#fff",
			"line-opacity": 0.4,
			"line-blur": 4,
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						4
					],
					[
						20,
						16
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-1-1-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"all",
			[
				"==",
				"type",
				0
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#933",
			"line-dasharray": [
				1,
				1,
				5,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-1-0-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"all",
			[
				"==",
				"type",
				0
			],
			[
				"==",
				"vietnam",
				0
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#666",
			"line-dasharray": [
				1,
				1,
				5,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-2-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		minzoom: 4,
		filter: [
			"all",
			[
				"==",
				"type",
				1
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#666",
			"line-dasharray": [
				1,
				1,
				3,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-2-conflict-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_conflict_index",
		minzoom: 4,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#933",
			"line-dasharray": [
				1,
				1,
				3,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-3-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		minzoom: 11,
		filter: [
			"all",
			[
				"==",
				"type",
				2
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#666",
			"line-dasharray": [
				1,
				1
			]
		}
	},
	{
		id: "line-vnrailway-line-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnrailway_index",
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#444",
			"line-opacity": {
				base: 1,
				stops: [
					[
						11,
						0
					],
					[
						17,
						1
					]
				]
			},
			"line-width": 1,
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnrailway-track-index",
		ref: "line-vnrailway-line-index",
		paint: {
			"line-color": "#444",
			"line-opacity": {
				base: 1,
				stops: [
					[
						11,
						0
					],
					[
						17,
						1
					]
				]
			},
			"line-dasharray": [
				0.1,
				0.5
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						3
					],
					[
						20,
						12
					]
				]
			}
		}
	},
	{
		id: "region_building3d_index",
		"source-layer": "region_building3d_index",
		source: "building",
		type: "fill-extrusion",
		minzoom: 15,
		paint: {
			"fill-extrusion-color": "#ccc",
			"fill-extrusion-height": {
				type: "identity",
				property: "height"
			},
			"fill-extrusion-base": {
				type: "identity",
				property: "base_height"
			},
			"fill-extrusion-opacity": 0.5
		}
	},
	{
		id: "label_vnmarine_line_index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnmarine_line_index",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-transform": "uppercase",
			"text-size": {
				stops: [
					[
						4,
						16
					],
					[
						12,
						40
					]
				]
			},
			"text-letter-spacing": {
				stops: [
					[
						0,
						0.1
					],
					[
						10,
						0.5
					]
				]
			},
			"symbol-placement": "line"
		},
		paint: {
			"text-color": "#111",
			"text-halo-color": "#fff",
			"text-halo-width": {
				stops: [
					[
						8,
						1
					],
					[
						14,
						2
					]
				]
			},
			"text-halo-blur": 0,
			"text-opacity": {
				stops: [
					[
						0,
						0.5
					],
					[
						10,
						1
					]
				]
			}
		}
	},
	{
		id: "label-vnriver-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnriver_index",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						8,
						8
					],
					[
						20,
						20
					]
				]
			},
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-color": "hsl(205, 57%, 34%)",
			"text-halo-width": 1,
			"text-halo-color": "#FFF"
		}
	},
	{
		id: "symbol-vnway-left-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			2
		],
		layout: {
			"icon-image": "arrow_left",
			"icon-rotation-alignment": "map",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 150
		},
		paint: {
		}
	},
	{
		id: "symbol-vnway-right-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			1
		],
		layout: {
			"icon-image": "arrow_right",
			"icon-rotation-alignment": "map",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 150
		},
		paint: {
		}
	},
	{
		id: "symbol-vnway-no-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			3
		],
		layout: {
			"icon-image": "no_entry",
			"icon-rotation-alignment": "viewport",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 100
		},
		paint: {
		}
	},
	{
		id: "label-vnroad-hemlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						12
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 100
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-color": "#fff",
			"text-halo-width": 1,
			"text-color": "#222"
		}
	},
	{
		id: "label-vnroad-huyenlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 10,
		filter: [
			"==",
			"level",
			2
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						14
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 130
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-color": "#fff",
			"text-halo-width": 1,
			"text-color": "#222"
		}
	},
	{
		id: "label-vnroad-tinhlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 8,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						16
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-color": "#fff",
			"text-halo-width": 1,
			"text-color": "#222"
		}
	},
	{
		id: "label-vnroad-quoclo-index",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		type: "symbol",
		minzoom: 6,
		filter: [
			"in",
			"level",
			-1,
			0
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						18
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-color": "#fff",
			"text-halo-width": 1.2,
			"text-color": "#222"
		}
	},
	{
		id: "label-vnroad-caotoc-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		filter: [
			"==",
			"level",
			-2
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						18
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-color": "#000",
			"text-halo-width": 1.2,
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-shield1-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnshield_1_index",
		layout: {
			"icon-image": "road_red_level1",
			"icon-rotation-alignment": "viewport",
			"symbol-placement": "line",
			"symbol-spacing": 200,
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": 9,
			"text-transform": "uppercase",
			"text-rotation-alignment": "viewport",
			"text-pitch-alignment": "viewport",
			"text-field": "{name}"
		},
		paint: {
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-shield2-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnshield_2_index",
		layout: {
			"icon-image": "road_yellow_level1",
			"icon-rotation-alignment": "viewport",
			"symbol-placement": "line",
			"symbol-spacing": 200,
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": 8,
			"text-transform": "uppercase",
			"text-rotation-alignment": "viewport",
			"text-pitch-alignment": "viewport",
			"text-field": "{name}"
		},
		paint: {
			"text-color": "#000",
			"text-translate-anchor": "viewport",
			"icon-opacity": 1
		}
	},
	{
		id: "label-vnpoi-hospital-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		minzoom: 8,
		filter: [
			"==",
			"groupcode",
			5
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#933",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		id: "label-vnpoi-park-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		minzoom: 8,
		filter: [
			"==",
			"categoryco",
			9362
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#30722b",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		id: "label-vnpoi-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		minzoom: 8,
		filter: [
			"all",
			[
				"!=",
				"groupcode",
				5
			],
			[
				"!=",
				"categoryco",
				9362
			]
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#374C51",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-10-index",
		minzoom: 14,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						20,
						0.2
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						14,
						10
					],
					[
						20,
						18
					]
				]
			}
		},
		filter: [
			"==",
			"level",
			10
		],
		paint: {
			"text-color": "#613000",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-789-index",
		minzoom: 13,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						20,
						0.2
					]
				]
			},
			"text-transform": "uppercase",
			"text-font": [
				"Roboto Condensed Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						13,
						10
					],
					[
						20,
						18
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			7,
			8,
			9
		],
		paint: {
			"text-color": "#613000",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-456-index",
		minzoom: 9,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						18,
						0.2
					]
				]
			},
			"text-font": [
				"Roboto Condensed Bold"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						6,
						10
					],
					[
						18,
						20
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			4,
			5,
			6
		],
		paint: {
			"text-color": "#613000",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						18,
						2
					]
				]
			}
		}
	},
	{
		id: "label-vncities-index",
		source: "vietbando",
		"source-layer": "label_vncities_index",
		maxzoom: 13,
		type: "symbol",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						16,
						18
					]
				]
			},
			"icon-image": "city_level1",
			"text-anchor": "bottom",
			"icon-offset": [
				0,
				6
			]
		},
		paint: {
			"text-color": "#000",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-12-index",
		minzoom: 5,
		maxzoom: 12,
		layout: {
			"text-field": "{name}",
			"text-transform": "uppercase",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						12,
						0.2
					]
				]
			},
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						2,
						8
					],
					[
						12,
						18
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			1,
			2
		],
		paint: {
			"text-color": "#333",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						12,
						2
					]
				]
			}
		}
	},
	{
		id: "label_wcountry_index",
		source: "vietbando",
		"source-layer": "label_wcountry_index",
		type: "symbol",
		minzoom: 20,
		maxzoom: 20,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						1,
						10
					],
					[
						10,
						30
					]
				]
			}
		},
		paint: {
			"text-color": "#333",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wcapitals_index",
		id: "label-wcapitals-index",
		maxzoom: 11,
		layout: {
			visibility: "visible",
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						10,
						18
					]
				]
			},
			"icon-image": "capital",
			"text-anchor": "bottom",
			"icon-offset": [
				0,
				6
			]
		},
		paint: {
			"text-color": "#933",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wmarine_index",
		id: "label-wmarine-sea-index",
		minzoom: 4,
		maxzoom: 14,
		filter: [
			"in",
			"featurecla",
			"sea"
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						5,
						12
					],
					[
						6,
						16
					],
					[
						7,
						20
					],
					[
						8,
						28
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0.1
					],
					[
						5,
						0.2
					],
					[
						6,
						0.4
					],
					[
						7,
						0.8
					],
					[
						8,
						1.2
					]
				]
			},
			"text-max-width": 20,
			"text-transform": "uppercase",
			"text-font": [
				"Noto Sans Medium"
			]
		},
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#000",
			"text-halo-width": 0
		}
	},
	{
		id: "label-vnisland-index",
		source: "vietbando",
		"source-layer": "label_vnisland_index",
		type: "symbol",
		minzoom: 4,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						4,
						10
					],
					[
						19,
						18
					]
				]
			}
		},
		paint: {
			"text-color": "#005291",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wmarine_index",
		id: "label-wmarine-ocean-index",
		filter: [
			"in",
			"featurecla",
			"ocean"
		],
		maxzoom: 10,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						1,
						10
					],
					[
						2,
						20
					],
					[
						3,
						30
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						1,
						0.1
					],
					[
						2,
						0.2
					],
					[
						3,
						0.4
					]
				]
			}
		},
		paint: {
			"text-color": "#fff"
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wcontient_index",
		id: "label-wcontient-index",
		layout: {
			visibility: "visible",
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						1,
						10
					],
					[
						2,
						20
					],
					[
						3,
						30
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						1,
						0.1
					],
					[
						2,
						0.2
					],
					[
						3,
						0.4
					]
				]
			}
		},
		paint: {
			"text-color": "#333",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						1,
						2
					],
					[
						2,
						2
					],
					[
						3,
						2
					]
				]
			}
		}
	}
];
var lightStyle = {
	version: version$5,
	name: name$5,
	owner: owner$5,
	id: id$4,
	sources: sources$5,
	sprite: sprite$5,
	glyphs: glyphs$5,
	layers: layers$6
};

var version$4 = 8;
var name$4 = "dark";
var owner$4 = "vietbando";
var sources$4 = {
	vietbando: {
		url: "https://images.vietbando.com/Source/vt_vbddefault/306ec9b5-8146-4a83-9271-bd7b343a574a",
		type: "vector"
	},
	building: {
		url: "https://images.vietbando.com/Source/vt_building/306ec9b5-8146-4a83-9271-bd7b343a574a",
		type: "vector"
	},
	vt_background: {
		url: "https://images.vietbando.com/Source/vt_background/306ec9b5-8146-4a83-9271-bd7b343a574a",
		type: "vector"
	}
};
var sprite$4 = "https://images.vietbando.com/Sprite/dark";
var glyphs$4 = "https://images.vietbando.com/Font/{fontstack}/{range}";
var layers$5 = [
	{
		id: "background",
		type: "background",
		paint: {
			"background-color": "rgb(12,12,12)"
		}
	},
	{
		id: "region_water_index",
		source: "vt_background",
		"source-layer": "region_water_index",
		type: "fill",
		paint: {
			"fill-color": "rgb(27 ,27 ,29)"
		}
	},
	{
		id: "region-bathymetry-index",
		source: "vt_background",
		"source-layer": "region_bathymetry_index",
		type: "fill",
		paint: {
			"fill-color": "rgb(17 ,17 ,19)",
			"fill-opacity": 0.15
		}
	},
	{
		id: "region_island_index",
		source: "vietbando",
		"source-layer": "region_island_index",
		type: "fill",
		paint: {
			"fill-color": "rgb(12,12,12)"
		}
	},
	{
		id: "region-river-index",
		source: "vietbando",
		"source-layer": "region_river_index",
		type: "fill",
		paint: {
			"fill-color": "rgb(27 ,27 ,29)",
			"fill-antialias": false
		}
	},
	{
		id: "fill-vnairport-index",
		source: "vietbando",
		"source-layer": "region_vnairport_index",
		minzoom: 4,
		type: "fill",
		paint: {
			"fill-color": "#25292d"
		}
	},
	{
		id: "fill-vnbuilding-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 10,
		type: "fill",
		filter: [
			"in",
			"groupcode",
			4,
			5,
			6
		],
		paint: {
			"fill-color": "#282200"
		}
	},
	{
		id: "fill-vnbuilding-school-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 12,
		type: "fill",
		filter: [
			"==",
			"groupcode",
			4
		],
		paint: {
			"fill-color": "#5b5237"
		}
	},
	{
		id: "fill-vnbuilding-hospital-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 12,
		type: "fill",
		filter: [
			"==",
			"groupcode",
			5
		],
		paint: {
			"fill-color": "#210000"
		}
	},
	{
		id: "fill-vnbuilding-park-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 12,
		type: "fill",
		filter: [
			"==",
			"groupcode",
			6
		],
		paint: {
			"fill-color": "#011105"
		}
	},
	{
		id: "fill-vnbusstation-index",
		source: "vietbando",
		"source-layer": "region_vnbusstation_index",
		minzoom: 4,
		type: "fill",
		paint: {
			"fill-color": "#25292d"
		}
	},
	{
		id: "fill-vnpark-index",
		source: "vietbando",
		"source-layer": "region_vnpark_index",
		minzoom: 3,
		type: "fill",
		paint: {
			"fill-color": "#011105"
		}
	},
	{
		id: "line-vntunnel-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 12,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 27%)",
			"line-opacity": 0.5,
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						13,
						0.4
					],
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						5
					],
					[
						17,
						5
					],
					[
						18,
						7
					],
					[
						19,
						9
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 27%)",
			"line-opacity": 0.5,
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						11,
						0.2
					],
					[
						12,
						2
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						10
					],
					[
						18,
						12
					],
					[
						19,
						17
					],
					[
						20,
						22
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 27%)",
			"line-opacity": 0.5,
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						1.2
					],
					[
						12,
						2.4
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						5
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"in",
			"level",
			0,
			-1
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 27%)",
			"line-opacity": 0.5,
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						2.2
					],
					[
						10,
						2.6
					],
					[
						11,
						3
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						14
					],
					[
						18,
						20
					],
					[
						19,
						30
					],
					[
						20,
						40
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 14,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "hsl(0, 0%, 17%)",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						7
					],
					[
						18,
						9
					],
					[
						19,
						12
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "hsl(0, 0%, 17%)",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						11,
						0.6
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						14
					],
					[
						19,
						19
					],
					[
						20,
						24
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 10,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "hsl(0, 0%, 27%)",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						10,
						0.8
					],
					[
						11,
						1.2
					],
					[
						12,
						2.4
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						5
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"in",
			"level",
			0,
			-1
		],
		minzoom: 8,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "hsl(0, 0%, 27%)",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						1.2
					],
					[
						10,
						1.6
					],
					[
						11,
						2
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						14
					],
					[
						18,
						20
					],
					[
						19,
						30
					],
					[
						20,
						40
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 13,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 17%)",
			"line-dasharray": [
				2,
				2
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						10,
						0.2
					],
					[
						11,
						0.4
					],
					[
						12,
						0.6
					],
					[
						13,
						0.8
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						7
					],
					[
						18,
						9
					],
					[
						19,
						12
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 17%)",
			"line-width": 1,
			"line-dasharray": [
				2,
				2
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						11,
						0.6
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 27%)",
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						1.2
					],
					[
						12,
						2.4
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						5
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 27%)",
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						1.2
					],
					[
						10,
						1.6
					],
					[
						11,
						2
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						14
					],
					[
						18,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 27%)",
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						1.2
					],
					[
						10,
						1.6
					],
					[
						11,
						2
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						14
					],
					[
						18,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 12,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"hsl(0, 0%, 17%)"
					],
					[
						14,
						"hsl(0, 0%, 17%)"
					],
					[
						15,
						"hsl(0, 0%, 27%)"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						0.5
					],
					[
						13,
						1
					],
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						6
					],
					[
						17,
						8
					],
					[
						18,
						10
					],
					[
						19,
						12
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"hsl(0, 0%, 17%)"
					],
					[
						13,
						"hsl(0, 0%, 17%)"
					],
					[
						14,
						"hsl(0, 0%, 27%)"
					]
				]
			},
			"line-width": {
				base: 0.1,
				stops: [
					[
						11,
						0.5
					],
					[
						12,
						1
					],
					[
						13,
						2
					],
					[
						14,
						4
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						10
					],
					[
						18,
						12
					],
					[
						19,
						14
					],
					[
						20,
						16
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"hsl(0, 0%, 20%)"
					],
					[
						12,
						"hsl(0, 0%, 20%)"
					],
					[
						13,
						"hsl(0, 0%, 30%)"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						3.2
					],
					[
						12,
						4.4
					],
					[
						13,
						5
					],
					[
						14,
						6
					],
					[
						15,
						7
					],
					[
						16,
						10
					],
					[
						17,
						15
					],
					[
						18,
						19
					],
					[
						19,
						29
					],
					[
						20,
						39
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			0
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"hsl(0, 0%, 20%)"
					],
					[
						11,
						"hsl(0, 0%, 20%)"
					],
					[
						12,
						"hsl(0, 0%, 30%)"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			-1
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"hsl(0, 0%, 20%)"
					],
					[
						11,
						"hsl(0, 0%, 20%)"
					],
					[
						12,
						"hsl(0, 0%, 30%)"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 17%)",
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						0.2
					],
					[
						13,
						0.5
					],
					[
						14,
						1
					],
					[
						15,
						3
					],
					[
						16,
						5
					],
					[
						17,
						7
					],
					[
						18,
						9
					],
					[
						19,
						11
					],
					[
						20,
						13
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			2
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 17%)",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						0.2
					],
					[
						12,
						0.5
					],
					[
						13,
						1
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						7
					],
					[
						17,
						9
					],
					[
						18,
						11
					],
					[
						19,
						13
					],
					[
						20,
						15
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 20%)",
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						4
					],
					[
						13,
						4.5
					],
					[
						14,
						5
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 20%)",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 20%)",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 13,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"hsl(0, 0%, 17%)"
					],
					[
						14,
						"hsl(0, 0%, 17%)"
					],
					[
						15,
						"hsl(0, 0%, 27%)"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						13,
						0.4
					],
					[
						14,
						3
					],
					[
						15,
						7
					],
					[
						16,
						8
					],
					[
						17,
						9
					],
					[
						18,
						11
					],
					[
						19,
						13
					],
					[
						20,
						18
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"hsl(0, 0%, 17%)"
					],
					[
						13,
						"hsl(0, 0%, 17%)"
					],
					[
						14,
						"hsl(0, 0%, 27%)"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.1
					],
					[
						11,
						0.5
					],
					[
						12,
						1.5
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						14
					],
					[
						19,
						19
					],
					[
						20,
						24
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 6.5,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"hsl(0, 0%, 20%)"
					],
					[
						12,
						"hsl(0, 0%, 20%)"
					],
					[
						13,
						"hsl(0, 0%, 30%)"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						3.2
					],
					[
						12,
						4.4
					],
					[
						13,
						5
					],
					[
						14,
						6
					],
					[
						15,
						10
					],
					[
						16,
						13
					],
					[
						17,
						18
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 5,
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"hsl(0, 0%, 20%)"
					],
					[
						11,
						"hsl(0, 0%, 20%)"
					],
					[
						12,
						"hsl(0, 0%, 30%)"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						14
					],
					[
						16,
						16
					],
					[
						17,
						20
					],
					[
						18,
						26
					],
					[
						19,
						36
					],
					[
						20,
						46
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 5,
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"hsl(0, 0%, 20%)"
					],
					[
						11,
						"hsl(0, 0%, 20%)"
					],
					[
						12,
						"hsl(0, 0%, 30%)"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						14
					],
					[
						16,
						16
					],
					[
						17,
						20
					],
					[
						18,
						26
					],
					[
						19,
						36
					],
					[
						20,
						46
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 14,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "hsl(0, 0%, 17%)",
			"line-width": {
				base: 1,
				stops: [
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						5
					],
					[
						17,
						5
					],
					[
						18,
						7
					],
					[
						19,
						9
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 13,
		filter: [
			"==",
			"level",
			2
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "hsl(0, 0%, 17%)",
			"line-width": {
				base: 1,
				stops: [
					[
						13,
						2
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						8
					],
					[
						18,
						10
					],
					[
						19,
						15
					],
					[
						20,
						20
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 20%)",
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						4
					],
					[
						13,
						4.5
					],
					[
						14,
						5
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 20%)",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "hsl(0, 0%, 20%)",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-1-1-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"all",
			[
				"==",
				"type",
				0
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#E65C5C",
			"line-dasharray": [
				1,
				1,
				5,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-1-0-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"all",
			[
				"==",
				"type",
				0
			],
			[
				"==",
				"vietnam",
				0
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#888",
			"line-dasharray": [
				1,
				1,
				5,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-2-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		minzoom: 4,
		filter: [
			"all",
			[
				"==",
				"type",
				1
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#888",
			"line-dasharray": [
				1,
				1,
				3,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-2-conflict-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_conflict_index",
		minzoom: 4,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#888",
			"line-dasharray": [
				1,
				1,
				3,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-3-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		minzoom: 11,
		filter: [
			"all",
			[
				"==",
				"type",
				2
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#888",
			"line-dasharray": [
				1,
				1
			]
		}
	},
	{
		id: "line-vnrailway-line-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnrailway_index",
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#bbb",
			"line-opacity": {
				base: 1,
				stops: [
					[
						11,
						0
					],
					[
						17,
						1
					]
				]
			},
			"line-width": 1,
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnrailway-track-index",
		ref: "line-vnrailway-line-index",
		paint: {
			"line-color": "#bbb",
			"line-opacity": {
				base: 1,
				stops: [
					[
						11,
						0
					],
					[
						17,
						1
					]
				]
			},
			"line-dasharray": [
				0.1,
				0.5
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						3
					],
					[
						20,
						12
					]
				]
			}
		}
	},
	{
		id: "region_building3d_index",
		"source-layer": "region_building3d_index",
		source: "building",
		type: "fill-extrusion",
		minzoom: 15,
		paint: {
			"fill-extrusion-color": "#666",
			"fill-extrusion-height": {
				type: "identity",
				property: "height"
			},
			"fill-extrusion-base": {
				type: "identity",
				property: "base_height"
			},
			"fill-extrusion-opacity": 0.5
		}
	},
	{
		id: "label_vnmarine_line_index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnmarine_line_index",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-transform": "uppercase",
			"text-size": {
				stops: [
					[
						4,
						16
					],
					[
						12,
						40
					]
				]
			},
			"text-letter-spacing": {
				stops: [
					[
						0,
						0.1
					],
					[
						10,
						0.5
					]
				]
			},
			"symbol-placement": "line"
		},
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#000",
			"text-halo-width": {
				stops: [
					[
						8,
						1
					],
					[
						14,
						2
					]
				]
			},
			"text-halo-blur": 0,
			"text-opacity": {
				stops: [
					[
						0,
						0.5
					],
					[
						10,
						1
					]
				]
			}
		}
	},
	{
		id: "label-vnriver-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnriver_index",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						8,
						8
					],
					[
						20,
						20
					]
				]
			},
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-color": "#FFF",
			"text-halo-width": 1,
			"text-halo-color": "hsl(205, 57%, 34%)"
		}
	},
	{
		id: "symbol-vnway-left-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			2
		],
		layout: {
			"icon-image": "arrow_left",
			"icon-rotation-alignment": "map",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 150
		},
		paint: {
		}
	},
	{
		id: "symbol-vnway-right-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			1
		],
		layout: {
			"icon-image": "arrow_right",
			"icon-rotation-alignment": "map",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 150
		},
		paint: {
		}
	},
	{
		id: "symbol-vnway-no-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			3
		],
		layout: {
			"icon-image": "no_entry",
			"icon-rotation-alignment": "viewport",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 100
		},
		paint: {
		}
	},
	{
		id: "label-vnroad-hemlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						12
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 100
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-width": 1,
			"text-halo-color": "#000",
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-huyenlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 10,
		filter: [
			"==",
			"level",
			2
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						14
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 130
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-width": 1,
			"text-halo-color": "#000",
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-tinhlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 8,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						16
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-width": 1,
			"text-halo-color": "#000",
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-quoclo-index",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		type: "symbol",
		minzoom: 6,
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						18
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-width": 1,
			"text-halo-color": "#000",
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-caotoc-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						18
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-halo-width": 1,
			"text-halo-color": "#000",
			"text-color": "#fff",
			"text-translate-anchor": "viewport"
		}
	},
	{
		id: "label-vnroad-shield1-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnshield_1_index",
		layout: {
			"icon-image": "road_red_level1",
			"icon-rotation-alignment": "viewport",
			"symbol-placement": "line",
			"symbol-spacing": 200,
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": 9,
			"text-transform": "uppercase",
			"text-rotation-alignment": "viewport",
			"text-pitch-alignment": "viewport",
			"text-field": "{name}"
		},
		paint: {
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-shield2-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnshield_2_index",
		layout: {
			"icon-image": "road_yellow_level1",
			"icon-rotation-alignment": "viewport",
			"symbol-placement": "line",
			"symbol-spacing": 200,
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": 8,
			"text-transform": "uppercase",
			"text-rotation-alignment": "viewport",
			"text-pitch-alignment": "viewport",
			"text-field": "{name}"
		},
		paint: {
			"text-color": "#000",
			"text-translate-anchor": "viewport",
			"icon-opacity": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		id: "label-vnpoi-hospital-index",
		minzoom: 8,
		filter: [
			"==",
			"groupcode",
			5
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#d3a0b1",
			"text-halo-color": "#000",
			"text-halo-width": 0.6
		}
	},
	{
		id: "label-vnpoi-park-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		minzoom: 8,
		filter: [
			"==",
			"categoryco",
			9362
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#a0e4a0",
			"text-halo-color": "#000",
			"text-halo-width": 0.6
		}
	},
	{
		type: "symbol",
		id: "label-vnpoi-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		minzoom: 14,
		filter: [
			"all",
			[
				"!=",
				"groupcode",
				5
			],
			[
				"!=",
				"categoryco",
				9362
			]
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#ccc",
			"text-halo-color": "#000",
			"text-halo-width": 0.6
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-10-index",
		minzoom: 14,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						20,
						0.2
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						14,
						10
					],
					[
						20,
						18
					]
				]
			}
		},
		filter: [
			"==",
			"level",
			10
		],
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#111",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-789-index",
		minzoom: 13,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						20,
						0.2
					]
				]
			},
			"text-transform": "uppercase",
			"text-font": [
				"Roboto Condensed Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						13,
						10
					],
					[
						20,
						18
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			7,
			8,
			9
		],
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#111",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-456-index",
		minzoom: 9,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						18,
						0.2
					]
				]
			},
			"text-font": [
				"Roboto Condensed Bold"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						6,
						10
					],
					[
						18,
						20
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			4,
			5,
			6
		],
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#111",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						18,
						2
					]
				]
			}
		}
	},
	{
		id: "label-vncities-index",
		source: "vietbando",
		"source-layer": "label_vncities_index",
		maxzoom: 13,
		type: "symbol",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						16,
						18
					]
				]
			},
			"icon-image": "city_level1",
			"text-anchor": "bottom",
			"icon-offset": [
				0,
				6
			]
		},
		paint: {
			"text-color": "#FFF"
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-12-index",
		minzoom: 5,
		maxzoom: 12,
		layout: {
			"text-field": "{name}",
			"text-transform": "uppercase",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						12,
						0.2
					]
				]
			},
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						2,
						8
					],
					[
						12,
						18
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			1,
			2
		],
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#000",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						12,
						2
					]
				]
			}
		}
	},
	{
		id: "label_wcountry_index",
		source: "vietbando",
		"source-layer": "label_wcountry_index",
		type: "symbol",
		minzoom: 20,
		maxzoom: 20,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						1,
						10
					],
					[
						10,
						30
					]
				]
			}
		},
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#000",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wcapitals_index",
		id: "label-wcapitals-index",
		maxzoom: 11,
		layout: {
			visibility: "visible",
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						10,
						18
					]
				]
			},
			"icon-image": "capital",
			"text-anchor": "bottom",
			"icon-offset": [
				0,
				6
			]
		},
		paint: {
			"text-color": "#E65C5C"
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wmarine_index",
		id: "label-wmarine-sea-index",
		minzoom: 4,
		maxzoom: 14,
		filter: [
			"in",
			"featurecla",
			"sea"
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						5,
						12
					],
					[
						6,
						16
					],
					[
						7,
						20
					],
					[
						8,
						28
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0.1
					],
					[
						5,
						0.2
					],
					[
						6,
						0.4
					],
					[
						7,
						0.8
					],
					[
						8,
						1.2
					]
				]
			},
			"text-max-width": 20,
			"text-transform": "uppercase",
			"text-font": [
				"Noto Sans Medium"
			]
		},
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#000",
			"text-halo-width": 0
		}
	},
	{
		id: "label-vnisland-index",
		source: "vietbando",
		"source-layer": "label_vnisland_index",
		type: "symbol",
		minzoom: 4,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						4,
						10
					],
					[
						19,
						18
					]
				]
			}
		},
		paint: {
			"text-color": "#fff",
			"text-halo-color": "hsl(205, 57%, 34%)",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wmarine_index",
		id: "label-wmarine-ocean-index",
		filter: [
			"in",
			"featurecla",
			"ocean"
		],
		maxzoom: 10,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						1,
						10
					],
					[
						2,
						20
					],
					[
						3,
						30
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						1,
						0.1
					],
					[
						2,
						0.2
					],
					[
						3,
						0.4
					]
				]
			}
		},
		paint: {
			"text-color": "#fff"
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wcontient_index",
		id: "label-wcontient-index",
		layout: {
			visibility: "visible",
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						1,
						10
					],
					[
						2,
						20
					],
					[
						3,
						30
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						1,
						0.1
					],
					[
						2,
						0.2
					],
					[
						3,
						0.4
					]
				]
			}
		},
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#111",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						1,
						2
					],
					[
						2,
						2
					],
					[
						3,
						2
					]
				]
			}
		}
	}
];
var darkStyle = {
	version: version$4,
	name: name$4,
	owner: owner$4,
	sources: sources$4,
	sprite: sprite$4,
	glyphs: glyphs$4,
	layers: layers$5
};

var version$3 = 8;
var name$3 = "light";
var owner$3 = "vietbando";
var id$3 = "mapstylelight";
var sources$3 = {
	vietbando: {
		url: "https://images.vietbando.com/Source/vt_vbddefault/306ec9b5-8146-4a83-9271-bd7b343a574a",
		type: "vector"
	},
	building: {
		url: "https://images.vietbando.com/Source/vt_building/306ec9b5-8146-4a83-9271-bd7b343a574a",
		type: "vector"
	},
	vt_background: {
		url: "https://images.vietbando.com/Source/vt_background/306ec9b5-8146-4a83-9271-bd7b343a574a",
		type: "vector"
	}
};
var sprite$3 = "https://images.vietbando.com/Sprite/sprite";
var glyphs$3 = "https://images.vietbando.com/Font/{fontstack}/{range}";
var layers$4 = [
	{
		id: "background",
		type: "background",
		paint: {
			"background-color": "#F0F1F1"
		}
	},
	{
		id: "region_water_index",
		source: "vt_background",
		"source-layer": "region_water_index",
		type: "fill",
		paint: {
			"fill-color": "#73B6E6"
		}
	},
	{
		id: "region-bathymetry-index",
		source: "vt_background",
		"source-layer": "region_bathymetry_index",
		type: "fill",
		paint: {
			"fill-color": "#15659f",
			"fill-opacity": 0.15
		}
	},
	{
		id: "region_island_index",
		source: "vietbando",
		"source-layer": "region_island_index",
		type: "fill",
		paint: {
			"fill-color": "#F0F1F1"
		}
	},
	{
		id: "region-river-index",
		source: "vietbando",
		"source-layer": "region_river_index",
		type: "fill",
		paint: {
			"fill-color": "#73B6E6"
		}
	},
	{
		id: "fill-vnairport-index",
		source: "vietbando",
		"source-layer": "region_vnairport_index",
		minzoom: 4,
		type: "fill",
		paint: {
			"fill-color": "#d8e1ee"
		}
	},
	{
		id: "fill-vnbusstation-index",
		source: "vietbando",
		"source-layer": "region_vnbusstation_index",
		minzoom: 4,
		type: "fill",
		paint: {
			"fill-color": "#d8e1ee"
		}
	},
	{
		id: "fill-vnbuilding-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 12,
		type: "fill",
		filter: [
			"!in",
			"groupcode",
			4,
			5,
			6
		],
		paint: {
			"fill-color": "#E6E6E6"
		}
	},
	{
		id: "fill-vnbuilding-school-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 12,
		type: "fill",
		filter: [
			"==",
			"groupcode",
			4
		],
		paint: {
			"fill-color": "#e5dec9"
		}
	},
	{
		id: "fill-vnbuilding-hospital-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 12,
		type: "fill",
		filter: [
			"==",
			"groupcode",
			5
		],
		paint: {
			"fill-color": "#ffe2e2"
		}
	},
	{
		id: "fill-vnbuilding-park-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 12,
		type: "fill",
		filter: [
			"==",
			"groupcode",
			6
		],
		paint: {
			"fill-color": "#C8DF9F"
		}
	},
	{
		id: "fill-vnpark-index",
		source: "vietbando",
		"source-layer": "region_vnpark_index",
		minzoom: 3,
		type: "fill",
		paint: {
			"fill-color": "#C8DF9F"
		}
	},
	{
		id: "line-vntunnel-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 13,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						13,
						0.4
					],
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						5
					],
					[
						17,
						5
					],
					[
						18,
						7
					],
					[
						19,
						9
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.1
					],
					[
						11,
						0.5
					],
					[
						12,
						1.5
					],
					[
						13,
						2
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						8
					],
					[
						18,
						10
					],
					[
						19,
						15
					],
					[
						20,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#E6B100",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						3.2
					],
					[
						12,
						4
					],
					[
						13,
						4.5
					],
					[
						14,
						5
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"in",
			"level",
			-1,
			0
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#F2822C",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			-2
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#f28585",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 14,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "#999",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						7
					],
					[
						18,
						9
					],
					[
						19,
						11
					],
					[
						20,
						16
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 13,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "#999",
			"line-gap-width": {
				base: 0.1,
				stops: [
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						10
					],
					[
						18,
						12
					],
					[
						19,
						17
					],
					[
						20,
						22
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 12,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "hsl(46, 87%, 35%)",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						12,
						4.4
					],
					[
						13,
						5
					],
					[
						14,
						6
					],
					[
						15,
						7
					],
					[
						16,
						10
					],
					[
						17,
						15
					],
					[
						18,
						19
					],
					[
						19,
						29
					],
					[
						20,
						39
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"in",
			"level",
			-1,
			0
		],
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "hsl(26, 87%, 34%)",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			-2
		],
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "#f28585",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 13,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#FFF",
			"line-dasharray": [
				2,
				2
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						10,
						0.2
					],
					[
						11,
						0.4
					],
					[
						12,
						0.6
					],
					[
						13,
						0.8
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						7
					],
					[
						18,
						9
					],
					[
						19,
						12
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#FFF",
			"line-width": 1,
			"line-dasharray": [
				2,
				2
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						11,
						0.6
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#E6B100",
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						1.2
					],
					[
						12,
						2.4
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						5
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"in",
			"level",
			-1,
			0
		],
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#F2822C",
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						1.2
					],
					[
						10,
						1.6
					],
					[
						11,
						2
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						14
					],
					[
						18,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			-2
		],
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#943232",
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						1.2
					],
					[
						10,
						1.6
					],
					[
						11,
						2
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						14
					],
					[
						18,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 12,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#BBB"
					],
					[
						14,
						"#BBB"
					],
					[
						15,
						"#999"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						0.5
					],
					[
						13,
						1
					],
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						6
					],
					[
						17,
						8
					],
					[
						18,
						10
					],
					[
						19,
						12
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#BBB"
					],
					[
						13,
						"#BBB"
					],
					[
						14,
						"#999"
					]
				]
			},
			"line-width": {
				base: 0.1,
				stops: [
					[
						11,
						0.5
					],
					[
						12,
						1
					],
					[
						13,
						2
					],
					[
						14,
						4
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						10
					],
					[
						18,
						12
					],
					[
						19,
						14
					],
					[
						20,
						16
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						0.2
					],
					[
						13,
						0.5
					],
					[
						14,
						1
					],
					[
						15,
						3
					],
					[
						16,
						5
					],
					[
						17,
						7
					],
					[
						18,
						9
					],
					[
						19,
						11
					],
					[
						20,
						13
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			2
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						0.2
					],
					[
						12,
						0.5
					],
					[
						13,
						1
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						7
					],
					[
						17,
						9
					],
					[
						18,
						11
					],
					[
						19,
						13
					],
					[
						20,
						15
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#E6B100"
					],
					[
						12,
						"#E6B100"
					],
					[
						13,
						"hsl(46, 87%, 35%)"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						3.2
					],
					[
						12,
						4.4
					],
					[
						13,
						5
					],
					[
						14,
						6
					],
					[
						15,
						7
					],
					[
						16,
						10
					],
					[
						17,
						15
					],
					[
						18,
						19
					],
					[
						19,
						29
					],
					[
						20,
						39
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"in",
			"level",
			-1,
			0
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#F2822C"
					],
					[
						11,
						"#F2822C"
					],
					[
						12,
						"#A24D0B"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			-2
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#cc3737"
					],
					[
						11,
						"#cc3737"
					],
					[
						12,
						"#943232"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#E6B100",
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						4
					],
					[
						13,
						4.5
					],
					[
						14,
						5
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 11,
		filter: [
			"in",
			"level",
			-1,
			0
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#F2822C",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			-2
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#cc3737",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 13,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#BBB"
					],
					[
						14,
						"#BBB"
					],
					[
						15,
						"#999"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						13,
						0.4
					],
					[
						14,
						3
					],
					[
						15,
						7
					],
					[
						16,
						8
					],
					[
						17,
						9
					],
					[
						18,
						11
					],
					[
						19,
						13
					],
					[
						20,
						18
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#BBB"
					],
					[
						13,
						"#BBB"
					],
					[
						14,
						"#999"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.1
					],
					[
						11,
						0.5
					],
					[
						12,
						1.5
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						14
					],
					[
						19,
						19
					],
					[
						20,
						24
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 6.5,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#E6B100"
					],
					[
						12,
						"#E6B100"
					],
					[
						13,
						"hsl(46, 87%, 35%)"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						3.2
					],
					[
						12,
						4.4
					],
					[
						13,
						5
					],
					[
						14,
						6
					],
					[
						15,
						10
					],
					[
						16,
						13
					],
					[
						17,
						18
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 5,
		filter: [
			"in",
			"level",
			-1,
			0
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#F2822C"
					],
					[
						11,
						"#F2822C"
					],
					[
						12,
						"hsl(26, 87%, 34%)"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						14
					],
					[
						16,
						16
					],
					[
						17,
						20
					],
					[
						18,
						26
					],
					[
						19,
						36
					],
					[
						20,
						46
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 5,
		filter: [
			"==",
			"level",
			-2
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#cc3737"
					],
					[
						11,
						"#cc3737"
					],
					[
						12,
						"#943232"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						14
					],
					[
						16,
						16
					],
					[
						17,
						20
					],
					[
						18,
						26
					],
					[
						19,
						36
					],
					[
						20,
						46
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 14,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						5
					],
					[
						17,
						5
					],
					[
						18,
						7
					],
					[
						19,
						9
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 13,
		filter: [
			"==",
			"level",
			2
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						13,
						2
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						8
					],
					[
						18,
						10
					],
					[
						19,
						15
					],
					[
						20,
						20
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#E6B100",
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						4
					],
					[
						13,
						4.5
					],
					[
						14,
						5
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 11,
		filter: [
			"in",
			"level",
			-1,
			0
		],
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#F2822C",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			-2
		],
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#cc3737",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-halo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"==",
			"type",
			0
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#fff",
			"line-opacity": 0.4,
			"line-blur": 4,
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						4
					],
					[
						20,
						16
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-1-1-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"all",
			[
				"==",
				"type",
				0
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#933",
			"line-dasharray": [
				1,
				1,
				5,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-1-0-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"all",
			[
				"==",
				"type",
				0
			],
			[
				"==",
				"vietnam",
				0
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#666",
			"line-dasharray": [
				1,
				1,
				5,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-2-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		minzoom: 4,
		filter: [
			"all",
			[
				"==",
				"type",
				1
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#666",
			"line-dasharray": [
				1,
				1,
				3,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-2-conflict-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_conflict_index",
		minzoom: 4,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#933",
			"line-dasharray": [
				1,
				1,
				3,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-3-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		minzoom: 11,
		filter: [
			"all",
			[
				"==",
				"type",
				2
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#666",
			"line-dasharray": [
				1,
				1
			]
		}
	},
	{
		id: "line-vnrailway-line-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnrailway_index",
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#444",
			"line-opacity": {
				base: 1,
				stops: [
					[
						11,
						0
					],
					[
						17,
						1
					]
				]
			},
			"line-width": 1,
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnrailway-track-index",
		ref: "line-vnrailway-line-index",
		paint: {
			"line-color": "#444",
			"line-opacity": {
				base: 1,
				stops: [
					[
						11,
						0
					],
					[
						17,
						1
					]
				]
			},
			"line-dasharray": [
				0.1,
				0.5
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						3
					],
					[
						20,
						12
					]
				]
			}
		}
	},
	{
		id: "region_building3d_index",
		"source-layer": "region_building3d_index",
		source: "building",
		type: "fill-extrusion",
		minzoom: 15,
		paint: {
			"fill-extrusion-color": "#ccc",
			"fill-extrusion-height": {
				type: "identity",
				property: "height"
			},
			"fill-extrusion-base": {
				type: "identity",
				property: "base_height"
			},
			"fill-extrusion-opacity": 0.5
		}
	},
	{
		id: "label_vnmarine_line_index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnmarine_line_index",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-transform": "uppercase",
			"text-size": {
				stops: [
					[
						4,
						16
					],
					[
						12,
						40
					]
				]
			},
			"text-letter-spacing": {
				stops: [
					[
						0,
						0.1
					],
					[
						10,
						0.5
					]
				]
			},
			"symbol-placement": "line"
		},
		paint: {
			"text-color": "#111",
			"text-halo-color": "#fff",
			"text-halo-width": {
				stops: [
					[
						8,
						1
					],
					[
						14,
						2
					]
				]
			},
			"text-halo-blur": 0,
			"text-opacity": {
				stops: [
					[
						0,
						0.5
					],
					[
						10,
						1
					]
				]
			}
		}
	},
	{
		id: "label-vnriver-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnriver_index",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						8,
						8
					],
					[
						20,
						20
					]
				]
			},
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-color": "hsl(205, 57%, 34%)",
			"text-halo-width": 1,
			"text-halo-color": "#FFF"
		}
	},
	{
		id: "symbol-vnway-left-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			2
		],
		layout: {
			"icon-image": "arrow_left",
			"icon-rotation-alignment": "map",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 150
		},
		paint: {
		}
	},
	{
		id: "symbol-vnway-right-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			1
		],
		layout: {
			"icon-image": "arrow_right",
			"icon-rotation-alignment": "map",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 150
		},
		paint: {
		}
	},
	{
		id: "symbol-vnway-no-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			3
		],
		layout: {
			"icon-image": "no_entry",
			"icon-rotation-alignment": "viewport",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 100
		},
		paint: {
		}
	},
	{
		id: "label-vnroad-hemlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						12
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 100
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-color": "#fff",
			"text-halo-width": 1,
			"text-color": "#222"
		}
	},
	{
		id: "label-vnroad-huyenlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 10,
		filter: [
			"==",
			"level",
			2
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						14
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 130
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-color": "#fff",
			"text-halo-width": 1,
			"text-color": "#222"
		}
	},
	{
		id: "label-vnroad-tinhlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 8,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						16
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-color": "#fff",
			"text-halo-width": 1,
			"text-color": "#222"
		}
	},
	{
		id: "label-vnroad-quoclo-index",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		type: "symbol",
		minzoom: 6,
		filter: [
			"in",
			"level",
			-1,
			0
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						18
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-color": "#fff",
			"text-halo-width": 1.2,
			"text-color": "#222"
		}
	},
	{
		id: "label-vnroad-caotoc-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		filter: [
			"==",
			"level",
			-2
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						18
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-color": "#000",
			"text-halo-width": 1.2,
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-shield1-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnshield_1_index",
		layout: {
			"icon-image": "road_red_level1",
			"icon-rotation-alignment": "viewport",
			"symbol-placement": "line",
			"symbol-spacing": 200,
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": 9,
			"text-transform": "uppercase",
			"text-rotation-alignment": "viewport",
			"text-pitch-alignment": "viewport",
			"text-field": "{name}"
		},
		paint: {
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-shield2-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnshield_2_index",
		layout: {
			"icon-image": "road_yellow_level1",
			"icon-rotation-alignment": "viewport",
			"symbol-placement": "line",
			"symbol-spacing": 200,
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": 8,
			"text-transform": "uppercase",
			"text-rotation-alignment": "viewport",
			"text-pitch-alignment": "viewport",
			"text-field": "{name}"
		},
		paint: {
			"text-color": "#000",
			"text-translate-anchor": "viewport",
			"icon-opacity": 1
		}
	},
	{
		id: "label-vnpoi-hospital-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		minzoom: 8,
		filter: [
			"==",
			"groupcode",
			5
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#933",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		id: "label-vnpoi-park-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		minzoom: 8,
		filter: [
			"==",
			"categoryco",
			9362
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#30722b",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		id: "label-vnpoi-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		minzoom: 8,
		filter: [
			"all",
			[
				"!=",
				"groupcode",
				5
			],
			[
				"!=",
				"categoryco",
				9362
			]
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#374C51",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-10-index",
		minzoom: 14,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						20,
						0.2
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						14,
						10
					],
					[
						20,
						18
					]
				]
			}
		},
		filter: [
			"==",
			"level",
			10
		],
		paint: {
			"text-color": "#613000",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-789-index",
		minzoom: 13,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						20,
						0.2
					]
				]
			},
			"text-transform": "uppercase",
			"text-font": [
				"Roboto Condensed Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						13,
						10
					],
					[
						20,
						18
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			7,
			8,
			9
		],
		paint: {
			"text-color": "#613000",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-456-index",
		minzoom: 9,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						18,
						0.2
					]
				]
			},
			"text-font": [
				"Roboto Condensed Bold"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						6,
						10
					],
					[
						18,
						20
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			4,
			5,
			6
		],
		paint: {
			"text-color": "#613000",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						18,
						2
					]
				]
			}
		}
	},
	{
		id: "label-vncities-index",
		source: "vietbando",
		"source-layer": "label_vncities_index",
		maxzoom: 13,
		type: "symbol",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						16,
						18
					]
				]
			},
			"icon-image": "city_level1",
			"text-anchor": "bottom",
			"icon-offset": [
				0,
				6
			]
		},
		paint: {
			"text-color": "#000",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-12-index",
		minzoom: 5,
		maxzoom: 12,
		layout: {
			"text-field": "{name}",
			"text-transform": "uppercase",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						12,
						0.2
					]
				]
			},
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						2,
						8
					],
					[
						12,
						18
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			1,
			2
		],
		paint: {
			"text-color": "#333",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						12,
						2
					]
				]
			}
		}
	},
	{
		id: "label_wcountry_index",
		source: "vietbando",
		"source-layer": "label_wcountry_index",
		type: "symbol",
		minzoom: 20,
		maxzoom: 20,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						1,
						10
					],
					[
						10,
						30
					]
				]
			}
		},
		paint: {
			"text-color": "#333",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wcapitals_index",
		id: "label-wcapitals-index",
		maxzoom: 11,
		layout: {
			visibility: "visible",
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						10,
						18
					]
				]
			},
			"icon-image": "capital",
			"text-anchor": "bottom",
			"icon-offset": [
				0,
				6
			]
		},
		paint: {
			"text-color": "#933",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wmarine_index",
		id: "label-wmarine-sea-index",
		minzoom: 4,
		maxzoom: 14,
		filter: [
			"in",
			"featurecla",
			"sea"
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						5,
						12
					],
					[
						6,
						16
					],
					[
						7,
						20
					],
					[
						8,
						28
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0.1
					],
					[
						5,
						0.2
					],
					[
						6,
						0.4
					],
					[
						7,
						0.8
					],
					[
						8,
						1.2
					]
				]
			},
			"text-max-width": 20,
			"text-transform": "uppercase",
			"text-font": [
				"Noto Sans Medium"
			]
		},
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#000",
			"text-halo-width": 0
		}
	},
	{
		id: "label-vnisland-index",
		source: "vietbando",
		"source-layer": "label_vnisland_index",
		type: "symbol",
		minzoom: 4,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						4,
						10
					],
					[
						19,
						18
					]
				]
			}
		},
		paint: {
			"text-color": "#005291",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wmarine_index",
		id: "label-wmarine-ocean-index",
		filter: [
			"in",
			"featurecla",
			"ocean"
		],
		maxzoom: 10,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						1,
						10
					],
					[
						2,
						20
					],
					[
						3,
						30
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						1,
						0.1
					],
					[
						2,
						0.2
					],
					[
						3,
						0.4
					]
				]
			}
		},
		paint: {
			"text-color": "#fff"
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wcontient_index",
		id: "label-wcontient-index",
		layout: {
			visibility: "visible",
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						1,
						10
					],
					[
						2,
						20
					],
					[
						3,
						30
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						1,
						0.1
					],
					[
						2,
						0.2
					],
					[
						3,
						0.4
					]
				]
			}
		},
		paint: {
			"text-color": "#333",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						1,
						2
					],
					[
						2,
						2
					],
					[
						3,
						2
					]
				]
			}
		}
	}
];
var defaultStyle = {
	version: version$3,
	name: name$3,
	owner: owner$3,
	id: id$3,
	sources: sources$3,
	sprite: sprite$3,
	glyphs: glyphs$3,
	layers: layers$4
};

var version$2 = 8;
var name$2 = "satellite";
var owner$2 = "vietbando";
var id$2 = "mapstylesatellite";
var sources$2 = {
	vietbando: {
		url: "https://images.vietbando.com/Source/vt_vbddefault/306ec9b5-8146-4a83-9271-bd7b343a574a",
		type: "vector"
	},
	building: {
		url: "https://images.vietbando.com/Source/vt_building/306ec9b5-8146-4a83-9271-bd7b343a574a",
		type: "vector"
	},
	satellite: {
		url: "https://images.vietbando.com/Source/bg_bing/306ec9b5-8146-4a83-9271-bd7b343a574a",
		type: "raster",
		tileSize: 256
	},
	area: {
		type: "raster",
		minzoom: 14,
		tiles: [
			"http://vdfs.vietbando.vn/api/v1/no_auth/drone_ortho_png/{z}_{x}_{y}"
		],
		tileSize: 256
	}
};
var sprite$2 = "https://images.vietbando.com/Sprite/dark";
var glyphs$2 = "https://images.vietbando.com/Font/{fontstack}/{range}";
var layers$3 = [
	{
		id: "background",
		type: "background",
		paint: {
			"background-color": "#000000"
		}
	},
	{
		id: "satellite",
		type: "raster",
		source: "satellite",
		layout: {
		},
		paint: {
		}
	},
	{
		id: "area",
		type: "raster",
		source: "area",
		layout: {
		},
		paint: {
		}
	},
	{
		id: "line-vntunnel-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 12,
		maxzoom: 18,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#fff",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0.01
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						13,
						0.4
					],
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						5
					],
					[
						17,
						5
					],
					[
						18,
						7
					],
					[
						19,
						9
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9,
		maxzoom: 18,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#fff",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0.01
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.1
					],
					[
						11,
						0.5
					],
					[
						12,
						1.5
					],
					[
						13,
						2
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						8
					],
					[
						18,
						10
					],
					[
						19,
						15
					],
					[
						20,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		maxzoom: 18,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#E6B100",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0.01
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						3.2
					],
					[
						12,
						4
					],
					[
						13,
						4.5
					],
					[
						14,
						5
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"in",
			"level",
			0,
			-1
		],
		minzoom: 5,
		maxzoom: 18,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#F2822C",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0.01
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 13,
		maxzoom: 18,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#FFF",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0.01
					]
				]
			},
			"line-dasharray": [
				2,
				2
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						10,
						0.2
					],
					[
						11,
						0.4
					],
					[
						12,
						0.6
					],
					[
						13,
						0.8
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						7
					],
					[
						18,
						9
					],
					[
						19,
						12
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9.5,
		maxzoom: 18,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#FFF",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0.01
					]
				]
			},
			"line-width": 1,
			"line-dasharray": [
				2,
				2
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						11,
						0.6
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		maxzoom: 18,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#E6B100",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0.01
					]
				]
			},
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						1.2
					],
					[
						12,
						2.4
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						5
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			0
		],
		minzoom: 4,
		maxzoom: 18,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#F2822C",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0.01
					]
				]
			},
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						1.2
					],
					[
						10,
						1.6
					],
					[
						11,
						2
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						14
					],
					[
						18,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			-1
		],
		minzoom: 4,
		maxzoom: 18,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#cc3737",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0.01
					]
				]
			},
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						1.2
					],
					[
						10,
						1.6
					],
					[
						11,
						2
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						14
					],
					[
						18,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 12,
		maxzoom: 18,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": "#BBB",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0.01
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						0.5
					],
					[
						13,
						1
					],
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						6
					],
					[
						17,
						8
					],
					[
						18,
						10
					],
					[
						19,
						12
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 11,
		maxzoom: 18,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": "#BBB",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0
					]
				]
			},
			"line-width": {
				base: 0.1,
				stops: [
					[
						11,
						0.5
					],
					[
						12,
						1
					],
					[
						13,
						2
					],
					[
						14,
						4
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						10
					],
					[
						18,
						12
					],
					[
						19,
						14
					],
					[
						20,
						16
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		maxzoom: 18,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": "#E6B100",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						3.2
					],
					[
						12,
						4.4
					],
					[
						13,
						5
					],
					[
						14,
						6
					],
					[
						15,
						7
					],
					[
						16,
						10
					],
					[
						17,
						15
					],
					[
						18,
						19
					],
					[
						19,
						29
					],
					[
						20,
						39
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			0
		],
		minzoom: 5,
		maxzoom: 18,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": "#F2822C",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			-1
		],
		minzoom: 5,
		maxzoom: 18,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": "#cc3737",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 13,
		maxzoom: 18,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#BBB",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						13,
						0.4
					],
					[
						14,
						3
					],
					[
						15,
						7
					],
					[
						16,
						8
					],
					[
						17,
						9
					],
					[
						18,
						11
					],
					[
						19,
						13
					],
					[
						20,
						18
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9,
		maxzoom: 18,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#BBB",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.1
					],
					[
						11,
						0.5
					],
					[
						12,
						1.5
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						14
					],
					[
						19,
						19
					],
					[
						20,
						24
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 6.5,
		maxzoom: 18,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#E6B100",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						3.2
					],
					[
						12,
						4.4
					],
					[
						13,
						5
					],
					[
						14,
						6
					],
					[
						15,
						10
					],
					[
						16,
						13
					],
					[
						17,
						18
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 5,
		maxzoom: 18,
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#F2822C",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						14
					],
					[
						16,
						16
					],
					[
						17,
						20
					],
					[
						18,
						26
					],
					[
						19,
						36
					],
					[
						20,
						46
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 5,
		maxzoom: 18,
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#cc3737",
			"line-opacity": {
				base: 1,
				stops: [
					[
						5,
						0.5
					],
					[
						18,
						0
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						14
					],
					[
						16,
						16
					],
					[
						17,
						20
					],
					[
						18,
						26
					],
					[
						19,
						36
					],
					[
						20,
						46
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-halo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"==",
			"type",
			0
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#fff",
			"line-opacity": 0.4,
			"line-blur": 4,
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						4
					],
					[
						20,
						16
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-1-1-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"all",
			[
				"==",
				"type",
				0
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#933",
			"line-dasharray": [
				1,
				1,
				5,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-1-0-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"all",
			[
				"==",
				"type",
				0
			],
			[
				"==",
				"vietnam",
				0
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#000",
			"line-dasharray": [
				1,
				1,
				5,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-2-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		minzoom: 4,
		filter: [
			"all",
			[
				"==",
				"type",
				1
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#ccc",
			"line-dasharray": [
				1,
				1,
				3,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-2-conflict-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_conflict_index",
		minzoom: 4,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#933",
			"line-dasharray": [
				1,
				1,
				3,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-3-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		minzoom: 11,
		filter: [
			"all",
			[
				"==",
				"type",
				2
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#ccc",
			"line-dasharray": [
				1,
				1
			]
		}
	},
	{
		id: "line-vnrailway-line-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnrailway_index",
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#444",
			"line-opacity": {
				base: 1,
				stops: [
					[
						11,
						0
					],
					[
						17,
						1
					]
				]
			},
			"line-width": 1,
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnrailway-track-index",
		ref: "line-vnrailway-line-index",
		paint: {
			"line-color": "#444",
			"line-opacity": {
				base: 1,
				stops: [
					[
						11,
						0
					],
					[
						17,
						1
					]
				]
			},
			"line-dasharray": [
				0.1,
				0.5
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						3
					],
					[
						20,
						12
					]
				]
			}
		}
	},
	{
		id: "label_vnmarine_line_index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnmarine_line_index",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-transform": "uppercase",
			"text-size": {
				stops: [
					[
						4,
						16
					],
					[
						12,
						40
					]
				]
			},
			"text-letter-spacing": {
				stops: [
					[
						0,
						0.1
					],
					[
						10,
						0.5
					]
				]
			},
			"symbol-placement": "line"
		},
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#000",
			"text-halo-width": {
				stops: [
					[
						8,
						1
					],
					[
						14,
						2
					]
				]
			},
			"text-halo-blur": 0,
			"text-opacity": {
				stops: [
					[
						0,
						0.5
					],
					[
						10,
						1
					]
				]
			}
		}
	},
	{
		id: "label-vnriver-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnriver_index",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						8,
						8
					],
					[
						20,
						20
					]
				]
			},
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-color": "#FFF",
			"text-halo-width": 1,
			"text-halo-color": "hsl(205, 57%, 34%)"
		}
	},
	{
		id: "symbol-vnway-left-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			2
		],
		layout: {
			"icon-image": "arrow_left",
			"icon-rotation-alignment": "map",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 150
		},
		paint: {
		}
	},
	{
		id: "symbol-vnway-right-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			1
		],
		layout: {
			"icon-image": "arrow_right",
			"icon-rotation-alignment": "map",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 150
		},
		paint: {
		}
	},
	{
		id: "symbol-vnway-no-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			3
		],
		layout: {
			"icon-image": "no_entry",
			"icon-rotation-alignment": "viewport",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 100
		},
		paint: {
		}
	},
	{
		id: "label-vnroad-hemlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						12
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 100
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-width": 1,
			"text-halo-color": "#000",
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-huyenlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 10,
		filter: [
			"==",
			"level",
			2
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						14
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 130
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-width": 1,
			"text-halo-color": "#000",
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-tinhlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 8,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						16
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-width": 1,
			"text-halo-color": "#000",
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-quoclo-index",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		type: "symbol",
		minzoom: 6,
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						18
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-width": 1,
			"text-halo-color": "#000",
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-caotoc-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						18
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-halo-width": 1,
			"text-halo-color": "#000",
			"text-color": "#fff",
			"text-translate-anchor": "viewport"
		}
	},
	{
		id: "label-vnroad-shield1-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnshield_1_index",
		layout: {
			"icon-image": "road_red_level1",
			"icon-rotation-alignment": "viewport",
			"symbol-placement": "line",
			"symbol-spacing": 200,
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": 9,
			"text-transform": "uppercase",
			"text-rotation-alignment": "viewport",
			"text-pitch-alignment": "viewport",
			"text-field": "{name}"
		},
		paint: {
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-shield2-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnshield_2_index",
		layout: {
			"icon-image": "road_yellow_level1",
			"icon-rotation-alignment": "viewport",
			"symbol-placement": "line",
			"symbol-spacing": 200,
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": 8,
			"text-transform": "uppercase",
			"text-rotation-alignment": "viewport",
			"text-pitch-alignment": "viewport",
			"text-field": "{name}"
		},
		paint: {
			"text-color": "#000"
		}
	},
	{
		id: "label-vnpoi-hospital-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		minzoom: 8,
		filter: [
			"==",
			"groupcode",
			5
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#933",
			"text-halo-color": "#FFF",
			"text-halo-width": 1.2
		}
	},
	{
		id: "label-vnpoi-park-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		minzoom: 8,
		filter: [
			"==",
			"categoryco",
			9362
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#a0e4a0",
			"text-halo-color": "#000",
			"text-halo-width": 1.4
		}
	},
	{
		id: "label-vnpoi-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		filter: [
			"all",
			[
				"!=",
				"groupcode",
				5
			],
			[
				"!=",
				"categoryco",
				9362
			]
		],
		minzoom: 8,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#000",
			"text-halo-width": 1.4
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-10-index",
		minzoom: 14,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						20,
						0.2
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						14,
						10
					],
					[
						20,
						18
					]
				]
			}
		},
		filter: [
			"==",
			"level",
			10
		],
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#000",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-789-index",
		minzoom: 13,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						20,
						0.2
					]
				]
			},
			"text-transform": "uppercase",
			"text-font": [
				"Roboto Condensed Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						13,
						10
					],
					[
						20,
						20
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			7,
			8,
			9
		],
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#000",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-456-index",
		minzoom: 9,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						18,
						0.2
					]
				]
			},
			"text-font": [
				"Roboto Condensed Bold"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						6,
						10
					],
					[
						18,
						20
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			4,
			5,
			6
		],
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#000",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						18,
						2
					]
				]
			}
		}
	},
	{
		id: "label-vncities-index",
		source: "vietbando",
		"source-layer": "label_vncities_index",
		maxzoom: 13,
		type: "symbol",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						16,
						18
					]
				]
			},
			"icon-image": "city_level1",
			"text-anchor": "bottom",
			"icon-offset": [
				0,
				6
			]
		},
		paint: {
			"text-color": "#000",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-12-index",
		minzoom: 5,
		maxzoom: 12,
		layout: {
			"text-field": "{name}",
			"text-transform": "uppercase",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						12,
						0.2
					]
				]
			},
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						2,
						8
					],
					[
						12,
						18
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			1,
			2
		],
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#000",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						12,
						2
					]
				]
			}
		}
	},
	{
		id: "label_wcountry_index",
		source: "vietbando",
		"source-layer": "label_wcountry_index",
		type: "symbol",
		minzoom: 20,
		maxzoom: 20,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						1,
						10
					],
					[
						10,
						30
					]
				]
			}
		},
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#000",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wcapitals_index",
		id: "label-wcapitals-index",
		maxzoom: 11,
		layout: {
			visibility: "visible",
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						10,
						18
					]
				]
			},
			"icon-image": "capital",
			"text-anchor": "bottom",
			"icon-offset": [
				0,
				6
			]
		},
		paint: {
			"text-color": "#933",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wmarine_index",
		id: "label-wmarine-sea-index",
		minzoom: 4,
		maxzoom: 14,
		filter: [
			"in",
			"featurecla",
			"sea"
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						5,
						12
					],
					[
						6,
						16
					],
					[
						7,
						20
					],
					[
						8,
						28
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0.1
					],
					[
						5,
						0.2
					],
					[
						6,
						0.4
					],
					[
						7,
						0.8
					],
					[
						8,
						1.2
					]
				]
			},
			"text-max-width": 20,
			"text-transform": "uppercase",
			"text-font": [
				"Noto Sans Medium"
			]
		},
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#000",
			"text-halo-width": 0
		}
	},
	{
		id: "label-vnisland-index",
		source: "vietbando",
		"source-layer": "label_vnisland_index",
		type: "symbol",
		minzoom: 4,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						4,
						10
					],
					[
						19,
						18
					]
				]
			}
		},
		paint: {
			"text-color": "#fff",
			"text-halo-color": "hsl(205, 57%, 34%)",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wmarine_index",
		id: "label-wmarine-ocean-index",
		filter: [
			"in",
			"featurecla",
			"ocean"
		],
		maxzoom: 10,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						1,
						10
					],
					[
						2,
						20
					],
					[
						3,
						30
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						1,
						0.1
					],
					[
						2,
						0.2
					],
					[
						3,
						0.4
					]
				]
			}
		},
		paint: {
			"text-color": "#fff"
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wcontient_index",
		id: "label-wcontient-index",
		layout: {
			visibility: "visible",
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						1,
						10
					],
					[
						2,
						20
					],
					[
						3,
						30
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						1,
						0.1
					],
					[
						2,
						0.2
					],
					[
						3,
						0.4
					]
				]
			}
		},
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#111",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						1,
						2
					],
					[
						2,
						2
					],
					[
						3,
						2
					]
				]
			}
		}
	}
];
var satelliteStyle = {
	version: version$2,
	name: name$2,
	owner: owner$2,
	id: id$2,
	sources: sources$2,
	sprite: sprite$2,
	glyphs: glyphs$2,
	layers: layers$3
};

var version$1 = 8;
var name$1 = "terrian";
var owner$1 = "vietbando";
var id$1 = "mapstyleterain";
var sources$1 = {
	vietbando: {
		url: "https://images.vietbando.com/Source/vt_vbddefault/306ec9b5-8146-4a83-9271-bd7b343a574a",
		type: "vector"
	},
	building: {
		url: "https://images.vietbando.com/Source/vt_building/306ec9b5-8146-4a83-9271-bd7b343a574a",
		type: "vector"
	},
	vt_background: {
		url: "https://images.vietbando.com/Source/vt_background/306ec9b5-8146-4a83-9271-bd7b343a574a",
		type: "vector"
	}
};
var sprite$1 = "https://images.vietbando.com/Sprite/terrian";
var glyphs$1 = "https://images.vietbando.com/Font/{fontstack}/{range}";
var layers$2 = [
	{
		id: "background",
		type: "background",
		paint: {
			"background-color": "#FFFFD3"
		}
	},
	{
		id: "region_water_index",
		source: "vt_background",
		"source-layer": "region_water_index",
		type: "fill",
		paint: {
			"fill-color": "#AAE6FF"
		}
	},
	{
		id: "region-bathymetry-index",
		source: "vt_background",
		"source-layer": "region_bathymetry_index",
		type: "fill",
		paint: {
			"fill-color": "#73B6E6",
			"fill-opacity": 0.15
		}
	},
	{
		id: "region_island_index",
		source: "vietbando",
		"source-layer": "region_island_index",
		type: "fill",
		paint: {
			"fill-color": "#FFFFD3"
		}
	},
	{
		id: "region-river-index",
		source: "vietbando",
		"source-layer": "region_river_index",
		type: "fill",
		paint: {
			"fill-color": "#AAE6FF"
		}
	},
	{
		id: "fill-vnairport-index",
		source: "vietbando",
		"source-layer": "region_vnairport_index",
		minzoom: 4,
		type: "fill",
		paint: {
			"fill-color": "#DDDCDC"
		}
	},
	{
		id: "fill-vnbusstation-index",
		source: "vietbando",
		"source-layer": "region_vnbusstation_index",
		minzoom: 4,
		type: "fill",
		paint: {
			"fill-color": "#DDDCDC"
		}
	},
	{
		id: "fill-vnbuilding-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 10,
		type: "fill",
		filter: [
			"!in",
			"groupcode",
			4,
			5,
			6
		],
		paint: {
			"fill-color": "#DDDCDC"
		}
	},
	{
		id: "fill-vnbuilding-school-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 12,
		type: "fill",
		filter: [
			"==",
			"groupcode",
			4
		],
		paint: {
			"fill-color": "#dbcda2"
		}
	},
	{
		id: "fill-vnbuilding-hospital-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 12,
		type: "fill",
		filter: [
			"==",
			"groupcode",
			5
		],
		paint: {
			"fill-color": "#eccbcb"
		}
	},
	{
		id: "fill-vnbuilding-park-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 12,
		type: "fill",
		filter: [
			"==",
			"groupcode",
			6
		],
		paint: {
			"fill-color": "#7A7"
		}
	},
	{
		id: "fill-vnpark-index",
		source: "vietbando",
		"source-layer": "region_vnpark_index",
		minzoom: 3,
		type: "fill",
		paint: {
			"fill-color": "#7A7"
		}
	},
	{
		id: "line-vntunnel-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 13,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#aaa",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						13,
						0.4
					],
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						5
					],
					[
						17,
						5
					],
					[
						18,
						7
					],
					[
						19,
						9
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#999",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.1
					],
					[
						11,
						0.5
					],
					[
						12,
						1.5
					],
					[
						13,
						2
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						8
					],
					[
						18,
						10
					],
					[
						19,
						15
					],
					[
						20,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#777",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						3.2
					],
					[
						12,
						4
					],
					[
						13,
						4.5
					],
					[
						14,
						5
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			0
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#666",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			-1
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#666",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		minzoom: 14,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "#999",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						7
					],
					[
						18,
						9
					],
					[
						19,
						11
					],
					[
						20,
						16
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 13,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "#888",
			"line-gap-width": {
				base: 0.1,
				stops: [
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						10
					],
					[
						18,
						12
					],
					[
						19,
						17
					],
					[
						20,
						22
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 12,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "#666",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						12,
						4.4
					],
					[
						13,
						5
					],
					[
						14,
						6
					],
					[
						15,
						7
					],
					[
						16,
						10
					],
					[
						17,
						15
					],
					[
						18,
						19
					],
					[
						19,
						29
					],
					[
						20,
						39
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			0
		],
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "#555",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			-1
		],
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "#444",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 13,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#888",
			"line-dasharray": [
				2,
				2
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						10,
						0.2
					],
					[
						11,
						0.4
					],
					[
						12,
						0.6
					],
					[
						13,
						0.8
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						7
					],
					[
						18,
						9
					],
					[
						19,
						12
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#888",
			"line-width": 1,
			"line-dasharray": [
				2,
				2
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						11,
						0.6
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#666",
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						1.2
					],
					[
						12,
						2.4
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						5
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#666",
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						1.2
					],
					[
						10,
						1.6
					],
					[
						11,
						2
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						14
					],
					[
						18,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#666",
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						1.2
					],
					[
						10,
						1.6
					],
					[
						11,
						2
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						14
					],
					[
						18,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 12,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#aaa"
					],
					[
						14,
						"#aaa"
					],
					[
						15,
						"#888"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						0.5
					],
					[
						13,
						1
					],
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						6
					],
					[
						17,
						8
					],
					[
						18,
						10
					],
					[
						19,
						12
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#999"
					],
					[
						13,
						"#999"
					],
					[
						14,
						"#777"
					]
				]
			},
			"line-width": {
				base: 0.1,
				stops: [
					[
						11,
						0.5
					],
					[
						12,
						1
					],
					[
						13,
						2
					],
					[
						14,
						4
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						10
					],
					[
						18,
						12
					],
					[
						19,
						14
					],
					[
						20,
						16
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#777"
					],
					[
						12,
						"#777"
					],
					[
						13,
						"#555"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						3.2
					],
					[
						12,
						4.4
					],
					[
						13,
						5
					],
					[
						14,
						6
					],
					[
						15,
						7
					],
					[
						16,
						10
					],
					[
						17,
						15
					],
					[
						18,
						19
					],
					[
						19,
						29
					],
					[
						20,
						39
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			0
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#666"
					],
					[
						11,
						"#666"
					],
					[
						12,
						"#444"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			-1
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#555"
					],
					[
						11,
						"#555"
					],
					[
						12,
						"#333"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#aaa",
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						0.2
					],
					[
						13,
						0.5
					],
					[
						14,
						1
					],
					[
						15,
						3
					],
					[
						16,
						5
					],
					[
						17,
						7
					],
					[
						18,
						9
					],
					[
						19,
						11
					],
					[
						20,
						13
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			2
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#999",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						0.2
					],
					[
						12,
						0.5
					],
					[
						13,
						1
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						7
					],
					[
						17,
						9
					],
					[
						18,
						11
					],
					[
						19,
						13
					],
					[
						20,
						15
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 12,
		filter: [
			"in",
			"level",
			1
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#777",
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						4
					],
					[
						13,
						4.5
					],
					[
						14,
						5
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#666",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#555",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 13,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#aaa"
					],
					[
						14,
						"#aaa"
					],
					[
						15,
						"#888"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						13,
						0.4
					],
					[
						14,
						3
					],
					[
						15,
						7
					],
					[
						16,
						8
					],
					[
						17,
						9
					],
					[
						18,
						11
					],
					[
						19,
						13
					],
					[
						20,
						18
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#999"
					],
					[
						13,
						"#999"
					],
					[
						14,
						"#777"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.1
					],
					[
						11,
						0.5
					],
					[
						12,
						1.5
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						14
					],
					[
						19,
						19
					],
					[
						20,
						24
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 6.5,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#777"
					],
					[
						12,
						"#777"
					],
					[
						13,
						"#555"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						3.2
					],
					[
						12,
						4.4
					],
					[
						13,
						5
					],
					[
						14,
						6
					],
					[
						15,
						10
					],
					[
						16,
						13
					],
					[
						17,
						18
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 5,
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#666"
					],
					[
						11,
						"#666"
					],
					[
						12,
						"#444"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						14
					],
					[
						16,
						16
					],
					[
						17,
						20
					],
					[
						18,
						26
					],
					[
						19,
						36
					],
					[
						20,
						46
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 5,
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#555"
					],
					[
						11,
						"#555"
					],
					[
						12,
						"#333"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						14
					],
					[
						16,
						16
					],
					[
						17,
						20
					],
					[
						18,
						26
					],
					[
						19,
						36
					],
					[
						20,
						46
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 14,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#aaa",
			"line-width": {
				base: 1,
				stops: [
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						5
					],
					[
						17,
						5
					],
					[
						18,
						7
					],
					[
						19,
						9
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 13,
		filter: [
			"==",
			"level",
			2
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#999",
			"line-width": {
				base: 1,
				stops: [
					[
						13,
						2
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						8
					],
					[
						18,
						10
					],
					[
						19,
						15
					],
					[
						20,
						20
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#777",
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						4
					],
					[
						13,
						4.5
					],
					[
						14,
						5
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#666",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#555",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-halo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"==",
			"type",
			0
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#fff",
			"line-opacity": 0.4,
			"line-blur": 4,
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						4
					],
					[
						20,
						16
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-1-1-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"all",
			[
				"==",
				"type",
				0
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#933",
			"line-dasharray": [
				1,
				1,
				5,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-1-0-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"all",
			[
				"==",
				"type",
				0
			],
			[
				"==",
				"vietnam",
				0
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#444",
			"line-dasharray": [
				1,
				1,
				5,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-2-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		minzoom: 4,
		filter: [
			"all",
			[
				"==",
				"type",
				1
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#444",
			"line-dasharray": [
				1,
				1,
				3,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-2-conflict-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_conflict_index",
		minzoom: 4,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#933",
			"line-dasharray": [
				1,
				1,
				3,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-3-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		minzoom: 11,
		filter: [
			"all",
			[
				"==",
				"type",
				2
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#444",
			"line-dasharray": [
				1,
				1
			]
		}
	},
	{
		id: "line-vnrailway-line-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnrailway_index",
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#444",
			"line-opacity": {
				base: 1,
				stops: [
					[
						11,
						0
					],
					[
						17,
						1
					]
				]
			},
			"line-width": 1,
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnrailway-track-index",
		ref: "line-vnrailway-line-index",
		paint: {
			"line-color": "#444",
			"line-opacity": {
				base: 1,
				stops: [
					[
						11,
						0
					],
					[
						17,
						1
					]
				]
			},
			"line-dasharray": [
				0.1,
				0.5
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						3
					],
					[
						20,
						12
					]
				]
			}
		}
	},
	{
		id: "region_building3d_index",
		"source-layer": "region_building3d_index",
		source: "building",
		type: "fill-extrusion",
		minzoom: 15,
		paint: {
			"fill-extrusion-color": "#ddd",
			"fill-extrusion-height": {
				type: "identity",
				property: "height"
			},
			"fill-extrusion-base": {
				type: "identity",
				property: "base_height"
			},
			"fill-extrusion-opacity": 0.6
		}
	},
	{
		id: "label_vnmarine_line_index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnmarine_line_index",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-transform": "uppercase",
			"text-size": {
				stops: [
					[
						4,
						16
					],
					[
						12,
						40
					]
				]
			},
			"text-letter-spacing": {
				stops: [
					[
						0,
						0.1
					],
					[
						10,
						0.5
					]
				]
			},
			"symbol-placement": "line"
		},
		paint: {
			"text-color": "#000",
			"text-halo-color": "#fff",
			"text-halo-width": {
				stops: [
					[
						8,
						1
					],
					[
						14,
						2
					]
				]
			},
			"text-halo-blur": 0,
			"text-opacity": {
				stops: [
					[
						0,
						0.5
					],
					[
						10,
						1
					]
				]
			}
		}
	},
	{
		id: "label-vnriver-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnriver_index",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						8,
						8
					],
					[
						20,
						20
					]
				]
			},
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-color": "hsl(205, 57%, 34%)",
			"text-halo-width": 1,
			"text-halo-color": "#FFF"
		}
	},
	{
		id: "symbol-vnway-left-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			2
		],
		layout: {
			"icon-image": "arrow_left",
			"icon-rotation-alignment": "map",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 150
		},
		paint: {
		}
	},
	{
		id: "symbol-vnway-right-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			1
		],
		layout: {
			"icon-image": "arrow_right",
			"icon-rotation-alignment": "map",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 150
		},
		paint: {
		}
	},
	{
		id: "symbol-vnway-no-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			3
		],
		layout: {
			"icon-image": "no_entry",
			"icon-rotation-alignment": "viewport",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 100
		},
		paint: {
		}
	},
	{
		id: "label-vnroad-hemlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						12
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 100
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-width": 2,
			"text-halo-color": "#444",
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-huyenlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 10,
		filter: [
			"==",
			"level",
			2
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						14
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 130
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-width": 2,
			"text-halo-color": "#444",
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-tinhlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 8,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						16
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-width": 2,
			"text-halo-color": "#444",
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-quoclo-index",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		type: "symbol",
		minzoom: 6,
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						18
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-width": 2,
			"text-halo-color": "#444",
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-caotoc-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						18
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-width": 2,
			"text-halo-color": "#444",
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-shield1-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnshield_1_index",
		layout: {
			"icon-image": "road_red_level1",
			"icon-rotation-alignment": "viewport",
			"symbol-placement": "line",
			"symbol-spacing": 200,
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": 9,
			"text-transform": "uppercase",
			"text-rotation-alignment": "viewport",
			"text-pitch-alignment": "viewport",
			"text-field": "{name}"
		},
		paint: {
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-shield2-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnshield_2_index",
		layout: {
			"icon-image": "road_yellow_level1",
			"icon-rotation-alignment": "viewport",
			"symbol-placement": "line",
			"symbol-spacing": 200,
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": 8,
			"text-transform": "uppercase",
			"text-rotation-alignment": "viewport",
			"text-pitch-alignment": "viewport",
			"text-field": "{name}"
		},
		paint: {
			"text-color": "#000",
			"text-translate-anchor": "viewport",
			"icon-opacity": 1
		}
	},
	{
		id: "label-vnpoi-hospital-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		minzoom: 8,
		filter: [
			"==",
			"groupcode",
			5
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#933",
			"text-halo-color": "#fff",
			"text-halo-width": 0.3
		}
	},
	{
		id: "label-vnpoi-park-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		minzoom: 8,
		filter: [
			"==",
			"categoryco",
			9362
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#096009",
			"text-halo-color": "#fff",
			"text-halo-width": 0.5
		}
	},
	{
		id: "label-vnpoi-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		minzoom: 8,
		filter: [
			"all",
			[
				"!=",
				"groupcode",
				5
			],
			[
				"!=",
				"categoryco",
				9362
			]
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#000",
			"text-halo-color": "#fff",
			"text-halo-width": 0.5
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-10-index",
		minzoom: 14,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						20,
						0.2
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						14,
						10
					],
					[
						20,
						18
					]
				]
			}
		},
		filter: [
			"==",
			"level",
			10
		],
		paint: {
			"text-color": "#613000",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-789-index",
		minzoom: 13,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						20,
						0.2
					]
				]
			},
			"text-transform": "uppercase",
			"text-font": [
				"Roboto Condensed Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						13,
						10
					],
					[
						20,
						18
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			7,
			8,
			9
		],
		paint: {
			"text-color": "#613000",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-456-index",
		minzoom: 9,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						18,
						0.2
					]
				]
			},
			"text-font": [
				"Roboto Condensed Bold"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						6,
						10
					],
					[
						18,
						20
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			4,
			5,
			6
		],
		paint: {
			"text-color": "#613000",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						18,
						2
					]
				]
			}
		}
	},
	{
		id: "label-vncities-index",
		source: "vietbando",
		"source-layer": "label_vncities_index",
		maxzoom: 13,
		type: "symbol",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						16,
						18
					]
				]
			},
			"icon-image": "city_level1",
			"text-anchor": "bottom",
			"icon-offset": [
				0,
				6
			]
		},
		paint: {
			"text-color": "#000",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-12-index",
		minzoom: 5,
		maxzoom: 12,
		layout: {
			"text-field": "{name}",
			"text-transform": "uppercase",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						12,
						0.2
					]
				]
			},
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						2,
						8
					],
					[
						12,
						18
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			1,
			2
		],
		paint: {
			"text-color": "#111",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						12,
						2
					]
				]
			}
		}
	},
	{
		id: "label_wcountry_index",
		source: "vietbando",
		"source-layer": "label_wcountry_index",
		type: "symbol",
		minzoom: 20,
		maxzoom: 20,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						1,
						10
					],
					[
						10,
						30
					]
				]
			}
		},
		paint: {
			"text-color": "#111",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wcapitals_index",
		id: "label-wcapitals-index",
		maxzoom: 11,
		layout: {
			visibility: "visible",
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						10,
						18
					]
				]
			},
			"icon-image": "capital",
			"text-anchor": "bottom",
			"icon-offset": [
				0,
				6
			]
		},
		paint: {
			"text-color": "#933",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wmarine_index",
		id: "label-wmarine-sea-index",
		minzoom: 4,
		maxzoom: 14,
		filter: [
			"in",
			"featurecla",
			"sea"
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						5,
						12
					],
					[
						6,
						16
					],
					[
						7,
						20
					],
					[
						8,
						28
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0.1
					],
					[
						5,
						0.2
					],
					[
						6,
						0.4
					],
					[
						7,
						0.8
					],
					[
						8,
						1.2
					]
				]
			},
			"text-max-width": 20,
			"text-transform": "uppercase",
			"text-font": [
				"Noto Sans Medium"
			]
		},
		paint: {
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnisland-index",
		source: "vietbando",
		"source-layer": "label_vnisland_index",
		type: "symbol",
		minzoom: 4,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						4,
						10
					],
					[
						19,
						18
					]
				]
			}
		},
		paint: {
			"text-color": "#005291",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wmarine_index",
		id: "label-wmarine-ocean-index",
		filter: [
			"in",
			"featurecla",
			"ocean"
		],
		maxzoom: 10,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						1,
						10
					],
					[
						2,
						20
					],
					[
						3,
						30
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						1,
						0.1
					],
					[
						2,
						0.2
					],
					[
						3,
						0.4
					]
				]
			}
		},
		paint: {
			"text-color": "#fff"
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wcontient_index",
		id: "label-wcontient-index",
		layout: {
			visibility: "visible",
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						1,
						10
					],
					[
						2,
						20
					],
					[
						3,
						30
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						1,
						0.1
					],
					[
						2,
						0.2
					],
					[
						3,
						0.4
					]
				]
			}
		},
		paint: {
			"text-color": "#000",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						1,
						2
					],
					[
						2,
						2
					],
					[
						3,
						2
					]
				]
			}
		}
	}
];
var terrainStyle = {
	version: version$1,
	name: name$1,
	owner: owner$1,
	id: id$1,
	sources: sources$1,
	sprite: sprite$1,
	glyphs: glyphs$1,
	layers: layers$2
};

var version = 8;
var name = "admin";
var owner = "vietbando";
var id = "mapstyleBoundary";
var sources = {
	vietbando: {
		url: "https://images.vietbando.com/Source/vt_vbddefault/306ec9b5-8146-4a83-9271-bd7b343a574a",
		type: "vector"
	},
	building: {
		url: "https://images.vietbando.com/Source/vt_building/306ec9b5-8146-4a83-9271-bd7b343a574a",
		type: "vector"
	},
	vt_background: {
		url: "https://images.vietbando.com/Source/vt_background/306ec9b5-8146-4a83-9271-bd7b343a574a",
		type: "vector"
	}
};
var sprite = "https://images.vietbando.com/Sprite/admin";
var glyphs = "https://images.vietbando.com/Font/{fontstack}/{range}";
var layers$1 = [
	{
		id: "background",
		type: "background",
		paint: {
			"background-color": "#E8E0D8"
		}
	},
	{
		id: "region_water_index",
		source: "vt_background",
		"source-layer": "region_water_index",
		type: "fill",
		paint: {
			"fill-color": "#8fc4ec"
		}
	},
	{
		id: "region-bathymetry-index",
		source: "vt_background",
		"source-layer": "region_bathymetry_index",
		type: "fill",
		paint: {
			"fill-color": "#15659f",
			"fill-opacity": 0.15
		}
	},
	{
		id: "region-vnisland-index",
		source: "vietbando",
		"source-layer": "region_island_index",
		type: "fill",
		paint: {
			"fill-opacity": 1,
			"fill-color": {
				property: "color",
				type: "categorical",
				stops: [
					[
						0,
						"#E8E0D8"
					],
					[
						1,
						"#cdd88b"
					],
					[
						2,
						"#f6d79e"
					],
					[
						3,
						"#f0eabe"
					],
					[
						4,
						"#b7d29c"
					],
					[
						5,
						"#F2E3F2"
					],
					[
						6,
						"#f4c2c2"
					],
					[
						7,
						"#d2caff"
					],
					[
						8,
						"#c2d4f4"
					]
				]
			}
		}
	},
	{
		id: "region-river-index",
		source: "vietbando",
		"source-layer": "region_river_index",
		type: "fill",
		paint: {
			"fill-color": "#8fc4ec"
		}
	},
	{
		id: "fill-vnairport-index",
		source: "vietbando",
		"source-layer": "region_vnairport_index",
		minzoom: 4,
		type: "fill",
		paint: {
			"fill-color": "#BBA"
		}
	},
	{
		id: "fill-vnbusstation-index",
		source: "vietbando",
		"source-layer": "region_vnbusstation_index",
		minzoom: 4,
		type: "fill",
		paint: {
			"fill-color": "#BBA"
		}
	},
	{
		id: "fill-vnbuilding-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 10,
		type: "fill",
		filter: [
			"!in",
			"groupcode",
			5,
			6
		],
		paint: {
			"fill-color": "#BBA"
		}
	},
	{
		id: "fill-vnbuilding-hospital-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 12,
		type: "fill",
		filter: [
			"==",
			"groupcode",
			5
		],
		paint: {
			"fill-color": "#ffe2e2"
		}
	},
	{
		id: "fill-vnbuilding-park-index",
		source: "vietbando",
		"source-layer": "region_vnbuilding_index",
		minzoom: 12,
		type: "fill",
		filter: [
			"==",
			"groupcode",
			6
		],
		paint: {
			"fill-color": "#7A7"
		}
	},
	{
		id: "fill-vnpark-index",
		source: "vietbando",
		"source-layer": "region_vnpark_index",
		type: "fill",
		minzoom: 3,
		paint: {
			"fill-color": "#7A7"
		}
	},
	{
		id: "line-vntunnel-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 13,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						13,
						0.4
					],
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						5
					],
					[
						17,
						5
					],
					[
						18,
						7
					],
					[
						19,
						9
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						13,
						2
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						8
					],
					[
						18,
						10
					],
					[
						19,
						15
					],
					[
						20,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						1.2
					],
					[
						12,
						2.4
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						5
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			0
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#933",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "line-vntunnel-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			-1
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-opacity": 0.5,
			"line-color": "#933",
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 14,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "#888",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						7
					],
					[
						18,
						9
					],
					[
						19,
						11
					],
					[
						20,
						16
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "#888",
			"line-gap-width": {
				base: 0.1,
				stops: [
					[
						0,
						0.1
					],
					[
						11,
						0.5
					],
					[
						12,
						1.5
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						10
					],
					[
						18,
						12
					],
					[
						19,
						17
					],
					[
						20,
						22
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 10,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "#888",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						10,
						0.8
					],
					[
						11,
						1.2
					],
					[
						12,
						2.4
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						5
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			0
		],
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "#fff",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "fill-vntunnel-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vntunnel_index",
		filter: [
			"==",
			"level",
			-1
		],
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-dasharray": [
				3,
				3
			],
			"line-width": 1,
			"line-color": "#fff",
			"line-gap-width": {
				base: 1,
				stops: [
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 13,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#888",
			"line-dasharray": [
				2,
				2
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						10,
						0.2
					],
					[
						11,
						0.4
					],
					[
						12,
						0.6
					],
					[
						13,
						0.8
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						7
					],
					[
						18,
						9
					],
					[
						19,
						12
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#888",
			"line-width": 1,
			"line-dasharray": [
				2,
				2
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						11,
						0.6
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#888",
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						1.2
					],
					[
						12,
						2.4
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						5
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#933",
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						1.2
					],
					[
						10,
						1.6
					],
					[
						11,
						2
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						14
					],
					[
						18,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vnferry-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnferry_index",
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			visibility: "visible",
			"line-cap": "square",
			"line-join": "round"
		},
		paint: {
			"line-color": "#933",
			"line-dasharray": [
				3,
				3
			],
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						1.2
					],
					[
						10,
						1.6
					],
					[
						11,
						2
					],
					[
						12,
						3
					],
					[
						13,
						4
					],
					[
						14,
						6
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						14
					],
					[
						18,
						20
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 12,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#BBB"
					],
					[
						14,
						"#BBB"
					],
					[
						15,
						"#777"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						0.5
					],
					[
						13,
						1
					],
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						6
					],
					[
						17,
						8
					],
					[
						18,
						10
					],
					[
						19,
						12
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#BBB"
					],
					[
						13,
						"#BBB"
					],
					[
						14,
						"#777"
					]
				]
			},
			"line-width": {
				base: 0.1,
				stops: [
					[
						11,
						0.5
					],
					[
						12,
						1
					],
					[
						13,
						2
					],
					[
						14,
						4
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						10
					],
					[
						18,
						12
					],
					[
						19,
						14
					],
					[
						20,
						16
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			1
		],
		minzoom: 6.5,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#BBB"
					],
					[
						12,
						"#BBB"
					],
					[
						13,
						"#777"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						3.2
					],
					[
						12,
						4.4
					],
					[
						13,
						5
					],
					[
						14,
						6
					],
					[
						15,
						7
					],
					[
						16,
						10
					],
					[
						17,
						15
					],
					[
						18,
						19
					],
					[
						19,
						29
					],
					[
						20,
						39
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			0
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#933"
					],
					[
						10,
						"#933"
					],
					[
						11,
						"#fff"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnroad-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		filter: [
			"==",
			"level",
			-1
		],
		minzoom: 5,
		layout: {
			visibility: "visible",
			"line-join": "round",
			"line-cap": "round"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#933"
					],
					[
						11,
						"#933"
					],
					[
						12,
						"#fff"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						10
					],
					[
						16,
						12
					],
					[
						17,
						16
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						0.2
					],
					[
						13,
						0.5
					],
					[
						14,
						1
					],
					[
						15,
						3
					],
					[
						16,
						5
					],
					[
						17,
						7
					],
					[
						18,
						9
					],
					[
						19,
						11
					],
					[
						20,
						13
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			2
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						0.2
					],
					[
						12,
						0.5
					],
					[
						13,
						1
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						7
					],
					[
						17,
						9
					],
					[
						18,
						11
					],
					[
						19,
						13
					],
					[
						20,
						15
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						4
					],
					[
						13,
						4.5
					],
					[
						14,
						5
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#933",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "fill-vnroad-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnroad_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#933",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		filter: [
			"==",
			"level",
			3
		],
		minzoom: 13,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#BBB"
					],
					[
						14,
						"#BBB"
					],
					[
						15,
						"#777"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						13,
						0.4
					],
					[
						14,
						3
					],
					[
						15,
						7
					],
					[
						16,
						8
					],
					[
						17,
						9
					],
					[
						18,
						11
					],
					[
						19,
						13
					],
					[
						20,
						18
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		filter: [
			"==",
			"level",
			2
		],
		minzoom: 9,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#BBB"
					],
					[
						13,
						"#BBB"
					],
					[
						14,
						"#777"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.1
					],
					[
						11,
						0.5
					],
					[
						12,
						1.5
					],
					[
						13,
						3
					],
					[
						14,
						4
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						14
					],
					[
						19,
						19
					],
					[
						20,
						24
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 6.5,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#BBB"
					],
					[
						12,
						"#BBB"
					],
					[
						13,
						"#777"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.2
					],
					[
						7,
						0.4
					],
					[
						10,
						0.8
					],
					[
						11,
						3.2
					],
					[
						12,
						4.4
					],
					[
						13,
						5
					],
					[
						14,
						6
					],
					[
						15,
						10
					],
					[
						16,
						13
					],
					[
						17,
						18
					],
					[
						18,
						22
					],
					[
						19,
						32
					],
					[
						20,
						42
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 5,
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#933"
					],
					[
						11,
						"#933"
					],
					[
						12,
						"#fff"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						14
					],
					[
						16,
						16
					],
					[
						17,
						20
					],
					[
						18,
						26
					],
					[
						19,
						36
					],
					[
						20,
						46
					]
				]
			}
		}
	},
	{
		id: "line-vnbridge-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 5,
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": {
				base: 1,
				stops: [
					[
						0,
						"#933"
					],
					[
						11,
						"#933"
					],
					[
						12,
						"#fff"
					]
				]
			},
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						0.4
					],
					[
						7,
						0.6
					],
					[
						8,
						0.8
					],
					[
						9,
						3.2
					],
					[
						10,
						3.6
					],
					[
						11,
						4
					],
					[
						12,
						5
					],
					[
						13,
						6
					],
					[
						14,
						8
					],
					[
						15,
						14
					],
					[
						16,
						16
					],
					[
						17,
						20
					],
					[
						18,
						26
					],
					[
						19,
						36
					],
					[
						20,
						46
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-hemlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 14,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						14,
						2
					],
					[
						15,
						4
					],
					[
						16,
						5
					],
					[
						17,
						5
					],
					[
						18,
						7
					],
					[
						19,
						9
					],
					[
						20,
						14
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-huyenlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 13,
		filter: [
			"==",
			"level",
			2
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						13,
						2
					],
					[
						14,
						3
					],
					[
						15,
						5
					],
					[
						16,
						6
					],
					[
						17,
						8
					],
					[
						18,
						10
					],
					[
						19,
						15
					],
					[
						20,
						20
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-tinhlo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#fff",
			"line-width": {
				base: 1,
				stops: [
					[
						12,
						4
					],
					[
						13,
						4.5
					],
					[
						14,
						5
					],
					[
						15,
						6
					],
					[
						16,
						8
					],
					[
						17,
						13
					],
					[
						18,
						17
					],
					[
						19,
						27
					],
					[
						20,
						37
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-quoclo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#933",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "fill-vnbridge-caotoc-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnbridge_index",
		minzoom: 11,
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#933",
			"line-width": {
				base: 1,
				stops: [
					[
						11,
						3
					],
					[
						12,
						4
					],
					[
						13,
						5
					],
					[
						14,
						7
					],
					[
						15,
						8
					],
					[
						16,
						10
					],
					[
						17,
						12
					],
					[
						18,
						18
					],
					[
						19,
						28
					],
					[
						20,
						38
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-halo-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"==",
			"type",
			0
		],
		layout: {
			visibility: "visible",
			"line-cap": "round",
			"line-join": "round"
		},
		paint: {
			"line-color": "#fff",
			"line-opacity": 0.4,
			"line-blur": 4,
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						4
					],
					[
						20,
						16
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-1-1-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"all",
			[
				"==",
				"type",
				0
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#933",
			"line-dasharray": [
				1,
				1,
				5,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-1-0-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		filter: [
			"all",
			[
				"==",
				"type",
				0
			],
			[
				"==",
				"vietnam",
				0
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#000",
			"line-dasharray": [
				1,
				1,
				5,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-2-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		minzoom: 4,
		filter: [
			"all",
			[
				"==",
				"type",
				1
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#fff",
			"line-dasharray": [
				1,
				1,
				3,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-2-conflict-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_conflict_index",
		minzoom: 4,
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#933",
			"line-dasharray": [
				1,
				1,
				3,
				1
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		id: "line-vnborder-3-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnborder_index",
		minzoom: 11,
		filter: [
			"all",
			[
				"==",
				"type",
				2
			],
			[
				"==",
				"vietnam",
				1
			]
		],
		layout: {
			visibility: "visible"
		},
		paint: {
			"line-color": "#fff",
			"line-dasharray": [
				1,
				1
			]
		}
	},
	{
		id: "line-vnrailway-line-index",
		type: "line",
		source: "vietbando",
		"source-layer": "line_vnrailway_index",
		minzoom: 11,
		layout: {
			visibility: "visible",
			"line-join": "round"
		},
		paint: {
			"line-color": "#444",
			"line-opacity": {
				base: 1,
				stops: [
					[
						11,
						0
					],
					[
						17,
						1
					]
				]
			},
			"line-width": 1,
			"line-gap-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						20,
						4
					]
				]
			}
		}
	},
	{
		id: "line-vnrailway-track-index",
		ref: "line-vnrailway-line-index",
		paint: {
			"line-color": "#444",
			"line-opacity": {
				base: 1,
				stops: [
					[
						11,
						0
					],
					[
						17,
						1
					]
				]
			},
			"line-dasharray": [
				0.1,
				0.5
			],
			"line-width": {
				base: 1,
				stops: [
					[
						0,
						3
					],
					[
						20,
						12
					]
				]
			}
		}
	},
	{
		id: "region_building3d_index",
		"source-layer": "region_building3d_index",
		source: "building",
		type: "fill-extrusion",
		minzoom: 15,
		paint: {
			"fill-extrusion-color": "#ddd",
			"fill-extrusion-height": {
				type: "identity",
				property: "height"
			},
			"fill-extrusion-base": {
				type: "identity",
				property: "base_height"
			},
			"fill-extrusion-opacity": 0.5
		}
	},
	{
		id: "label_vnmarine_line_index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnmarine_line_index",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-transform": "uppercase",
			"text-size": {
				stops: [
					[
						4,
						16
					],
					[
						12,
						40
					]
				]
			},
			"text-letter-spacing": {
				stops: [
					[
						0,
						0.1
					],
					[
						10,
						0.5
					]
				]
			},
			"symbol-placement": "line"
		},
		paint: {
			"text-color": "#111",
			"text-halo-color": "#fff",
			"text-halo-width": {
				stops: [
					[
						8,
						1
					],
					[
						14,
						2
					]
				]
			},
			"text-halo-blur": 0,
			"text-opacity": {
				stops: [
					[
						0,
						0.5
					],
					[
						10,
						1
					]
				]
			}
		}
	},
	{
		id: "label-vnriver-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnriver_index",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						8,
						8
					],
					[
						20,
						20
					]
				]
			},
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-color": "hsl(205, 57%, 34%)",
			"text-halo-width": 1,
			"text-halo-color": "#FFF"
		}
	},
	{
		id: "symbol-vnway-left-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			2
		],
		layout: {
			"icon-image": "arrow_left",
			"icon-rotation-alignment": "map",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 150
		},
		paint: {
		}
	},
	{
		id: "symbol-vnway-right-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			1
		],
		layout: {
			"icon-image": "arrow_right",
			"icon-rotation-alignment": "map",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 150
		},
		paint: {
		}
	},
	{
		id: "symbol-vnway-no-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "symbol_vnway_index",
		minzoom: 16,
		filter: [
			"==",
			"direction",
			3
		],
		layout: {
			"icon-image": "no_entry",
			"icon-rotation-alignment": "viewport",
			"icon-padding": 0,
			"symbol-placement": "line",
			"symbol-spacing": 100
		},
		paint: {
		}
	},
	{
		id: "label-vnroad-hemlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 12,
		filter: [
			"==",
			"level",
			3
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						12
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 100
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-color": "#fff",
			"text-halo-width": 1,
			"text-color": "#000"
		}
	},
	{
		id: "label-vnroad-huyenlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 10,
		filter: [
			"==",
			"level",
			2
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						14
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 130
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-color": "#fff",
			"text-halo-width": 1,
			"text-color": "#000"
		}
	},
	{
		id: "label-vnroad-tinhlo-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		minzoom: 8,
		filter: [
			"==",
			"level",
			1
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						16
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-color": "#fff",
			"text-halo-width": 1,
			"text-color": "#000"
		}
	},
	{
		id: "label-vnroad-quoclo-index",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		type: "symbol",
		minzoom: 6,
		filter: [
			"==",
			"level",
			0
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						18
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-color": "#000",
			"text-halo-width": 1,
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-caotoc-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnroad_index",
		filter: [
			"==",
			"level",
			-1
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						20,
						18
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-transform": "uppercase",
			"text-max-angle": 30,
			"text-pitch-alignment": "viewport",
			"text-letter-spacing": 0.01,
			"symbol-placement": "line",
			"symbol-spacing": 200
		},
		paint: {
			"text-translate-anchor": "viewport",
			"text-halo-color": "#000",
			"text-halo-width": 1,
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-shield1-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnshield_1_index",
		layout: {
			"icon-image": "road_red_level1",
			"icon-rotation-alignment": "viewport",
			"symbol-placement": "line",
			"symbol-spacing": 200,
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": 9,
			"text-transform": "uppercase",
			"text-rotation-alignment": "viewport",
			"text-pitch-alignment": "viewport",
			"text-field": "{name}"
		},
		paint: {
			"text-color": "#fff"
		}
	},
	{
		id: "label-vnroad-shield2-index",
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnshield_2_index",
		layout: {
			"icon-image": "road_yellow_level1",
			"icon-rotation-alignment": "viewport",
			"symbol-placement": "line",
			"symbol-spacing": 200,
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": 8,
			"text-transform": "uppercase",
			"text-rotation-alignment": "viewport",
			"text-pitch-alignment": "viewport",
			"text-field": "{name}"
		},
		paint: {
			"text-color": "#000",
			"text-translate-anchor": "viewport",
			"icon-opacity": 1
		}
	},
	{
		id: "label-vnpoi-hospital-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		minzoom: 8,
		filter: [
			"==",
			"groupcode",
			5
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#933",
			"text-halo-color": "#fff",
			"text-halo-width": 0.3
		}
	},
	{
		id: "label-vnpoi-park-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		minzoom: 8,
		filter: [
			"==",
			"categoryco",
			9362
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#096009",
			"text-halo-color": "#fff",
			"text-halo-width": 0.5
		}
	},
	{
		id: "label-vnpoi-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		minzoom: 8,
		filter: [
			"all",
			[
				"!=",
				"groupcode",
				5
			],
			[
				"!=",
				"categoryco",
				9362
			]
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						15
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#000",
			"text-halo-color": "#fff",
			"text-halo-width": 0.5
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-10-index",
		minzoom: 14,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						20,
						0.2
					]
				]
			},
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						14,
						10
					],
					[
						20,
						18
					]
				]
			}
		},
		filter: [
			"==",
			"level",
			10
		],
		paint: {
			"text-color": "#613000",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-789-index",
		minzoom: 13,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						20,
						0.2
					]
				]
			},
			"text-transform": "uppercase",
			"text-font": [
				"Roboto Condensed Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						13,
						10
					],
					[
						20,
						18
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			7,
			8,
			9
		],
		paint: {
			"text-color": "#613000",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						20,
						2
					]
				]
			}
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-456-index",
		minzoom: 9,
		layout: {
			"text-field": "{name}",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						18,
						0.2
					]
				]
			},
			"text-font": [
				"Roboto Condensed Bold"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						6,
						10
					],
					[
						18,
						20
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			4,
			5,
			6
		],
		paint: {
			"text-color": "#613000",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						18,
						2
					]
				]
			}
		}
	},
	{
		id: "label-vncities-index",
		source: "vietbando",
		"source-layer": "label_vncities_index",
		maxzoom: 14,
		type: "symbol",
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						16,
						18
					]
				]
			},
			"icon-image": "city_level1",
			"text-anchor": "bottom",
			"icon-offset": [
				0,
				6
			]
		},
		paint: {
			"text-color": "#000",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_vnadmin_index",
		id: "label-vnadmin-12-index",
		minzoom: 5,
		maxzoom: 12,
		layout: {
			"text-field": "{name}",
			"text-transform": "uppercase",
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						12,
						0.2
					]
				]
			},
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						2,
						8
					],
					[
						12,
						18
					]
				]
			}
		},
		filter: [
			"in",
			"level",
			1,
			2
		],
		paint: {
			"text-color": "#111",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						8,
						1
					],
					[
						12,
						2
					]
				]
			}
		}
	},
	{
		id: "label_wcountry_index",
		source: "vietbando",
		"source-layer": "label_wcountry_index",
		type: "symbol",
		minzoom: 20,
		maxzoom: 20,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						1,
						10
					],
					[
						10,
						30
					]
				]
			}
		},
		paint: {
			"text-color": "#111",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wcapitals_index",
		id: "label-wcapitals-index",
		maxzoom: 11,
		layout: {
			visibility: "visible",
			"text-field": "{name}",
			"text-font": [
				"Roboto Bold"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						10,
						18
					]
				]
			},
			"icon-image": "capital",
			"text-anchor": "bottom",
			"icon-offset": [
				0,
				6
			]
		},
		paint: {
			"text-color": "#933",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wmarine_index",
		id: "label-wmarine-sea-index",
		minzoom: 4,
		maxzoom: 14,
		filter: [
			"in",
			"featurecla",
			"sea"
		],
		layout: {
			"text-field": "{name}",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						5,
						12
					],
					[
						6,
						16
					],
					[
						7,
						20
					],
					[
						8,
						28
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0.1
					],
					[
						5,
						0.2
					],
					[
						6,
						0.4
					],
					[
						7,
						0.8
					],
					[
						8,
						1.2
					]
				]
			},
			"text-max-width": 20,
			"text-transform": "uppercase",
			"text-font": [
				"Noto Sans Medium"
			]
		},
		paint: {
			"text-color": "#fff",
			"text-halo-color": "#000",
			"text-halo-width": 0
		}
	},
	{
		id: "label-vnisland-index",
		source: "vietbando",
		"source-layer": "label_vnisland_index",
		type: "symbol",
		minzoom: 4,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						4,
						10
					],
					[
						19,
						18
					]
				]
			}
		},
		paint: {
			"text-color": "#005291",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wmarine_index",
		id: "label-wmarine-ocean-index",
		filter: [
			"in",
			"featurecla",
			"ocean"
		],
		maxzoom: 10,
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						1,
						10
					],
					[
						2,
						20
					],
					[
						3,
						30
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						1,
						0.1
					],
					[
						2,
						0.2
					],
					[
						3,
						0.4
					]
				]
			}
		},
		paint: {
			"text-color": "#fff"
		}
	},
	{
		type: "symbol",
		source: "vietbando",
		"source-layer": "label_wcontient_index",
		id: "label-wcontient-index",
		layout: {
			visibility: "visible",
			"text-field": "{name}",
			"text-font": [
				"Noto Sans Italic"
			],
			"text-transform": "uppercase",
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						8
					],
					[
						1,
						10
					],
					[
						2,
						20
					],
					[
						3,
						30
					]
				]
			},
			"text-letter-spacing": {
				base: 1,
				stops: [
					[
						0,
						0
					],
					[
						1,
						0.1
					],
					[
						2,
						0.2
					],
					[
						3,
						0.4
					]
				]
			}
		},
		paint: {
			"text-color": "#333",
			"text-halo-color": "#fff",
			"text-halo-width": {
				base: 1,
				stops: [
					[
						0,
						1
					],
					[
						1,
						2
					],
					[
						2,
						2
					],
					[
						3,
						2
					]
				]
			}
		}
	}
];
var boundaryStyle = {
	version: version,
	name: name,
	owner: owner,
	id: id,
	sources: sources,
	sprite: sprite,
	glyphs: glyphs,
	layers: layers$1
};

var override$4 = {
  layers: [{
    id: 'region_water_index',
    paint: {
      'fill-color': {
        stops: [[6, 'rgba(192, 201, 203, 1)'], [10, '#C0C9CB']]
      },
      'fill-opacity': {
        stops: [[6, 1], [10, 1]]
      }
    }
  }, {
    id: 'region-bathymetry-index',
    paint: {
      'fill-color': {
        stops: [[6, '#AFB6B9'], [10, '#AFB6B9']]
      },
      'fill-opacity': 0.15
    }
  }, {
    id: 'region_island_index',
    paint: {
      'fill-color': {
        stops: [[6, '#eeeeee'], [10, '#eeeeee']]
      }
    }
  }, {
    id: 'region-river-index',
    paint: {
      'fill-color': {
        stops: [[6, '#C9D0D4'], [10, '#C9D0D4']]
      }
    }
  }, {
    id: 'fill-vnairport-index',
    paint: {
      'fill-color': 'rgba(226, 226, 226, 1)'
    }
  }, {
    id: 'fill-vnpark-index',
    paint: {
      'fill-color': 'rgba(213, 226, 210, 1)'
    }
  }, {
    id: 'line-vntunnel-tinhlo-index',
    paint: {
      'line-opacity': 0.5,
      'line-color': {
        stops: [[6, 'rgba(255, 255, 255, .84)'], [10, 'rgba(255, 255, 255, .84)']]
      }
    }
  }, {
    id: 'line-vntunnel-quoclo-index',
    paint: {
      'line-color': 'rgba(255, 255, 255, 0.94)'
    }
  }, {
    id: 'fill-vntunnel-tinhlo-index',
    paint: {
      'line-color': {
        stops: [[6, 'rgba(255, 255, 255, 0.05)'], [10, 'rgba(255, 255, 255, 0.05)']]
      }
    }
  }, {
    id: 'fill-vntunnel-quoclo-index',
    paint: {
      'line-color': {
        stops: [[6, 'rgba(232, 214, 201, 0.94)'], [10, 'rgba(232, 214, 201, 0.94)']]
      }
    }
  }, {
    id: 'line-vnferry-tinhlo-index',
    paint: {
      'line-color': 'rgba(255, 255, 255, 0.94)'
    }
  }, {
    id: 'line-vnferry-quoclo-index',
    paint: {
      'line-color': 'rgba(255, 255, 255, 0.94)'
    }
  }, {
    id: 'line-vnroad-hemlo-index',
    paint: {
      'line-color': {
        stops: [[0, 'rgba(0, 0, 0, 0.01)'], [14, 'rgba(0, 0, 0, 0.01)'], [15, 'rgba(0, 0, 0, 0.01)']]
      }
    }
  }, {
    id: 'line-vnroad-huyenlo-index',
    paint: {
      'line-color': {
        stops: [[0, 'rgba(0, 0, 0, 0.01)'], [13, 'rgba(0, 0, 0, 0.01)'], [14, 'rgba(0, 0, 0, 0.01)']]
      }
    }
  }, {
    id: 'line-vnroad-tinhlo-index',
    paint: {
      'line-color': {
        stops: [[0, '#fff'], [11, '#fff'], [13, 'rgba(0, 0, 0, 0.01)']]
      },
      'line-width': {
        stops: [[0, 0.1], [7, 0.2], [10, 0.4], [11, 0.8], [12, 4.4], [13, 5], [14, 6], [15, 7], [16, 10], [17, 15], [18, 19], [19, 29], [20, 39]]
      }
    }
  }, {
    id: 'line-vnroad-quoclo-index',
    paint: {
      'line-color': {
        stops: [[0, 'rgba(255, 255, 255, 0.5)'], [11, 'rgba(255, 255, 255, 0.5)'], [13, 'rgba(0, 0, 0, 0.01)'], [15, 'rgba(0, 0, 0, 0.01)']]
      }
    }
  }, {
    id: 'fill-vnroad-hemlo-index',
    paint: {
      'line-color': '#fff',
      'line-width': {
        base: 1,
        stops: [[12, 0.2], [13, 0.5], [14, 1], [15, 2], [16, 2], [17, 5], [18, 9], [19, 11], [20, 13]]
      }
    }
  }, {
    id: 'fill-vnroad-tinhlo-index',
    paint: {
      'line-color': {
        stops: [[6, '#fff'], [10, '#fff']]
      }
    }
  }, {
    id: 'fill-vnroad-quoclo-index',
    paint: {
      'line-color': {
        stops: [[6, '#fff'], [10, '#fff']]
      }
    }
  }, {
    id: 'line-vnbridge-huyenlo-index',
    paint: {
      'line-color': {
        base: 1,
        stops: [[0, 'rgba(0, 0, 0, 0.05)'], [13, 'rgba(0, 0, 0, 0.05)'], [14, 'rgba(0, 0, 0, 0.05)']]
      }
    }
  }, {
    id: 'line-vnbridge-tinhlo-index',
    paint: {
      'line-color': {
        base: 1,
        stops: [[0, '#fff'], [14, '#fff'], [15, 'rgba(0, 0, 0, 0.05)']]
      }
    }
  }, {
    id: 'line-vnbridge-quoclo-index',
    paint: {
      'line-color': {
        base: 1,
        stops: [[0, '#fff'], [10, '#fff'], [13, 'rgba(137, 85, 34, 0.1)'], [16, 'rgba(176, 152, 116, 0.1)']]
      }
    }
  }, {
    id: 'fill-vnbridge-tinhlo-index',
    paint: {
      'line-color': {
        stops: [[6, '#fff'], [10, '#fff']]
      }
    }
  }, {
    id: 'fill-vnbridge-quoclo-index',
    paint: {
      'line-color': '#fff',
      'line-width': {
        stops: [[6, 4], [11, 4], [12, 4], [13, 5], [14, 7], [15, 8], [16, 10], [17, 12], [18, 18], [19, 28], [20, 38]]
      }
    }
  }, {
    id: 'line-vnborder-1-1-index',
    paint: {
      'line-color': 'rgba(162, 135, 135, 0.84)'
    }
  }, {
    id: 'line-vnborder-2-index',
    paint: {
      'line-color': 'rgba(0, 0, 0, 0.05)'
    }
  }, {
    id: 'line-vnborder-3-index',
    paint: {
      'line-color': 'rgba(0, 0, 0, 0.05)'
    }
  }, {
    id: 'line-vnrailway-line-index',
    paint: {
      'line-color': 'rgba(0, 0, 0, 0.1)'
    }
  }, {
    id: 'line-vnrailway-track-index',
    paint: {
      'line-color': 'rgba(0, 0, 0, 0.1)'
    }
  }, {
    id: 'region_building3d_index',
    paint: {
      'fill-extrusion-color': 'rgba(220, 220, 220, 1)',
      'fill-extrusion-opacity': 0.1
    }
  }, {
    id: 'label-vnriver-index',
    paint: {
      'text-color': 'rgba(78, 129, 133, 0.84)',
      'text-halo-width': 2,
      'text-halo-color': 'rgba(255, 255, 255, 0.54)'
    }
  }, {
    id: 'symbol-vnway-left-index',
    paint: {
      'icon-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0.44]
    }
  }, {
    id: 'symbol-vnway-right-index',
    paint: {
      'icon-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0.44]
    }
  }, {
    id: 'symbol-vnway-no-index',
    paint: {
      'icon-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0.74]
    }
  }, {
    id: 'label-vnroad-hemlo-index',
    paint: {
      'text-halo-color': 'rgba(255, 255, 255, 0.94)',
      'text-color': 'rgba(90, 90, 90, 0.84)'
    }
  }, {
    id: 'label-vnroad-huyenlo-index',
    layout: {
      'text-transform': 'none' // 'text-keep-upright': true,

    },
    paint: {
      'text-halo-color': 'rgba(255, 255, 255, .94)',
      'text-color': 'rgba(90, 90, 90, 0.84)',
      'text-halo-width': 2
    }
  }, {
    id: 'label-vnroad-tinhlo-index',
    layout: {
      'text-transform': 'none'
    },
    paint: {
      'text-halo-color': 'rgba(255, 255, 255, .94)',
      'text-color': 'rgba(90, 90, 90, 0.84)',
      'text-halo-width': 2
    }
  }, {
    id: 'label-vnroad-quoclo-index',
    layout: {
      'text-transform': 'none'
    },
    paint: {
      'text-halo-color': 'rgba(255, 255, 255, 0.94)',
      'text-halo-width': 2,
      'text-color': 'rgba(90, 90, 90, 0.84)'
    }
  }, {
    id: 'label-vnroad-shield1-index',
    paint: {
      'text-color': '#fff',
      'icon-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0.72]
    }
  }, {
    id: 'label-vnroad-shield2-index',
    paint: {
      'text-color': '#2e2e2e',
      'icon-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0.44]
    }
  }, {
    id: 'label-vnpoi-hospital-index',
    layout: {
      'text-size': {
        stops: [[0, 10], [14, 12], [20, 16]]
      }
    },
    paint: {
      'text-color': 'rgba(150, 115, 115, 0.94)',
      'text-halo-color': 'rgba(255, 255, 255, 0.94)',
      'text-halo-width': 2,
      'icon-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0.74]
    }
  }, {
    id: 'label-vnpoi-park-index',
    layout: {
      'text-size': {
        stops: [[0, 10], [14, 12], [20, 16]]
      }
    },
    paint: {
      'text-color': 'rgba(87, 113, 86, 0.84)',
      'text-halo-color': 'rgba(255, 255, 255, 0.94)',
      'text-halo-width': 2,
      'icon-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0.74]
    }
  }, {
    id: 'label-vnpoi-index',
    layout: {
      'text-size': {
        stops: [[0, 10], [14, 10], [20, 14]]
      }
    },
    paint: {
      'text-color': 'rgba(111, 116, 121, 0.84)',
      'text-halo-color': 'rgba(255, 255, 255, 94)',
      'text-halo-width': 2,
      'icon-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0.74]
    }
  }, {
    id: 'label-vnpoi-police-index',
    layout: {
      'text-size': {
        stops: [[0, 10], [14, 12], [20, 16]]
      }
    },
    paint: {
      'text-color': 'rgba(113, 99, 78, 0.84)',
      'text-halo-color': 'rgba(255, 255, 255, 94)',
      'text-halo-width': 2,
      'icon-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0.74]
    }
  }, {
    id: 'label-vnadmin-789-index',
    paint: {
      'text-color': {
        stops: [[13, 'rgba(162, 135, 121, 0.94)'], [22, 'rgba(43, 41, 38, 0.05)']]
      },
      'text-halo-color': 'rgba(255, 255, 255, 0.94)',
      'text-halo-width': 2
    }
  }, {
    id: 'label-vnadmin-456-index',
    paint: {
      'text-color': {
        stops: [[9, 'rgba(123, 93, 74, 1)'], [20, 'rgba(43, 41, 38, 0.05)']]
      }
    }
  }, {
    id: 'label-vncities-index',
    paint: {
      'text-color': {
        stops: [[0, '#333'], [13, 'rgba(53, 53, 53, 0.25)']]
      },
      'text-halo-color': 'rgba(255, 255, 255, 0.94)',
      'text-halo-width': 2
    }
  }, {
    id: 'label-vnadmin-12-index',
    maxzoom: 16,
    paint: {
      'text-color': {
        stops: [[6, 'rgba(51, 51, 51, 0.84)'], [16, 'rgba(53, 53, 53, 0.1)']]
      },
      'text-halo-color': 'rgba(255, 255, 255, 0.94)'
    }
  }, {
    id: 'label-wcapitals-index',
    paint: {
      'text-color': {
        stops: [[6, 'rgba(76, 51, 51, 0.84)'], [14, 'rgba(76, 28, 28, 0.05)']]
      },
      'text-halo-color': 'rgba(255, 255, 255, 0.54)',
      'text-halo-width': 2,
      'icon-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0.44]
    }
  }, {
    id: 'label-vnisland-index',
    paint: {
      'text-color': 'rgba(117, 126, 140, 1)',
      'text-halo-color': 'rgba(255, 255, 255, 0.94)'
    }
  }]
};

var dark14 = '#393939';
var dark16 = '#494949';
var dark18 = '#505050';
var darkStyleOverride = {
  'layers': [{
    'id': 'background',
    'paint': {
      'background-color': '#464646'
    }
  }, {
    'id': 'region_water_index',
    'paint': {
      'fill-color': '#414550'
    }
  }, {
    'id': 'region-bathymetry-index',
    'paint': {
      'fill-color': '#040c18'
    }
  }, {
    'id': 'region_island_index',
    'paint': {
      'fill-color': '#565656'
    }
  }, {
    'id': 'region-river-index',
    'paint': {
      'fill-color': '#414550'
    }
  }, {
    'id': 'fill-vnairport-index',
    'paint': {
      'fill-color': '#626473'
    }
  }, {
    'id': 'region_vnbuilding_index',
    'paint': {
      'fill-color': '#555555'
    }
  }, {
    'id': 'fill-vnbuilding-school-index',
    'paint': {
      'fill-color': '#e5dec9'
    }
  }, {
    'id': 'fill-vnbuilding-hospital-index',
    'paint': {
      'fill-color': '#ffe2e2'
    }
  }, {
    'id': 'fill-vnbuilding-park-index',
    'paint': {
      'fill-color': '#C8DF9F'
    }
  }, {
    'id': 'fill-vnbusstation-index',
    'paint': {
      'fill-color': '#3f7b72'
    }
  }, {
    'id': 'fill-vnpark-index',
    'paint': {
      'fill-color': '#5c6b4d'
    }
  }, {
    'id': 'line-vntunnel-hemlo-index',
    'paint': {
      'line-color': {
        'base': 1,
        'stops': [[0, '#BBB'], [14, '#BBB'], [15, '#999']]
      }
    }
  }, {
    'id': 'line-vntunnel-huyenlo-index',
    'paint': {
      'line-color': {
        'base': 1,
        'stops': [[0, '#BBB'], [14, '#BBB'], [15, '#999']]
      }
    }
  }, {
    'id': 'line-vntunnel-tinhlo-index',
    'paint': {
      'line-color': '#2a2a2a'
    }
  }, {
    'id': 'line-vntunnel-huyenlo-index',
    'paint': {
      'line-color': {
        'base': 1,
        'stops': [[0, '#F2822C'], [11, '#F2822C'], [12, 'hsl(26, 87%, 34%)']]
      }
    }
  }, {
    'id': 'line-vntunnel-caotoc-index',
    'add': true
  }, {
    'id': 'fill-vntunnel-hemlo-index',
    'paint': {
      'line-color': '#fff',
      'line-opacity': 0.5
    }
  }, {
    'id': 'fill-vntunnel-huyenlo-index',
    'paint': {
      'line-color': '#fff',
      'line-opacity': 0.5
    }
  }, {
    'id': 'fill-vntunnel-tinhlo-index',
    'paint': {
      'line-color': '#5a5a5a',
      'line-opacity': 0.5
    }
  }, {
    'id': 'fill-vntunnel-quoclo-index',
    'paint': {
      'line-color': '#F2822C',
      'line-opacity': 0.5
    }
  }, {
    'id': 'fill-vntunnel-caotoc-index',
    'add': true
  }, {
    'id': 'line-vnferry-hemlo-index',
    'paint': {
      'line-color': '#FFF'
    }
  }, {
    'id': 'line-vnferry-huyenlo-index',
    'paint': {
      'line-color': '#FFF'
    }
  }, {
    'id': 'line-vnferry-tinhlo-index',
    'paint': {
      'line-color': '#E6B100'
    }
  }, {
    'id': 'line-vnferry-quoclo-index',
    'paint': {
      'line-color': '#F2822C'
    }
  }, {
    'id': 'line-vnferry-caotoc-index',
    'paint': {
      'line-color': '#943232'
    }
  }, {
    'id': 'line-vnroad-hemlo-index',
    'paint': {
      'line-color': '#3d3d3d'
    }
  }, {
    'id': 'line-vnroad-huyenlo-index',
    'paint': {
      'line-color': '#373737'
    }
  }, {
    'id': 'line-vnroad-tinhlo-index',
    'paint': {
      'line-color': '#393939'
    }
  }, {
    'id': 'line-vnroad-quoclo-index',
    'paint': {
      'line-color': {
        'base': 1,
        'stops': [[0, '#F2822C'], [11, '#F2822C'], [12, 'hsl(26, 87%, 34%)']]
      }
    }
  }, {
    'id': 'line-vnroad-caotoc-index',
    'paint': {
      'line-color': {
        'base': 1,
        'stops': [[0, '#cc3737'], [11, '#cc3737'], [12, '#943232']]
      }
    }
  }, {
    'id': 'fill-vnroad-hemlo-index',
    'paint': {
      'line-color': dark18
    }
  }, {
    'id': 'fill-vnroad-huyenlo-index',
    'paint': {
      'line-color': {
        'stops': [[16, dark16], [18, dark18]]
      }
    }
  }, {
    'id': 'fill-vnroad-tinhlo-index',
    'paint': {
      'line-color': {
        'stops': [[14, dark14], [16, dark16], [18, dark18]]
      }
    }
  }, {
    'id': 'fill-vnroad-quoclo-index',
    'paint': {
      'line-color': '#F2822C'
    }
  }, {
    'id': 'fill-vnroad-caotoc-index',
    'paint': {
      'line-color': '#cc3737'
    }
  }, {
    'id': 'line-vnbridge-hemlo-index',
    'paint': {
      'line-color': '#2a2a2a'
    }
  }, {
    'id': 'line-vnbridge-huyenlo-index',
    'paint': {
      'line-color': '#2a2a2a'
    }
  }, {
    'id': 'line-vnbridge-tinhlo-index',
    'paint': {
      'line-color': '#2a2a2a'
    }
  }, {
    'id': 'line-vnbridge-quoclo-index',
    'paint': {
      'line-color': {
        'base': 1,
        'stops': [[0, '#F2822C'], [11, '#F2822C'], [12, 'hsl(26, 87%, 34%)']]
      }
    }
  }, {
    'id': 'line-vnbridge-caotoc-index',
    'paint': {
      'line-color': {
        'base': 1,
        'stops': [[0, '#cc3737'], [11, '#cc3737'], [12, '#943232']]
      }
    }
  }, {
    'id': 'fill-vnbridge-hemlo-index',
    'paint': {
      'line-color': dark18
    }
  }, {
    'id': 'fill-vnbridge-huyenlo-index',
    'paint': {
      'line-color': {
        'stops': [[16, dark16], [18, dark18]]
      }
    }
  }, {
    'id': 'fill-vnbridge-tinhlo-index',
    'paint': {
      'line-color': {
        'stops': [[14, dark14], [16, dark16], [18, dark18]]
      }
    }
  }, {
    'id': 'fill-vnbridge-quoclo-index',
    'paint': {
      'line-color': '#F2822C'
    }
  }, {
    'id': 'fill-vnbridge-caotoc-index',
    'paint': {
      'line-color': '#cc3737'
    }
  }, {
    'id': 'line-vnborder-halo-index',
    'add': true
  }, {
    'id': 'line-vnborder-1-1-index',
    'paint': {
      'line-color': '#933'
    }
  }, {
    'id': 'line-vnborder-1-0-index',
    'paint': {
      'line-color': 'rgba(15, 15, 15, 1)'
    }
  }, {
    'id': 'line-vnborder-2-index',
    'paint': {
      'line-color': '#666'
    }
  }, {
    'id': 'line-vnborder-2-conflict-index',
    'paint': {
      'line-color': '#933'
    }
  }, {
    'id': 'line-vnborder-3-index',
    'paint': {
      'line-color': '#666'
    }
  }, {
    'id': 'line-vnrailway-line-index',
    'paint': {
      'line-color': '#444'
    }
  }, {
    'id': 'line-vnrailway-track-index',
    'paint': {
      'line-color': '#444'
    }
  }, {
    'id': 'region_building3d_index',
    'paint': {
      'fill-extrusion-color': 'rgba(82, 82, 82, 1)'
    }
  }, {
    'id': 'label_vnmarine_line_index',
    'paint': {
      'text-color': '#111'
    }
  }, {
    'id': 'label-vnriver-index',
    'paint': {
      'text-color': '#ffffff'
    }
  }, {
    'id': 'label-vnroad-hemlo-index',
    'paint': {
      'text-color': '#ffffff',
      'text-halo-color': '#222'
    }
  }, {
    'id': 'label-vnroad-huyenlo-index',
    'paint': {
      'text-color': '#ffffff',
      'text-halo-color': '#222'
    }
  }, {
    'id': 'label-vnroad-tinhlo-index',
    'paint': {
      'text-color': '#ffffff',
      'text-halo-color': '#222'
    }
  }, {
    'id': 'label-vnroad-quoclo-index',
    'paint': {
      'text-color': '#ffffff',
      'text-halo-color': '#222',
      'text-halo-width': 1.2
    }
  }, {
    'id': 'label-vnroad-caotoc-index',
    'paint': {
      'text-halo-width': 1.2
    }
  }, {
    'id': 'label-vnpoi-hospital-index',
    'paint': {
      'text-color': '#ffffff',
      'text-halo-color': '#933',
      'text-halo-width': 1
    }
  }, {
    'id': 'label-vnpoi-park-index',
    'paint': {
      'text-color': '#ffffff',
      'text-halo-color': '#30722b',
      'text-halo-width': 1
    }
  }, {
    'id': 'label-vnpoi-police-index',
    'paint': {
      'text-color': '#ffffff',
      'text-halo-color': '#714c12',
      'text-halo-width': 1
    }
  }, {
    'id': 'label-vnpoi-index',
    'paint': {
      'text-color': '#ffffff',
      'text-halo-color': '#374C51',
      'text-halo-width': 1
    }
  }, {
    'id': 'label-vnadmin-10-index',
    'paint': {
      'text-color': '#ffffff',
      'text-halo-color': '#613000'
    }
  }, {
    'id': 'label-vnadmin-789-index',
    'paint': {
      'text-color': '#aaaaaa',
      'text-halo-color': '#3c1e00'
    }
  }, {
    'id': 'label-vnadmin-456-index',
    'paint': {
      'text-color': '#ffffff',
      'text-halo-color': '#613000'
    }
  }, {
    'id': 'label-vncities-index',
    'paint': {
      'text-color': '#ffffff',
      'text-halo-color': '#800',
      'text-halo-width': 1
    }
  }, {
    'id': 'label-vnadmin-12-index',
    'paint': {
      'text-color': '#ffffff',
      'text-halo-color': '#333'
    }
  }, {
    'id': 'label_wcountry_index'
  }, {
    'id': 'label-wcapitals-index',
    'paint': {
      'text-color': '#ffffff',
      'text-halo-color': '#933',
      'text-halo-width': 1
    }
  }, {
    'id': 'label-vnisland-index',
    'paint': {
      'text-color': '#ffffff',
      'text-halo-color': '#005291'
    }
  }, {
    'id': 'label-wcontient-index',
    'paint': {
      'text-color': '#ffffff',
      'text-halo-color': '#333'
    }
  }]
};

var override$3 = {
  layers: []
};

var override$2 = {
  'layers': [{
    'id': 'label-vnpoi-police-index',
    'paint': {
      'text-color': '#FFB200',
      'text-halo-color': '#000',
      'text-halo-width': 1.4
    }
  }]
};

var override$1 = {
  'layers': [{
    'id': 'label-vnpoi-police-index',
    'paint': {
      'text-halo-width': 0.3
    }
  }]
};

var override = {
  'layers': [{
    'id': 'label-vnpoi-police-index',
    'paint': {
      'text-halo-width': 0.3
    }
  }]
};

var layers = [
	{
		id: "label-vnpoi-hospital-index",
		layout: {
			"text-font": [
				"Roboto Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						12
					]
				]
			}
		}
	},
	{
		id: "label-vnpoi-park-index",
		layout: {
			"text-font": [
				"Roboto Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						12
					]
				]
			}
		}
	},
	{
		id: "label-vnpoi-police-index",
		comment: "add police layer as a top label",
		add: true,
		after: "label-vnpoi-park-index",
		source: "vietbando",
		"source-layer": "label_vnpoi_index",
		type: "symbol",
		minzoom: 8,
		filter: [
			"==",
			"categoryco",
			7322
		],
		layout: {
			"text-field": "{name}",
			"text-font": [
				"Roboto Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						14
					]
				]
			},
			"text-anchor": "top",
			"text-padding": 0,
			"text-letter-spacing": 0.01,
			"text-pitch-alignment": "viewport",
			"text-offset": [
				0,
				0.8
			],
			"icon-image": "{categoryco}",
			"icon-padding": 0,
			"icon-allow-overlap": false
		},
		paint: {
			"text-color": "#714c12",
			"text-halo-color": "#fff",
			"text-halo-width": 1
		}
	},
	{
		id: "label-vnpoi-index",
		comment: "display all POI below level 16 and filter out hospital, park, police",
		minzoom: 16,
		filter: [
			"all",
			[
				"!=",
				"groupcode",
				5
			],
			[
				"!in",
				"categoryco",
				9362,
				7322
			]
		],
		layout: {
			"text-font": [
				"Roboto Medium"
			],
			"text-size": {
				base: 1,
				stops: [
					[
						0,
						10
					],
					[
						20,
						12
					]
				]
			}
		}
	}
];
var globalOverride = {
	layers: layers
};

var mapDefaultImage = "data:image/png;base64,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";

var mapLightImage = "data:image/png;base64,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";

var mapDarkImage = "data:image/png;base64,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";

var mapTerrainImage = "data:image/png;base64,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";

var mapSatelliteImage = "data:image/png;base64,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";

var mapBoundaryImage = "data:image/png;base64,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";

var mapBoxBuildingImage = "data:image/png;base64,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";

var map3dBuildingImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAAB9CAMAAABd7Js+AAADAFBMVEWenJWloJmysKiOh3UfJSRtfICHhoBJRj+TgWtvdHUrMiw4LyRtaF9LXFNeZWdGWj85OTVNXWVWY0p4cWleYFYjNT5bcE5OOCuFmZOoi3FyUUnAmXidvrK1yL2RMylqNzFAekK+Qz7/8MIhJCYeICIWGBpzc3NnaGh2dnZpamwlKSwQExVFR0o7PkEtMDFiYmBTU1RKSkoaHB5bXFogJixjZGdKTFBXV1esrq8pKyxnY1p6eXeAgH9dWVJWUUqIiYZ9fYBXWFx6e3xubmuMjY1mZWNdXmGOh34/QkaCgoSQkY9IRkF1eHswMzdSVVlEQj6FhYJycW9RTEadnpxubnCMjIhMSkM1OT1OUFRPTktDREUKDA5XVVA5OzsoLTNua2Z5dnG3ubqfmY5+fXkhKyChop+Xl5SEhoiSi4IoKSaSlZk2NzYbISYcJB2HiYxtcXR9dmt4cmpuZ1qVlJFZW2AWIBZAPzqmqax1b2Wlp6SSjoiio6ZqbXCYmp6YmZllYFRbVkyOkZWWkourq6ippZ5gYWYCBQRiW1e8vLyBe2+xs6+8tqqdlYl9goVgYFtRUk07OjWGg313a1mEf3mIfnLGyMa2tbOwqp+cnqMjLiaws7hrZ2Jwa2GBeXUkKjE0Mi4nMinQ0Mm8v8Sbj4GBdGQvLimmnpK7vLKWjHrb3t3CvbWuopUwOS94f4FvdXgSGxDDxMBWSz4KFQq6r6LMx7s7Oi1LSDmIjZKMgXplW0rX1tJCPDPe1MfUy8CLfGUdKxS1qZhgaG5tY1KFhnZZY2X+/vzIy81JQDTj5N98m7EjIR3P0tYuOSbIu6Z/iIymmIR3amNgVEGJp77f0MApNRuepKrr3s7LwLKXiG9sdltGVmRmbmOxnYotJh/q7Ozh3NCRoJ1cbns7UldyfWiUts9viJk/TD1/lKH39e5UaHP16diGblXbyrkpQDY+TCzx7ON8imPIrp4vR0esurpfeYmUpYc2PxmarqKXgF/WxrBekmGUSj4bYnlJaXuoy+X/2oSicVzCAAAAI3RSTlP+/v7+8v3y8v7y8v7y/PL+8v3+8vL6/v79/v7++P79/v358q6XOvYAADpnSURBVGjeLFZ9VFplHL6wtKw505zHvk6dU10u5QIPIeTFLsIFhIgguEvtQ5AAYwU6TAYqiw8/BqKRQ0xHxVwyQM0mSzNtmh95Mp2dNU3xTNOTma25tdZOnTon1um597zn3PvH+3ve9/f8zvMAifPtSfsScTiHgOlOTU7aF0dS/E1MTIQTzUn33MPDxT9v/fwP+9LT05OTk0Wi5Iy09MQ7VsNOBZDY9cW+5JSMjIyUlLT0JJM0KfGe9L1770lK2JeelL430bA30WtPSkr037PXr8hMyNwrDYUjEWcmGg7YgUAIcF4XnL4251zv66sszKKBnBhViMEQTKExiC8qg2OugFM8OSkg5BRmy9lEJp8JgWxSUVZlc1pycix5cr3D/mBIkby1sf+NK3EK0PmISmuRkzgkNokwXtPrJrBJBgvcS1cb7BYNYzAz044DjOsyh6Ld0xXpFjOc/YBOyBuIiBN+zqmkdsphUGIGbGZ15wGioFXSUOi+npkgPG7DDE1NpkGQltMnHNegTL4UX5owric/S8wveLU35IqOpm2qBAKs+3RXKY/RJSBlUfUQJH/+GVCf88jzNL1WALSpNCrv9ZumslIHHo/TpIogzOdb8qllMmA9gVPzw8pKpd9PUJoFakOr3CPucyK2wFADs4xbSK4iAW1eO7D+wE8ronyY1+kW0Xz9D/z4T6rsjyt8mb7tElDU4L/yx9jUsKkx7DOaT/kHB2VlBjXKsOFMTvNRQ60IaeNhztmOXszvH/L7ea0VYhraUYv9lECE5fcASZUibp3erQeVYjVgYwjb++Yj/mB/E/r7zyqkYggeLwRrCkXCzB8Tsqnl795x/+odkoTUlR96+/gpZ2FBeGoqNOyA+IcgJ4czr7XqqQ68VOoacFVnrtNVwf6uUwKjtRVQm5uWxiCrGiTA5Aa3Ti3LhwTIyv6NyZp7gAIuAZKhUgGmVhn6WOXP4mcU+a8Szt9/xzifleqgJ2jmupI3rF6vy+YK4hJSNaVD4yvcErNFgLIOe6eil6biuFQisVAIQqIoP1+Eqe3RgFRqWegOmsJigslYMeTo8vmuzS21j89bDiQjC0M8mDRZPT3bqPlhfGMDSIdkGGAyAIbeSTmVMLTgd/Rrx8cT2geu3dug7wMiY0FpyTGfa6xJCYoTfv/959RJPRMTIJzmUv/BwHbky8+WRkaagCnv6T/OsdkQQ5YjYsfGxznHS/FB5811+gOGsoHRRoend5Bx30P3NVlqDOZyeZ9Ge1GKbwz1X0RZQCKAA3BqAYvn/+Rdv9oqq2hQ4h0emJXwg1sFAMGludXVruNEiEOAx2tk8RXCMCQ+DMLsIzyR0hfZkweURqL9HZYyfPDDK2nNkpYtKrcgdXKy121xZmauu5ZtU2uDNfkFBz7/5NtTagvpVbbPoXb//FvV2ySrdZ5nA3A4nI2gjjQcPtWF6/cOBILlRZ2uYPmEVA9aXHYEiKxGTOtGKRQ/HsRiSmCMz0IYoLyE/aQk6J3uHx5eWlyrqa+vV041vnTu3DfHfQiBkrGxkrqy0XL1+2Wl69wZv1xG4jMsdZWFbn3+45CKmkVgd7KIRHp8I74bMGjyFw4P4TDUOu/04hUhp1ySWyLnYAGf2c9Wwg68GrGJIXYJm8Ggchgy2CBGMCpXZmAgBnEfBBqCI9teqIrcv618s+e1lw6vBVbvv/eXw8Q+4iT7xsSVjN7H3zz65VESyrR0VrxNkUgFEBOUoKbe3j6CtIHUOQQAiTE2YjdevK6YR31NwPSDxt7ioxPiMj8/c90J2B08BCkpaWVTWBADgmA+nwlhNnOFJ7AbjXqdGlqL6MVHHjlELg3Qm6vee/P1pp2g/vv7r1370zUkD0abH390a+u1c2mbKSkpV/KOLzTBHE8JWFVM0CFqlX0dhEmVcjOANUVwJgewnin0TqtxUanbaJGaBHRjLX193cQAJSCBFL99UMyAGHwGGyQUtfoXrv25VFYeDftckWhguFEAUaKeA+yJs2cHdu0czKO2O+O6BxyhmSCw57Ovvvu0pK4P24zVcelSOpznFGTzZdm9xjYvupWSATMBXgSBzZGm1oVT0uuaMseQ33pR0djmNAVr9TUwpETEJBaLyOKLIQiScDgNbNdo6NLU9oz30tTYKR/Q3BJzTE0FbFWdch/eEZQ9LxYY8IDZr17+mIPSA8PR0fPfffv9anh4pPugnEomUuwChoxBeJRck/PrLWzdDdxbRjchddSuAVO1UyFFcKW8mw8+aIeZrDqZxGy2GMQgzNAgGiWnWazjZobXgt2BS9vx2Z/JBXZ3pfLYQWDGRmmpUqqcYk/R00oDtrAwAAikUNGEYFJEVE33v+4fGVmaW1qam1vt7vY5VA96h0N00Xvv/VpQKCJz9wF+JQ8QCOeNVtTkMKNtoX4z1NtLJHI4MJ8IIWoBhiEI3MorawWAg5PXZ8ZOn1/IPXYkPPyOasqLD0dDU17y870sT5s0+yUCiQCJMWHtqHieaeyXOoHSreQa+2nyi0STa+7yhcsXLly+PDAWBcTT2/bxmjqqXuhXA8DAqoBZ6lCtI0wBX0B3YsyEcQpJ6QG5oBISG/hMhMEo85SOjs5O3fij23bi3a7Vgcge34wrPMM6VPVKFkVS9E0MP2xHSDSRSlIMCzzG6zqdQsfUFLr7ozc29diNzUKPK7x0i8DlP/+cW1pEzrwiUFGpNPlyWtryXmAgMhqYZ0kWOuOtARGos6L1luYgmAVjAiYLYVccP706MPjTbOhkmm83PBr1NZ0f25mytAVqCp7seaS+SpKX1r1o54J8WIjSCBIMs5U6++l6HfHx/IvC9evO8IRrcXHkQhwj8fXyhW3xmZ43Y1IKVyITb8ZS7gQSs0T4rjsWFiQSkOXxN0vkbDYDBSGNRcMSM1DMg1NBJXOroLvlXA8JrFZ4Z4cD2zPiIrbNQyM/3fN6M4OC21UUc3WEbIKF08I2K1WhUKj61YKCF8cbg6h9aXRn8fLlW/UXb2F01HDm7Gc9yc5QowFEWEIwH9j/xEsl104fgVBzmdkAs1AIRFG+GFcqFsJ4fKZaNd9xsqbh/OXD9Wdf2yJmJW9N6lGMhXrkx083AcXv9RSZ7U7dAQrK5RBg/rMUSO5x9E97VUJZK841srN4YSQ6Eq+7trOzM3JhLSqRsDu/zt2D8w7POvEIr+GDtHTgtlefeiq1Bom7kZiBieNzhzLhie6IGLG51rz4SGntVGijYrT77Ndv1he3IRkP/xUjKa1Wm8NhC5ue/fQFx64Kfq6Kko+yipsxTkuzGDE3hdts+Ft1R0YWd+LPYpuSCLHwNhB6rF6sCFS8dQ5QuD2CUcB2+pO7bgf2v//UY1mYzYAhYr4BAAw43tXl1SUB5htY254ubw1MDRdLAnhbaWnX2yfompSHH85E1XoqbFGY7KpPJ0Z2BUUMBvmAm0h7WWkozmZ4YHV0LhJ3yOjlxTh2dpZcKmpNYX09FQWbyd7tSyGkpx5Tl+AbTbDHhGttB/a/uv+NLBxixgxSAOn7eYVRWtqEc6jNBsfI6L1DJ7dH74jbo9NkavS2OYOK9b9u3DSWkLWmjkaFRokbCROfBlWyVyq5HE8DSUmjtMBmXmdge/HC4s5aMLC2NtAEUrmSkpikHmrDywNTdnUb47WPMafdRNfQGIKmSCKwv+CpJ56QOdQCQcXmcuFKcurGysq4Rud2i3lDZbjI6RNDvAlbv1E42efWtitOBr0n+6M2tQkf9PGCM05aMRNmEfKLJa0Vz4oML7/CUKulTK03GLB7Z3IKUH3WiwSYUuIMXKIxgn+9jFWr5YrRTbXXyswiaCVM+X2/7I234EDhAZpNr2z+7uPvlvdczUhJpsQmYivjTFavm8GOMVDb1QlvR3sfSBUSn0NBIYoqZqvbAgFXNIBRJGBctOAHzfKSilylzRAeGR1d2x0BVJf6iEbC049kuSGUJZ2J5zYe8teVsyajVKUI9FebKnNy+kBJ4ef3maXAY8/ZEKYHyqEUPNXTk5axfPXq1Yy05Tg2NzfZbKG7t7dXCCsUtdb22o72OmtB0Uv6i26rdrC2w8kkIeocEqsui9NwVPn2EQwXXlsbibd9dzdER2AiUwh5Z7RCSmkAL2CcSPvrhiPQaDe066wGEzWfLKyD2bQXJMPAbTV7cvsmCTCjjihmkLeupKRNTMCx5f8RpyEB2WzFyd4XKwuY0xfbZWIEba8TavnVCilRoKNRWK+wMXJueV6uA5JE19ZmZgLXbyIkgoaiumUZgbSWPAMSa14POmcC3n4WlYp2tHOs8ewopLJIhBoRE0jvPPjV688fA+B3XikmcLfOnDnXs4WpsFY5PBG/g1sMljNiCkW7W6vTdQglJCZdTK3RdkzPzp7UUAoRGUnCyzuUm1tx1B5CkXDo5mTyVs87LwOxt1RTcTt2xDbTbkoND4YuNRp1VKO7jqkVgj0oUV+pIUItXOYgE7j9rid+O3H++1jyOx++9dp7b7318Vtn6s9JtNZ2qYAhL4EncnPjPKYVwny3e/CkRg1qmBxGXA5CyNhPoNQKKUhJbl72y8cO5/G9M2ogiGW3xCqUZp9absDbOiWBiRvOEJ2OGul11JqsarSOKeZYtMZKAhmpg4nJ49Yk4O6VH2+eL9nYn9siImQfOtTz2ntvfnymvgWRimUQFWKyIBnIVjqlmkphcYH2Iz6k1TKZwnisIsWtvR2VwVDFnpaqI0fKD8OK2bCShBy5paLlq66wN1hqV4SGh6cVXIhaO8ilkYsb+ZN6acdPB9B4EDqWDx348LUztwFJ62Nw8t9/nzh1sOfZgwfJLSJyS1HVN2yBUgnrQU/coJQSGVNCgNzGDqtRoyVRqaCRqncjhuqAlClGuOySwy203PLcT6WzHcPKbPDlY5tXr94YGwBmZ9tOtp80xqMVkQ8ZZLRKLrlNNy4ERdrjY+ZjR46IWKTfNn5KALqOb/z988NpdxxveP5g88tFZ6uyyZRmDkHC1Ah0CIJhYqVSLAcJer3QIrioo2ukjdLqOtCq65j2xr2KCMlf2NPwyomjeQuNHbV0qcVmAyG+YVoKE1G+TsOd7misbeNAVCmTW8ctVrNYZaW8pqHyqqPl5XUk2vXQ7D5gX+7ff3+a8j3vVG42ka8DwbyDhJbvzlYdej67GWJoNP8SZeVBidVx/K2O27FN9zFN/zSz7XvgugIB8uK+WcQUEEmKhIcHRIaAKCi3YoKwKB5IwLqFZh7trpt57FppbrlLukeOTrVTO9lotjPd9zTT8aypPm/em3l/fT+/7/n5vlfsN7Gk1ckk7DbGuxJHxAI9Umu0JRA6nd+CiUImHNVs6Wnu1FA7g0k7Is6gC4+dzy8nU3gs8JjfhPD9R1qgkpN2iFJQeUQ3uG+pzczAt4pyc1Mdauj6KvFWIC83ZXbcnOudTWksFq1GAOGJdBmRgOuueVWFF2BAOl+slwYzxrm58jiyGY+5k+WmJ8lzdF5jFwWVELLqKC6qolIZqa5MJvnDT79cXEFWjDDsUjndJxNue0nCngHnXOUUdAW1TUZSnVFe476Q1We1CGUlnxYV+QHgiqXOYPXJmZ+vff05QyDr0wpwGJxKJpYJVBhNt0BcXUHHuJPwppvvSTQYwblMe6JDD6/C7S/puRAb3TloEE7eaWHA8Cb28m8Pr9rtK+JxpEiY8c85TSsZ2JSQtg9PdnRwCvARx3xupK6b6nCcF0XJPOJXX31/GQgMtvEWFpYdvq8XNzYWm54W8DSCKE+mjkbxQoyCx2fhcTyFJ2k8mdiEM247jmgqdlbOJVbGV86JXRUgQRalpssYDomvJZPRQw8/vOLn20/4/RyXHYSdHk8MYIQvhS8NP44HcTFDyDxM1PTVDUd8VhyWhrvjjhduByiA+hnvyJlm7/unFzdqFmuampoOVR2pxEU1Fo1aRYhqVAQcFhiAG7gcV8aNYEoGggmb2O8eX43T3RgBS0u1MCUpqtfnzCRNyV++HRdCKyaBjIvhRov5xX19OeHp0ZhhVBupiLVqhUIBxiDTMb2hfqJCQEhd+fB24JHQmQd6359l9F547XTT6UV0vVs7jXpi40WC8vPuVF/n2uJGs0rLKjbapW0D7owL7zduVpqS49czgBiqrqNoqN5OtdfMkAeRhK0yuXo9vjLO5es7QFpxQ2sdWk8guoAuXRo9jmZUpJqOAWlkEKSZLUUYgVb33Zc64M4r1Z+p3l+W987WHKhpeq6paXFxY20Djcbia6+dXut++bWmxbUNA4DFmjACoLyr1gCsJJ8tEm+Om3ACHl0AQUqHWpKmpqnOZCZRkkCtu92PD8BYMKdNq42BFE7j9LRBZzhaxKnUjob6RTJaNZdAYTo4XKI0EGjJAW6KbGfXj21FR3DvzSgXPnlxba2mBo3DHpU9Mk01aGq81jqlZ7v9dDqPW4AtPxeExOVT7w5IsRgIS5PR6ESIgpYhkrG7NxPBVVdiPHPd3cF+/XhkKTwBz7EiBlRZcHDkoxrd+cmIuO9ZbSokMpdiBJXXti77gRHRbnZ9ffsYa/3H3199tvDAgQNrGy8/8+p7TY8eOn369N7xm04/rxnwCNl+k1MKs4XFsOdowxyr5eK4MFqNw0EyOkahiqbSxc6M23b5pevJ1Ywi47fRJ6YnAmGN26QZnJ4MaPF4fKVost8hUBnqdOa00sHByM5/dMcdtwM3jfzKo5XkCXa3t9e/v5G9dldpE2FW7pUvzLz8zDM1z6GOQEcDscvOFXMhmMgX8+CMh8P2YLBdMGqaLmRYmd1EZYrQSRP63clPp8bJRtg/7m5ofL3PwJhsiyNdk8PU+Zito6Mo4pA4WgMiXqjM0e+wQbic8NJP54Hb+sdGlt9/n4mjfrZ17a51lEb2xidlatVC2axcPnvgwMza2qtN5i50BBnFdqezAF9ezueIW2D7QBcXUw1SzGgTkjvU8qtSckPlyU+Ri/bV1eR1k61iIjYY/sCZJGvnQ5FBrY1TSohEYhGzwIKNiI6L0hwQqit3tucAhvlcK7X3zMLy2UOHqh75LHvjx/X7DtfXk/JffFbCRP1w4cyF2RnRlJ2OYVNMeiefHW+Zo0AmT/DcIFYqg1JaS5rApFqpDNocW8H2Z8b1A8aycecp1usfhIFBSnFxzvSkaJRaSu7AjurOO44bdIDIYelPkYnE9vbacg9wj2gsPXth2dpLfZxEOkiqerSeRMonkUhD6H34rp2tuz4pWDjQ/3pLnSdudJawyYraWifkh5GBl17hQqC2U0ZlEH3WTjmV7lYQjMaBVYo9A6/oGyrCffsil+IDxsHhfvOoRdhAFi4NG66IRJ24yPl5M4WME5g8gdpy4HhszKr0XfUuW+tR06RHSaRHSEP/gHR454/t7I9Z0mfGzcuNGJSw2AnqYcR9VOHxBy++wsHEojIBw6ySo2FgYhLspynk2lVnMqFvUZCL3wxPT4cbTBTd9KRuicJx2YijEarVYmlrDKXlDBwWogViogo+cK9mbMQqP2PttT5bn5+fP7R3cvSJIp9Udd+1H3/P7lzb3s5m3e7dTedBbTVYZ4Rt+i5n8DpCo2loQouDoWJaU0wGlysuYdv8LUQjBhufO9k2ARiuLlUjmdfnzdThqA3bodEx0vMAwEg50vPniS5K6+uBwKgB2B8bG/Exe5lnR8rq8x/L/9vw30DJkB596jDpvqHPftxdz26to/1i5/Ll43pTogCTsA+MD/AglgCn8aYlex7opjdwuRhyogXTAmeQkoa2Cd30UrgFsbUe7xdpZThsJWU0otNRtLS2frM8BDYQKybi8Ykc4Db1lZG096zX2vs06fGqqsfy/wbpPxw89Oijz+ORzcRuFsX2tRgStJP1CXfw3BSvGgQ1vJTkaYa1U4J6QEqj4fgInISRdv2xfW+ER9vahE7jxJKuWoYh741undlBM/BESmrIjCq80Q/COWgV7Bddudk722v1jTDrq1A8Vlh48OBjVSiF//EUZaqrQvtpdjOzXkRUcYxYdzITHJg6Re6zMFIq9ZNMhpqpZmOJWKlADLcgcDAubgDCIl3bRNeAOydt1o1CeDyIVVRIQRlUoJ2fd6Q5JRTunD8njBKIDb9ltfq8V0e89UN7EUBJ5Ff964WD9Xup+RR0rouGESu76uqkvNpyfmkDWobjwd3dHSzvHe/siTNMqqRZSseShURWsAU22mFbR93rE9PhQaiCPDi6L9B6pLLgqMbQKRAXg/TjjLT1qtAVvf/z7zvEAcAQG7vZqjx71rfMJD3++BAJvar+wR6Jg/UHURbPa85l0KVKDHv4sieRINwxZ3cOXMxk0bTI7lJ33n5HxZydEXv0IN1W24WtY7XEuadywoaQaLoRSb4islgNFDLWBYxRRSIBVd1/NWS2chQC3U/f3n3HXcB+ee6HXuqZC8u9vsP1Q1WPV6FlgOb/909UodmYj76gNJ4nTCXdjXGWPWn3cOEVuKjEL566iLy9s4vm5RxaqluMt6+J+bYerLC2q7jLicAuaHByOByeSBrxo7miQV2RooQsvTJscKhELMMyg5kWQt1zbk/gp2+B/Zqxm3sXzvQuowzKHqt6ET0/WoroA0U+GpC963D3S7ATbVt2Zy2N6FxNKlDRN3Ax3pcSKN7BndrZ2clubW/vZPNu5DHK443tWHo7lx344INAoM0Ft0wviYZ1RWRXUV+uQyRqO443o3LEKySmvwP4c34/cI/XfPNZxtn3rVaro/eq947CvcjvWS78OwykPS6Hi87ZTbDbBDthI14ctJeKnfaV60GIx41GrWcvnKiMEveqdHs7T9BSi3Uau+InTwUCrYHBV4I/HDOMRCZbS22co/2TuRGNGv0saEY7dwc0/OV3342FAGC/zzw2wpztHfF5j1DUXuuyT1628RwJDcZQftUQmgIoi6eKXoJrM0lpOSgVg7XuDFnhNAa/iIMYLI8i8Jb1zMoln1xbL9n9UQi1TzkRZ8bZ4dr35sTkdAWGr52cbGujPSnk2CIGbUjU2qe1MkP9USwl9xKKpSXgnrRjuJfpOyt46M8HP5MUEOS+ZevZ2bWa5w5uDNW/eLSQVJ9fdRh/zu5BEFRkxltT0gYEoiWDKxeDLggjiBKZzJ7mMvUJX0wDQXpcbdIPJ5LtJdxXJo9tVU8OxpN1lpR5Ho+FMPtEMYNDk9L0n/emcViN62SrbunSJaCPmh7r9S30Yh/686Gmn2dnlYQnC3wMn+/M1z/XPN+NF0YL64eeqvxmAI7DSJxfDjciA04hz+1OXuzi0GRkfJTR08xkKmfUUkwHQQyVI+gsgGvJYDiA6pwfkDzN8FsfT/MqXdgOQ67PG4rFYkyG2SwkdzZs3bjxNnc/cNvY2FjvLLN3+epDzOdeWzy98XmZUk6QyH2+u+/4ubsZrNBwjlQVDE4Z0Z0sg7RLBe6MHaLBA8lxRAaClG6KUtIjlzN7CNVisAAE4/Y5t9DfzqWHJ3bX19HeWWt3ztVZ8BTOs6G0Q9TXiq4QIYsDj02V5OXloRyA/Zbu/l41832qqqpZ8lSP8tXnata+/lrOVBKYqBvkCwwJAw8qpLVckFXGz8AJbnkmKcTx4czFuKyBTMRT1D0n5D7liW4W31aAoQfFGLsRcTZgwv0jAfvu+s7O9vr6uuDtorIekc6a7tSyWr3eTgcHS3Hl5Z3aargFnYYuHv4YvYxTyuYrmmVgiUrI21jcmJmZZSol3Qz1gdlZdXO3lAeBGJoUrBM3V8TtLm5tcuo6ApYScSqVRFIoYTJPEMQm7FEFC07Y7a5aoxAcvBQeHq02Vny6mc2ub+1mb5zin5GHIiKCIx2ypCsVEPrT5FRe3i3AbVS5AMdQXrhQlnqyqOflg4WHHoMkJ058sifOlXoFW1jGbJ6ZaU+iih6iKfQtAqPbLXTxjch4OwUSEChqNUpALjnRWUKGSvWNcQzbiIXdJeywQWQZDQeLATPoYb29g+re9Z3dfrWWh26nylSlFrysPyaVSvcDN0V5aZ+8Oe1bWGguohwqPPRcIcHn61aW9by4OEMkEk3dPC65syXo4fJ5er5YbON7jFiux4m8VA7JyBQ8hal8trlZOSPQs4uOSANBvdHuDorJYM4+9I+feO6dtqXh4StlpbvZrez22yMxEe64z2zoLNW8c+MkUMxi7Qfu7VZAReQGl1+rNLHEBIjLx1IkcjmaAEzlgcWNxeYZSTTKNXEVkJitd5azQY+JTcY0wpmXnGQsuegvEq00NrEqClOrcamJGo1Gf8qUpTwKr8ijpWV50AJlbYGyFQYGAqWLZRUpXaBQhjJlprQwpRGQ1Ja2duJY7GK3GcdWranbNGqcGKvxh3EZE6MxRv95Ry+XwJ+X+71zzzn3O9+51Gl2oD8dkJRAnapGcFUrvJ5x15xP3bKyHMpUiV+xT2WZHqufgYrKobGjpNFM3MmCH7+Z/ucDHCDBPYB51FMoeLclNcb8abkBW9stYdac9Zb3K7thdmTri7/+euet3pNyusuHw7U2c/hqbptqvo+IawV8wE4UUFHYqA+kFWnJGaWdKEeaq+bi0i9HX+sREO6zpAAfeRkN7RRzVlingCmLNz1APXIEj93ZBHoF+vmB713XgQ88mWXZzGGaRtOZUDSRG7r3WUz22TPHiv2PK0t3nzs93WWzFG++GZ3kUAhqu5jHmcaNDccpY8ONr8f8KAWZntYrSopAukzhtBANOPulwb5BYiNO0Hxfbjm7jB8dy1kzmRSC0gwsZ9KZcSaMydvJJWOcbxgQ/fjnn+8+jGHpw51SPJ1CV9NxnXSTRlOiolsVjezFx+78/fc3n92cnfVuv/OmZU7lU/nG8AwCzzc0jzIGua17Dh2RCsGwRJIOaIATigk6Bk4Vi3NbWxp7iF05ZjY71diIjyaTy6sIDEHm5ZmgUW/r8jCZsxQ8tf7i14DjPfE9xshSag6Pt9PHu6c13bJyjedtU+/JSUDy9J27dz5//cPvPlwRplaXiqqujjGfnSOmU3CUPj/e4WhZsfsZROADJUU6LVGeXeFwRfXEsVj7fF9LjIDapqomrmH8g83XrBmn0IT6kZa8xpuJ5pneQrKgp9NMpD9+/gEEB+ZRvHSQT8lzbQpLpZ5CgIhfDtqOOlhLd+4++/rLEx9OvmxfO5iyclodXe0tLRxHM108zoMofHzHnEOOEHwCmt7UtJXeKvP5RB6F71AJBnH0xnZi10RHxr0x1CiOJopOoc6vk3mEnmomzZK57dWEQTnbP9AA+MfXTwBSimvmE6lUpp4ZecHUMVO0dPK7pEt/372159jFzC2sF6s2lq3Ly1MbISCgdnX2wtyXIUZXh2/FJ4cZzQxC6zSNhk+f0AAnBJrAGGVwdDRGjHdgZq5tLHPfZqTAs3mRSIQIs6yIbcaSUbLdt5ERan3tACC83ecwT7LYzKX9s7PtSkVyEbZmkhsWsuj8c3c39hyHy77owmu2Gc9E1bV/bqUm1tdwXR39ihjoYSAtvvs4EKoX6fVGDZ4jxinaWghtNMLYpfbR8Vb7u/SODatQGFI35qxCZrFoQOPQTtArNJvbPFlzJEzt1L/6wsAAmPdjHqW4aMROzYiLkjdArA4/WcCjiKC7G8N9waqrtzY6zKmqj16hejfm5ibnOLgWB8bm++j9b1vpvqEuVMeAyf3pNDYgoVDaxjg4HE08pu7rGx6m+2es5tQ3G42fmoth4XLQMOI3ZFPeQqdlxlIwB5lIJ7nhBbD8PQBPXknoLR6J8YpEn/DEWkXUWB9ZrothKDMzmNxUh2Vx46dvefwWtXRY3GFdW7vxy+YERvDt+3MOR0iuo8KmgKS/XC4fn9FApShWh1Q9o33z86g8M5VL3WpD+7qsTnORCfl11Iw7WOw0GwvVeRZTThDVDgzUvTDwAgDADmtWd9mVZ7aW/vlkxZpcnZvkuLTND3nx/OxES3B18dqaoxMHQTZVbGpt8+C7g4ODG3k+aN3ZZ0AQGkwgB/SW4EAthS5AcF2tDt74+PA8ilZF25jFquH5kCcSzFCQd+WQM+tJKm83F4NAzmFQ7rnAALauDmyBN2iunmXvH1s//+efXxc/+2b3aHNZn//qvpBwx5P87NbaemNcJGqO5sBtHdB5/H9es+QWYs11/ToTWREo9SoCZycUAr4XIoh9raM9qlaRDhMtLuc40veCKaFzB0beBRYIu5MWy3SyOpFIUAnwPQAD2FeBBVgFpnu2Yvzkc8DQFiPZ3z9JuVObVTZw4Wfi2kYuNn6diMjpmDXQrL9xcAOMz+/N3OYvBxl1HGsImNKl/nTvVg2NiKOK+KpWYg+E98Xjoaoqi9DyRt9QxuOupsGQaFroLjCNHps7wmZeQXGG2oH/qvFHgAUKzCSgRHu//PP77Gn1rd8/+aRqYm3PDsp+/oR4hChCRkaIeJ9qcmX51uaNTYDg4KuNqZXvfvrl198+JJKaFGmTonfrtIYKSJeaoJKSea4uX5wRcs4IrZg+1HKUXXYGYETUlkywCsKg3sP0JI0CAkT6PwyABSJhVnBp99j08k//fAOW/3WjytGFsU9OTYUUnUSIjvOp8DqFff3t0b2vlj+5sbm5efD5tWu3FlPf/bYevRU1NSkUvaXd41raCN3v4op7cG9fHmuRU6M5a3Yxbxu3ZzxBNyyHZBZr8sicsDR7jfyCXqA2kMDyr/4XBcxwMLl0um9Bpffa/FOXVFxOJz8T2/vtIIdp59qHfM1USHQFc2FUHNvM5VK3c8ATv/pkKrd5VTVz4/3J/nS5oVI5qaWoUb+UMKamDrrELSgjOpOttjpG37UVPM4iAsnISavF7cmYzeB1mQE84/wA9t4W/AcgEXQv7e7zG6nytVxozK6iUdqYmTcGh2amvhNzW2kBBkMEh4z0L+VNMZCUC8eete9urK0Pjbdjfnp9cihwgi0dn52cUClxOZ0wRqCP94wRtdRl62IyKpB2Onc8zKJOrkMyTk8SSOWe2/nC0nS8vuFeAYjFYu/HPFgImz1LhzVN1xspHRy8xWbLm4uZFrxI2k65Lwchfj4XJZNDXXBc160F92w2nXrb0N7C4GV7M+eS3j7UcFLa7z3pPYFRAQqISo+a1zOGQ2jWYJ69aB1SN7O81dl61A9ljvRsczHfFkzuzMJEkAZAEP6fCZnMaXb16Ztt7fL5vftCYpyxmBEKd3acM0MY1vqCVMCgMchkmpkzTu6ue2BePPfbwvqH7y84hlYwa7GuDy+dBBTlc+D81NPokJ8gbsdxeQCAXpis/izF/5QmXD1yevrlcm3Rw0oy82FvdYEdodIVW1gAAQwAIOm2uB+qnGnmxejwT99NOjxCodApFC5mnQt7awutJoYa1ZKbM7AUITW96vqShwNXQMRjPsxEl+r1SXtnOnDSiwUmECACNK5ukeJxuh4ClRK1pjIh27zYabE5PSC1ynaq2eHg0qynkHCzTO7Z08rx/ramfuARzIOVbfPsnUolLB9VkdXfTnomYr4dZ3TRmlpa3pu70COgqKlaiJXHcaFuCKr/clIgtsEtVzv4OAi/x+8Ilc8AAOxJGQiRJSIRRzFIL4/j4SshpzXlJHJpTqfZbdbKofNJb2EHqInBvDHiOVy9c3j37imgW4paDFBJt09vHj+T+RIZv2qgX+i4dBVQiBt7k87s7egkZsQwTddptXmKyaWrNSGI1Gb/6ILj6jodgk28haH1KKm36R6AXlgkJ8fxzTw1jsoVQG1WoTuRMQ/2CI2sYEHULzPtrDK9Zop6Jh2+eech7+Hp7uzucc3+MRvzFCiIvZXj0+3RSf/4goDceMEx4Vw9+Gg4V2W3d+DlgjY6pNUymqkCOdZkQriMzvVY+0ojqkN1fa+rxHlSuRcAIDXA4GBS41sYCJF6OQ51htjuZKrHxahe8iRZWjKMz4TDHhxdsXTz5k324exuqZTe3i53Lz2PeZAd8Xoru5Vt+uBreNw6V3DZ1BYSRh32mHjEL9fRdQEGrNXSYPgNpMkAQe2+ZluUMzUXB8ll8CPxXKa7CQBo6AYA0HqquqMNrxZwERMes7gatQg+FQqZ7GBeFPfHgVroNi7dublU0YRnZyNpRf/Wx1uV9KOYR4AZIoenZ6ULOPpHPdTGQfm5c2RZvYvnh+r9vMtEiIbXyWR6msGPYMlaxEXruG/KcWlObpAjg3uNc2ZSLwBQWwu2h0aN43jTKMXAEyB8obla6OTg2nZmV1eVBoEWzoa9iaXZglHJDO/OHir7AwrF1pb38ATzeKlcDlS2ak94V3mCq8Nk7rys+1xtPSoQuN64PHidqjPoEJnM0E+9DjWQySJup8QaNUysxHWofHRBNVm8CHwArN9tgmlkHY+nF3B5XB2Ud2bdSQ9z5mjV7XFPa2UmptMbBjW0Inx7N6JkARFEETCB7+4s4ISlF0ml/ZNAy8grKsaFVxAuVFt/rmlkXNUnjaOQCdbTdefrDIx+OVKr1YroeZu1qnXlkh9kt76FoZi5uxd70kAidWshxEBVt7twBFezHOJnwt7kZ85OZpB55DbBTLebqVQyNWw3ix1RKpUapXJaoggEAvsPYh4sl9iS8klvt2+O+vIFtO+V6/Wk89i664NqVORv7xtBDJChvq7fQCVCtWSR1kWhTUzwJ2JyHUruAWFoJjU1NJwjdZMUkKgeJrbgR65LeRDZnBKuLgav4GzJILM66Q4m2BolO6HUsBJKUEYYWRrYyFZKFArF45gHn3nmWAl6Iy/BjReg8Q8YIx/5L9Zj61D6yOXRYVUrUm/y6+qwJn1/XFfbT5YROfwjZ+d9l1AI1l6+2jVX7D7X0FBLulj2lshaSM0jSgUoATIUneYIU9jz7kw2WO0OsmEji60U6dnsCKjjFJJExNQkkyhZbInhQcwzYJyVt958i8P1XWD0fEDnCkjaOtL1VxqH33bRUEQHzvImbL2JitdhyQAAjR+y2oYaqZAckq7bVMWLDfc8oHvrkN1/nkrEyV14Is4gcnvC2S6KC+9e9IY1SsU0zciWkI2RgESh0Ug07Ei6oUkvUYD69z8ANeXZyMWLna+1cyfx+NfeltXK6kjSlwlUCH95PN6vhUV12H7TeRTBGgznpV0sYYplb0QhREZcsc39D4BEKldONTIDXkpT62A+RLYAdeDIvXrrUMlmKxOwia1U6kEHRqKXgH8siTJc6i2h0MePRSKYmpqzcvimcqA/QXhtkDHXKnjNdbG+Dgu24Hr72yAKIQNCBuq1AuQAkkwri9PMyzlbrBERIaKedRvmysXac7Uk8Dk+3T8vIhLqdagfrz0/s1x95843nx1K/q3ZemPaKMN451CQOcWoMTO6xdzdSu961/Y6rhzQjjKKB+21G2O9/rtOWdlWjoOJFMZ/UDk2HVAZKtVpL0KVxEKluk1C3NwkLlkWUKPRqPugiSZmwQ/7oCb74nMzvoRQ0rf3/J7/z/u8T70V9mCkOxlx+H1i0L9qaXRMJd3d54eDYpyVKL+7RHfz5nnHyAV3SNUfNL03SkJ7x0nwUezKdxc9Bn1dl5PEjSFwy0y6jlRQLjpQGjzZNzVU7rUwgcFT+oMWBVyAwMLX4TyfJuuamDWvdyDy1cbnGwtbT0z57F6Hw+2wAO/uoM3hc7vt/rQvzl8ZsU9FumVWtBTqSq6tjMABV93cXt5iLZ8N9Z4KhKMs1tU+FihbnFhfkzhOQDKklzNa0mw02nWg8uzxIy/1Gkmjsf2jhoN+ReMfjPDr5elpu8klQsL/GQZrf5i3Tp50OOzdbrvDIXYH/f6piKPbYet2s3Hlx29+2Jg554hF3D5ww5WR88N+9fbmmv7Yc9bW57z9tQrFEoHFpcX2iwNdDIfzPpH58eEra1f0FratS+9vftnd0MMYA1LNR4a9QYUG+uEwnV6+tjJ98uzpuZ9/3rFj/mpn5/jpaT/Y37jd3+gOBn2NVlfEFzKn4+j13C+/fX3hwkN/uk2Hx0t0j04vb1tNbv766/Zyff3rppq3qqFRRIXXvpsouzLW1VHG82aLYPzVu/bHL794Qyizb/wZXaS3nBGMgudU7QtuRaNPYOjN1QtfT88vbCxMz8+PW+3nZs4ND7sdwaA9EvQn/VP+SF1XIEQhKBpPp43M4ed/v3z5rz9HDj+ge/TC8qp8e/v09ErNW3rP67a6LyfCCEt0eczM0vrERBlFmUkBJqV/gbZemYXmAsHmN10He4wkIwycKq10Kxr/WBhLpy8MT8NTOhsbTzxf4e88MWUHaw9agn5ft89kcxtJgUJplGWlblJYHp85ftjx559/XXhAV3IzdvvX29P//LPj6FL/sd3v7TMMoghFMIuL660TY+YQRYUYxrv28JWOAasrEOaagu+c6T5aHiA5qumVmqM+zQhpjBWhrbS8snK18RyM9Jwbt3dWmO0+90iQTYIW6gJmI8miKJqheFwijfzI9NWRr+ZWvv3rBgBI3r59+6eNn3f809Jj65+t6x0dQwCA8bv1urUu55KBb0sHoRlnXTNDtUwSQsjU1/xsS49FU8FHlVVuRaMv6sWb6VX79Mp0xfP2zhm4zG30acG2sVtyjExFSNIHwo/j8WS3hKK8xTcyP79yfC6WUy8X6oo3f92e9Nuvzm9UDb5k6S+3zJYjGIUZOwIBzzGPxxCieMRSN7nvnQO7TRKC8Uyw70V/bU+ANLKlH1T2hRQCowmaFDPp+Or0pXl/RWcnXCB1OyKWqUa/w/rTpNkWoqIIlOAsJZACjiHkSGMy6545/RDMbcWKdY9tv3Tp1tXlx7dd6K0/9IZzsJypl2ge4yYm2ts7nE6nycYTmGg0W80iMEHgVODF5gND/RzPCZ4PjlSBCjAaU8LuC9vOp1fnTw9Put3Q4vU7GoGrxqC1w2UUcRTRLuMokhQtRmjC+WK5hCrGLt9IJFIAYGajqKjo0q0nHreW9+1/q6O+vAmlKZqcmDCMjZUtetipEKbQYL1gQSiCtPHUM1ssVS0MaYx2vORq6FYQGsUU9u2VbRkJ2uZpixuat36/Y9w+HgkGOSPARliW4kmSinJB26TL9XZElm9kYUooQyAA4IEfLv23bp0oe+W4+TlP03NcmEXJrkDHxOJSxxqdCSEYiiN3IXjXvIJYeebwCy0cRfKel0r3+sLwBobSaTsUOeevORoj7ojfF/E77C6X2SLhNHyUzQqCwPM85+UouBvlbGI2C0MBgUmIihHd//SLLjXPWnvrbafqDRxBodT6+uJSl7erQ1JoVmLhGMWSDDNQZ6OQt5snq14wChxf0+s6FFQQGUMkWmGTme7VZbsP0o3dHukO+iwhKo62AfesRAp8VDB6SVm7EZVVNfu7GsuSUyarD9LxI1AlXyoCBP/Mr/cbBg+O9QyyYRylFg1eL8yReiTwcZETSMbpNXI8Dld5ruP2/UOMIERBAmdDBIsBACSsEGzyGtQcERC+1+z3gdPToDJKlCSR54UQYyTzeRXGZGBE5YaYEQVeoiieL9Fdne48WXTXCjbqDW/pj/WYep0Ki1JjZesTHQNdHMpTCkYazWagDuqkUEz/8oH9LzAggY7eyWctcVAAK9FhiMa+5WXwv2TEzIksqi0Ex0UjSUHa4MgoisbUbCIPM4ux7FQkZCbxPRjLF+uKLk1fhQgGIpgpr+445fQ8V01CTYYsjk50kd6BCQaxQNGNiBSGwnkyTuGY9YXJqqNw4H53qffA3kiYQACDlhDDqHs8koS+mUYdRI8jkL45hiedjBCl5ZisUhJCwIiOSlpdlNPIs/mEXKDbWvTDjn9uAYSrJ3e31Da9ZRr4skvZgyJjXq/TMzt0jMN4ioCHUzSiLRZBXLoDe2s5nhQmyq1n/YqMxAkM0wCEscZGikVA8uB34POsQPJCSgXnx1k6pcoxioqyqAxxQWBjCI6Ec6nsg7qtMzNQO0Bj+talXn3twbqXSy8OKDiKrk3Mth4bsAWk/yoeRHMncAUcR94+7jswylGCsNjraXArYSyOowSkA0gKdBwF8nEWwQUjJ+BggzngMpeIgUhicorCMmJcYIS2dxEZzSv5nLXGrNu6dWHhCw3EjqLK/rL6oc5XZzllTxsxUH7MbKmrbw0pWrIjEOk/AOAO1kPP7m0H9qjSHsN+G43lWZLyIcA/DThhV0aScFwQcJlFwxiqmZ2ci6k0JqfiEjgmDy6No7lYVtpnk4wldwFov2e2Dh8p7TdUf1AxO6uEacJ4xdAxOnisjIVjigaAAvqwcByNvOY60g5ixJsOVvaJKOiVRv3jLEgCtrGIxEHIwfK5HJFIyQiVklOxWEpVKXDKuITvYVmgriQmTVV7DVaJIHQLC898unVhbu79k9ePDJn6a8C5Z9dphTD0D2oaMJAAIAxP5v8DsAdB7WcPH2ogcYE3HHSdS4d5ElUwLOmDgERgcRYXOJJH8uGYCjJPpVQ2paZA33QcpwE8PEHO58WQpaGakeJKIp/QzW3MgR3Ovb9w/tq++gZzeXXTS9WjR7dUNVwsI63Vo61c+K4K9ggoeIE2TEDb+iy7G8io8O5PZ4ZnpDDGknEMl2U3Gw4nVBQVQ5QsJ3Ia1yk5zqJgNkCWhr9RcAz5Rj4x1dCyzwwo9xC5m9ugQzK3sXGm+cOVbddGq6sOWXvq616prnrzNVPdUnvrxQFGgIBC3JUACq9Ae2jkGdf+/RDaoufe7+xkw1oxIFnSsoiE85flfIKiZC3apABBDDJgmEDBJqM4naCQVEKJTOptFtfvIh+mheSup+9s0z2xa9etT7d8vLCa/n1tsOrTlrL+Kmv50b7XagYvGgLM2GIXTdN7NAAIRrQZGRwjgn2mytM8T1KRtzMSi9EojZAhjEBjbF4JJ1KgcjmW0lYsLlEsbgphLM7yLJHI52OW2qrdkxCM4pCeHtv59NNPFOu+3rVz5847t1ZWr2df1Lc37x4qqz1mGnrlaI0hZFwabV0kER6Up7ER5QIBkAfmPx2Z2crjFB4HlxNJBBDESQ5RMDHEyqB5VY2poHc5juA8Qu2uM8AOlkrlCYksrTXbeIyOUVgipiZ33ll+7DHoDzxx587Ox1el6/65ZmdrpbOnrKrFytj0uxdH25e8Fo7gQxgEVYoKMFHNzzDf1s7OYYQGj6NZhApBsgSGRSMVToksrcqJrCojKRRJpXjKohcZmxn0AlIx11brm0goX1MIncvnZBkuqTcfw3QFKTF47fFr8WTFyZmfXxwbrXL2WytbDjU01JY6Oaen1aCEQfg0LrAIhsGgGRpOnmNprTbg96BsHEVIjpahtKGmJBQ2IKB6Gc2qqSxjNdTvhosJhCDAJkTV1G4V8LZEXpYhNOXicgLMZFMo0CUuy1CeZH3Dh6qOf3yiz+Bpb2ownNU16J3mgYutE3UMpmgxDosCUc0PaCAClHAcIgoEPUk0cjKEOzUlMSGRhAJAhnomFQqJ1R02k2aP4AnZVEzNxdg2nJfzMqgnlUtkZRjjV1XolBYk8kk3wZ4YDv00dWjLCV2XZ6isdctp0wCUZEvOwJgBDYMbAgAtyLYhiOYTOEqDSgQKo2nLpBs4kdUbKkuFgtCWp7RwQFYPBTjT8+//pAC/KaB4A0xTpeJpOpfNqplUgo7BnGQqm45Dq9ZmsxDhxpPD6bQ/W//mfLPZM+Ttu6elvdTGlHnW17sgERCgAxYAtP0nAc0fIReRFAqVliuWywL5GIKAWEjGgtrMdSJis3810/fs2c+eVRQ5dSNzPtmdzMahbiVyapbNUFg+kcuBGDY3S3QFzoF4pqICGhcjJ6eye7fMvD8w0cDs219m1bePggYY5C4ATMtygAGH3ITC4gUhlYhzITYLAQ+YY6FwlDKQm8m99V5DxTNbPvngyaf+PnTmeDafPH8+nUmmM/FMRkZisQybkQBIDmZmN7t37dQVSNtLIg8UFpbYHynaXlhy35szuvvvO3r/Pvjy+f0Pmh+9//4CAkhiaHEBrGL4QdG7r0qKtf8KixNycXFxSWFJwaMPnF54tLiw5sEHj9zz2etfPvWktu7d8n1hAWwojJRon4KdJYWwSkoKrhcUr+66s/PpfwGpgnZSIDm2pwAAAABJRU5ErkJggg==";

var compassImage = "data:image/svg+xml,%3Csvg%20id%3D%22compass%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xml%3Aspace%3D%22preserve%22%20width%3D%2260px%22%20height%3D%2260px%22%20version%3D%221.1%22%20shape-rendering%3D%22geometricPrecision%22%20text-rendering%3D%22geometricPrecision%22%20image-rendering%3D%22optimizeQuality%22%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20viewBox%3D%220%200%2060%2060%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%20%20%20%20%3Cg%20id%3D%22Layer_x0020_1%22%3E%20%20%20%20%20%20%20%20%3Crect%20fill%3D%22none%22%20width%3D%2260%22%20height%3D%2260%22%3E%3C%2Frect%3E%20%20%20%20%20%20%20%20%3Cpath%20fill%3D%22white%22%20d%3D%22M30%201c16.016%2C0%2029%2C12.984%2029%2C29%200%2C16.016%20-12.984%2C29%20-29%2C29%20-16.016%2C0%20-29%2C-12.984%20-29%2C-29%200%2C-16.016%2012.984%2C-29%2029%2C-29zm-27%2028.252l8%200%200%201.5%20-8%200%200%20-1.5zm3.243%2013.6l3.464%20-2%200.75%201.299%20-3.464%202%20-0.75%20-1.299zm9.609%2010.157l2%20-3.464%201.299%200.75%20-2%203.464%20-1.299%20-0.75zm27%200.748l-2%20-3.464%201.299%20-0.75%202%203.464%20-1.299%200.75zm10.157%20-9.609l-3.464%20-2%200.75%20-1.299%203.464%202%20-0.75%201.299zm0.748%20-27l-3.464%202%20-0.75%20-1.299%203.464%20-2%200.75%201.299zm-9.609%20-10.157l-2%203.464%20-1.299%20-0.75%202%20-3.464%201.299%200.75zm-27%20-0.748l2%203.464%20-1.299%200.75%20-2%20-3.464%201.299%20-0.75zm-10.157%209.609l3.464%202%20-0.75%201.299%20-3.464%20-2%200.75%20-1.299zm-2.363%2019.913c0.534%2C-0.142%201.082%2C0.174%201.225%2C0.708%200.143%2C0.533%20-0.174%2C1.081%20-0.708%2C1.225%20-0.533%2C0.142%20-1.081%2C-0.174%20-1.224%2C-0.708%20-0.143%2C-0.533%200.173%2C-1.081%200.707%2C-1.225zm6.282%2011.914c0.39%2C-0.39%201.023%2C-0.39%201.414%2C0%200.391%2C0.391%200.391%2C1.024%200%2C1.415%20-0.391%2C0.39%20-1.024%2C0.39%20-1.414%2C0%20-0.391%2C-0.391%20-0.391%2C-1.024%200%2C-1.415zm11.397%207.177c0.143%2C-0.534%200.691%2C-0.85%201.225%2C-0.707%200.533%2C0.143%200.85%2C0.691%200.707%2C1.225%20-0.143%2C0.533%20-0.691%2C0.85%20-1.225%2C0.707%20-0.533%2C-0.143%20-0.85%2C-0.691%20-0.707%2C-1.225zm13.458%200.517c-0.142%2C-0.534%200.174%2C-1.082%200.708%2C-1.225%200.533%2C-0.143%201.081%2C0.173%201.225%2C0.707%200.142%2C0.534%20-0.174%2C1.082%20-0.708%2C1.225%20-0.533%2C0.143%20-1.081%2C-0.174%20-1.225%2C-0.707zm11.914%20-6.282c-0.39%2C-0.391%20-0.39%2C-1.024%200%2C-1.414%200.391%2C-0.391%201.024%2C-0.391%201.415%2C0%200.39%2C0.39%200.39%2C1.023%200%2C1.414%20-0.391%2C0.39%20-1.024%2C0.39%20-1.415%2C0zm7.177%20-11.397c-0.534%2C-0.143%20-0.85%2C-0.692%20-0.707%2C-1.225%200.143%2C-0.534%200.691%2C-0.85%201.225%2C-0.707%200.533%2C0.143%200.85%2C0.691%200.707%2C1.225%20-0.143%2C0.533%20-0.691%2C0.85%20-1.225%2C0.707zm0.517%20-13.459c-0.534%2C0.143%20-1.082%2C-0.173%20-1.225%2C-0.707%20-0.143%2C-0.534%200.173%2C-1.082%200.707%2C-1.225%200.534%2C-0.143%201.082%2C0.174%201.225%2C0.707%200.143%2C0.534%20-0.174%2C1.082%20-0.707%2C1.225zm-6.282%20-11.914c-0.391%2C0.391%20-1.024%2C0.391%20-1.414%2C0%20-0.391%2C-0.39%20-0.391%2C-1.023%200%2C-1.414%200.39%2C-0.391%201.023%2C-0.391%201.414%2C0%200.39%2C0.391%200.39%2C1.024%200%2C1.414zm-11.397%20-7.176c-0.143%2C0.533%20-0.692%2C0.85%20-1.225%2C0.707%20-0.534%2C-0.143%20-0.85%2C-0.692%20-0.707%2C-1.225%200.143%2C-0.534%200.691%2C-0.85%201.225%2C-0.707%200.533%2C0.143%200.85%2C0.691%200.707%2C1.225zm-13.459%20-0.517c0.143%2C0.534%20-0.173%2C1.082%20-0.707%2C1.225%20-0.534%2C0.143%20-1.082%2C-0.174%20-1.225%2C-0.708%20-0.143%2C-0.533%200.174%2C-1.081%200.707%2C-1.224%200.534%2C-0.143%201.082%2C0.173%201.225%2C0.707zm-11.914%206.282c0.391%2C0.39%200.391%2C1.023%200%2C1.414%20-0.39%2C0.391%20-1.023%2C0.391%20-1.414%2C0%20-0.391%2C-0.391%20-0.391%2C-1.024%200%2C-1.414%200.391%2C-0.391%201.024%2C-0.391%201.414%2C0zm-7.176%2011.397c0.533%2C0.143%200.85%2C0.691%200.707%2C1.225%20-0.143%2C0.533%20-0.692%2C0.85%20-1.225%2C0.707%20-0.534%2C-0.143%20-0.85%2C-0.692%20-0.707%2C-1.225%200.143%2C-0.534%200.691%2C-0.85%201.225%2C-0.707zm43.855%206.945l8%200%200%201.5%20-8%200%200%20-1.5z%22%3E%3C%2Fpath%3E%20%20%20%20%20%20%20%20%3Cpolygon%20fill%3D%22%23FF3732%22%20points%3D%2230%2C3%2036%2C15%2024%2C15%20%22%3E%3C%2Fpolygon%3E%20%20%20%20%20%20%20%20%3Cpolygon%20fill%3D%22%23363636%22%20points%3D%2230%2C57.001%2036%2C45.002%2024%2C45.002%20%22%3E%3C%2Fpolygon%3E%20%20%20%20%20%20%20%20%3Cpath%20fill%3D%22%23363636%22%20d%3D%22M24.001%2023.001c1.067%2C0%202.134%2C0%203.2%2C0l5.801%208.924%200%20-8.924%203%200%200%2014c-1.067%2C0%20-2.134%2C0%20-3.2%2C0l-5.801%20-8.923%200%208.923%20-3%200%200%20-14z%22%3E%3C%2Fpath%3E%20%20%20%20%3C%2Fg%3E%3C%2Fsvg%3E";

var StyleSwitcherItem = /*#__PURE__*/function (_Component) {
  _inherits(StyleSwitcherItem, _Component);

  var _super = _createSuper(StyleSwitcherItem);

  function StyleSwitcherItem() {
    _classCallCheck(this, StyleSwitcherItem);

    return _super.apply(this, arguments);
  }

  _createClass(StyleSwitcherItem, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          _onClick = _this$props.onClick,
          isActive = _this$props.isActive,
          mapStyle = _this$props.mapStyle;
      var label = mapStyle.label,
          image = mapStyle.image;
      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "style-switcher-popup-item ".concat(isActive ? 'active' : '', " "),
        onClick: function onClick() {
          return _onClick(mapStyle);
        },
        children: [/*#__PURE__*/jsxRuntime.jsx(Image$1, {
          className: 'style-switcher-popup-image',
          id: 'image',
          src: image,
          alt: label,
          width: '60px',
          height: '60px'
        }), /*#__PURE__*/jsxRuntime.jsx(TB1, {
          className: 'style-switcher-popup-label',
          children: label
        })]
      });
    }
  }]);

  return StyleSwitcherItem;
}(React.Component);

_defineProperty$1(StyleSwitcherItem, "propTypes", {
  mapStyle: PropTypes__default['default'].object.isRequired,
  isActive: PropTypes__default['default'].bool.isRequired,
  onClick: PropTypes__default['default'].func.isRequired
});

var MapControlButton = /*#__PURE__*/function (_Component) {
  _inherits(MapControlButton, _Component);

  var _super = _createSuper(MapControlButton);

  function MapControlButton() {
    _classCallCheck(this, MapControlButton);

    return _super.apply(this, arguments);
  }

  _createClass(MapControlButton, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsx(Button, {
        className: "map-control map-control-button ".concat(this.props.active ? 'active' : ''),
        innerRef: this.props.innerRef,
        size: 'sm',
        iconSize: 'md',
        icon: this.props.icon,
        onlyIcon: true,
        onClick: this.props.onClick
      });
    }
  }]);

  return MapControlButton;
}(React.Component);
MapControlButton.propTypes = {
  active: PropTypes__default['default'].bool,
  onClick: PropTypes__default['default'].func,
  icon: PropTypes__default['default'].string
};

var StyleSwitcher = /*#__PURE__*/function (_Component) {
  _inherits(StyleSwitcher, _Component);

  var _super = _createSuper(StyleSwitcher);

  function StyleSwitcher() {
    var _this;

    _classCallCheck(this, StyleSwitcher);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      isExpand: false,
      selectedStyleId: _this.props.style.id,
      selectedOverlayIds: _this.props.overlays.map(function (o) {
        return o.id;
      })
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleToggleFab", function () {
      _this.setState({
        isExpand: !_this.state.isExpand
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "onChangeMapStyle", function (style) {
      if (style.id !== _this.state.selectedStyleId) {
        if (_this.props.onChangeMapStyle) {
          _this.props.onChangeMapStyle(style);
        }

        _this.setState({
          selectedStyleId: style.id
        });
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "onToggleMapOverlay", function (overlay) {
      if (_this.state.selectedOverlayIds.includes(overlay.id)) {
        _this.setState({
          selectedOverlayIds: _this.state.selectedOverlayIds.filter(function (id) {
            return id !== overlay.id;
          })
        });

        if (_this.props.onToggleMapOverlay) {
          _this.props.onToggleMapOverlay(overlay, false);
        }
      } else {
        _this.setState({
          selectedOverlayIds: [].concat(_toConsumableArray(_this.state.selectedOverlayIds), [overlay.id])
        });

        if (_this.props.onToggleMapOverlay) {
          _this.props.onToggleMapOverlay(overlay, true);
        }
      }
    });

    return _this;
  }

  _createClass(StyleSwitcher, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: 'style-switcher-container',
        children: [/*#__PURE__*/jsxRuntime.jsx(MapControlButton, {
          icon: 'layer-group',
          onClick: this.handleToggleFab,
          active: this.state.isExpand
        }), this.state.isExpand && /*#__PURE__*/jsxRuntime.jsxs("div", {
          className: 'style-switcher-popup action-menu',
          children: [this.props.mapStyles.map(function (style) {
            return /*#__PURE__*/jsxRuntime.jsx(StyleSwitcherItem, {
              isActive: style.id === _this2.state.selectedStyleId,
              mapStyle: style,
              onClick: _this2.onChangeMapStyle
            }, style.id);
          }), this.props.showOverlays && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
            children: [/*#__PURE__*/jsxRuntime.jsx("div", {
              className: 'style-switcher-popup-break'
            }), this.props.mapOverlays.map(function (overlay) {
              return /*#__PURE__*/jsxRuntime.jsx(StyleSwitcherItem, {
                isActive: _this2.state.selectedOverlayIds.includes(overlay.id),
                mapStyle: overlay,
                onClick: _this2.onToggleMapOverlay
              }, overlay.id);
            })]
          })]
        })]
      });
    }
  }]);

  return StyleSwitcher;
}(React.Component);

_defineProperty$1(StyleSwitcher, "propTypes", {
  onChangeMapStyle: PropTypes__default['default'].func.isRequired,
  onToggleMapOverlay: PropTypes__default['default'].func.isRequired
});

StyleSwitcher.propTypes = {
  showOverlays: PropTypes__default['default'].bool
};
StyleSwitcher.defaultProps = {
  showOverlays: true
};

var MAXD = 800; // converts from WGS84 Longitude, Latitude into a unit vector anchor at the top left as needed for GL JS custom layers

var MERCATOR_EXTENT = 20037508.3427892;
var MERCATOR_SCALE = 1 / (2 * MERCATOR_EXTENT);
var CAMERA_FOV = 45;
var CAMERA_NEAR = 0.1;
var CAMERA_FAR = 1e6; // derived from https://gist.github.com/springmeyer/871897

var mecator = function mecator(lon, lat) {
  var x = lon * MERCATOR_EXTENT / 180;
  var y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
  y = y * MERCATOR_EXTENT / 180;
  return [(x + MERCATOR_EXTENT) / (2 * MERCATOR_EXTENT), 1 - (y + MERCATOR_EXTENT) / (2 * MERCATOR_EXTENT)];
};

var getTransform = function getTransform(ll, h) {
  var translate = mecator(ll[0], ll[1]);
  return new THREE__namespace.Matrix4().makeTranslation(translate[0], translate[1], h * MERCATOR_SCALE).scale(new THREE__namespace.Vector3(MERCATOR_SCALE, -MERCATOR_SCALE, MERCATOR_SCALE));
}; // Extend Number object with method to convert numeric degrees to radians


if (Number.prototype.toRadians === undefined) {
  Number.prototype.toRadians = function () {
    return this * Math.PI / 180;
  };
} // Extend Number object with method to convert radians to numeric (signed) degrees


if (Number.prototype.toDegrees === undefined) {
  Number.prototype.toDegrees = function () {
    return this * 180 / Math.PI;
  };
} // Warn if overriding existing method


if (Array.prototype.equals === undefined) {
  // attach the .equals method to Array's prototype to call it on any array
  Array.prototype.equals = function (array) {
    // if the other array is a falsy value, return
    if (!array) {
      return false;
    } // compare lengths - can save a lot of time


    if (this.length != array.length) {
      return false;
    }

    for (var i = 0, l = this.length; i < l; i++) {
      // Check if we have nested arrays
      if (this[i] instanceof Array && array[i] instanceof Array) {
        // recurse into the nested arrays
        if (!this[i].equals(array[i])) {
          return false;
        }
      } else if (this[i] != array[i]) {
        // Warning - two different object instances will never be equal: {x:20} != {x:20}
        return false;
      }
    }

    return true;
  };
}
/* http://www.apsalin.com/convert-cartesian-to-geodetic.aspx */


var cartesian2Eeodetic = function cartesian2Eeodetic(x, y, z) {
  var a = 6378137;
  var b = 6356752.314245;
  var e2 = (a * a - b * b) / (a * a); // 1st eccentricity squared

  var ε2 = (a * a - b * b) / (b * b); // 2nd eccentricity squared

  var p = Math.sqrt(x * x + y * y); // distance from minor axis

  var R = Math.sqrt(p * p + z * z); // polar radius
  // parametric latitude (Bowring eqn 17, replacing tanβ = z·a / p·b)

  var tanβ = b * z / (a * p) * (1 + ε2 * b / R);
  var sinβ = tanβ / Math.sqrt(1 + tanβ * tanβ);
  var cosβ = sinβ / tanβ; // geodetic latitude (Bowring eqn 18: tanφ = z+ε²bsin³β / p−e²cos³β)

  var φ = Math.atan2(z + ε2 * b * sinβ * sinβ * sinβ, p - e2 * a * cosβ * cosβ * cosβ); // longitude

  var λ = Math.atan2(y, x); // height above ellipsoid (Bowring eqn 7)

  var sinφ = Math.sin(φ);
  var cosφ = Math.cos(φ);
  var ν = a / Math.sqrt(1 - e2 * sinφ * sinφ); // length of the normal terminated by the minor axis

  var h = p * cosφ + z * sinφ - a * a / ν;
  return [λ.toDegrees(), φ.toDegrees(), h];
};

var getCameraPosition = function getCameraPosition(matrix, rootTransform) {
  var cam = new THREE__namespace.Camera();
  var rootInverse = new THREE__namespace.Matrix4().copy(rootTransform).invert();
  cam.projectionMatrix.elements = matrix;
  cam.projectionMatrixInverse = new THREE__namespace.Matrix4().copy(cam.projectionMatrix).invert(); // add since three@0.103.0

  var campos = new THREE__namespace.Vector3(0, 0, 0).unproject(cam).applyMatrix4(rootInverse);
  return campos;
};
//= ====================================================


var TileLoader = /*#__PURE__*/function () {
  // This class contains the common code to load tile content, such as b3dm and pnts files.
  // It is not to be used directly. Instead, subclasses are used to implement specific
  // content loaders for different tile types.
  function TileLoader(url) {
    _classCallCheck(this, TileLoader);

    this.url = url;
    this.type = url.slice(-4);
    this.version = null;
    this.byteLength = null;
    this.featureTableJSON = null;
    this.featureTableBinary = null;
    this.batchTableJson = null;
    this.batchTableBinary = null;
    this.binaryData = null;
  }

  _createClass(TileLoader, [{
    key: "load",
    value: function load() {
      var self = this;
      return new Promise(function (resolve, reject) {
        fetch(self.url).then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP ".concat(response.status, " - ").concat(response.statusText));
          }

          return response;
        }).then(function (response) {
          return response.arrayBuffer();
        }).then(function (buffer) {
          return self.parseResponse(buffer);
        }).then(function (res) {
          return resolve(res);
        })["catch"](function (error) {
          reject(error);
        });
      });
    }
  }, {
    key: "parseResponse",
    value: function parseResponse(buffer) {
      var header = new Uint32Array(buffer.slice(0, 28));
      var decoder = new TextDecoder();
      var magic = decoder.decode(new Uint8Array(buffer.slice(0, 4)));

      if (magic != this.type) {
        throw new Error("Invalid magic string, expected '".concat(this.type, "', got '").concat(this.magic, "'"));
      }

      this.version = header[1];

      if (this.version !== 1) {
        throw new Error('Only Batched 3D Model version 1 is supported.  Version ' + this.version + ' is not.');
      }

      this.byteLength = header[2];
      var featureTableJSONByteLength = header[3];
      var featureTableBinaryByteLength = header[4];
      var batchTableJsonByteLength = header[5];
      var batchTableBinaryByteLength = header[6]; // console.log('magic: ' + magic);
      // console.log('version: ' + this.version);
      // console.log('featureTableJSONByteLength: ' + featureTableJSONByteLength);
      // console.log('featureTableBinaryByteLength: ' + featureTableBinaryByteLength);
      // console.log('batchTableJsonByteLength: ' + batchTableJsonByteLength);
      // console.log('batchTableBinaryByteLength: ' + batchTableBinaryByteLength);

      var pos = 28; // header length
      // Legacy header #2: [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]
      // Current header: [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]
      // If the header is in the first legacy format 'batchTableJsonByteLength' will be the start of the JSON string (a quotation mark) or the glTF magic.
      // Accordingly its first byte will be either 0x22 or 0x67, and so the minimum uint32 expected is 0x22000000 = 570425344 = 570MB. It is unlikely that the feature table JSON will exceed this length.
      // The check for the second legacy format is similar, except it checks 'batchTableBinaryByteLength' instead

      if (batchTableJsonByteLength >= 570425344) {
        // First legacy check
        pos -= 2;
        batchTableJsonByteLength = featureTableBinaryByteLength;
        batchTableBinaryByteLength = 0;
        featureTableJSONByteLength = 0;
        featureTableBinaryByteLength = 0;
      } else if (batchTableBinaryByteLength >= 570425344) {
        // Second legacy check
        pos -= 1;
        batchTableJsonByteLength = featureTableJSONByteLength;
        batchTableBinaryByteLength = featureTableBinaryByteLength;
        featureTableJSONByteLength = 0;
        featureTableBinaryByteLength = 0;
      } // featureTableJsonByteLength


      if (featureTableJSONByteLength === 0) {
        this.featureTableJSON = {};
      } else {
        var featureTableString = decoder.decode(new Uint8Array(buffer.slice(pos, pos + featureTableJSONByteLength)));
        this.featureTableJSON = JSON.parse(featureTableString);
        pos += featureTableJSONByteLength;
      } // featureTableBinaryByteLength


      this.featureTableBinary = buffer.slice(pos, pos + featureTableBinaryByteLength);
      pos += featureTableBinaryByteLength;

      if (batchTableJsonByteLength > 0) {
        var batchTableString = decoder.decode(new Uint8Array(buffer.slice(pos, pos + batchTableJsonByteLength)));
        this.batchTableJson = JSON.parse(batchTableString);
        pos += batchTableJsonByteLength;

        if (batchTableBinaryByteLength > 0) {
          this.batchTableBinary = buffer.slice(pos, pos + batchTableBinaryByteLength);
          pos += batchTableBinaryByteLength;
        }
      } else {
        this.batchTableJson = {};
      }

      var gltfByteLength = this.byteLength - pos;

      if (gltfByteLength === 0) {
        throw new Error('glTF byte length must be greater than 0.');
      }

      if (pos % 4 === 0) {
        this.binaryData = buffer.slice(pos);
      } else {
        // Create a copy of the glb so that it is 4-byte aligned
        pos = 40;
        gltfByteLength = 2521;
        this.binaryData = buffer.slice(pos, pos + gltfByteLength);
      } // this.binaryData = buffer.slice(pos);


      return this;
    }
  }]);

  return TileLoader;
}(); //-----------------------------------------------------


var B3DM = /*#__PURE__*/function (_TileLoader) {
  _inherits(B3DM, _TileLoader);

  var _super = _createSuper(B3DM);

  function B3DM(url) {
    var _this;

    _classCallCheck(this, B3DM);

    _this = _super.call(this, url);
    _this.glbData = null;
    return _this;
  }

  _createClass(B3DM, [{
    key: "parseResponse",
    value: function parseResponse(buffer) {
      _get(_getPrototypeOf(B3DM.prototype), "parseResponse", this).call(this, buffer);

      this.glbData = this.binaryData;
      return this;
    }
  }]);

  return B3DM;
}(TileLoader); //-----------------------------------------------------


var PNTS = /*#__PURE__*/function (_TileLoader2) {
  _inherits(PNTS, _TileLoader2);

  var _super2 = _createSuper(PNTS);

  function PNTS(url) {
    var _this2;

    _classCallCheck(this, PNTS);

    _this2 = _super2.call(this, url);
    _this2.points = new Float32Array();
    _this2.rgba = null;
    _this2.rgb = null;
    return _this2;
  }

  _createClass(PNTS, [{
    key: "parseResponse",
    value: function parseResponse(buffer) {
      _get(_getPrototypeOf(PNTS.prototype), "parseResponse", this).call(this, buffer);

      if (this.featureTableJSON.POINTS_LENGTH && this.featureTableJSON.POSITION) {
        var len = this.featureTableJSON.POINTS_LENGTH;
        var pos = this.featureTableJSON.POSITION.byteOffset;
        this.points = new Float32Array(this.featureTableBinary.slice(pos, pos + len * Float32Array.BYTES_PER_ELEMENT * 3));
        this.rtc_center = this.featureTableJSON.RTC_CENTER;

        if (this.featureTableJSON.RGBA) {
          pos = this.featureTableJSON.RGBA.byteOffset;
          var colorInts = new Uint8Array(this.featureTableBinary.slice(pos, pos + len * Uint8Array.BYTES_PER_ELEMENT * 4));
          var rgba = new Float32Array(colorInts.length);

          for (var i = 0; i < colorInts.length; i++) {
            rgba[i] = colorInts[i] / 255.0;
          }

          this.rgba = rgba;
        } else if (this.featureTableJSON.RGB) {
          pos = this.featureTableJSON.RGB.byteOffset;

          var _colorInts = new Uint8Array(this.featureTableBinary.slice(pos, pos + len * Uint8Array.BYTES_PER_ELEMENT * 3));

          var rgb = new Float32Array(_colorInts.length);

          for (var _i = 0; _i < _colorInts.length; _i++) {
            rgb[_i] = _colorInts[_i] / 255.0;
          }

          this.rgb = rgb;
        } else if (this.featureTableJSON.RGB565) {
          console.error('RGB565 is currently not supported in pointcloud tiles.');
        }
      }

      return this;
    }
  }]);

  return PNTS;
}(TileLoader); //= ====================================================
//= ====================================================


var Data3D = /*#__PURE__*/function () {
  function Data3D(params, layer) {
    _classCallCheck(this, Data3D);

    this.hasmodel = 0;
    this.scene = null;
    this.camera = null;
    this.layer = layer;
    this.box = null;
    this.clock = null;
    this.mixer = null;
    this.parse(params);
  }

  _createClass(Data3D, [{
    key: "initScene",
    value: function initScene() {
      this.scene = new THREE__namespace.Scene();
      this.camera = this.layer.camera(); // init light

      var light = new THREE__namespace.AmbientLight(0xFFFFFF); // soft white light

      this.scene.add(light);
    }
  }, {
    key: "parse",
    value: function parse(params) {}
  }, {
    key: "render",
    value: function render(renderer) {
      if (this.visible && this.hasmodel) {
        if (this.mixer) {
          if (this.clock == null) {
            this.clock = new THREE__namespace.Clock();
          }

          this.mixer.update(this.clock.getDelta());
        }

        renderer.render(this.scene, this.camera);
        return true;
      }

      return false;
    }
  }, {
    key: "raycast",
    value: function raycast(mouse, raycaster) {
      if (this.visible && this.hasmodel) {
        // 1. update camera
        this.camera.projectionMatrixInverse.copy(this.camera.projectionMatrix).invert(); // <--
        // 2. set the picking ray from the camera position and mouse coordinates

        raycaster.setFromCamera(mouse, this.camera); // 3. compute intersections

        var intersects = raycaster.intersectObjects(this.scene.children, true);

        for (var i = 0; i < intersects.length; i++) {// An intersection has the following properties :
          // - object : intersected object (THREE.Mesh)
          // - distance : distance from camera to intersection (number)
          // - face : intersected face (THREE.Face3)
          // - faceIndex : intersected face index (number)
          // - point : intersection point (THREE.Vector3)
          // - uv : intersection point in the object's UV coordinates (THREE.Vector2)
        }
      }
    }
  }, {
    key: "resize",
    value: function resize() {
      this.camera = this.layer.camera();
    }
  }, {
    key: "load",
    value: function load() {}
  }, {
    key: "unload",
    value: function unload() {
      this.visible = false;
    }
  }, {
    key: "checkLoad",
    value: function checkLoad(matrix) {
      this.unload();
      this.camera.projectionMatrix = new THREE__namespace.Matrix4().fromArray(matrix).multiply(this.rootTransform);
      var frustum = new THREE__namespace.Frustum();
      frustum.setFromProjectionMatrix(new THREE__namespace.Matrix4().multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse));

      if (!this.sphere || !frustum.intersectsSphere(this.sphere)) {
        return false;
      }

      var cameraPosition = getCameraPosition(matrix, this.rootTransform);
      this.dist = cameraPosition.length();

      if (this.dist > this.far) {
        return false;
      }

      this.load();
      return true;
    }
  }]);

  return Data3D;
}(); //-----------------------------------------------------


var Model3D = /*#__PURE__*/function (_Data3D) {
  _inherits(Model3D, _Data3D);

  var _super3 = _createSuper(Model3D);

  function Model3D() {
    _classCallCheck(this, Model3D);

    return _super3.apply(this, arguments);
  }

  _createClass(Model3D, [{
    key: "parse",
    value: function parse(params) {
      this.model = null;
      this.url = params['name'];
      this.rootTransform = getTransform(params['ll'], 0);
      this.scale = null;

      if ('scale' in params) {
        this.scale = params['scale'];
      }

      this.heading = null;

      if ('rotate' in params) {
        this.heading = params['rotate'].toRadians();
      }

      if ('heading' in params) {
        this.heading = params['heading'];
      }

      this.sphere = new THREE__namespace.Sphere(new THREE__namespace.Vector3(0, 0, 0), 50);
      this.initScene();
      this.loaded = false;
      this.visible = false;
      this.dist = 0;
      this.far = MAXD;
    }
  }, {
    key: "load",
    value: function load() {
      this.visible = true;

      if (this.loaded) {
        return;
      }

      this.loaded = true;
      this.loadProgress();
    }
  }, {
    key: "loadProgress",
    value: function loadProgress() {}
  }, {
    key: "loadSuccess",
    value: function loadSuccess(model) {
      var trans = new THREE__namespace.Matrix4().multiply(new THREE__namespace.Matrix4().makeRotationAxis(new THREE__namespace.Vector3(1, 0, 0), Math.PI / 2));

      if (this.scale != null) {
        trans.scale(new THREE__namespace.Vector3(this.scale, this.scale, this.scale));
      }

      if (this.heading != null) {
        trans.multiply(new THREE__namespace.Matrix4().makeRotationAxis(new THREE__namespace.Vector3(0, 1, 0), this.heading));
      }

      model.applyMatrix4(trans);

      if (model.animations != null && model.animations.length > 0) {
        this.mixer = new THREE__namespace.AnimationMixer(model);
        var action = this.mixer.clipAction(model.animations[0]);
        action.play();
      }

      var box = new THREE__namespace.Box3().setFromObject(model);
      var dx = box.max.x - box.min.x;
      var dy = box.max.y - box.min.y;
      var dz = box.max.z - box.min.z;
      var radius = Math.sqrt(dx * dx + dy * dy + dz * dz);
      this.sphere = new THREE__namespace.Sphere(new THREE__namespace.Vector3(0, 0, 0), radius);
      var far = radius * 8;

      if (far > MAXD) {
        this.far = far;
      }

      this.scene.add(model);
      this.hasmodel = true;
      this.layer.refesh();
    }
  }]);

  return Model3D;
}(Data3D);

var ModelFbx = /*#__PURE__*/function (_Model3D) {
  _inherits(ModelFbx, _Model3D);

  var _super4 = _createSuper(ModelFbx);

  function ModelFbx() {
    _classCallCheck(this, ModelFbx);

    return _super4.apply(this, arguments);
  }

  _createClass(ModelFbx, [{
    key: "loadProgress",
    value: function loadProgress() {}
  }]);

  return ModelFbx;
}(Model3D);

var ModelGltf = /*#__PURE__*/function (_Model3D2) {
  _inherits(ModelGltf, _Model3D2);

  var _super5 = _createSuper(ModelGltf);

  function ModelGltf() {
    _classCallCheck(this, ModelGltf);

    return _super5.apply(this, arguments);
  }

  _createClass(ModelGltf, [{
    key: "loadProgress",
    value: function loadProgress() {
      var loader = new GLTFLoader__default['default']();
      loader.load(this.url, function (gltf) {
        this.loadSuccess(gltf.scene);
      }.bind(this));
    }
  }]);

  return ModelGltf;
}(Model3D);

var ModelDae = /*#__PURE__*/function (_Model3D3) {
  _inherits(ModelDae, _Model3D3);

  var _super6 = _createSuper(ModelDae);

  function ModelDae() {
    _classCallCheck(this, ModelDae);

    return _super6.apply(this, arguments);
  }

  _createClass(ModelDae, [{
    key: "loadProgress",
    value: function loadProgress() {}
  }]);

  return ModelDae;
}(Model3D); //-----------------------------------------------------


var TileData = /*#__PURE__*/function () {
  function TileData(layer, json, resourcePath, level, nId) {
    _classCallCheck(this, TileData);

    this.hasmodel = 0;
    this.layer = layer;
    this.level = level;
    this.nId = nId;
    this.loaded = false;
    this.resourcePath = resourcePath;
    this.totalContent = new THREE__namespace.Group(); // Three JS Object3D Group for this tile and all its children

    this.tileContent = new THREE__namespace.Group(); // Three JS Object3D Group for this tile's content

    this.childContent = new THREE__namespace.Group(); // Three JS Object3D Group for this tile's children

    this.totalContent.add(this.tileContent);
    this.totalContent.add(this.childContent);
    this.boundingVolume = json.boundingVolume;
    this.geometricError = json.geometricError;
    this.children = [];
    this.sphere = null;
    this.far = 0;
    this.near = 0;
    this.dist = 0;

    if (json.content) {
      this.url = json.content.uri ? json.content.uri : json.content.url;
    }

    if (this.boundingVolume) {
      // this.far = this.geometricError * 2000;
      // this.near = this.far/2;
      if (this.boundingVolume.box) {
        var box = this.boundingVolume.box;
        var dx = box[3];
        var dy = box[7];
        var dz = box[11];
        var radius = Math.sqrt(dx * dx + dy * dy + dz * dz);
        this.sphere = new THREE__namespace.Sphere(new THREE__namespace.Vector3(0, 0, 0), radius);
        this.far = this.geometricError * 2100; // this.far = radius * 12;

        this.near = this.far / 3; // root

        this.ll = cartesian2Eeodetic(box[0], box[1], box[2]); // console.log('level ' + this.level  + ' h: ' + this.ll[2]);

        this.rootTransform = getTransform(this.ll, this.ll[2]);
        this.loadChild(layer, json, resourcePath);
      } else if (this.boundingVolume.sphere) {
        var sphere = this.boundingVolume.sphere;
        var _radius = sphere[3];
        this.sphere = new THREE__namespace.Sphere(new THREE__namespace.Vector3(0, 0, 0), _radius);
        this.far = this.geometricError * 2100; // this.far = radius * 12;

        this.near = this.far / 3; // root

        this.ll = cartesian2Eeodetic(sphere[0], sphere[1], sphere[2]); // console.log('level ' + this.level + ' h: ' + this.ll[2]);

        this.rootTransform = getTransform(this.ll, this.ll[2]);
        this.loadChild(layer, json, resourcePath);
      }
    }
  }

  _createClass(TileData, [{
    key: "loadChild",
    value: function loadChild(layer, json, resourcePath) {
      if (json.children
      /* && this.level < 0 */
      ) {
        var nId = 1;

        for (var i = 0; i < json.children.length; i++) {
          var child = new TileData(layer, json.children[i], resourcePath, this.level + 1, nId);
          this.childContent.add(child.totalContent);
          this.children.push(child);
          nId = nId + 1;
        }
      }
    }
  }, {
    key: "load",
    value: function load() {
      this.tileContent.visible = true;
      this.childContent.visible = false;

      if (this.loaded) {
        return;
      }

      this.loaded = true;

      if (!this.url) {
        return;
      }

      var url = this.url;
      var self = this;

      if (url.substr(0, 4) != 'http') {
        url = this.resourcePath + url;
      }

      var type = url.slice(-4);

      if (type == 'json') {
        // child is a tileset json
        var tileset = new TileSet(self.layer, 1);
        tileset.load(url).then(function () {
          self.children.push(tileset.root);
          self.childContent.add(tileset.root.totalContent);
          self.hasmodel = 2;
          self.layer.refesh();
        });
      } else if (type == 'b3dm') {
        var loader = new GLTFLoader__default['default']();
        var b3dm = new B3DM(url);
        b3dm.load().then(function (d) {
          return loader.parse(d.glbData, self.resourcePath, function (gltf) {
            var model = gltf.scene;
            var rotX = self.ll[1];
            var rotY = -self.ll[0] - 90;
            var trans = new THREE__namespace.Matrix4().multiply(new THREE__namespace.Matrix4().makeRotationAxis(new THREE__namespace.Vector3(1, 0, 0), rotX.toRadians())).multiply(new THREE__namespace.Matrix4().makeRotationAxis(new THREE__namespace.Vector3(0, 1, 0), rotY.toRadians()));
            model.castShadow = false;
            model.applyMatrix4(trans);
            self.tileContent.add(model); // is root

            if (self.level == 0) {
              // model.position.y
              var box = new THREE__namespace.Box3().setFromObject(model);
              var center = box.getCenter(new THREE__namespace.Vector3());

              var _trans = new THREE__namespace.Matrix4().makeTranslation(-center.x, -center.y, -center.z);

              self.totalContent.applyMatrix4(_trans);
            }

            self.hasmodel = 1;
            self.layer.refesh();
          }, function (e) {
            throw new Error('error parsing gltf: ' + e);
          });
        });
      } else if (type == 'pnts') {
        var pnts = new PNTS(url);
        pnts.load().then(function (d) {
          var geometry = new THREE__namespace.BufferGeometry();
          geometry.setAttribute('position', new THREE__namespace.Float32BufferAttribute(d.points, 3));
          var material = new THREE__namespace.PointsMaterial();
          material.size = 1.0;
          material.vertexColors = THREE__namespace.NoColors;
          material.color = new THREE__namespace.Color(0xff0000);
          material.opacity = 1.0;

          if (d.rgba) {
            geometry.setAttribute('color', new THREE__namespace.Float32BufferAttribute(d.rgba, 4));
            material.vertexColors = THREE__namespace.VertexColors;
          } else if (d.rgb) {
            geometry.setAttribute('color', new THREE__namespace.Float32BufferAttribute(d.rgb, 3));
            material.vertexColors = THREE__namespace.VertexColors;
          }

          self.tileContent.add(new THREE__namespace.Points(geometry, material));

          if (d.rtc_center) {
            var c = d.rtc_center;
            self.tileContent.applyMatrix4(new THREE__namespace.Matrix4().makeTranslation(c[0], c[1], c[2]));
          }

          self.tileContent.add(new THREE__namespace.Points(geometry, material));
        });
      }
    }
  }, {
    key: "unload",
    value: function unload(includeChildren) {
      this.tileContent.visible = false;

      if (includeChildren) {
        this.childContent.visible = false;
      } else {
        this.childContent.visible = true;
      } // TODO: should we also free up memory?

    }
  }, {
    key: "checkLoad",
    value: function checkLoad(matrix, camera) {
      var l = new THREE__namespace.Matrix4().fromArray(matrix);
      camera.projectionMatrix = l.multiply(this.rootTransform);
      var frustum = new THREE__namespace.Frustum();
      frustum.setFromProjectionMatrix(new THREE__namespace.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));

      if (!this.sphere || !frustum.intersectsSphere(this.sphere)) {
        this.unload(true);
        return false;
      }

      var cameraPosition = getCameraPosition(matrix, this.rootTransform);
      this.dist = cameraPosition.length(); // are we too far to render this tile?

      if (this.dist > this.far) {
        this.unload(true);
        return false;
      }

      this.load();

      if (!this.hasmodel) {
        return false;
      } // should we load this tile?


      if (this.children.length > 0 && this.dist < this.near) {
        this.unload(false);
        var c = 0;

        for (var i = 0; i < this.children.length; i++) {
          if (this.children[i].checkLoad(matrix, camera)) {
            c = c + 1;
          }
        }

        this.tileContent.visible = c == 0;
      } else {
        // no model to view
        if (this.hasmodel == 2) {
          return false;
        } else {
          for (var _i2 = 0; _i2 < this.children.length; _i2++) {
            this.children[_i2].unload(true);
          }
        }
      }

      return true;
    }
  }]);

  return TileData;
}(); //-----------------------------------------------------


var TileSet = /*#__PURE__*/function () {
  function TileSet(layer, level) {
    _classCallCheck(this, TileSet);

    this.layer = layer;
    this.url = null;
    this.version = null;
    this.geometricError = null;
    this.root = null;
    this.level = level;
    this.camera = this.layer.camera();
  }

  _createClass(TileSet, [{
    key: "load",
    value: function load(url) {
      this.url = url;
      var resourcePath = THREE__namespace.LoaderUtils.extractUrlBase(url);
      var self = this;
      return new Promise(function (resolve, reject) {
        fetch(self.url).then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP ".concat(response.status, " - ").concat(response.statusText));
          }

          return response;
        }).then(function (response) {
          return response.json();
        }).then(function (json) {
          self.version = json.asset.version;
          self.geometricError = json.geometricError;
          self.root = new TileData(self.layer, json.root, resourcePath, self.level, 1);
        }).then(function (res) {
          return resolve();
        })["catch"](function (error) {
          console.error(error);
          reject(error);
        });
      });
    }
  }, {
    key: "checkLoad",
    value: function checkLoad(matrix) {
      if (this.root) {
        return this.root.checkLoad(matrix, this.camera);
      }

      return true;
    }
  }, {
    key: "resize",
    value: function resize() {
      this.camera = this.layer.camera();
    }
  }]);

  return TileSet;
}(); //-----------------------------------------------------


var ModelTile = /*#__PURE__*/function (_Data3D2) {
  _inherits(ModelTile, _Data3D2);

  var _super7 = _createSuper(ModelTile);

  function ModelTile() {
    _classCallCheck(this, ModelTile);

    return _super7.apply(this, arguments);
  }

  _createClass(ModelTile, [{
    key: "parse",
    value: function parse(params) {
      this.initScene();
      this.url = params['name'];
      this.tileset = new TileSet(this.layer, 0);
      this.clippingPlane = null;
      var self = this;
      this.tileset.load(this.url).then(function () {
        self.clippingPlane = new THREE__namespace.Plane(new THREE__namespace.Vector3(0, 0, 1), self.tileset.root.ll[2] + 4);
        self.scene.add(self.tileset.root.totalContent);
        self.hasmodel = 1;
        self.layer.refesh();
      });
    }
  }, {
    key: "checkLoad",
    value: function checkLoad(matrix) {
      this.visible = false;

      if (this.hasmodel) {
        this.camera.projectionMatrix = new THREE__namespace.Matrix4().fromArray(matrix).multiply(this.tileset.root.rootTransform);
        this.visible = this.tileset.checkLoad(matrix);
      }

      return this.visible;
    }
  }, {
    key: "render",
    value: function render(renderer) {
      if (this.visible && this.hasmodel) {
        renderer.clippingPlanes = [this.clippingPlane];
        renderer.localClippingEnabled = true;
        renderer.render(this.scene, this.camera);
        renderer.localClippingEnabled = false;
        return true;
      }

      return false;
    }
  }]);

  return ModelTile;
}(Data3D); //= ====================================================
//= ====================================================


var BuildingLayer = /*#__PURE__*/function () {
  function BuildingLayer(layerId, models, level) {
    _classCallCheck(this, BuildingLayer);

    this.id = layerId;
    this.type = 'custom';
    this.renderingMode = '3d';
    this.models = models;
    this.datas = [];
    this.renderer = null;
    this.desc = '';
    this.level = level;
  }

  _createClass(BuildingLayer, [{
    key: "onAdd",
    value: function onAdd(map, gl) {
      this.map = map;
      this.matrix = null;
      var loadjson = false;

      for (var i = 0; i < this.models.length; i++) {
        var params = this.models[i];
        var type = params['name'].slice(-4);

        if (type == 'gltf') {
          this.datas.push(new ModelGltf(params, this));
        } else if (type == '.fbx') {
          this.datas.push(new ModelFbx(params, this));
        } else if (type == '.dae') {
          this.datas.push(new ModelDae(params, this));
        } else if (type == 'json' && !loadjson) {
          this.datas.push(new ModelTile(params, this));
        }
      }

      var self = this; // function refresh(){  self.matrix = null; }
      // map.on('dragend', refresh);
      // map.on('moveend', refresh);

      this.renderer = new THREE__namespace.WebGLRenderer({
        canvas: map.getCanvas(),
        context: gl,
        antialias: false
      });
      this.renderer.outputEncoding = THREE__namespace.GammaEncoding;
      this.renderer.shadowMap.enabled = false;
      this.renderer.autoClear = false; // var globalPlane = new THREE.Plane( new THREE.Vector3( 0, 0, 1 ), 93 );
      // this.renderer.clippingPlanes = [ globalPlane ];
      // this.renderer.localClippingEnabled = true;

      function resize() {
        self.resize();
      }

      map.on('resize', resize);

      function raycast(e) {
        self.raycast(e);
      }

      map.on('click', raycast);
    }
  }, {
    key: "raycast",
    value: function raycast(e) {
      var mouse = new THREE__namespace.Vector2();
      mouse.x = e.point.x / this.map.transform.width * 2 - 1;
      mouse.y = 1 - e.point.y / this.map.transform.height * 2;
      var raycaster = new THREE__namespace.Raycaster();

      for (var i = 0; i < this.datas.length; i++) {
        this.datas[i].raycast(mouse, raycaster);
      } // const raycaster = new THREE.Raycaster();
      // raycaster.setFromCamera(mouse, this.camera);
      // console.log(raycaster.intersectObjects(this.scene.children, true));

    }
  }, {
    key: "resize",
    value: function resize() {
      for (var i = 0; i < this.datas.length; i++) {
        this.datas[i].resize();
      }

      this.refesh();
    }
  }, {
    key: "camera",
    value: function camera() {
      return new THREE__namespace.PerspectiveCamera(CAMERA_FOV, this.map.transform.width / this.map.transform.height, CAMERA_NEAR, CAMERA_FAR);
    }
  }, {
    key: "refesh",
    value: function refesh() {
      this.matrix = null;
    }
  }, {
    key: "render",
    value: function render(gl, matrix) {
      this.render3D(gl, matrix);
    }
  }, {
    key: "render3D",
    value: function render3D(gl, matrix) {
      if (this.datas.length < 1 || this.renderer == null) {
        return;
      }

      var level = this.map.getZoom();

      if (level < this.level) {
        return;
      }

      this.renderer.state.reset(); // this.renderer.setClearColor(0, 1)

      if (!this.matrix || !this.matrix.equals(matrix)) {
        this.matrix = matrix;

        for (var i = 0; i < this.datas.length; i++) {
          this.datas[i].checkLoad(this.matrix);
        }
      }

      for (var _i3 = 0; _i3 < this.datas.length; _i3++) {
        this.datas[_i3].render(this.renderer);
      }

      this.map.triggerRepaint();
    }
  }]);

  return BuildingLayer;
}();

var base = ['--size-xs', '--size-sm', '--size-md', '--size-lg', '--size-xl', '--size-xxl'];
var featureItem = ['--feature-item-width', '--feature-item-height'];
var baseRgb = ['--default', '--success', '--info', '--warning', '--danger', '--primary', '--secondary'];
var baseColor = ['--default-color', '--primary-color', '--primary-highlight', '--secondary-color', '--secondary-light', '--tertiary-color', '--success-color', '--info-color', '--warning-color', '--danger-color', '--base-rgb', '--contrast', '--base-color', '--base-light', '--base-lighter', '--base-highlight', '--contrast-color', '--contrast-light', '--contrast-lighter', '--contrast-highlight'];
var alpha = ['--primary-highlight-alpha', '--secondary-highlight-alpha', '--base-light-alpha', '--base-lighter-alpha', '--base-highlight-alpha', '--text-alpha', '--text-light-alpha', '--text-dark-alpha', '--sub-text-alpha', '--border-alpha', '--border-light-alpha', '--border-lighter-alpha', '--btn-alpha', '--bg-alpha', '--divide-alpha', '--form-control-bg-alpha'];
var text = ['--text-rgb', '--text-color', '--text-contrast-color', '--text-light', '--text-dark', '--sub-text-color', '--default-text-color'];
var border = ['--border', '--border-color', '--border-light', '--border-lighter', '--marker-popup-border-radius', '--popup-border-radius', '--popup-border'];
var button = ['--button-color'];
var tag = ['--tag-green-bg-light', '--tag-green-fg-light', '--tag-lime-bg-light', '--tag-lime-fg-light', '--tag-yellow-bg-light', '--tag-yellow-fg-light', '--tag-orange-bg-light', '--tag-orange-fg-light', '--tag-red-bg-light', '--tag-red-fg-light', '--tag-green-bg-dark', '--tag-green-fg-dark', '--tag-lime-bg-dark', '--tag-lime-fg-dark', '--tag-yellow-bg-dark', '--tag-yellow-fg-dark', '--tag-orange-bg-dark', '--tag-orange-fg-dark', '--tag-red-bg-dark', '--tag-red-fg-dark', '--tag-green-bg', '--tag-green-fg', '--tag-lime-bg', '--tag-lime-fg', '--tag-yellow-bg', '--tag-yellow-fg', '--tag-orange-bg', '--tag-orange-fg', '--tag-red-bg', '--tag-red-fg'];
var background = ['--bg', '--form-control-bg', '--popup-bg', '--bg-color', '--bg-dark', '--bg-light', '--map-tool-bg', '--sidebar-bg', '--tab-bg', 'overlay-bg'];
var panel = ['--panel-bg', '--panel-header-bg', '--panel-footer-bg', '--panel-split-shine', '--panel-split-shadow'];
var cssVars = [].concat(base, featureItem, baseRgb, baseColor, alpha, text, border, button, tag, background, panel);

/**
 * Define theme's information
 * @example
 *  {
 *      id: "ogis-light",
 *      base: 'light',
 *      name: {
 *          vi: "Giao diện màu sáng",
 *          en: "ogis light"
 *      }
 *  }
*/
var isSingleTheme = function isSingleTheme(varConfig) {
  return !!varConfig.base && !!varConfig.name;
};

/**
 * Hook to override global VUI's css variables.
 */

var useThemeOverride = function useThemeOverride(themeConfig) {
  var _ref = themeConfig || {},
      fontBase = _ref.fontBase,
      varConfigs = _ref.varConfigs,
      themeTransitDuration = _ref.themeTransitDuration;

  var DATA_STYLESHEET_OVERRIDE = {
    FONT_BASE: 'fontBase',
    CSS_VAR: 'cssVar',
    THEME_TRANSITION: 'themeTransition'
  };
  React.useEffect(function () {
    return function () {
      removeStyleSheet(DATA_STYLESHEET_OVERRIDE.CSS_VAR);
      removeStyleSheet(DATA_STYLESHEET_OVERRIDE.FONT_BASE);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  if (varConfigs) {
    removeStyleSheet(DATA_STYLESHEET_OVERRIDE.CSS_VAR);
    var styleSheets = transformToStyleSheet(varConfigs);
    appendStyleSheetToHead(styleSheets, DATA_STYLESHEET_OVERRIDE.CSS_VAR);
  }

  if (fontBase) {
    removeStyleSheet(DATA_STYLESHEET_OVERRIDE.FONT_BASE);
    var fontBaseMediaQuery = createBreakpointVarStyleSheet(fontBase);
    fontBaseMediaQuery && appendStyleSheetToHead(fontBaseMediaQuery, DATA_STYLESHEET_OVERRIDE.FONT_BASE);
  }

  if (themeTransitDuration) {
    removeStyleSheet(DATA_STYLESHEET_OVERRIDE.THEME_TRANSITION);

    var _fontBaseMediaQuery = createCssVarStyleSheet({
      themeTransitDuration: themeTransitDuration
    }, ".".concat(THEME_SWITCHING_CLASS));

    _fontBaseMediaQuery && appendStyleSheetToHead(_fontBaseMediaQuery, DATA_STYLESHEET_OVERRIDE.THEME_TRANSITION);
  }
};

var transformToStyleSheet = function transformToStyleSheet(varConfigs) {
  var invalidKeysWithTheme = [];
  var transformedStyleSheet = varConfigs.reduce(function (combinedStyleSheet, config) {
    if (isSingleTheme(config)) {
      var selectors = config.selectors,
          id = config.id,
          cssVar = config.cssVar;
      var styleSheetOfSelector = (selectors === null || selectors === void 0 ? void 0 : selectors.reduce(function (styleSheet, selectorConfig) {
        var selector = selectorConfig.selector,
            cssVar = selectorConfig.cssVar;
        var selectorWithTheme = ".".concat(id, " ").concat(selector);
        invalidKeysWithTheme.push([selectorWithTheme, getInvalidOverrideKeys(cssVar)]);
        return cssVar ? "".concat(styleSheet).concat(createCssVarStyleSheet(cssVar, selectorWithTheme), "\n") : styleSheet;
      }, '')) || '';
      var styleSheetOfTheme = cssVar ? createCssVarStyleSheet(cssVar, ".".concat(id)) : '';
      return combinedStyleSheet + styleSheetOfTheme + styleSheetOfSelector;
    } else {
      var _id = config.id,
          _cssVar = config.cssVar,
          cssVarDark = config.cssVarDark,
          cssVarLight = config.cssVarLight,
          _selectors = config.selectors;
      var MAPPED_THEME_SELECTOR = {
        cssVar: ".".concat(_id),
        cssVarDark: ".theme-dark.".concat(_id),
        cssVarLight: ".theme-light.".concat(_id)
      };

      var _styleSheetOfSelector = (_selectors === null || _selectors === void 0 ? void 0 : _selectors.reduce(function (styleSheet, selectorConfig) {
        var selector = selectorConfig.selector,
            cssVar = selectorConfig.cssVar;
        var selectorWithTheme = "".concat(MAPPED_THEME_SELECTOR.cssVar, " ").concat(selector);
        invalidKeysWithTheme.push([selectorWithTheme, getInvalidOverrideKeys(cssVar)]);
        return cssVar ? "".concat(styleSheet).concat(createCssVarStyleSheet(cssVar, selectorWithTheme), "\n") : styleSheet;
      }, '')) || '';

      var _styleSheetOfTheme = Object.entries({
        cssVar: _cssVar,
        cssVarDark: cssVarDark,
        cssVarLight: cssVarLight
      }).reduce(function (styleSheet, cssVariable) {
        var _ref2 = cssVariable,
            _ref3 = _slicedToArray(_ref2, 2),
            curKey = _ref3[0],
            curCssVar = _ref3[1];

        var selector = MAPPED_THEME_SELECTOR[curKey];
        invalidKeysWithTheme.push([selector, getInvalidOverrideKeys(curCssVar)]);
        return curCssVar ? "".concat(styleSheet).concat(createCssVarStyleSheet(curCssVar, selector), "\n") : styleSheet;
      }, '');

      return combinedStyleSheet + _styleSheetOfTheme + _styleSheetOfSelector;
    }
  }, '');
  logInvalidOverrideKeys(invalidKeysWithTheme);
  return transformedStyleSheet;
};

var createCssVarStyleSheet = function createCssVarStyleSheet(cssVar, cssSelector) {
  var styleSheetOfSelector = Object.entries(cssVar).reduce(function (styleSheet, _ref4) {
    var _ref5 = _slicedToArray(_ref4, 2),
        cssVarKey = _ref5[0],
        cssVarVal = _ref5[1];

    var camelCssVarKey = camelToCssVar(cssVarKey);
    return styleSheet + "".concat(camelCssVarKey, ": ").concat(cssVarVal, ";");
  }, '');
  return "".concat(cssSelector, " {").concat(styleSheetOfSelector, "}");
};

var createBreakpointVarStyleSheet = function createBreakpointVarStyleSheet(fontBase) {
  var breakpointVars = Object.entries(fontBase).sort(function (a, b) {
    return breakpoints[a[0]] - breakpoints[b[0]];
  }).reduce(function (bpVar, cur) {
    var _cur = _slicedToArray(cur, 2),
        bp = _cur[0],
        fontSize = _cur[1];

    return bpVar + "--font-base-".concat(bp, ": ").concat(fontSize, ";\n");
  }, '');
  return ":root {".concat(breakpointVars, "}");
};

var appendStyleSheetToHead = function appendStyleSheetToHead(styleSheet, dataAttribute) {
  if (!window) {
    return;
  }

  var css = document.createElement('style');
  css.dataset.vuiOverride = dataAttribute;
  css.appendChild(document.createTextNode(styleSheet));
  document.head.append(css);
};

var removeStyleSheet = function removeStyleSheet(dataAttribute) {
  if (!window) {
    return;
  }

  var lastDataSet = document.querySelector("[data-vui-override='".concat(dataAttribute, "']"));
  lastDataSet && document.head.removeChild(lastDataSet);
};

var logInvalidOverrideKeys = function logInvalidOverrideKeys(mappedInvalidKeys) {
  var invalidKeyByThemes = mappedInvalidKeys.reduce(function (acc, cur) {
    var _cur2 = _slicedToArray(cur, 2),
        selector = _cur2[0],
        overrideKey = _cur2[1];

    return overrideKey.length > 0 ? acc + "At selector: \"".concat(selector, "\", keys: \"").concat(overrideKey, "\"\n") : acc;
  }, '');
  console.warn(invalidKeyByThemes + "These keys will not override VUI's css variable, make sure to use VUI's css variable name for overriding.");
};

var getInvalidOverrideKeys = function getInvalidOverrideKeys(cssVar) {
  return cssVar ? Object.keys(cssVar).reduce(function (invalidVarKeys, cssVarKey) {
    var isValidKey = cssVars === null || cssVars === void 0 ? void 0 : cssVars.includes(camelToCssVar(cssVarKey));
    return isValidKey ? invalidVarKeys : invalidVarKeys + " ".concat(cssVarKey);
  }, '') : '';
}; // primaryHighlightAlpha => --primary-highlight-alpha


var camelToCssVar = function camelToCssVar(camelCase) {
  return "--".concat(camelToKebab(camelCase));
};

var themeList = [// Theme for Ogis project - test the class theme-mobile
{
  id: 'ogis-light',
  name: 'Ogis light',
  base: 'light',
  className: 'theme-ogis theme-mobile'
}, {
  id: 'ogis-dark',
  name: 'Ogis dark',
  base: 'dark',
  className: 'theme-ogis theme-mobile'
}, {
  id: 'theme-blue',
  name: 'Xanh tối',
  base: 'dark',
  className: 'theme-blue'
}, {
  id: 'theme-red',
  name: 'Đỏ tối',
  base: 'dark',
  className: 'theme-red'
}, {
  id: 'theme-steel',
  name: 'Thép tối',
  base: 'dark',
  className: 'theme-steel'
}, {
  id: 'theme-gray',
  name: 'Xám tối',
  base: 'dark',
  className: 'theme-gray'
}, {
  id: 'theme-red',
  name: 'Đỏ sáng',
  base: 'light',
  className: 'theme-red'
}, {
  id: 'theme-green',
  name: 'Xanh lá',
  base: 'light',
  className: 'theme-green'
}, {
  id: 'theme-purple',
  name: 'Tím',
  base: 'light',
  className: 'theme-purple'
}];
var ThemeContext = /*#__PURE__*/React.createContext({
  theme: themeList[0],
  setTheme: function setTheme() {
    return null;
  }
});
var THEME_SWITCHING_CLASS = 'theme-switching';

var ThemeProvider = function ThemeProvider(props) {
  var _tenantContext$config, _tenantContext$config2;

  var theme = props.theme,
      children = props.children;

  var _useState = React.useState(themeList[0]),
      _useState2 = _slicedToArray(_useState, 2),
      isTheme = _useState2[0],
      setTheme = _useState2[1];

  var _useState3 = React.useState(themeList),
      _useState4 = _slicedToArray(_useState3, 2),
      themes = _useState4[0],
      setThemes = _useState4[1];

  var timeout = React.useRef();
  var tenantContext = React.useContext(TenantContext);
  useThemeOverride((_tenantContext$config = tenantContext.config) === null || _tenantContext$config === void 0 ? void 0 : _tenantContext$config.themeConfig);
  var themeName = localStorage.getItem('theme') || ((_tenantContext$config2 = tenantContext.config) === null || _tenantContext$config2 === void 0 ? void 0 : _tenantContext$config2.theme);
  React.useEffect(function () {
    var _tenantContext$config3;

    var themeConfig = tenantContext.config.themeConfig;

    if (themeConfig) {
      var newThemeList = createThemeFromConfig(themeConfig);
      return setThemes(newThemeList);
    }

    ((_tenantContext$config3 = tenantContext.config) === null || _tenantContext$config3 === void 0 ? void 0 : _tenantContext$config3.themeList) && setThemes(tenantContext.config.themeList);
  }, [tenantContext.config.themeConfig, tenantContext.config.themeList]);
  React.useEffect(function () {
    var initTheme = themes.find(function (theme) {
      return theme.id === themeName;
    }) || themes[0];
    handleThemeChange(theme || initTheme, !!theme);
  }, [theme, themes]);

  var handleThemeChange = function handleThemeChange(theme) {
    var _tenantContext$config4;

    var saveLocal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    timeout.current && clearTimeout(timeout.current);
    var themeTransitDuration = ((_tenantContext$config4 = tenantContext.config.themeConfig) === null || _tenantContext$config4 === void 0 ? void 0 : _tenantContext$config4.themeTransitDuration) || 900;
    var bodyClassName = getBodyClassName(theme);
    document.body.className = "".concat(bodyClassName, " ").concat(THEME_SWITCHING_CLASS);
    timeout.current = setTimeout(function () {
      return document.body.className = bodyClassName;
    }, themeTransitDuration);

    if (saveLocal) {
      localStorage.setItem('theme', typeof theme === 'string' ? theme : theme.id);
    }

    var newTheme = typeof theme !== 'string' ? theme : themes.find(function (_ref) {
      var id = _ref.id;
      return id === theme;
    });
    newTheme && setTheme(newTheme);
  };

  var getBodyClassName = function getBodyClassName(theme) {
    // Fallback old tenant api, still use 'themeList'
    if (typeof theme !== 'string') {
      return "theme-base theme-".concat(theme.base, " ").concat(theme.className);
    } else {
      var themeSelected = themes.find(function (_ref2) {
        var id = _ref2.id;
        return id === theme;
      });
      return themeSelected ? "theme-base theme-".concat(themeSelected.base, " ").concat(themeSelected.className) : 'theme-base';
    }
  };

  var createThemeFromConfig = function createThemeFromConfig(themeConfig) {
    var fromConfigToTheme = function fromConfigToTheme(config) {
      return {
        name: config.name.vi,
        base: config.base,
        id: config.id
      };
    };

    return themeConfig.varConfigs.reduce(function (themes, config) {
      var newThemes = isSingleTheme(config) ? [fromConfigToTheme(config)] : config.info.map(fromConfigToTheme);
      return [].concat(_toConsumableArray(themes), _toConsumableArray(newThemes.map(function (theme) {
        return _objectSpread2(_objectSpread2({}, theme), {}, {
          className: config.id
        });
      })));
    }, []);
  };

  return /*#__PURE__*/jsxRuntime.jsx(ThemeContext.Provider, {
    value: {
      theme: isTheme,
      setTheme: handleThemeChange
    },
    children: children
  });
};

var FullScreenContext = /*#__PURE__*/React.createContext({
  toggleFullScreen: function toggleFullScreen() {
    return undefined;
  },
  isFullScreen: false
});
var FullScreenOverlayContext = /*#__PURE__*/React.createContext({
  toggleFullScreen: function toggleFullScreen() {
    return undefined;
  },
  isFullScreen: false
});

var FullScreenButton = function FullScreenButton(props) {
  var _useContext = React.useContext(FullScreenOverlayContext),
      isFullScreen = _useContext.isFullScreen,
      toggleFullScreen = _useContext.toggleFullScreen;

  return /*#__PURE__*/jsxRuntime.jsx(IconButton, _objectSpread2(_objectSpread2({}, props), {}, {
    variant: "fill",
    icon: isFullScreen ? 'compress' : 'expand',
    onClick: toggleFullScreen
  }));
};

var FullScreenProvider = function FullScreenProvider(_ref) {
  var children = _ref.children;
  var fullScreenRef = React.useRef(null);
  var handleFullScreen = reactFullScreen.useFullScreenHandle();
  var isFullScreen = handleFullScreen === null || handleFullScreen === void 0 ? void 0 : handleFullScreen.active;

  var toggleFullScreen = function toggleFullScreen() {
    return isFullScreen ? handleFullScreen.exit() : handleFullScreen.enter();
  };

  var handleChange = function handleChange(state, handle) {
    if (!state && fullScreenRef.current) {
      fullScreenRef.current.className = fullScreenRef.current.className.replace(' fullscreen-apply', '');
    }
  };

  return /*#__PURE__*/jsxRuntime.jsx(FullScreenContext.Provider, {
    value: {
      toggleFullScreen: toggleFullScreen,
      isFullScreen: isFullScreen
    },
    children: /*#__PURE__*/jsxRuntime.jsx(reactFullScreen.FullScreen, {
      handle: handleFullScreen,
      onChange: handleChange,
      children: children
    })
  });
};

var FullScreenOverlay = function FullScreenOverlay(_ref) {
  var children = _ref.children;

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isFullScreen = _useState2[0],
      setIsFullScreen = _useState2[1];

  var _useContext = React.useContext(FullScreenContext),
      isAppFullScreen = _useContext.isFullScreen,
      appToggleFullScreen = _useContext.toggleFullScreen;

  React.useEffect(function () {
    !isAppFullScreen && isFullScreen && setIsFullScreen(isAppFullScreen);

    if (!isAppFullScreen && isFullScreen) {
      setIsFullScreen(isAppFullScreen);
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [isAppFullScreen]);

  var toggleFullScreen = function toggleFullScreen() {
    appToggleFullScreen();
    setIsFullScreen(!isFullScreen);
  };

  return /*#__PURE__*/jsxRuntime.jsx(FullScreenOverlayContext.Provider, {
    value: {
      isFullScreen: isFullScreen,
      toggleFullScreen: toggleFullScreen
    },
    children: isFullScreen ? /*#__PURE__*/jsxRuntime.jsx(Overlay, {
      fullscreen: true,
      children: children
    }, 'Overlay') : children
  });
};

var MapContext = /*#__PURE__*/React.createContext({});
var MapProvider = function MapProvider(props) {
  var children = props.children;

  var _useState = React.useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      styles = _useState2[0],
      setStyles = _useState2[1];

  return /*#__PURE__*/jsxRuntime.jsx(MapContext.Provider, {
    value: {
      styles: styles,
      setStyles: setStyles
    },
    children: children
  });
};

var B3DMData = [{
  name: '/api/model3d/b3dm/quan_1-ab_tower/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-bcm_building/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-bitexco/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-bo_cong_thuong/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-citilight_tower/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-exchange_tower/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-hanwa_life/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-hmc_tower/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-indochina_park_tower/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-intercontinential_hotel_mplaza/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-petrosetco/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-prudential_building/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-russian_tower/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-saigon_sky_garden_the_landcaster_building/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-sheraton_hotel/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-somerset_hotel/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-takashimaya/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-techcombank_tower/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-the_golden_tower/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-times_square/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-vietcombank_tower/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-vincom_center/root.json'
}, {
  name: '/api/model3d/b3dm/quan_1-vpbank_tower/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-binh_khanh_apartment/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-can_ho_hoang_anh_gia_lai/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-cao_oc_an_phu/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-centana_thu_thiem/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-chung_cu_an_cu_chung_cu_an_thinh/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-chung_cu_an_hoa/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-chung_cu_bo_cong_an/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-cuc_thue_tp_hcm/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-dao_kim_cuong/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-estella/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-gateway_thao_dien/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-homyland_riverside/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-imperia_an_phu/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-intresco_an_khang/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-masteri_thao_dien/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-new_city_thu_thiem/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-palm_city/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-petroland/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-river_garden/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-sadora/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-thao_dien_pearl/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-the_ascent/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-the_krista/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-the_nassim/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-the_sun_avenue/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-the_vista/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-the_vista_verde_benh_vien_da_khoa_quoc_te/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-thuan_viet_apartment/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-tropic_garden/root.json'
}, {
  name: '/api/model3d/b3dm/quan_2-xi_riverview_palace/root.json'
}, {
  name: '/api/model3d/b3dm/quan_3-ccb/root.json'
}, {
  name: '/api/model3d/b3dm/quan_3-chung_cu_nguyen_phuc_nguyen/root.json'
}, {
  name: '/api/model3d/b3dm/quan_3-sacombank_building/root.json'
}, {
  name: '/api/model3d/b3dm/quan_3-sherwood_residence/root.json'
}, {
  name: '/api/model3d/b3dm/quan_3-shinhan_bank_building/root.json'
}, {
  name: '/api/model3d/b3dm/quan_3-t78_hotel/root.json'
}, {
  name: '/api/model3d/b3dm/quan_3-the_vista_an_phu/root.json'
}, {
  name: '/api/model3d/b3dm/quan_3-toa_nha_mb_bank/root.json'
}, {
  name: '/api/model3d/b3dm/quan_3-van_phong_quan_uy_quan_3/root.json'
}, {
  name: '/api/model3d/b3dm/quan_3-vietbank_building/root.json'
}, {
  name: '/api/model3d/b3dm/quan_4-chung_cu_h3/root.json'
}, {
  name: '/api/model3d/b3dm/quan_4-copac_square/root.json'
}, {
  name: '/api/model3d/b3dm/quan_4-gold_view/root.json'
}, {
  name: '/api/model3d/b3dm/quan_4-rivergate_residence_milenium_masteri/root.json'
}, {
  name: '/api/model3d/b3dm/quan_4-the_tresor_ree_tower/root.json'
}, {
  name: '/api/model3d/b3dm/quan_5-chung_cu_phuc_thinh/root.json'
}, {
  name: '/api/model3d/b3dm/quan_5-hung_vuong_plaza/root.json'
}, {
  name: '/api/model3d/b3dm/quan_5-ngan_hang_tmcp_sai_gon_quan_5/root.json'
}, {
  name: '/api/model3d/b3dm/quan_5-the_garden_mall/root.json'
}, {
  name: '/api/model3d/b3dm/quan_6-lucky_palace/root.json'
}, {
  name: '/api/model3d/b3dm/quan_6-remax_plaza/root.json'
}, {
  name: '/api/model3d/b3dm/quan_6-viva_riverside/root.json'
}, {
  name: '/api/model3d/b3dm/quan_7-chung_cu_luxgarden/root.json'
}, {
  name: '/api/model3d/b3dm/quan_7-chung_cu_my_phu/root.json'
}, {
  name: '/api/model3d/b3dm/quan_7-chung_cu_quoc_cuong_gia_lai/root.json'
}, {
  name: '/api/model3d/b3dm/quan_7-dockland_saigon_cosmo_city_the_golden_star/root.json'
}, {
  name: '/api/model3d/b3dm/quan_7-golden_king/root.json'
}, {
  name: '/api/model3d/b3dm/quan_7-grandview_the_panorama/root.json'
}, {
  name: '/api/model3d/b3dm/quan_7-him_lam_riverside/root.json'
}, {
  name: '/api/model3d/b3dm/quan_7-ipc/root.json'
}, {
  name: '/api/model3d/b3dm/quan_7-jamona_city/root.json'
}, {
  name: '/api/model3d/b3dm/quan_7-maple_tree/root.json'
}, {
  name: '/api/model3d/b3dm/quan_7-m_one_nam_sai_gon/root.json'
}, {
  name: '/api/model3d/b3dm/quan_7-petroland_tower/root.json'
}, {
  name: '/api/model3d/b3dm/quan_7-phu_my_hung_tower_crescent_mall/root.json'
}, {
  name: '/api/model3d/b3dm/quan_7-riviera_point/root.json'
}, {
  name: '/api/model3d/b3dm/quan_7-sunrise_city_sunrise_city_view_hoang_anh_thanh_binh_apartment/root.json'
}, {
  name: '/api/model3d/b3dm/quan_8-chung_cu_resco_481/root.json'
}, {
  name: '/api/model3d/b3dm/quan_8-diamond_lotus_riverside/root.json'
}, {
  name: '/api/model3d/b3dm/quan_10-ha_do_centrosa/root.json'
}, {
  name: '/api/model3d/b3dm/quan_10-viettel_tower/root.json'
}, {
  name: '/api/model3d/b3dm/quan_binh_thanh-can_ho_soho_premier_binh_thanh/root.json'
}, {
  name: '/api/model3d/b3dm/quan_binh_thanh-chung_cu_d5/root.json'
}, {
  name: '/api/model3d/b3dm/quan_binh_thanh-chung_cu_phu_dat/root.json'
}, {
  name: '/api/model3d/b3dm/quan_binh_thanh-chung_cu_sgc_nguyen_cuu_van/root.json'
}, {
  name: '/api/model3d/b3dm/quan_binh_thanh-city_garden/root.json'
}, {
  name: '/api/model3d/b3dm/quan_binh_thanh-coteccons_office_tower/root.json'
}, {
  name: '/api/model3d/b3dm/quan_binh_thanh-dai_hoc_hong_bang/root.json'
}, {
  name: '/api/model3d/b3dm/quan_binh_thanh-pearl_plaza/root.json'
}, {
  name: '/api/model3d/b3dm/quan_binh_thanh-saigonres_plaza/root.json'
}, {
  name: '/api/model3d/b3dm/quan_binh_thanh-the_manor/root.json'
}, {
  name: '/api/model3d/b3dm/quan_binh_thanh-the_morning_star_building/root.json'
}, {
  name: '/api/model3d/b3dm/quan_nha_be-can_ho_silver_star/root.json'
}, {
  name: '/api/model3d/b3dm/quan_nha_be-cao_oc_hung_phat/root.json'
}, {
  name: '/api/model3d/b3dm/quan_nha_be-dragon_hill_the_park_residence/root.json'
}, {
  name: '/api/model3d/b3dm/quan_nha_be-hoang_anh_gold_house/root.json'
}, {
  name: '/api/model3d/b3dm/quan_nha_be-kenton_node/root.json'
}, {
  name: '/api/model3d/b3dm/quan_nha_be-new_saigon/root.json'
}, {
  name: '/api/model3d/b3dm/quan_nha_be-saigon_south_residence/root.json'
}, {
  name: '/api/model3d/b3dm/quan_nha_be-sunrise_riverside_1/root.json'
}, {
  name: '/api/model3d/b3dm/quan_nha_be-sunrise_riverside_2/root.json'
}, // update 2021-01-08
{
  label: 'Quận 10 - Chung cư Nguyễn Kim',
  name: '/api/model3d/3dbuidings_08012021/quan-10-chung_cu_nguyen_kim-1/root.json'
}, {
  label: 'Quận 10 - Chung cư Xi Grand Court',
  name: '/api/model3d/3dbuidings_08012021/quan-10-chung_cu_xi_grand_court/root.json'
}, {
  label: 'Quận 11 - Chung cư Tân Phước 1',
  name: '/api/model3d/3dbuidings_08012021/quan-11-chung_cu_tan_phuoc-1/root.json'
}, {
  label: 'Quận 11 - Chung cư Tân Phước 2',
  name: '/api/model3d/3dbuidings_08012021/quan-11-chung_cu_tan_phuoc-2/root.json'
}, {
  label: 'Quận 11 - Flemmington Tower 1',
  name: '/api/model3d/3dbuidings_08012021/quan-11-flemmington_tower-1/root.json'
}, {
  label: 'Quận 11 - Flemming Tower 2',
  name: '/api/model3d/3dbuidings_08012021/quan-11-flemmington_tower-2/root.json'
}, {
  label: 'Quận 12 - Chung cư The Parkland',
  name: '/api/model3d/3dbuidings_08012021/quan-12-chung_cu_the_parkland/root.json'
}, {
  label: 'Quận 12 - Hiệp Thành Building 1',
  name: '/api/model3d/3dbuidings_08012021/quan-12-hiep_thanh_building-1/root.json'
}, {
  label: 'Quận 12 - Hiệp Thành Building 2',
  name: '/api/model3d/3dbuidings_08012021/quan-12-hiep_thanh_building-2/root.json'
}, {
  label: 'Quận 2 - Căn hộ Bella vida',
  name: '/api/model3d/3dbuidings_08012021/quan-2-can_ho_bella_vida/root.json'
}, {
  label: 'Quận 2 - Cao ốc Thịnh Vượng',
  name: '/api/model3d/3dbuidings_08012021/quan-2-cao_oc_thinh_vuong/root.json'
}, {
  label: 'Quận 2 - Chung cư Thủ Thiêm Xanh',
  name: '/api/model3d/3dbuidings_08012021/quan-2-chung_cu_thu_thiem_xanh/root.json'
}, {
  label: 'Quận 2 - Citihome 1',
  name: '/api/model3d/3dbuidings_08012021/quan-2-citihome-1/root.json'
}, {
  label: 'Quận 2 - Citihome 2',
  name: '/api/model3d/3dbuidings_08012021/quan-2-citihome-2/root.json'
}, {
  label: 'Quận 2 - Citihoso',
  name: '/api/model3d/3dbuidings_08012021/quan-2-citihoso/root.json'
}, {
  label: 'Quận 2 - Homyland 2',
  name: '/api/model3d/3dbuidings_08012021/quan-2-homyland_2/root.json'
}, {
  label: 'Quận 2 - La Astoria',
  name: '/api/model3d/3dbuidings_08012021/quan-2-la_astoria/root.json'
}, {
  label: 'Quận 6 - Chung cư Him Lam Chợ Lớn 1',
  name: '/api/model3d/3dbuidings_08012021/quan-6-chung_cu_him_lam_cho_lon-1/root.json'
}, {
  label: 'Quận 6 - Chung cư Him Lam Chợ Lớn 2',
  name: '/api/model3d/3dbuidings_08012021/quan-6-chung_cu_him_lam_cho_lon-2/root.json'
}, {
  label: 'Quận 6 - Chung cư Him Lam Chợ Lớn 3',
  name: '/api/model3d/3dbuidings_08012021/quan-6-chung_cu_him_lam_cho_lon-3/root.json'
}, {
  label: 'Quận 6 - Chung cư Him Lam Chợ Lớn 4',
  name: '/api/model3d/3dbuidings_08012021/quan-6-chung_cu_him_lam_cho_lon-4/root.json'
}, {
  label: 'Quận 6 - Chung cư Him Lam Chợ Lớn 5',
  name: '/api/model3d/3dbuidings_08012021/quan-6-chung_cu_him_lam_cho_lon-5/root.json'
}, {
  label: 'Quận 6 - Chung cư Him Lam Chợ Lớn 6',
  name: '/api/model3d/3dbuidings_08012021/quan-6-chung_cu_him_lam_cho_lon-6/root.json'
}, {
  label: 'Quận 6 - Chung cư Him Lam Chợ Lớn 7',
  name: '/api/model3d/3dbuidings_08012021/quan-6-chung_cu_him_lam_cho_lon-7/root.json'
}, {
  label: 'Quận 6 - Khu Căn hộ An Phú',
  name: '/api/model3d/3dbuidings_08012021/quan-6-khu_can_ho_an_phu/root.json'
}, {
  label: 'Quận 8 - Căn hộ Tara Residences 1',
  name: '/api/model3d/3dbuidings_08012021/quan-8-can_ho_tara_residences-1/root.json'
}, {
  label: 'Quận 8 - Căn hộ Tara Residences 2',
  name: '/api/model3d/3dbuidings_08012021/quan-8-can_ho_tara_residences-2/root.json'
}, {
  label: 'Quận 8 - Căn hộ The Pegasuite One',
  name: '/api/model3d/3dbuidings_08012021/quan-8-can_ho_the_pegasuite_one/root.json'
}, {
  label: 'Quận 8 - Chung cư Carina Plaza',
  name: '/api/model3d/3dbuidings_08012021/quan-8-chung_cu_carina_plaza/root.json'
}, {
  label: 'Quận 8 - Chung cư City Gate Towers',
  name: '/api/model3d/3dbuidings_08012021/quan-8-chung_cu_city_gate_towers/root.json'
}, {
  label: 'Quận 8 - Chung cư Diamond Riverside',
  name: '/api/model3d/3dbuidings_08012021/quan-8-chung_cu_diamond_riverside/root.json'
}, {
  label: 'Quận 8 - Chung cư Ngọc Phương Nam',
  name: '/api/model3d/3dbuidings_08012021/quan-8-chung_cu_ngoc_phuong_nam/root.json'
}, {
  label: 'Quận 8 - Chung cư The Avila',
  name: '/api/model3d/3dbuidings_08012021/quan-8-chung_cu_the_avila/root.json'
}, {
  label: 'Quận 8 - Chung cư Topaz City 1',
  name: '/api/model3d/3dbuidings_08012021/quan-8-chung_cu_topaz_city-1/root.json'
}, {
  label: 'Quận 8 - Chung cư Topaz City 2',
  name: '/api/model3d/3dbuidings_08012021/quan-8-chung_cu_topaz_city-2/root.json'
}, {
  label: 'Quận 8 - Chung cư Topaz City 3',
  name: '/api/model3d/3dbuidings_08012021/quan-8-chung_cu_topaz_city-3/root.json'
}, {
  label: 'Quận 9 - Căn hộ Jamila Khang Điền',
  name: '/api/model3d/3dbuidings_08012021/quan-9-can_ho_jamila_khang_dien/root.json'
}, {
  label: 'Quận 9 - Chung cư 9 View',
  name: '/api/model3d/3dbuidings_08012021/quan-9-chung_cu_9_view/root.json'
}, {
  label: 'Quận 9 - Chung cư Him Lam Phú An',
  name: '/api/model3d/3dbuidings_08012021/quan-9-chung_cu_him_lam_phu_an-1/root.json'
}, {
  label: 'Quận 9 - Chung cư Him Lam Phú An',
  name: '/api/model3d/3dbuidings_08012021/quan-9-chung_cu_him_lam_phu_an-2/root.json'
}, {
  label: 'Quận 9 - Chung cư Sky 9 - 1',
  name: '/api/model3d/3dbuidings_08012021/quan-9-chung_cu_sky_9-1/root.json'
}, {
  label: 'Quận 9 - Chung cư Sky 9 - 2',
  name: '/api/model3d/3dbuidings_08012021/quan-9-chung_cu_sky_9-2/root.json'
}, {
  label: 'Quận 9 - Chung cư The Eastern',
  name: '/api/model3d/3dbuidings_08012021/quan-9-chung_cu_the_eastern/root.json'
}, {
  label: 'Quận 9 - Chung cư Thủ Thiêm Garden',
  name: '/api/model3d/3dbuidings_08012021/quan-9-chung_cu_thu_thiem_garden/root.json'
}, {
  label: 'Quận 9 - Citrine Apartment',
  name: '/api/model3d/3dbuidings_08012021/quan-9-citrine_apartment/root.json'
}, {
  label: 'Quận 9 - Flora Anh Đào Apartment',
  name: '/api/model3d/3dbuidings_08012021/quan-9-flora_anh_dao_apartment/root.json'
}, {
  label: 'Quận 9 - Flora Fuji Residence',
  name: '/api/model3d/3dbuidings_08012021/quan-9-flora_fuji_residence/root.json'
}, {
  label: 'Quận 9 - Flora Kikyo Apartment',
  name: '/api/model3d/3dbuidings_08012021/quan-9-flora_kikyo_apartment/root.json'
}, {
  label: 'Quận 9 - Khu Dân Cư eHome S 1',
  name: '/api/model3d/3dbuidings_08012021/quan-9-khu_dan_cu_ehome_s-1/root.json'
}, {
  label: 'Quận 9 - Khu Dân Cư eHome S 2',
  name: '/api/model3d/3dbuidings_08012021/quan-9-khu_dan_cu_ehome_s-2/root.json'
}, {
  label: 'Quận 9 - Khu Dân Cư eHome S 3',
  name: '/api/model3d/3dbuidings_08012021/quan-9-khu_dan_cu_ehome_s-3/root.json'
}, {
  label: 'Quận 9 - Mega Sapphire Khang Điền 1',
  name: '/api/model3d/3dbuidings_08012021/quan-9-mega_sapphire_khang_dien-1/root.json'
}, {
  label: 'Quận 9 - Mega Sapphire Khang Điền 2',
  name: '/api/model3d/3dbuidings_08012021/quan-9-mega_sapphire_khang_dien-2/root.json'
}, {
  label: 'Quận 9 - The Art Apartment 1',
  name: '/api/model3d/3dbuidings_08012021/quan-9-the_art_apartment-1/root.json'
}, {
  label: 'Quận 9 - The Art Apartment 2',
  name: '/api/model3d/3dbuidings_08012021/quan-9-the_art_apartment-2/root.json'
}, {
  label: 'Quận 9 - The Art Apartment 3',
  name: '/api/model3d/3dbuidings_08012021/quan-9-the_art_apartment-3/root.json'
}, {
  label: 'Quận 9 - The Art Apartment 4',
  name: '/api/model3d/3dbuidings_08012021/quan-9-the_art_apartment-4/root.json'
}, {
  label: 'Quận Bình Chánh - Chung cư Conic Đông Nam Á 1',
  name: '/api/model3d/3dbuidings_08012021/quan-binh_chanh-chung_cu_conic_dong_nam_a-1/root.json'
}, {
  label: 'Quận Bình Chánh - Chung cư Conic Đông Nam Á 2',
  name: '/api/model3d/3dbuidings_08012021/quan-binh_chanh-chung_cu_conic_dong_nam_a-2/root.json'
}, {
  label: 'Quận Bình Chánh - Chung cư Happy City',
  name: '/api/model3d/3dbuidings_08012021/quan-binh_chanh-chung_cu_happy_city/root.json'
}, {
  label: 'Quận Bình Chánh - Chung cư The Mansion',
  name: '/api/model3d/3dbuidings_08012021/quan-binh_chanh-chung_cu_the_mansion/root.json'
}, {
  label: 'Quận Bình Chánh - Khu Dân cư Greenlife 13c',
  name: '/api/model3d/3dbuidings_08012021/quan-binh_chanh-khu_dan_cu_greenlife_13c/root.json'
}, {
  label: 'Quận Bình Chánh - Khu Dân cư Terra Rosa',
  name: '/api/model3d/3dbuidings_08012021/quan-binh_chanh-khu_dan_cu_terra_rosa/root.json'
}, {
  label: 'Quận Bình Tân - Căn hộ Monnlight Boulevard',
  name: '/api/model3d/3dbuidings_08012021/quan-binh_tan-can_ho_moonlight_boulevard/root.json'
}, {
  label: 'Quận Bình Tân - Chung cư An Lạc',
  name: '/api/model3d/3dbuidings_08012021/quan-binh_tan-chung_cu_an_lac/root.json'
}, {
  label: 'Quận Bình Tân - Chung cư Imperial Place 1',
  name: '/api/model3d/3dbuidings_08012021/quan-binh_tan-chung_cu_imperial_place-1/root.json'
}, {
  label: 'Quận Bình Tân - Chung cư Imperial Place 2',
  name: '/api/model3d/3dbuidings_08012021/quan-binh_tan-chung_cu_imperial_place-2/root.json'
}, {
  label: 'Quận Bình Tân - Chung cxư Lê Thành Block A',
  name: '/api/model3d/3dbuidings_08012021/quan-binh_tan-chung_cu_le_thanh_block_a/root.json'
}, {
  label: 'Quận Bình Tân - Chung cxư Lê Thành Block B',
  name: '/api/model3d/3dbuidings_08012021/quan-binh_tan-chung_cu_le_thanh_block_b/root.json'
}, {
  label: 'Quận Bình Tân - Chung cư Long Phụng',
  name: '/api/model3d/3dbuidings_08012021/quan-binh_tan-chung_cu_long_phung/root.json'
}, {
  label: 'Quận Bình Tân - Monnlight parkview Apartment 1',
  name: '/api/model3d/3dbuidings_08012021/quan-binh_tan-moonlight_parkview_apartment-1/root.json'
}, {
  label: 'Quận Bình Tân - Monnlight parkview Apartment 2',
  name: '/api/model3d/3dbuidings_08012021/quan-binh_tan-moonlight_parkview_apartment-2/root.json'
}];

var mapStyleList = [{
  id: 'light',
  label: 'Màu Sáng'
}, {
  id: 'dark',
  label: 'Màu Tối'
}, {
  id: 'default',
  label: 'Tiêu chuẩn'
}, {
  id: 'satellite',
  label: 'Vệ Tinh'
}, {
  id: 'terrain',
  label: 'Địa hình'
}, {
  id: 'boundary',
  label: 'Ranh giới'
}];
var Map$2 = /*#__PURE__*/React__default['default'].memo(function (props) {
  var _props$width = props.width,
      width = _props$width === void 0 ? '100%' : _props$width,
      _props$height = props.height,
      height = _props$height === void 0 ? '100%' : _props$height,
      center = props.center,
      zoomLevel = props.zoomLevel,
      _props$preserveDrawin = props.preserveDrawingBuffer,
      preserveDrawingBuffer = _props$preserveDrawin === void 0 ? false : _props$preserveDrawin,
      onViewportChange = props.onViewportChange,
      onStyleLoad = props.onStyleLoad,
      onRender = props.onRender,
      onZoomEnd = props.onZoomEnd,
      onMoveEnd = props.onMoveEnd,
      onContextMenu = props.onContextMenu,
      onMove = props.onMove,
      onClick = props.onClick,
      _props$saveViewport = props.saveViewport,
      saveViewport = _props$saveViewport === void 0 ? false : _props$saveViewport,
      droneURL = props.droneURL,
      fontURL = props.fontURL,
      _props$showOverlays = props.showOverlays,
      showOverlays = _props$showOverlays === void 0 ? true : _props$showOverlays,
      _props$scrollZoom = props.scrollZoom,
      scrollZoom = _props$scrollZoom === void 0 ? true : _props$scrollZoom,
      boxZoom = props.boxZoom,
      dragRotate = props.dragRotate,
      dragPan = props.dragPan,
      interactive = props.interactive,
      showLocateControl = props.showLocateControl,
      mapImageURL = props.mapImageURL,
      _props$isNotControl = props.isNotControl,
      isNotControl = _props$isNotControl === void 0 ? false : _props$isNotControl,
      isNotScaleControl = props.isNotScaleControl,
      map = props.map,
      children = props.children;
  var context = React.useContext(ThemeContext);
  var mapRef = React.useRef();
  var mapStyles = [];
  var mapStyle = '';
  var mapDefaultStyle = {};
  var mapCenter = center;
  var mapZoomLevel = zoomLevel;
  var themeBase = '';
  var pressTimeout = undefined;
  var rotating = false;
  var showLocate = false;
  var mapOverlays = [{
    id: '3d-building',
    label: 'Tòa nhà 3D',
    image: map3dBuildingImage
  }, {
    id: 'box-building',
    label: 'Tòa vuông',
    image: mapBoxBuildingImage
  }];
  var defaultOverlays = [mapOverlays[1]];

  var _useContext = React.useContext(MapContext),
      styles = _useContext.styles;

  mapStyles = styles !== null && styles !== void 0 && styles.length ? styles : (props.mapStyles || mapStyleList).map(function (style) {
    switch (style.id) {
      case 'light':
        style['style'] = lightStyle;
        style['image'] = mapLightImage;
        break;

      case 'dark':
        style['style'] = darkStyle;
        style['image'] = mapDarkImage;
        break;

      case 'default':
        style['style'] = defaultStyle;
        style['image'] = mapDefaultImage;
        break;

      case 'satellite':
        style['style'] = satelliteStyle;
        style['image'] = mapSatelliteImage;
        break;

      case 'terrain':
        style['style'] = terrainStyle;
        style['image'] = mapTerrainImage;
        break;

      case 'boundary':
        style['style'] = boundaryStyle;
        style['image'] = mapBoundaryImage;
        break;
    }

    return style;
  });
  React.useEffect(function () {
    // global override
    overrideStyle(lightStyle, globalOverride);
    overrideStyle(darkStyle, globalOverride);
    overrideStyle(satelliteStyle, globalOverride);
    overrideStyle(defaultStyle, globalOverride);
    overrideStyle(terrainStyle, globalOverride);
    overrideStyle(boundaryStyle, globalOverride); // local override

    overrideStyle(lightStyle, override$4);
    overrideStyle(darkStyle, darkStyleOverride);
    overrideStyle(defaultStyle, override$3);
    overrideStyle(satelliteStyle, override$2);
    overrideStyle(terrainStyle, override$1);
    overrideStyle(boundaryStyle, override); // component override

    overrideStyle(lightStyle, props.lightStyleOverride);
    overrideStyle(darkStyle, props.darkStyleOverride);
    overrideStyle(defaultStyle, props.defaultStyleOverride);
    overrideStyle(satelliteStyle, props.satelliteStyleOverride);
    overrideStyle(terrainStyle, props.terrainStyleOverride);
    overrideStyle(boundaryStyle, props.boundaryStyleOverride);

    if (mapImageURL) {
      var _context$theme;

      var changeSource = function changeSource(style) {
        for (var _i = 0, _Object$keys = Object.keys(style.sources); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];

          if (style.sources[key].url) {
            style.sources[key].url = style.sources[key].url.replace('https://images.vietbando.com', mapImageURL);
          } // $RELATIVE_URL


          if (Array.isArray(style.sources[key].tiles) && style.sources[key].tiles.length) {
            style.sources[key].tiles[0] = style.sources[key].tiles[0].replace('$RELATIVE_URL', window.location.origin);
          }
        }

        style.sprite = style.sprite.replace('https://images.vietbando.com', mapImageURL);
        style.glyphs = style.glyphs.replace('https://images.vietbando.com', mapImageURL);
      };

      changeSource(lightStyle);
      changeSource(darkStyle);
      changeSource(defaultStyle);
      changeSource(satelliteStyle);
      changeSource(terrainStyle);
      changeSource(boundaryStyle);
      themeBase = context === null || context === void 0 ? void 0 : (_context$theme = context.theme) === null || _context$theme === void 0 ? void 0 : _context$theme.base;
    }

    if (droneURL !== null && droneURL !== undefined) {
      // proxy drone orthomosaic tile
      satelliteStyle.sources.area.tiles[0] = "".concat(props.droneURL);
    }

    if (fontURL !== null && fontURL !== undefined) {
      lightStyle.glyphs = darkStyle.glyphs = defaultStyle.glyphs = satelliteStyle.glyphs = terrainStyle.glyphs = boundaryStyle.glyphs = "".concat(props.fontURL, "/fonts/{fontstack}/{range}.pbf");
    }
  }, []);
  React.useEffect(function () {
    var style = mapStyles.find(function (ms) {
      return ms.id === context.theme.base;
    });

    if (style) {
      handleChangeMapStyle(style);
    }
  }, [context.theme.base]);

  var overrideStyle = function overrideStyle(origin, override) {
    if (!override) {
      return;
    }

    if (override.sources && Object.keys(override.sources).length) {
      for (var key in override.sources) {
        var source = override.sources[key];
        var originSource = origin.sources[key];

        if (originSource) {
          origin.sources[key] = JSON.parse(JSON.stringify(source));
        } else {
          origin.sources.push(JSON.parse(JSON.stringify(source)));
        }
      }
    }

    if (override.layers && Object.keys(override.layers).length) {
      var _iterator = _createForOfIteratorHelper(override.layers),
          _step;

      try {
        var _loop = function _loop() {
          var layer = _step.value;

          if (layer.add) {
            var originLayer = origin.layers.find(function (l) {
              return l.id === layer.id;
            });
            var afterLayerIndex = origin.layers.findIndex(function (l) {
              return l.id === layer.after;
            });

            if (!originLayer && afterLayerIndex >= 0) {
              origin.layers.splice(afterLayerIndex, 0, JSON.parse(JSON.stringify(layer)));
            }
          } else {
            var _originLayer = origin.layers.find(function (l) {
              return l.id === layer.id;
            });

            if (_originLayer) {
              overrideObject(_originLayer, layer);
            }
          }
        };

        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  };

  var overrideObject = function overrideObject(origin, override) {
    for (var _i2 = 0, _Object$keys2 = Object.keys(override); _i2 < _Object$keys2.length; _i2++) {
      var key = _Object$keys2[_i2];
      var prop = override[key];

      if (Array.isArray(prop)) {
        origin[key] = Object.assign([], prop);
      } else if (_typeof(prop) !== 'object') {
        origin[key] = prop;
      } else {
        if (_typeof(origin[key]) === 'object') {
          overrideObject(origin[key], prop);
        } else {
          origin[key] = prop;
        }
      }
    }
  };

  var getViewport = function getViewport() {
    var _mapRef$current, _mapRef$current2;

    var bounds = ((_mapRef$current = mapRef.current) === null || _mapRef$current === void 0 ? void 0 : _mapRef$current.getBounds) && mapRef.current.getBounds();
    var level = ((_mapRef$current2 = mapRef.current) === null || _mapRef$current2 === void 0 ? void 0 : _mapRef$current2.getZoom) && mapRef.current.getZoom();

    if (!bounds || !level) {
      return;
    }

    return {
      left: bounds.getWest(),
      top: bounds.getNorth(),
      right: bounds.getEast(),
      bottom: bounds.getSouth(),
      level: Math.round(level)
    };
  };

  var handleRender = function handleRender(map) {
    var _context$theme2;

    mapRef.current = map;

    if (onViewportChange) {
      onViewportChange(getViewport());
    }

    if (onRender) {
      onRender(map);
    }

    if (showLocateControl && (!showLocate || themeBase !== (context === null || context === void 0 ? void 0 : (_context$theme2 = context.theme) === null || _context$theme2 === void 0 ? void 0 : _context$theme2.base))) {
      var _context$theme3, _mapRef$current3;

      showLocate = true;
      themeBase = context === null || context === void 0 ? void 0 : (_context$theme3 = context.theme) === null || _context$theme3 === void 0 ? void 0 : _context$theme3.base;
      var geolocate = new mapboxgl__default['default'].GeolocateControl({
        positionOptions: {
          enableHighAccuracy: true
        },
        trackUserLocation: true
      });
      (_mapRef$current3 = mapRef.current) === null || _mapRef$current3 === void 0 ? void 0 : _mapRef$current3.addControl(geolocate);

      if (showLocateControl.autoLocate) {
        var _mapRef$current4;

        (_mapRef$current4 = mapRef.current) === null || _mapRef$current4 === void 0 ? void 0 : _mapRef$current4.on('load', function () {
          geolocate.trigger();
        });
      }
    }
  };

  var findFirstLayerType = function findFirstLayerType(type) {
    var _mapRef$current5;

    var layers = (_mapRef$current5 = mapRef.current) === null || _mapRef$current5 === void 0 ? void 0 : _mapRef$current5.getStyle().layers; // Find the index of the first symbol layer in the map style

    var layer = layers === null || layers === void 0 ? void 0 : layers.find(function (layer) {
      return layer.type === type;
    });
    return layer ? layer.id : undefined;
  };

  var handleStyleLoad = function handleStyleLoad(map) {
    var _mapRef$current6;

    if (onStyleLoad) {
      onStyleLoad(map);
    } // temporary leave it here until find another good place


    var element = (_mapRef$current6 = mapRef.current) === null || _mapRef$current6 === void 0 ? void 0 : _mapRef$current6.getContainer().querySelector('.map-rotation-control > button > span');

    if (element) {
      element.innerHTML = "<img src='".concat(compassImage, "' alt={'compass'}>");
    }
  };

  var handleChangeMapStyle = function handleChangeMapStyle(mapStyle) {
    var _mapRef$current7;

    (_mapRef$current7 = mapRef.current) === null || _mapRef$current7 === void 0 ? void 0 : _mapRef$current7.setStyle(mapStyle.styleUrl || mapStyle.style);
  };

  var handleToggleMapOverlay = function handleToggleMapOverlay(overlay, checked) {
    if (overlay.id === '3d-building') {
      if (checked) {
        var _mapRef$current8;

        // turn it on
        var firstSymbolId = findFirstLayerType('symbol');
        (_mapRef$current8 = mapRef.current) === null || _mapRef$current8 === void 0 ? void 0 : _mapRef$current8.addLayer(new BuildingLayer('b3dm', B3DMData), firstSymbolId); // mapRef.current?.addLayer(new BuildingLayer('gltf', GLTFData) as mapboxgl.CustomLayerInterface);
      } else {
        var _mapRef$current9, _mapRef$current10;

        // turn it off
        if ((_mapRef$current9 = mapRef.current) !== null && _mapRef$current9 !== void 0 && _mapRef$current9.getLayer('b3dm')) {
          mapRef.current.removeLayer('b3dm');
        }

        if ((_mapRef$current10 = mapRef.current) !== null && _mapRef$current10 !== void 0 && _mapRef$current10.getLayer('gltf')) {
          mapRef.current.removeLayer('gltf');
        }
      }
    } else if (overlay.id === 'box-building') {
      var _mapRef$current11;

      if ((_mapRef$current11 = mapRef.current) !== null && _mapRef$current11 !== void 0 && _mapRef$current11.getLayer('region_building3d_index')) {
        if (checked) {
          // turn it on
          mapRef.current.setLayoutProperty('region_building3d_index', 'visibility', 'visible');
        } else {
          // turn it off
          mapRef.current.setLayoutProperty('region_building3d_index', 'visibility', 'none');
        }
      }
    }
  };

  var handleMove = function handleMove(map, event) {
    if (onMove) {
      onMove(map, event);
    }
  };

  var saveMapState = function saveMapState() {
    if (saveViewport && mapRef.current) {
      var _mapRef$current12, _mapRef$current13;

      ((_mapRef$current12 = mapRef.current) === null || _mapRef$current12 === void 0 ? void 0 : _mapRef$current12.getCenter) && localStorage.setItem('center', JSON.stringify(mapRef.current.getCenter()));
      ((_mapRef$current13 = mapRef.current) === null || _mapRef$current13 === void 0 ? void 0 : _mapRef$current13.getZoom) && localStorage.setItem('zoom', mapRef.current.getZoom());
    }
  };

  var handleMoveEnd = function handleMoveEnd(map, event) {
    saveMapState();

    if (onViewportChange) {
      onViewportChange(getViewport());
    }

    cancelContextMenuMobile();

    if (onMoveEnd) {
      onMoveEnd(map, event);
    }
  };

  var handleZoomEnd = function handleZoomEnd(map) {
    saveMapState();

    if (onViewportChange) {
      onViewportChange(getViewport());
    }

    if (onZoomEnd && typeof onZoomEnd === 'function') {
      onZoomEnd(map);
    }
  };

  var handleContextMenu = function handleContextMenu(map, event) {
    if (!reactDeviceDetect.isMobile && !rotating && onContextMenu) {
      onContextMenu(map, event);
    }
  };

  var handleRotateStart = function handleRotateStart() {
    rotating = true;
  };

  var handleRotateEnd = function handleRotateEnd() {
    setTimeout(function () {
      rotating = false;
    }, 100);
  };

  var handleTouchStart = function handleTouchStart(map, event) {
    if (reactDeviceDetect.isMobile && pressTimeout === undefined && onContextMenu) {
      pressTimeout = setTimeout(function () {
        onContextMenu(map, event);
      }, 500);
    }
  };

  var handleTouchEnd = function handleTouchEnd() {
    cancelContextMenuMobile();
  };

  var handleTouchCancel = function handleTouchCancel() {
    cancelContextMenuMobile();
  };

  var handleTouchMove = function handleTouchMove() {
    cancelContextMenuMobile();
  };

  var cancelContextMenuMobile = function cancelContextMenuMobile() {
    if (reactDeviceDetect.isMobile && pressTimeout) {
      clearTimeout(pressTimeout);
    }
  };

  var mapContent = React.useMemo(function () {
    var _context$theme4, _mapDefaultStyle, _mapDefaultStyle2;

    var MapBox = map || ReactMapboxGl__default['default']({
      accessToken: '',
      scrollZoom: scrollZoom,
      boxZoom: boxZoom,
      dragRotate: dragRotate,
      dragPan: dragPan,
      interactive: interactive,
      preserveDrawingBuffer: preserveDrawingBuffer
    });

    if (saveViewport) {
      var saveCenter = JSON.parse(localStorage.getItem('center') || '{}');

      if (saveCenter && saveCenter.lat && saveCenter.lng) {
        mapCenter = saveCenter;
      } else {
        localStorage.setItem('zoom', JSON.stringify(center));
      }

      var saveZoom = +(localStorage.getItem('zoom') || 0);

      if (saveZoom >= 0 && saveZoom <= 20) {
        mapZoomLevel = [saveZoom];
      } else {
        localStorage.setItem('zoom', mapZoomLevel);
      }
    }

    mapStyle = props.mapStyle || (context === null || context === void 0 ? void 0 : (_context$theme4 = context.theme) === null || _context$theme4 === void 0 ? void 0 : _context$theme4.base);
    mapDefaultStyle = mapStyle ? mapStyles.find(function (ms) {
      return ms.id === mapStyle;
    }) : mapStyles[1];
    return /*#__PURE__*/jsxRuntime.jsx(FullScreenOverlay, {
      children: /*#__PURE__*/jsxRuntime.jsxs(MapBox, {
        style: ((_mapDefaultStyle = mapDefaultStyle) === null || _mapDefaultStyle === void 0 ? void 0 : _mapDefaultStyle.styleUrl) || ((_mapDefaultStyle2 = mapDefaultStyle) === null || _mapDefaultStyle2 === void 0 ? void 0 : _mapDefaultStyle2.style),
        containerStyle: {
          height: height,
          width: width
        },
        center: mapCenter,
        zoom: mapZoomLevel // trackResize
        ,
        onStyleLoad: handleStyleLoad,
        onRender: handleRender,
        onZoomEnd: handleZoomEnd,
        onMoveEnd: handleMoveEnd,
        onContextMenu: handleContextMenu,
        onTouchStart: handleTouchStart,
        onTouchEnd: handleTouchEnd,
        onTouchCancel: handleTouchCancel,
        onTouchMove: handleTouchMove,
        onMove: handleMove,
        onClick: onClick,
        onRotateStart: handleRotateStart,
        onRotateEnd: handleRotateEnd,
        children: [!isNotControl && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
          children: [/*#__PURE__*/jsxRuntime.jsx(ReactMapboxGl.ZoomControl, {
            className: 'map-zoom-control'
          }), !isNotScaleControl && /*#__PURE__*/jsxRuntime.jsx(ReactMapboxGl.ScaleControl, {
            className: 'map-scale-control',
            position: 'bottom-left'
          }), /*#__PURE__*/jsxRuntime.jsx(ReactMapboxGl.RotationControl, {
            className: 'map-rotation-control'
          }), /*#__PURE__*/jsxRuntime.jsx(StyleSwitcher, {
            mapStyles: mapStyles,
            style: mapDefaultStyle,
            mapOverlays: props.mapOverlays || mapOverlays,
            overlays: props.defaultOverlays || defaultOverlays,
            showOverlays: showOverlays,
            onChangeMapStyle: handleChangeMapStyle,
            onToggleMapOverlay: handleToggleMapOverlay
          }), /*#__PURE__*/jsxRuntime.jsx(FullScreenButton, {
            className: "map-expand-control"
          })]
        }), children]
      })
    });
  }, [center, zoomLevel, styles]);
  return mapContent;
}, function (prevProps, nextProps) {
  var _nextProps$center = nextProps.center,
      nextLng = _nextProps$center.lng,
      nextLat = _nextProps$center.lat;
  var nextZoomLevel = nextProps.zoomLevel;
  var _prevProps$center = prevProps.center,
      lng = _prevProps$center.lng,
      lat = _prevProps$center.lat;
  var zoomLevel = prevProps.zoomLevel;

  if (lat !== nextLat || lng !== nextLng || (zoomLevel === null || zoomLevel === void 0 ? void 0 : zoomLevel.length) !== (nextZoomLevel === null || nextZoomLevel === void 0 ? void 0 : nextZoomLevel.length)) {
    return false;
  }

  for (var i = 0; i < (zoomLevel === null || zoomLevel === void 0 ? void 0 : zoomLevel.length); i++) {
    if (zoomLevel[i] !== nextZoomLevel[i]) {
      return false;
    }
  }

  return true;
});

function hasInterface (o, i) {
  return o.interfaces_ && o.interfaces_.indexOf(i) > -1
}

function Clonable () {}

class CoordinateSequence {
  constructor () {
    CoordinateSequence.constructor_.apply(this, arguments);
  }

  setOrdinate (index, ordinateIndex, value) {}
  size () {}
  getOrdinate (index, ordinateIndex) {}
  getCoordinate () {
  }

  getCoordinateCopy (i) {}
  getDimension () {}
  getX (index) {}
  expandEnvelope (env) {}
  copy () {}
  getY (index) {}
  toCoordinateArray () {}
  getClass () {
    return CoordinateSequence
  }

  get interfaces_ () {
    return [Clonable]
  }
}
CoordinateSequence.constructor_ = function () {};
CoordinateSequence.X = 0;
CoordinateSequence.Y = 1;
CoordinateSequence.Z = 2;
CoordinateSequence.M = 3;

class CoordinateSequenceFactory {
  constructor () {
    CoordinateSequenceFactory.constructor_.apply(this, arguments);
  }

  create () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof Array) ; else if (hasInterface(arguments[0], CoordinateSequence)) ;
    }
  }

  getClass () {
    return CoordinateSequenceFactory
  }

  get interfaces_ () {
    return []
  }
}
CoordinateSequenceFactory.constructor_ = function () {};

function IllegalArgumentException (message) {
  this.message = message;
}

class GeometryComponentFilter {
  constructor () {
    GeometryComponentFilter.constructor_.apply(this, arguments);
  }

  filter (geom) {}
  getClass () {
    return GeometryComponentFilter
  }

  get interfaces_ () {
    return []
  }
}
GeometryComponentFilter.constructor_ = function () {};

function Comparable () {}

function Serializable () {}

class NumberUtil {
  constructor () {
    NumberUtil.constructor_.apply(this, arguments);
  }

  static equalsWithTolerance (x1, x2, tolerance) {
    return Math.abs(x1 - x2) <= tolerance
  }

  getClass () {
    return NumberUtil
  }

  get interfaces_ () {
    return []
  }
}
NumberUtil.constructor_ = function () {};

function Long (high, low) {
  this.low = low | 0;
  this.high = high | 0;
}

Long.toBinaryString = function (i) {
  let mask;
  let result = '';
  for (mask = 0x80000000; mask > 0; mask >>>= 1) { result += (i.high & mask) === mask ? '1' : '0'; }
  for (mask = 0x80000000; mask > 0; mask >>>= 1) { result += (i.low & mask) === mask ? '1' : '0'; }
  return result
};

function Double () { }

Double.isNaN = n => Number.isNaN(n);
Double.isInfinite = n => !Number.isFinite(n);
Double.MAX_VALUE = Number.MAX_VALUE;

if (typeof Float64Array === 'function' &&
  typeof Int32Array === 'function') {
  // Simple and fast conversion between double and long bits
  // using TypedArrays and ArrayViewBuffers.
  (function () {
    const EXP_BIT_MASK = 0x7ff00000;
    const SIGNIF_BIT_MASK = 0xFFFFF;
    const f64buf = new Float64Array(1);
    const i32buf = new Int32Array(f64buf.buffer);
    Double.doubleToLongBits = function (value) {
      f64buf[0] = value;
      let low = i32buf[0] | 0;
      let high = i32buf[1] | 0;
      // Check for NaN based on values of bit fields, maximum
      // exponent and nonzero significand.
      if (((high & EXP_BIT_MASK) === EXP_BIT_MASK) &&
        ((high & SIGNIF_BIT_MASK) !== 0) &&
        (low !== 0)) {
        low = 0 | 0;
        high = 0x7ff80000 | 0;
      }
      return new Long(high, low)
    };
    Double.longBitsToDouble = function (bits) {
      i32buf[0] = bits.low;
      i32buf[1] = bits.high;
      return f64buf[0]
    };
  })();
} else {
  // More complex and slower fallback implementation using
  // math and the divide-by-two and multiply-by-two algorithms.
  (function () {
    const BIAS = 1023;
    const log2 = Math.log2;
    const floor = Math.floor;
    const pow = Math.pow;
    const MAX_REL_BITS_INTEGER = (function () {
      for (let i = 53; i > 0; i--) {
        const bits = pow(2, i) - 1;
        if (floor(log2(bits)) + 1 === i) {
          return bits
        }
      }
      return 0
    })();
    Double.doubleToLongBits = function (value) {
      let x, y, f, bits, skip;
      let sign, exp, high, low;

      // Get the sign bit and absolute value.
      if (value < 0 || 1 / value === Number.NEGATIVE_INFINITY) {
        sign = (1 << 31);
        value = (-value);
      } else {
        sign = 0;
      }

      // Handle some special values.
      if (value === 0) {
        // Handle zeros (+/-0).
        low = 0 | 0;
        high = sign; // exponent: 00..00, significand: 00..00
        return new Long(high, low)
      }

      if (value === Infinity) {
        // Handle infinity (only positive values for value possible).
        low = 0 | 0;
        high = sign | 0x7ff00000; // exponent: 11..11, significand: 00..00
        return new Long(high, low)
      }

      if (value !== value) { // eslint-disable-line
        // Handle NaNs (boiled down to only one distinct NaN).
        low = 0 | 0;
        high = 0x7ff80000; // exponent: 11..11, significand: 10..00
        return new Long(high, low)
      }

      // Preinitialize variables, that are not neccessarily set by
      // the algorithm.
      bits = 0;
      low = 0 | 0;

      // Get the (always positive) integer part of value.
      x = floor(value);

      // Process the integer part if it's greater than 1. Zero requires
      // no bits at all, 1 represents the implicit (hidden) leading bit,
      // which must not be written as well.
      if (x > 1) {
        // If we can reliably determine the number of bits required for
        // the integer part,
        if (x <= MAX_REL_BITS_INTEGER) {
          // get the number of bits required to represent it minus 1
          bits = floor(log2(x)); /* + 1 - 1 */
          // and simply copy/shift the integer bits into low and high.
          // That's much faster than the divide-by-two algorithm (saves
          // up to ~60%).
          // We always need to mask out the most significant bit, which
          // is the implicit (aka hidden) bit.
          if (bits <= 20) {
            // The simple case in which the integer fits into the
            // lower 20 bits of the high word is worth to be handled
            // separately (saves ~25%).
            low = 0 | 0;
            high = (x << (20 - bits)) & 0xfffff;
          } else {
            // Here, the integer part is split into low and high.
            // Since its value may require more than 32 bits, we
            // cannot use bitwise operators (which implicitly cast
            // to Int32), but use arithmetic operators % and / to
            // get low and high parts. The uppper 20 bits go to high,
            // the remaining bits (in f) to low.
            f = bits - 20;
            // Like (1 << f) but safe with even more than 32 bits.
            y = pow(2, f);
            low = (x % y) << (32 - f);
            high = (x / y) & 0xfffff;
          }
        } else {
          // For greater values, we must use the much slower divide-by-two
          // algorithm. Bits are generated from right to left, that is from
          // least to most significant bit. For each bit, we left-shift both
          // low and high by one and carry bit #0 from high to #31 in low.
          // The next bit is then copied into bit #19 in high, the leftmost
          // bit of the double's significand.

          // Preserve x for later user, so work with f.
          f = x;
          low = 0 | 0;
          while (true) {
            y = f / 2;
            f = floor(y);
            if (f === 0) {
              // We just found the most signigicant (1-)bit, which
              // is the implicit bit and so, not stored in the double
              // value. So, it's time to leave the loop.
              break
            }
            // Count this bit, shift low and carry bit #0 from high.
            bits++;
            low >>>= 1;
            low |= (high & 0x1) << 31;
            // Shift high.
            high >>>= 1;
            if (y !== f) {
              // Copy the new bit into bit #19 in high (only required if 1).
              high |= 0x80000;
            }
          }
        }
      }

      // Bias the exponent.
      exp = bits + BIAS;

      // If the integer part is zero, we've not yet seen the implicit
      // leading bit. Variable skip is later used while processing the
      // fractional part (if any).
      skip = (x === 0);

      // Get fraction only into x.
      x = value - x;

      // If some significand bits are still left to be filled and
      // the fractional part is not zero, convert the fraction using
      // the multiply-by-2 algorithm.
      if (bits < 52 && x !== 0) {
        // Initialize 'buffer' f, into which newly created bits get
        // shifted from right to left.
        f = 0;

        while (true) {
          y = x * 2;
          if (y >= 1) {
            // This is a new 1-bit. Add and count this bit, if not
            // prohibited by skip.
            x = y - 1;
            if (!skip) {
              f <<= 1;
              f |= 1;
              bits++;
            } else {
              // Otherwise, decrement the exponent and unset
              // skip, so that all following bits get written.
              exp--;
              skip = false;
            }
          } else {
            // This is a new 0-bit. Add and count this bit, if not
            // prohibited by skip.
            x = y;
            if (!skip) {
              f <<= 1;
              bits++;
            } else if (--exp === 0) {
              // Otherwise we've just decremented the exponent. If the
              // biased exponent is zero now (-1023), we process a
              // subnormal number, which has no impled leading 1-bit.
              // So, count this 0-bit and unset skip to write out
              // all the following bits.
              bits++;
              skip = false;
            }
          }
          if (bits === 20) {
            // When 20 bits have been created in total, we're done with
            // the high word. Copy the bits from 'buffer' f into high
            // and reset 'buffer' f. Following bits will end up in the
            // low word.
            high |= f;
            f = 0;
          } else if (bits === 52) {
            // When 52 bits have been created in total, we're done with
            // low word as well. Copy the bits from 'buffer' f into low
            // and exit the loop.
            low |= f;
            break
          }
          if (y === 1) {
            // When y is exactly 1, there is no remainder and the process
            // is complete (the number is finite). Copy the bits from
            // 'buffer' f into either low or high and exit the loop.
            if (bits < 20) {
              high |= (f << (20 - bits));
            } else if (bits < 52) {
              low |= (f << (52 - bits));
            }
            break
          }
        }
      }

      // Copy/shift the exponent and sign bits into the high word.
      high |= (exp << 20);
      high |= sign;

      return new Long(high, low)
    };
    Double.longBitsToDouble = function (bits) {
      let i;
      let x, sign, exp, fract;
      const high = bits.high;
      const low = bits.low;

      // Extract the sign.
      sign = (high & (1 << 31)) ? -1 : 1;

      // Extract the unbiased exponent.
      exp = ((high & 0x7ff00000) >> 20) - BIAS;

      // Calculate the fraction from left to right. Start
      // off with the 20 lower bits from the high word.
      fract = 0;
      x = (1 << 19);
      for (i = 1; i <= 20; i++) {
        if (high & x) {
          fract += pow(2, -i);
        }
        x >>>= 1;
      }
      // Continue with all 32 bits from the low word.
      x = (1 << 31);
      for (i = 21; i <= 52; i++) {
        if (low & x) {
          fract += pow(2, -i);
        }
        x >>>= 1;
      }

      // Handle special values.
      // Check for zero and subnormal values.
      if (exp === -BIAS) {
        if (fract === 0) {
          // +/-1.0 * 0.0 => +/-0.0
          return sign * 0
        }
        exp = -1022;
      } else if (exp === BIAS + 1) { // Check for +/-Infinity or NaN.
        if (fract === 0) {
          // +/-1.0 / 0.0 => +/-Infinity
          return sign / 0
        }
        return NaN
      } else { // Nothing special? Seems to be a normal number.
        // Add the implicit leading bit (1*2^0).
        fract += 1;
      }

      return sign * fract * pow(2, exp)
    };
  })();
}

function Comparator () {}

function RuntimeException (message) {
  this.name = 'RuntimeException';
  this.message = message;
  this.stack = (new Error()).stack;
  Error.call(this, message);
}

RuntimeException.prototype = Object.create(Error.prototype);
RuntimeException.prototype.constructor = Error;

class AssertionFailedException extends RuntimeException {
  constructor () {
    super();
    AssertionFailedException.constructor_.apply(this, arguments);
  }

  getClass () {
    return AssertionFailedException
  }

  get interfaces_ () {
    return []
  }
}
AssertionFailedException.constructor_ = function () {
  if (arguments.length === 0) {
    RuntimeException.constructor_.call(this);
  } else if (arguments.length === 1) {
    const message = arguments[0];
    RuntimeException.constructor_.call(this, message);
  }
};

class Assert {
  constructor () {
    Assert.constructor_.apply(this, arguments);
  }

  static shouldNeverReachHere () {
    if (arguments.length === 0) {
      Assert.shouldNeverReachHere(null);
    } else if (arguments.length === 1) {
      const message = arguments[0];
      throw new AssertionFailedException('Should never reach here' + (message !== null ? ': ' + message : ''))
    }
  }

  static isTrue () {
    if (arguments.length === 1) {
      const assertion = arguments[0];
      Assert.isTrue(assertion, null);
    } else if (arguments.length === 2) {
      const assertion = arguments[0]; const message = arguments[1];
      if (!assertion) {
        if (message === null) {
          throw new AssertionFailedException()
        } else {
          throw new AssertionFailedException(message)
        }
      }
    }
  }

  static equals () {
    if (arguments.length === 2) {
      const expectedValue = arguments[0]; const actualValue = arguments[1];
      Assert.equals(expectedValue, actualValue, null);
    } else if (arguments.length === 3) {
      const expectedValue = arguments[0]; const actualValue = arguments[1]; const message = arguments[2];
      if (!actualValue.equals(expectedValue)) {
        throw new AssertionFailedException('Expected ' + expectedValue + ' but encountered ' + actualValue + (message !== null ? ': ' + message : ''))
      }
    }
  }

  getClass () {
    return Assert
  }

  get interfaces_ () {
    return []
  }
}
Assert.constructor_ = function () {};

class Coordinate {
  constructor () {
    Coordinate.constructor_.apply(this, arguments);
  }

  static hashCode () {
    if (arguments.length === 1 && typeof arguments[0] === 'number') {
      const x = arguments[0];
      const f = Double.doubleToLongBits(x);
      return Math.trunc(f ^ f >>> 32)
    }
  }

  setOrdinate (ordinateIndex, value) {
    switch (ordinateIndex) {
      case Coordinate.X:
        this.x = value;
        break
      case Coordinate.Y:
        this.y = value;
        break
      case Coordinate.Z:
        this.z = value;
        break
      default:
        throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)
    }
  }

  equals2D () {
    if (arguments.length === 1) {
      const other = arguments[0];
      if (this.x !== other.x) {
        return false
      }
      if (this.y !== other.y) {
        return false
      }
      return true
    } else if (arguments.length === 2) {
      const c = arguments[0]; const tolerance = arguments[1];
      if (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {
        return false
      }
      if (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {
        return false
      }
      return true
    }
  }

  getOrdinate (ordinateIndex) {
    switch (ordinateIndex) {
      case Coordinate.X:
        return this.x
      case Coordinate.Y:
        return this.y
      case Coordinate.Z:
        return this.z
    }
    throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)
  }

  equals3D (other) {
    return this.x === other.x && this.y === other.y && (this.z === other.z || Double.isNaN(this.z) && Double.isNaN(other.z))
  }

  equals (other) {
    if (!(other instanceof Coordinate)) {
      return false
    }
    return this.equals2D(other)
  }

  equalInZ (c, tolerance) {
    return NumberUtil.equalsWithTolerance(this.z, c.z, tolerance)
  }

  compareTo (o) {
    const other = o;
    if (this.x < other.x) return -1
    if (this.x > other.x) return 1
    if (this.y < other.y) return -1
    if (this.y > other.y) return 1
    return 0
  }

  clone () {
    try {
      const coord = null;
      return coord
    } catch (e) {
      if (e instanceof CloneNotSupportedException) {
        Assert.shouldNeverReachHere("this shouldn't happen because this class is Cloneable");
        return null
      } else throw e
    } finally {}
  }

  copy () {
    return new Coordinate(this)
  }

  toString () {
    return '(' + this.x + ', ' + this.y + ', ' + this.z + ')'
  }

  distance3D (c) {
    const dx = this.x - c.x;
    const dy = this.y - c.y;
    const dz = this.z - c.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz)
  }

  distance (c) {
    const dx = this.x - c.x;
    const dy = this.y - c.y;
    return Math.sqrt(dx * dx + dy * dy)
  }

  hashCode () {
    let result = 17;
    result = 37 * result + Coordinate.hashCode(this.x);
    result = 37 * result + Coordinate.hashCode(this.y);
    return result
  }

  setCoordinate (other) {
    this.x = other.x;
    this.y = other.y;
    this.z = other.z;
  }

  getClass () {
    return Coordinate
  }

  get interfaces_ () {
    return [Comparable, Clonable, Serializable]
  }
}
class DimensionalComparator {
  constructor () {
    DimensionalComparator.constructor_.apply(this, arguments);
  }

  static compare (a, b) {
    if (a < b) return -1
    if (a > b) return 1
    if (Double.isNaN(a)) {
      if (Double.isNaN(b)) return 0
      return -1
    }
    if (Double.isNaN(b)) return 1
    return 0
  }

  compare (o1, o2) {
    const c1 = o1;
    const c2 = o2;
    const compX = DimensionalComparator.compare(c1.x, c2.x);
    if (compX !== 0) return compX
    const compY = DimensionalComparator.compare(c1.y, c2.y);
    if (compY !== 0) return compY
    if (this._dimensionsToTest <= 2) return 0
    const compZ = DimensionalComparator.compare(c1.z, c2.z);
    return compZ
  }

  getClass () {
    return DimensionalComparator
  }

  get interfaces_ () {
    return [Comparator]
  }
}
DimensionalComparator.constructor_ = function () {
  this._dimensionsToTest = 2;
  if (arguments.length === 0) {
    DimensionalComparator.constructor_.call(this, 2);
  } else if (arguments.length === 1) {
    const dimensionsToTest = arguments[0];
    if (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new IllegalArgumentException('only 2 or 3 dimensions may be specified')
    this._dimensionsToTest = dimensionsToTest;
  }
};
Coordinate.DimensionalComparator = DimensionalComparator;
Coordinate.constructor_ = function () {
  this.x = null;
  this.y = null;
  this.z = null;
  if (arguments.length === 0) {
    Coordinate.constructor_.call(this, 0.0, 0.0);
  } else if (arguments.length === 1) {
    const c = arguments[0];
    Coordinate.constructor_.call(this, c.x, c.y, c.z);
  } else if (arguments.length === 2) {
    const x = arguments[0]; const y = arguments[1];
    Coordinate.constructor_.call(this, x, y, Coordinate.NULL_ORDINATE);
  } else if (arguments.length === 3) {
    const x = arguments[0]; const y = arguments[1]; const z = arguments[2];
    this.x = x;
    this.y = y;
    this.z = z;
  }
};
Coordinate.serialVersionUID = 6683108902428366910;
Coordinate.NULL_ORDINATE = Double.NaN;
Coordinate.X = 0;
Coordinate.Y = 1;
Coordinate.Z = 2;

class Envelope {
  constructor () {
    Envelope.constructor_.apply(this, arguments);
  }

  static intersects () {
    if (arguments.length === 3) {
      const p1 = arguments[0]; const p2 = arguments[1]; const q = arguments[2];
      if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) {
        return true
      }
      return false
    } else if (arguments.length === 4) {
      const p1 = arguments[0]; const p2 = arguments[1]; const q1 = arguments[2]; const q2 = arguments[3];
      let minq = Math.min(q1.x, q2.x);
      let maxq = Math.max(q1.x, q2.x);
      let minp = Math.min(p1.x, p2.x);
      let maxp = Math.max(p1.x, p2.x);
      if (minp > maxq) return false
      if (maxp < minq) return false
      minq = Math.min(q1.y, q2.y);
      maxq = Math.max(q1.y, q2.y);
      minp = Math.min(p1.y, p2.y);
      maxp = Math.max(p1.y, p2.y);
      if (minp > maxq) return false
      if (maxp < minq) return false
      return true
    }
  }

  getArea () {
    return this.getWidth() * this.getHeight()
  }

  equals (other) {
    if (!(other instanceof Envelope)) {
      return false
    }
    const otherEnvelope = other;
    if (this.isNull()) {
      return otherEnvelope.isNull()
    }
    return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY()
  }

  intersection (env) {
    if (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope()
    const intMinX = this._minx > env._minx ? this._minx : env._minx;
    const intMinY = this._miny > env._miny ? this._miny : env._miny;
    const intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;
    const intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;
    return new Envelope(intMinX, intMaxX, intMinY, intMaxY)
  }

  isNull () {
    return this._maxx < this._minx
  }

  getMaxX () {
    return this._maxx
  }

  covers () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof Coordinate) {
        const p = arguments[0];
        return this.covers(p.x, p.y)
      } else if (arguments[0] instanceof Envelope) {
        const other = arguments[0];
        if (this.isNull() || other.isNull()) {
          return false
        }
        return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy
      }
    } else if (arguments.length === 2) {
      const x = arguments[0]; const y = arguments[1];
      if (this.isNull()) return false
      return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy
    }
  }

  intersects () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof Envelope) {
        const other = arguments[0];
        if (this.isNull() || other.isNull()) {
          return false
        }
        return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny)
      } else if (arguments[0] instanceof Coordinate) {
        const p = arguments[0];
        return this.intersects(p.x, p.y)
      }
    } else if (arguments.length === 2) {
      if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
        const a = arguments[0]; const b = arguments[1];
        if (this.isNull()) {
          return false
        }
        const envminx = a.x < b.x ? a.x : b.x;
        if (envminx > this._maxx) return false
        const envmaxx = a.x > b.x ? a.x : b.x;
        if (envmaxx < this._minx) return false
        const envminy = a.y < b.y ? a.y : b.y;
        if (envminy > this._maxy) return false
        const envmaxy = a.y > b.y ? a.y : b.y;
        if (envmaxy < this._miny) return false
        return true
      } else if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
        const x = arguments[0]; const y = arguments[1];
        if (this.isNull()) return false
        return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny)
      }
    }
  }

  getMinY () {
    return this._miny
  }

  getMinX () {
    return this._minx
  }

  expandToInclude () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof Coordinate) {
        const p = arguments[0];
        this.expandToInclude(p.x, p.y);
      } else if (arguments[0] instanceof Envelope) {
        const other = arguments[0];
        if (other.isNull()) {
          return null
        }
        if (this.isNull()) {
          this._minx = other.getMinX();
          this._maxx = other.getMaxX();
          this._miny = other.getMinY();
          this._maxy = other.getMaxY();
        } else {
          if (other._minx < this._minx) {
            this._minx = other._minx;
          }
          if (other._maxx > this._maxx) {
            this._maxx = other._maxx;
          }
          if (other._miny < this._miny) {
            this._miny = other._miny;
          }
          if (other._maxy > this._maxy) {
            this._maxy = other._maxy;
          }
        }
      }
    } else if (arguments.length === 2) {
      const x = arguments[0]; const y = arguments[1];
      if (this.isNull()) {
        this._minx = x;
        this._maxx = x;
        this._miny = y;
        this._maxy = y;
      } else {
        if (x < this._minx) {
          this._minx = x;
        }
        if (x > this._maxx) {
          this._maxx = x;
        }
        if (y < this._miny) {
          this._miny = y;
        }
        if (y > this._maxy) {
          this._maxy = y;
        }
      }
    }
  }

  minExtent () {
    if (this.isNull()) return 0.0
    const w = this.getWidth();
    const h = this.getHeight();
    if (w < h) return w
    return h
  }

  getWidth () {
    if (this.isNull()) {
      return 0
    }
    return this._maxx - this._minx
  }

  compareTo (o) {
    const env = o;
    if (this.isNull()) {
      if (env.isNull()) return 0
      return -1
    } else {
      if (env.isNull()) return 1
    }
    if (this._minx < env._minx) return -1
    if (this._minx > env._minx) return 1
    if (this._miny < env._miny) return -1
    if (this._miny > env._miny) return 1
    if (this._maxx < env._maxx) return -1
    if (this._maxx > env._maxx) return 1
    if (this._maxy < env._maxy) return -1
    if (this._maxy > env._maxy) return 1
    return 0
  }

  translate (transX, transY) {
    if (this.isNull()) {
      return null
    }
    this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);
  }

  toString () {
    return 'Env[' + this._minx + ' : ' + this._maxx + ', ' + this._miny + ' : ' + this._maxy + ']'
  }

  setToNull () {
    this._minx = 0;
    this._maxx = -1;
    this._miny = 0;
    this._maxy = -1;
  }

  getHeight () {
    if (this.isNull()) {
      return 0
    }
    return this._maxy - this._miny
  }

  maxExtent () {
    if (this.isNull()) return 0.0
    const w = this.getWidth();
    const h = this.getHeight();
    if (w > h) return w
    return h
  }

  expandBy () {
    if (arguments.length === 1) {
      const distance = arguments[0];
      this.expandBy(distance, distance);
    } else if (arguments.length === 2) {
      const deltaX = arguments[0]; const deltaY = arguments[1];
      if (this.isNull()) return null
      this._minx -= deltaX;
      this._maxx += deltaX;
      this._miny -= deltaY;
      this._maxy += deltaY;
      if (this._minx > this._maxx || this._miny > this._maxy) this.setToNull();
    }
  }

  contains () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof Envelope) {
        const other = arguments[0];
        return this.covers(other)
      } else if (arguments[0] instanceof Coordinate) {
        const p = arguments[0];
        return this.covers(p)
      }
    } else if (arguments.length === 2) {
      const x = arguments[0]; const y = arguments[1];
      return this.covers(x, y)
    }
  }

  centre () {
    if (this.isNull()) return null
    return new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0)
  }

  init () {
    if (arguments.length === 0) {
      this.setToNull();
    } else if (arguments.length === 1) {
      if (arguments[0] instanceof Coordinate) {
        const p = arguments[0];
        this.init(p.x, p.x, p.y, p.y);
      } else if (arguments[0] instanceof Envelope) {
        const env = arguments[0];
        this._minx = env._minx;
        this._maxx = env._maxx;
        this._miny = env._miny;
        this._maxy = env._maxy;
      }
    } else if (arguments.length === 2) {
      const p1 = arguments[0]; const p2 = arguments[1];
      this.init(p1.x, p2.x, p1.y, p2.y);
    } else if (arguments.length === 4) {
      const x1 = arguments[0]; const x2 = arguments[1]; const y1 = arguments[2]; const y2 = arguments[3];
      if (x1 < x2) {
        this._minx = x1;
        this._maxx = x2;
      } else {
        this._minx = x2;
        this._maxx = x1;
      }
      if (y1 < y2) {
        this._miny = y1;
        this._maxy = y2;
      } else {
        this._miny = y2;
        this._maxy = y1;
      }
    }
  }

  getMaxY () {
    return this._maxy
  }

  distance (env) {
    if (this.intersects(env)) return 0
    let dx = 0.0;
    if (this._maxx < env._minx) dx = env._minx - this._maxx; else if (this._minx > env._maxx) dx = this._minx - env._maxx;
    let dy = 0.0;
    if (this._maxy < env._miny) dy = env._miny - this._maxy; else if (this._miny > env._maxy) dy = this._miny - env._maxy;
    if (dx === 0.0) return dy
    if (dy === 0.0) return dx
    return Math.sqrt(dx * dx + dy * dy)
  }

  hashCode () {
    let result = 17;
    result = 37 * result + Coordinate.hashCode(this._minx);
    result = 37 * result + Coordinate.hashCode(this._maxx);
    result = 37 * result + Coordinate.hashCode(this._miny);
    result = 37 * result + Coordinate.hashCode(this._maxy);
    return result
  }

  getClass () {
    return Envelope
  }

  get interfaces_ () {
    return [Comparable, Serializable]
  }
}
Envelope.constructor_ = function () {
  this._minx = null;
  this._maxx = null;
  this._miny = null;
  this._maxy = null;
  if (arguments.length === 0) {
    this.init();
  } else if (arguments.length === 1) {
    if (arguments[0] instanceof Coordinate) {
      const p = arguments[0];
      this.init(p.x, p.x, p.y, p.y);
    } else if (arguments[0] instanceof Envelope) {
      const env = arguments[0];
      this.init(env);
    }
  } else if (arguments.length === 2) {
    const p1 = arguments[0]; const p2 = arguments[1];
    this.init(p1.x, p2.x, p1.y, p2.y);
  } else if (arguments.length === 4) {
    const x1 = arguments[0]; const x2 = arguments[1]; const y1 = arguments[2]; const y2 = arguments[3];
    this.init(x1, x2, y1, y2);
  }
};
Envelope.serialVersionUID = 5873921885273102420;

class Geometry {
  constructor () {
    Geometry.constructor_.apply(this, arguments);
  }

  isGeometryCollection () {
    return this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION
  }

  getFactory () {
    return this._factory
  }

  getGeometryN (n) {
    return this
  }

  getArea () {
    return 0.0
  }

  isRectangle () {
    return false
  }

  equals () {
    if (arguments[0] instanceof Geometry) {
      const g = arguments[0];
      if (g === null) return false
      return this.equalsTopo(g)
    } else if (arguments[0] instanceof Object) {
      const o = arguments[0];
      if (!(o instanceof Geometry)) return false
      const g = o;
      return this.equalsExact(g)
    }
  }

  equalsExact (other) {
    return this === other || this.equalsExact(other, 0)
  }

  geometryChanged () {
    this.apply(Geometry.geometryChangedFilter);
  }

  geometryChangedAction () {
    this._envelope = null;
  }

  equalsNorm (g) {
    if (g === null) return false
    return this.norm().equalsExact(g.norm())
  }

  getLength () {
    return 0.0
  }

  getNumGeometries () {
    return 1
  }

  compareTo () {
    let other;
    if (arguments.length === 1) {
      const o = arguments[0];
      other = o;
      if (this.getTypeCode() !== other.getTypeCode()) {
        return this.getTypeCode() - other.getTypeCode()
      }
      if (this.isEmpty() && other.isEmpty()) {
        return 0
      }
      if (this.isEmpty()) {
        return -1
      }
      if (other.isEmpty()) {
        return 1
      }
      return this.compareToSameClass(o)
    } else if (arguments.length === 2) {
      const o = arguments[0]; const comp = arguments[1];
      other = o;
      if (this.getTypeCode() !== other.getTypeCode()) {
        return this.getTypeCode() - other.getTypeCode()
      }
      if (this.isEmpty() && other.isEmpty()) {
        return 0
      }
      if (this.isEmpty()) {
        return -1
      }
      if (other.isEmpty()) {
        return 1
      }
      return this.compareToSameClass(o, comp)
    }
  }

  getUserData () {
    return this._userData
  }

  getSRID () {
    return this._SRID
  }

  getEnvelope () {
    return this.getFactory().toGeometry(this.getEnvelopeInternal())
  }

  checkNotGeometryCollection (g) {
    if (g.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION) {
      throw new IllegalArgumentException('This method does not support GeometryCollection arguments')
    }
  }

  equal (a, b, tolerance) {
    if (tolerance === 0) {
      return a.equals(b)
    }
    return a.distance(b) <= tolerance
  }

  norm () {
    const copy = this.copy();
    copy.normalize();
    return copy
  }

  getPrecisionModel () {
    return this._factory.getPrecisionModel()
  }

  getEnvelopeInternal () {
    if (this._envelope === null) {
      this._envelope = this.computeEnvelopeInternal();
    }
    return new Envelope(this._envelope)
  }

  setSRID (SRID) {
    this._SRID = SRID;
  }

  setUserData (userData) {
    this._userData = userData;
  }

  compare (a, b) {
    const i = a.iterator();
    const j = b.iterator();
    while (i.hasNext() && j.hasNext()) {
      const aElement = i.next();
      const bElement = j.next();
      const comparison = aElement.compareTo(bElement);
      if (comparison !== 0) {
        return comparison
      }
    }
    if (i.hasNext()) {
      return 1
    }
    if (j.hasNext()) {
      return -1
    }
    return 0
  }

  hashCode () {
    return this.getEnvelopeInternal().hashCode()
  }

  isGeometryCollectionOrDerived () {
    if (this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === Geometry.TYPECODE_MULTIPOINT || this.getTypeCode() === Geometry.TYPECODE_MULTILINESTRING || this.getTypeCode() === Geometry.TYPECODE_MULTIPOLYGON) {
      return true
    }
    return false
  }

  get interfaces_ () {
    return [Clonable, Comparable, Serializable]
  }

  getClass () {
    return Geometry
  }

  static hasNonEmptyElements (geometries) {
    for (let i = 0; i < geometries.length; i++) {
      if (!geometries[i].isEmpty()) {
        return true
      }
    }
    return false
  }

  static hasNullElements (array) {
    for (let i = 0; i < array.length; i++) {
      if (array[i] === null) {
        return true
      }
    }
    return false
  }
}Geometry.constructor_ = function (factory) {
  if (!factory) { return }
  this._envelope = null;
  this._userData = null;
  this._factory = factory;
  this._SRID = factory.getSRID();
};
Geometry.serialVersionUID = 8763622679187376702;
Geometry.TYPECODE_POINT = 0;
Geometry.TYPECODE_MULTIPOINT = 1;
Geometry.TYPECODE_LINESTRING = 2;
Geometry.TYPECODE_LINEARRING = 3;
Geometry.TYPECODE_MULTILINESTRING = 4;
Geometry.TYPECODE_POLYGON = 5;
Geometry.TYPECODE_MULTIPOLYGON = 6;
Geometry.TYPECODE_GEOMETRYCOLLECTION = 7;
Geometry.TYPENAME_POINT = 'Point';
Geometry.TYPENAME_MULTIPOINT = 'MultiPoint';
Geometry.TYPENAME_LINESTRING = 'LineString';
Geometry.TYPENAME_LINEARRING = 'LinearRing';
Geometry.TYPENAME_MULTILINESTRING = 'MultiLineString';
Geometry.TYPENAME_POLYGON = 'Polygon';
Geometry.TYPENAME_MULTIPOLYGON = 'MultiPolygon';
Geometry.TYPENAME_GEOMETRYCOLLECTION = 'GeometryCollection';
Geometry.geometryChangedFilter = {
  get interfaces_ () {
    return [GeometryComponentFilter]
  },
  filter (geom) {
    geom.geometryChangedAction();
  }
};

class CoordinateFilter {
  constructor () {
    CoordinateFilter.constructor_.apply(this, arguments);
  }

  filter (coord) {}
  getClass () {
    return CoordinateFilter
  }

  get interfaces_ () {
    return []
  }
}
CoordinateFilter.constructor_ = function () {};

class BoundaryNodeRule {
  constructor () {
    BoundaryNodeRule.constructor_.apply(this, arguments);
  }

  isInBoundary (boundaryCount) {}
  getClass () {
    return BoundaryNodeRule
  }

  get interfaces_ () {
    return []
  }
}
class Mod2BoundaryNodeRule {
  constructor () {
    Mod2BoundaryNodeRule.constructor_.apply(this, arguments);
  }

  isInBoundary (boundaryCount) {
    return boundaryCount % 2 === 1
  }

  getClass () {
    return Mod2BoundaryNodeRule
  }

  get interfaces_ () {
    return [BoundaryNodeRule]
  }
}
Mod2BoundaryNodeRule.constructor_ = function () {};
class EndPointBoundaryNodeRule {
  constructor () {
    EndPointBoundaryNodeRule.constructor_.apply(this, arguments);
  }

  isInBoundary (boundaryCount) {
    return boundaryCount > 0
  }

  getClass () {
    return EndPointBoundaryNodeRule
  }

  get interfaces_ () {
    return [BoundaryNodeRule]
  }
}
EndPointBoundaryNodeRule.constructor_ = function () {};
class MultiValentEndPointBoundaryNodeRule {
  constructor () {
    MultiValentEndPointBoundaryNodeRule.constructor_.apply(this, arguments);
  }

  isInBoundary (boundaryCount) {
    return boundaryCount > 1
  }

  getClass () {
    return MultiValentEndPointBoundaryNodeRule
  }

  get interfaces_ () {
    return [BoundaryNodeRule]
  }
}
MultiValentEndPointBoundaryNodeRule.constructor_ = function () {};
class MonoValentEndPointBoundaryNodeRule {
  constructor () {
    MonoValentEndPointBoundaryNodeRule.constructor_.apply(this, arguments);
  }

  isInBoundary (boundaryCount) {
    return boundaryCount === 1
  }

  getClass () {
    return MonoValentEndPointBoundaryNodeRule
  }

  get interfaces_ () {
    return [BoundaryNodeRule]
  }
}
MonoValentEndPointBoundaryNodeRule.constructor_ = function () {};
BoundaryNodeRule.Mod2BoundaryNodeRule = Mod2BoundaryNodeRule;
BoundaryNodeRule.EndPointBoundaryNodeRule = EndPointBoundaryNodeRule;
BoundaryNodeRule.MultiValentEndPointBoundaryNodeRule = MultiValentEndPointBoundaryNodeRule;
BoundaryNodeRule.MonoValentEndPointBoundaryNodeRule = MonoValentEndPointBoundaryNodeRule;
BoundaryNodeRule.constructor_ = function () {};
BoundaryNodeRule.MOD2_BOUNDARY_RULE = new Mod2BoundaryNodeRule();
BoundaryNodeRule.ENDPOINT_BOUNDARY_RULE = new EndPointBoundaryNodeRule();
BoundaryNodeRule.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new MultiValentEndPointBoundaryNodeRule();
BoundaryNodeRule.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new MonoValentEndPointBoundaryNodeRule();
BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = BoundaryNodeRule.MOD2_BOUNDARY_RULE;

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html
 *
 * @constructor
 * @private
 */
function Collection () {}
/**
 * Ensures that this collection contains the specified element (optional
 * operation).
 * @param {Object} e
 * @return {boolean}
 */
Collection.prototype.add = function () {};

/**
 * Appends all of the elements in the specified collection to the end of this
 * list, in the order that they are returned by the specified collection's
 * iterator (optional operation).
 * @param {javascript.util.Collection} c
 * @return {boolean}
 */
Collection.prototype.addAll = function () {};

/**
 * Returns true if this collection contains no elements.
 * @return {boolean}
 */
Collection.prototype.isEmpty = function () {};

/**
 * Returns an iterator over the elements in this collection.
 * @return {javascript.util.Iterator}
 */
Collection.prototype.iterator = function () {};

/**
 * Returns an iterator over the elements in this collection.
 * @return {number}
 */
Collection.prototype.size = function () {};

/**
 * Returns an array containing all of the elements in this collection.
 * @return {Array}
 */
Collection.prototype.toArray = function () {};

/**
 * Removes a single instance of the specified element from this collection if it
 * is present. (optional)
 * @param {Object} e
 * @return {boolean}
 */
Collection.prototype.remove = function () {};

/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function IndexOutOfBoundsException (message) {
  this.message = message || '';
}IndexOutOfBoundsException.prototype = new Error();

/**
 * @type {string}
 */
IndexOutOfBoundsException.prototype.name = 'IndexOutOfBoundsException';

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html
 *
 * @extends {javascript.util.Collection}
 * @constructor
 * @private
 */
function List () { }List.prototype = Object.create(Collection.prototype);
List.prototype.constructor = List;

/**
 * Returns the element at the specified position in this list.
 * @param {number} index
 * @return {Object}
 */
List.prototype.get = function () { };

/**
 * Replaces the element at the specified position in this list with the
 * specified element (optional operation).
 * @param {number} index
 * @param {Object} e
 * @return {Object}
 */
List.prototype.set = function () { };

/**
 * Returns true if this collection contains no elements.
 * @return {boolean}
 */
List.prototype.isEmpty = function () { };

/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function NoSuchElementException (message) {
  this.message = message || '';
}NoSuchElementException.prototype = new Error();

/**
 * @type {string}
 */
NoSuchElementException.prototype.name = 'NoSuchElementException';

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html
 *
 * @extends List
 * @private
 */
function ArrayList () {
  /**
   * @type {Array}
   * @private
  */
  this.array_ = [];

  if (arguments[0] instanceof Collection) {
    this.addAll(arguments[0]);
  }
}ArrayList.prototype = Object.create(List.prototype);
ArrayList.prototype.constructor = ArrayList;

ArrayList.prototype.ensureCapacity = function () {};
ArrayList.prototype.interfaces_ = [List, Collection];

/**
 * @override
 */
ArrayList.prototype.add = function (e) {
  if (arguments.length === 1) {
    this.array_.push(e);
  } else {
    this.array_.splice(arguments[0], 0, arguments[1]);
  }
  return true
};

ArrayList.prototype.clear = function () {
  this.array_ = [];
};

/**
 * @override
 */
ArrayList.prototype.addAll = function (c) {
  for (let i = c.iterator(); i.hasNext();) {
    this.add(i.next());
  }
  return true
};

/**
 * @override
 */
ArrayList.prototype.set = function (index, element) {
  const oldElement = this.array_[index];
  this.array_[index] = element;
  return oldElement
};

/**
 * @override
 */
ArrayList.prototype.iterator = function () {
  return new Iterator_$2(this)
};

/**
 * @override
 */
ArrayList.prototype.get = function (index) {
  if (index < 0 || index >= this.size()) {
    throw new IndexOutOfBoundsException()
  }

  return this.array_[index]
};

/**
 * @override
 */
ArrayList.prototype.isEmpty = function () {
  return this.array_.length === 0
};

/**
 * @override
 */
ArrayList.prototype.size = function () {
  return this.array_.length
};

/**
 * @override
 */
ArrayList.prototype.toArray = function () {
  const array = [];

  for (let i = 0, len = this.array_.length; i < len; i++) {
    array.push(this.array_[i]);
  }

  return array
};

/**
 * @override
 */
ArrayList.prototype.remove = function (o) {
  let found = false;

  for (let i = 0, len = this.array_.length; i < len; i++) {
    if (this.array_[i] === o) {
      this.array_.splice(i, 1);
      found = true;
      break
    }
  }

  return found
};

ArrayList.prototype.removeAll = function (c) {
  for (let i = c.iterator(); i.hasNext();) {
    this.remove(i.next());
  }
  return true
};

/**
 * @extends {Iterator}
 * @param {ArrayList} arrayList
 * @constructor
 * @private
 */
const Iterator_$2 = function (arrayList) {
  /**
   * @type {ArrayList}
   * @private
  */
  this.arrayList_ = arrayList;
  /**
   * @type {number}
   * @private
  */
  this.position_ = 0;
};

/**
 * @override
 */
Iterator_$2.prototype.next = function () {
  if (this.position_ === this.arrayList_.size()) {
    throw new NoSuchElementException()
  }
  return this.arrayList_.get(this.position_++)
};

/**
 * @override
 */
Iterator_$2.prototype.hasNext = function () {
  if (this.position_ < this.arrayList_.size()) {
    return true
  } else {
    return false
  }
};

/**
 * TODO: should be in ListIterator
 * @override
 */
Iterator_$2.prototype.set = function (element) {
  return this.arrayList_.set(this.position_ - 1, element)
};

/**
 * @override
 */
Iterator_$2.prototype.remove = function () {
  this.arrayList_.remove(this.arrayList_.get(this.position_));
};

class CoordinateList extends ArrayList {
  constructor () {
    super();
    CoordinateList.constructor_.apply(this, arguments);
  }

  getCoordinate (i) {
    return this.get(i)
  }

  addAll () {
    if (arguments.length === 2 && (typeof arguments[1] === 'boolean' && hasInterface(arguments[0], Collection))) {
      const coll = arguments[0]; const allowRepeated = arguments[1];
      let isChanged = false;
      for (let i = coll.iterator(); i.hasNext();) {
        this.add(i.next(), allowRepeated);
        isChanged = true;
      }
      return isChanged
    } else return super.addAll.apply(this, arguments)
  }

  clone () {
    const clone = super.clone.call(this);
    for (let i = 0; i < this.size(); i++) {
      clone.add(i, this.get(i).clone());
    }
    return clone
  }

  toCoordinateArray () {
    return this.toArray(CoordinateList.coordArrayType)
  }

  add () {
    if (arguments.length === 1) {
      const coord = arguments[0];
      super.add.call(this, coord);
    } else if (arguments.length === 2) {
      if (arguments[0] instanceof Array && typeof arguments[1] === 'boolean') {
        const coord = arguments[0]; const allowRepeated = arguments[1];
        this.add(coord, allowRepeated, true);
        return true
      } else if (arguments[0] instanceof Coordinate && typeof arguments[1] === 'boolean') {
        const coord = arguments[0]; const allowRepeated = arguments[1];
        if (!allowRepeated) {
          if (this.size() >= 1) {
            const last = this.get(this.size() - 1);
            if (last.equals2D(coord)) return null
          }
        }
        super.add.call(this, coord);
      } else if (arguments[0] instanceof Object && typeof arguments[1] === 'boolean') {
        const obj = arguments[0]; const allowRepeated = arguments[1];
        this.add(obj, allowRepeated);
        return true
      }
    } else if (arguments.length === 3) {
      if (typeof arguments[2] === 'boolean' && (arguments[0] instanceof Array && typeof arguments[1] === 'boolean')) {
        const coord = arguments[0]; const allowRepeated = arguments[1]; const direction = arguments[2];
        if (direction) {
          for (let i = 0; i < coord.length; i++) {
            this.add(coord[i], allowRepeated);
          }
        } else {
          for (let i = coord.length - 1; i >= 0; i--) {
            this.add(coord[i], allowRepeated);
          }
        }
        return true
      } else if (typeof arguments[2] === 'boolean' && (Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate)) {
        const i = arguments[0]; const coord = arguments[1]; const allowRepeated = arguments[2];
        if (!allowRepeated) {
          const size = this.size();
          if (size > 0) {
            if (i > 0) {
              const prev = this.get(i - 1);
              if (prev.equals2D(coord)) return null
            }
            if (i < size) {
              const next = this.get(i);
              if (next.equals2D(coord)) return null
            }
          }
        }
        super.add.call(this, i, coord);
      }
    } else if (arguments.length === 4) {
      const coord = arguments[0]; const allowRepeated = arguments[1]; const start = arguments[2]; const end = arguments[3];
      let inc = 1;
      if (start > end) inc = -1;
      for (let i = start; i !== end; i += inc) {
        this.add(coord[i], allowRepeated);
      }
      return true
    }
  }

  closeRing () {
    if (this.size() > 0) this.add(new Coordinate(this.get(0)), false);
  }

  getClass () {
    return CoordinateList
  }

  get interfaces_ () {
    return []
  }
}
CoordinateList.constructor_ = function () {
  if (arguments.length === 0) ; else if (arguments.length === 1) {
    const coord = arguments[0];
    this.ensureCapacity(coord.length);
    this.add(coord, true);
  } else if (arguments.length === 2) {
    const coord = arguments[0]; const allowRepeated = arguments[1];
    this.ensureCapacity(coord.length);
    this.add(coord, allowRepeated);
  }
};
CoordinateList.coordArrayType = new Array(0).fill(null);

class MathUtil {
  constructor () {
    MathUtil.constructor_.apply(this, arguments);
  }

  static log10 (x) {
    const ln = Math.log(x);
    if (Double.isInfinite(ln)) return ln
    if (Double.isNaN(ln)) return ln
    return ln / MathUtil.LOG_10
  }

  static min (v1, v2, v3, v4) {
    let min = v1;
    if (v2 < min) min = v2;
    if (v3 < min) min = v3;
    if (v4 < min) min = v4;
    return min
  }

  static clamp () {
    if (typeof arguments[2] === 'number' && (typeof arguments[0] === 'number' && typeof arguments[1] === 'number')) {
      const x = arguments[0]; const min = arguments[1]; const max = arguments[2];
      if (x < min) return min
      if (x > max) return max
      return x
    } else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {
      const x = arguments[0]; const min = arguments[1]; const max = arguments[2];
      if (x < min) return min
      if (x > max) return max
      return x
    }
  }

  static wrap (index, max) {
    if (index < 0) {
      return max - -index % max
    }
    return index % max
  }

  static max () {
    if (arguments.length === 3) {
      const v1 = arguments[0]; const v2 = arguments[1]; const v3 = arguments[2];
      let max = v1;
      if (v2 > max) max = v2;
      if (v3 > max) max = v3;
      return max
    } else if (arguments.length === 4) {
      const v1 = arguments[0]; const v2 = arguments[1]; const v3 = arguments[2]; const v4 = arguments[3];
      let max = v1;
      if (v2 > max) max = v2;
      if (v3 > max) max = v3;
      if (v4 > max) max = v4;
      return max
    }
  }

  static average (x1, x2) {
    return (x1 + x2) / 2.0
  }

  getClass () {
    return MathUtil
  }

  get interfaces_ () {
    return []
  }
}
MathUtil.constructor_ = function () {};
MathUtil.LOG_10 = Math.log(10);

function System () { }

System.arraycopy = (src, srcPos, dest, destPos, len) => {
  let c = 0;
  for (let i = srcPos; i < srcPos + len; i++) {
    dest[destPos + c] = src[i];
    c++;
  }
};

System.getProperty = (name) => {
  return {
    'line.separator': '\n'
  }[name]
};

class CoordinateArrays {
  constructor () {
    CoordinateArrays.constructor_.apply(this, arguments);
  }

  static isRing (pts) {
    if (pts.length < 4) return false
    if (!pts[0].equals2D(pts[pts.length - 1])) return false
    return true
  }

  static ptNotInList (testPts, pts) {
    for (let i = 0; i < testPts.length; i++) {
      const testPt = testPts[i];
      if (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt
    }
    return null
  }

  static scroll (coordinates, firstCoordinate) {
    const i = CoordinateArrays.indexOf(firstCoordinate, coordinates);
    if (i < 0) return null
    const newCoordinates = new Array(coordinates.length).fill(null);
    System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);
    System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);
    System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);
  }

  static equals () {
    if (arguments.length === 2) {
      const coord1 = arguments[0]; const coord2 = arguments[1];
      if (coord1 === coord2) return true
      if (coord1 === null || coord2 === null) return false
      if (coord1.length !== coord2.length) return false
      for (let i = 0; i < coord1.length; i++) {
        if (!coord1[i].equals(coord2[i])) return false
      }
      return true
    } else if (arguments.length === 3) {
      const coord1 = arguments[0]; const coord2 = arguments[1]; const coordinateComparator = arguments[2];
      if (coord1 === coord2) return true
      if (coord1 === null || coord2 === null) return false
      if (coord1.length !== coord2.length) return false
      for (let i = 0; i < coord1.length; i++) {
        if (coordinateComparator.compare(coord1[i], coord2[i]) !== 0) return false
      }
      return true
    }
  }

  static intersection (coordinates, env) {
    const coordList = new CoordinateList();
    for (let i = 0; i < coordinates.length; i++) {
      if (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);
    }
    return coordList.toCoordinateArray()
  }

  static hasRepeatedPoints (coord) {
    for (let i = 1; i < coord.length; i++) {
      if (coord[i - 1].equals(coord[i])) {
        return true
      }
    }
    return false
  }

  static removeRepeatedPoints (coord) {
    if (!CoordinateArrays.hasRepeatedPoints(coord)) return coord
    const coordList = new CoordinateList(coord, false);
    return coordList.toCoordinateArray()
  }

  static reverse (coord) {
    const last = coord.length - 1;
    const mid = Math.trunc(last / 2);
    for (let i = 0; i <= mid; i++) {
      const tmp = coord[i];
      coord[i] = coord[last - i];
      coord[last - i] = tmp;
    }
  }

  static removeNull (coord) {
    let nonNull = 0;
    for (let i = 0; i < coord.length; i++) {
      if (coord[i] !== null) nonNull++;
    }
    const newCoord = new Array(nonNull).fill(null);
    if (nonNull === 0) return newCoord
    let j = 0;
    for (let i = 0; i < coord.length; i++) {
      if (coord[i] !== null) newCoord[j++] = coord[i];
    }
    return newCoord
  }

  static copyDeep () {
    if (arguments.length === 1) {
      const coordinates = arguments[0];
      const copy = new Array(coordinates.length).fill(null);
      for (let i = 0; i < coordinates.length; i++) {
        copy[i] = new Coordinate(coordinates[i]);
      }
      return copy
    } else if (arguments.length === 5) {
      const src = arguments[0]; const srcStart = arguments[1]; const dest = arguments[2]; const destStart = arguments[3]; const length = arguments[4];
      for (let i = 0; i < length; i++) {
        dest[destStart + i] = new Coordinate(src[srcStart + i]);
      }
    }
  }

  static isEqualReversed (pts1, pts2) {
    for (let i = 0; i < pts1.length; i++) {
      const p1 = pts1[i];
      const p2 = pts2[pts1.length - i - 1];
      if (p1.compareTo(p2) !== 0) return false
    }
    return true
  }

  static envelope (coordinates) {
    const env = new Envelope();
    for (let i = 0; i < coordinates.length; i++) {
      env.expandToInclude(coordinates[i]);
    }
    return env
  }

  static toCoordinateArray (coordList) {
    return coordList.toArray(CoordinateArrays.coordArrayType)
  }

  static atLeastNCoordinatesOrNothing (n, c) {
    return c.length >= n ? c : []
  }

  static indexOf (coordinate, coordinates) {
    for (let i = 0; i < coordinates.length; i++) {
      if (coordinate.equals(coordinates[i])) {
        return i
      }
    }
    return -1
  }

  static increasingDirection (pts) {
    for (let i = 0; i < Math.trunc(pts.length / 2); i++) {
      const j = pts.length - 1 - i;
      const comp = pts[i].compareTo(pts[j]);
      if (comp !== 0) return comp
    }
    return 1
  }

  static compare (pts1, pts2) {
    let i = 0;
    while (i < pts1.length && i < pts2.length) {
      const compare = pts1[i].compareTo(pts2[i]);
      if (compare !== 0) return compare
      i++;
    }
    if (i < pts2.length) return -1
    if (i < pts1.length) return 1
    return 0
  }

  static minCoordinate (coordinates) {
    let minCoord = null;
    for (let i = 0; i < coordinates.length; i++) {
      if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {
        minCoord = coordinates[i];
      }
    }
    return minCoord
  }

  static extract (pts, start, end) {
    start = MathUtil.clamp(start, 0, pts.length);
    end = MathUtil.clamp(end, -1, pts.length);
    let npts = end - start + 1;
    if (end < 0) npts = 0;
    if (start >= pts.length) npts = 0;
    if (end < start) npts = 0;
    const extractPts = new Array(npts).fill(null);
    if (npts === 0) return extractPts
    let iPts = 0;
    for (let i = start; i <= end; i++) {
      extractPts[iPts++] = pts[i];
    }
    return extractPts
  }

  getClass () {
    return CoordinateArrays
  }

  get interfaces_ () {
    return []
  }
}
class ForwardComparator {
  constructor () {
    ForwardComparator.constructor_.apply(this, arguments);
  }

  compare (o1, o2) {
    const pts1 = o1;
    const pts2 = o2;
    return CoordinateArrays.compare(pts1, pts2)
  }

  getClass () {
    return ForwardComparator
  }

  get interfaces_ () {
    return [Comparator]
  }
}
ForwardComparator.constructor_ = function () {};
class BidirectionalComparator {
  constructor () {
    BidirectionalComparator.constructor_.apply(this, arguments);
  }

  compare (o1, o2) {
    const pts1 = o1;
    const pts2 = o2;
    if (pts1.length < pts2.length) return -1
    if (pts1.length > pts2.length) return 1
    if (pts1.length === 0) return 0
    const forwardComp = CoordinateArrays.compare(pts1, pts2);
    const isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);
    if (isEqualRev) return 0
    return forwardComp
  }

  OLDcompare (o1, o2) {
    const pts1 = o1;
    const pts2 = o2;
    if (pts1.length < pts2.length) return -1
    if (pts1.length > pts2.length) return 1
    if (pts1.length === 0) return 0
    const dir1 = CoordinateArrays.increasingDirection(pts1);
    const dir2 = CoordinateArrays.increasingDirection(pts2);
    let i1 = dir1 > 0 ? 0 : pts1.length - 1;
    let i2 = dir2 > 0 ? 0 : pts1.length - 1;
    for (let i = 0; i < pts1.length; i++) {
      const comparePt = pts1[i1].compareTo(pts2[i2]);
      if (comparePt !== 0) return comparePt
      i1 += dir1;
      i2 += dir2;
    }
    return 0
  }

  getClass () {
    return BidirectionalComparator
  }

  get interfaces_ () {
    return [Comparator]
  }
}
BidirectionalComparator.constructor_ = function () {};
CoordinateArrays.ForwardComparator = ForwardComparator;
CoordinateArrays.BidirectionalComparator = BidirectionalComparator;
CoordinateArrays.constructor_ = function () {};
CoordinateArrays.coordArrayType = new Array(0).fill(null);

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html
 *
 * @constructor
 * @private
 */
function Map$1 () {}
/**
 * Returns the value to which the specified key is mapped, or null if this map
 * contains no mapping for the key.
 * @param {Object} key
 * @return {Object}
 */
Map$1.prototype.get = function () {};

/**
 * Associates the specified value with the specified key in this map (optional
 * operation).
 * @param {Object} key
 * @param {Object} value
 * @return {Object}
 */
Map$1.prototype.put = function () {};

/**
 * Returns the number of key-value mappings in this map.
 * @return {number}
 */
Map$1.prototype.size = function () {};

/**
 * Returns a Collection view of the values contained in this map.
 * @return {javascript.util.Collection}
 */
Map$1.prototype.values = function () {};

/**
 * Returns a {@link Set} view of the mappings contained in this map.
 * The set is backed by the map, so changes to the map are
 * reflected in the set, and vice-versa.  If the map is modified
 * while an iteration over the set is in progress (except through
 * the iterator's own <tt>remove</tt> operation, or through the
 * <tt>setValue</tt> operation on a map entry returned by the
 * iterator) the results of the iteration are undefined.  The set
 * supports element removal, which removes the corresponding
 * mapping from the map, via the <tt>Iterator.remove</tt>,
 * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and
 * <tt>clear</tt> operations.  It does not support the
 * <tt>add</tt> or <tt>addAll</tt> operations.
 *
 * @return {Set} a set view of the mappings contained in this map
 */
Map$1.prototype.entrySet = function () {};

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html
 *
 * @extends {Map}
 * @constructor
 * @private
 */
function SortedMap () {}SortedMap.prototype = new Map$1();

/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function OperationNotSupported (message) {
  this.message = message || '';
}OperationNotSupported.prototype = new Error();

/**
 * @type {string}
 */
OperationNotSupported.prototype.name = 'OperationNotSupported';

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html
 *
 * @extends {Collection}
 * @constructor
 * @private
 */
function Set$1 () {}Set$1.prototype = new Collection();

/**
 * Returns true if this set contains the specified element. More formally,
 * returns true if and only if this set contains an element e such that (o==null ?
 * e==null : o.equals(e)).
 * @param {Object} e
 * @return {boolean}
 */
Set$1.prototype.contains = function () {};

/**
 * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html
 *
 * @extends {javascript.util.Set}
 * @constructor
 * @private
 */
function HashSet () {
  /**
   * @type {Array}
   * @private
  */
  this.array_ = [];

  if (arguments[0] instanceof Collection) {
    this.addAll(arguments[0]);
  }
}HashSet.prototype = new Set$1();

/**
 * @override
 */
HashSet.prototype.contains = function (o) {
  for (let i = 0, len = this.array_.length; i < len; i++) {
    const e = this.array_[i];
    if (e === o) {
      return true
    }
  }
  return false
};

/**
 * @override
 */
HashSet.prototype.add = function (o) {
  if (this.contains(o)) {
    return false
  }

  this.array_.push(o);

  return true
};

/**
 * @override
 */
HashSet.prototype.addAll = function (c) {
  for (let i = c.iterator(); i.hasNext();) {
    this.add(i.next());
  }
  return true
};

/**
 * @override
 */
HashSet.prototype.remove = function (o) {
  throw new OperationNotSupported()
};

/**
 * @override
 */
HashSet.prototype.size = function () {
  return this.array_.length
};

/**
 * @override
 */
HashSet.prototype.isEmpty = function () {
  return this.array_.length === 0
};

/**
 * @override
 */
HashSet.prototype.toArray = function () {
  const array = [];

  for (let i = 0, len = this.array_.length; i < len; i++) {
    array.push(this.array_[i]);
  }

  return array
};

/**
 * @override
 */
HashSet.prototype.iterator = function () {
  return new Iterator_$1(this)
};

/**
 * @extends {Iterator}
 * @param {HashSet} hashSet
 * @constructor
 * @private
 */
const Iterator_$1 = function (hashSet) {
  /**
   * @type {HashSet}
   * @private
   */
  this.hashSet_ = hashSet;
  /**
   * @type {number}
   * @private
   */
  this.position_ = 0;
};

/**
 * @override
 */
Iterator_$1.prototype.next = function () {
  if (this.position_ === this.hashSet_.size()) {
    throw new NoSuchElementException()
  }
  return this.hashSet_.array_[this.position_++]
};

/**
 * @override
 */
Iterator_$1.prototype.hasNext = function () {
  if (this.position_ < this.hashSet_.size()) {
    return true
  } else {
    return false
  }
};

/**
 * @override
 */
Iterator_$1.prototype.remove = function () {
  throw new OperationNotSupported()
};

const BLACK = 0;
const RED = 1;
function colorOf (p) { return (p == null ? BLACK : p.color) }
function parentOf (p) { return (p == null ? null : p.parent) }
function setColor (p, c) { if (p !== null) p.color = c; }
function leftOf (p) { return (p == null ? null : p.left) }
function rightOf (p) { return (p == null ? null : p.right) }

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html
 *
 * @extends {SortedMap}
 * @constructor
 * @private
 */
function TreeMap () {
  /**
   * @type {Object}
   * @private
   */
  this.root_ = null;
  /**
   * @type {number}
   * @private
  */
  this.size_ = 0;
}TreeMap.prototype = new SortedMap();

/**
 * @override
 */
TreeMap.prototype.get = function (key) {
  var p = this.root_;
  while (p !== null) {
    var cmp = key.compareTo(p.key);
    if (cmp < 0) {
      p = p.left;
    } else if (cmp > 0) {
      p = p.right;
    } else {
      return p.value
    }
  }
  return null
};

/**
 * @override
 */
TreeMap.prototype.put = function (key, value) {
  if (this.root_ === null) {
    this.root_ = {
      key: key,
      value: value,
      left: null,
      right: null,
      parent: null,
      color: BLACK,
      getValue () { return this.value },
      getKey () { return this.key }
    };
    this.size_ = 1;
    return null
  }
  var t = this.root_; var parent; var cmp;
  do {
    parent = t;
    cmp = key.compareTo(t.key);
    if (cmp < 0) {
      t = t.left;
    } else if (cmp > 0) {
      t = t.right;
    } else {
      var oldValue = t.value;
      t.value = value;
      return oldValue
    }
  } while (t !== null)
  var e = {
    key: key,
    left: null,
    right: null,
    value: value,
    parent: parent,
    color: BLACK,
    getValue () { return this.value },
    getKey () { return this.key }
  };
  if (cmp < 0) {
    parent.left = e;
  } else {
    parent.right = e;
  }
  this.fixAfterInsertion(e);
  this.size_++;
  return null
};

/**
 * @param {Object} x
 */
TreeMap.prototype.fixAfterInsertion = function (x) {
  let y;
  x.color = RED;
  while (x != null && x !== this.root_ && x.parent.color === RED) {
    if (parentOf(x) === leftOf(parentOf(parentOf(x)))) {
      y = rightOf(parentOf(parentOf(x)));
      if (colorOf(y) === RED) {
        setColor(parentOf(x), BLACK);
        setColor(y, BLACK);
        setColor(parentOf(parentOf(x)), RED);
        x = parentOf(parentOf(x));
      } else {
        if (x === rightOf(parentOf(x))) {
          x = parentOf(x);
          this.rotateLeft(x);
        }
        setColor(parentOf(x), BLACK);
        setColor(parentOf(parentOf(x)), RED);
        this.rotateRight(parentOf(parentOf(x)));
      }
    } else {
      y = leftOf(parentOf(parentOf(x)));
      if (colorOf(y) === RED) {
        setColor(parentOf(x), BLACK);
        setColor(y, BLACK);
        setColor(parentOf(parentOf(x)), RED);
        x = parentOf(parentOf(x));
      } else {
        if (x === leftOf(parentOf(x))) {
          x = parentOf(x);
          this.rotateRight(x);
        }
        setColor(parentOf(x), BLACK);
        setColor(parentOf(parentOf(x)), RED);
        this.rotateLeft(parentOf(parentOf(x)));
      }
    }
  }
  this.root_.color = BLACK;
};

/**
 * @override
 */
TreeMap.prototype.values = function () {
  var arrayList = new ArrayList();
  var p = this.getFirstEntry();
  if (p !== null) {
    arrayList.add(p.value);
    while ((p = TreeMap.successor(p)) !== null) {
      arrayList.add(p.value);
    }
  }
  return arrayList
};

/**
 * @override
 */
TreeMap.prototype.entrySet = function () {
  var hashSet = new HashSet();
  var p = this.getFirstEntry();
  if (p !== null) {
    hashSet.add(p);
    while ((p = TreeMap.successor(p)) !== null) {
      hashSet.add(p);
    }
  }
  return hashSet
};

/**
 * @param {Object} p
 */
TreeMap.prototype.rotateLeft = function (p) {
  if (p != null) {
    var r = p.right;
    p.right = r.left;
    if (r.left != null) { r.left.parent = p; }
    r.parent = p.parent;
    if (p.parent == null) { this.root_ = r; } else if (p.parent.left === p) { p.parent.left = r; } else { p.parent.right = r; }
    r.left = p;
    p.parent = r;
  }
};

/**
 * @param {Object} p
 */
TreeMap.prototype.rotateRight = function (p) {
  if (p != null) {
    var l = p.left;
    p.left = l.right;
    if (l.right != null) l.right.parent = p;
    l.parent = p.parent;
    if (p.parent == null) { this.root_ = l; } else if (p.parent.right === p) { p.parent.right = l; } else p.parent.left = l;
    l.right = p;
    p.parent = l;
  }
};

/**
 * @return {Object}
 */
TreeMap.prototype.getFirstEntry = function () {
  var p = this.root_;
  if (p != null) {
    while (p.left != null) {
      p = p.left;
    }
  }
  return p
};

/**
 * @param {Object} t
 * @return {Object}
 * @private
 */
TreeMap.successor = function (t) {
  let p;
  if (t === null) { return null } else if (t.right !== null) {
    p = t.right;
    while (p.left !== null) {
      p = p.left;
    }
    return p
  } else {
    p = t.parent;
    var ch = t;
    while (p !== null && ch === p.right) {
      ch = p;
      p = p.parent;
    }
    return p
  }
};

/**
 * @override
 */
TreeMap.prototype.size = function () {
  return this.size_
};

TreeMap.prototype.containsKey = function (key) {
  var p = this.root_;
  while (p !== null) {
    var cmp = key.compareTo(p.key);
    if (cmp < 0) {
      p = p.left;
    } else if (cmp > 0) {
      p = p.right;
    } else {
      return true
    }
  }
  return false
};

class Lineal {
  constructor () {
    Lineal.constructor_.apply(this, arguments);
  }

  getClass () {
    return Lineal
  }

  get interfaces_ () {
    return []
  }
}
Lineal.constructor_ = function () {};

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html
 *
 * @extends {Set}
 * @constructor
 * @private
 */
function SortedSet () {}SortedSet.prototype = new Set$1();

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html
 *
 * @extends {SortedSet}
 * @constructor
 * @private
 */
function TreeSet () {
  /**
   * @type {Array}
   * @private
  */
  this.array_ = [];

  if (arguments[0] instanceof Collection) {
    this.addAll(arguments[0]);
  }
}TreeSet.prototype = new SortedSet();

/**
 * @override
 */
TreeSet.prototype.contains = function (o) {
  for (let i = 0, len = this.array_.length; i < len; i++) {
    const e = this.array_[i];
    if (e.compareTo(o) === 0) {
      return true
    }
  }
  return false
};

/**
 * @override
 */
TreeSet.prototype.add = function (o) {
  if (this.contains(o)) {
    return false
  }

  for (let i = 0, len = this.array_.length; i < len; i++) {
    const e = this.array_[i];
    if (e.compareTo(o) === 1) {
      this.array_.splice(i, 0, o);
      return true
    }
  }

  this.array_.push(o);

  return true
};

/**
 * @override
 */
TreeSet.prototype.addAll = function (c) {
  for (let i = c.iterator(); i.hasNext();) {
    this.add(i.next());
  }
  return true
};

/**
 * @override
 */
TreeSet.prototype.remove = function (e) {
  throw new OperationNotSupported()
};

/**
 * @override
 */
TreeSet.prototype.size = function () {
  return this.array_.length
};

/**
 * @override
 */
TreeSet.prototype.isEmpty = function () {
  return this.array_.length === 0
};

/**
 * @override
 */
TreeSet.prototype.toArray = function () {
  const array = [];

  for (let i = 0, len = this.array_.length; i < len; i++) {
    array.push(this.array_[i]);
  }

  return array
};

/**
 * @override
 */
TreeSet.prototype.iterator = function () {
  return new Iterator_(this)
};

/**
 * @extends {javascript.util.Iterator}
 * @param {javascript.util.TreeSet} treeSet
 * @constructor
 * @private
 */
const Iterator_ = function (treeSet) {
  /**
   * @type {javascript.util.TreeSet}
   * @private
   */
  this.treeSet_ = treeSet;
  /**
   * @type {number}
   * @private
   */
  this.position_ = 0;
};

/**
 * @override
 */
Iterator_.prototype.next = function () {
  if (this.position_ === this.treeSet_.size()) {
    throw new NoSuchElementException()
  }
  return this.treeSet_.array_[this.position_++]
};

/**
 * @override
 */
Iterator_.prototype.hasNext = function () {
  if (this.position_ < this.treeSet_.size()) {
    return true
  } else {
    return false
  }
};

/**
 * @override
 */
Iterator_.prototype.remove = function () {
  throw new OperationNotSupported()
};

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html
 *
 * @constructor
 * @private
 */
function Arrays () {}
/**
 */
Arrays.sort = function () {
  const a = arguments[0]; let i; let t; let comparator; let compare;
  if (arguments.length === 1) {
    compare = function (a, b) {
      return a.compareTo(b)
    };
    a.sort(compare);
  } else if (arguments.length === 2) {
    comparator = arguments[1];
    compare = function (a, b) {
      return comparator.compare(a, b)
    };
    a.sort(compare);
  } else if (arguments.length === 3) {
    t = a.slice(arguments[1], arguments[2]);
    t.sort();
    const r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
    a.splice(0, a.length);
    for (i = 0; i < r.length; i++) {
      a.push(r[i]);
    }
  } else if (arguments.length === 4) {
    t = a.slice(arguments[1], arguments[2]);
    comparator = arguments[3];
    compare = function (a, b) {
      return comparator.compare(a, b)
    };
    t.sort(compare);
    const r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
    a.splice(0, a.length);
    for (i = 0; i < r.length; i++) {
      a.push(r[i]);
    }
  }
};

/**
 * @param {Array} array
 * @return {ArrayList}
 */
Arrays.asList = function (array) {
  const arrayList = new ArrayList();
  for (let i = 0, len = array.length; i < len; i++) {
    arrayList.add(array[i]);
  }
  return arrayList
};

function Character () {}
Character.isWhitespace = c => ((c <= 32 && c >= 0) || c === 127);
Character.toUpperCase = c => c.toUpperCase();

class Dimension {
  constructor () {
    Dimension.constructor_.apply(this, arguments);
  }

  static toDimensionSymbol (dimensionValue) {
    switch (dimensionValue) {
      case Dimension.FALSE:
        return Dimension.SYM_FALSE
      case Dimension.TRUE:
        return Dimension.SYM_TRUE
      case Dimension.DONTCARE:
        return Dimension.SYM_DONTCARE
      case Dimension.P:
        return Dimension.SYM_P
      case Dimension.L:
        return Dimension.SYM_L
      case Dimension.A:
        return Dimension.SYM_A
    }
    throw new IllegalArgumentException('Unknown dimension value: ' + dimensionValue)
  }

  static toDimensionValue (dimensionSymbol) {
    switch (Character.toUpperCase(dimensionSymbol)) {
      case Dimension.SYM_FALSE:
        return Dimension.FALSE
      case Dimension.SYM_TRUE:
        return Dimension.TRUE
      case Dimension.SYM_DONTCARE:
        return Dimension.DONTCARE
      case Dimension.SYM_P:
        return Dimension.P
      case Dimension.SYM_L:
        return Dimension.L
      case Dimension.SYM_A:
        return Dimension.A
    }
    throw new IllegalArgumentException('Unknown dimension symbol: ' + dimensionSymbol)
  }

  getClass () {
    return Dimension
  }

  get interfaces_ () {
    return []
  }
}
Dimension.constructor_ = function () {};
Dimension.P = 0;
Dimension.L = 1;
Dimension.A = 2;
Dimension.FALSE = -1;
Dimension.TRUE = -2;
Dimension.DONTCARE = -3;
Dimension.SYM_FALSE = 'F';
Dimension.SYM_TRUE = 'T';
Dimension.SYM_DONTCARE = '*';
Dimension.SYM_P = '0';
Dimension.SYM_L = '1';
Dimension.SYM_A = '2';

class GeometryFilter {
  constructor () {
    GeometryFilter.constructor_.apply(this, arguments);
  }

  filter (geom) {}
  getClass () {
    return GeometryFilter
  }

  get interfaces_ () {
    return []
  }
}
GeometryFilter.constructor_ = function () {};

class CoordinateSequenceFilter {
  constructor () {
    CoordinateSequenceFilter.constructor_.apply(this, arguments);
  }

  filter (seq, i) {}
  isDone () {}
  isGeometryChanged () {}
  getClass () {
    return CoordinateSequenceFilter
  }

  get interfaces_ () {
    return []
  }
}
CoordinateSequenceFilter.constructor_ = function () {};

class GeometryCollection extends Geometry {
  constructor () {
    super();
    GeometryCollection.constructor_.apply(this, arguments);
  }

  computeEnvelopeInternal () {
    const envelope = new Envelope();
    for (let i = 0; i < this._geometries.length; i++) {
      envelope.expandToInclude(this._geometries[i].getEnvelopeInternal());
    }
    return envelope
  }

  getGeometryN (n) {
    return this._geometries[n]
  }

  getCoordinates () {
    const coordinates = new Array(this.getNumPoints()).fill(null);
    let k = -1;
    for (let i = 0; i < this._geometries.length; i++) {
      const childCoordinates = this._geometries[i].getCoordinates();
      for (let j = 0; j < childCoordinates.length; j++) {
        k++;
        coordinates[k] = childCoordinates[j];
      }
    }
    return coordinates
  }

  getArea () {
    let area = 0.0;
    for (let i = 0; i < this._geometries.length; i++) {
      area += this._geometries[i].getArea();
    }
    return area
  }

  equalsExact () {
    if (arguments.length === 2 && (typeof arguments[1] === 'number' && arguments[0] instanceof Geometry)) {
      const other = arguments[0]; const tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false
      }
      const otherCollection = other;
      if (this._geometries.length !== otherCollection._geometries.length) {
        return false
      }
      for (let i = 0; i < this._geometries.length; i++) {
        if (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {
          return false
        }
      }
      return true
    } else return super.equalsExact.apply(this, arguments)
  }

  normalize () {
    for (let i = 0; i < this._geometries.length; i++) {
      this._geometries[i].normalize();
    }
    Arrays.sort(this._geometries);
  }

  getCoordinate () {
    if (this.isEmpty()) return null
    return this._geometries[0].getCoordinate()
  }

  getBoundaryDimension () {
    let dimension = Dimension.FALSE;
    for (let i = 0; i < this._geometries.length; i++) {
      dimension = Math.max(dimension, this._geometries[i].getBoundaryDimension());
    }
    return dimension
  }

  getTypeCode () {
    return Geometry.TYPECODE_GEOMETRYCOLLECTION
  }

  getDimension () {
    let dimension = Dimension.FALSE;
    for (let i = 0; i < this._geometries.length; i++) {
      dimension = Math.max(dimension, this._geometries[i].getDimension());
    }
    return dimension
  }

  getLength () {
    let sum = 0.0;
    for (let i = 0; i < this._geometries.length; i++) {
      sum += this._geometries[i].getLength();
    }
    return sum
  }

  getNumPoints () {
    let numPoints = 0;
    for (let i = 0; i < this._geometries.length; i++) {
      numPoints += this._geometries[i].getNumPoints();
    }
    return numPoints
  }

  getNumGeometries () {
    return this._geometries.length
  }

  reverse () {
    const n = this._geometries.length;
    const revGeoms = new Array(n).fill(null);
    for (let i = 0; i < this._geometries.length; i++) {
      revGeoms[i] = this._geometries[i].reverse();
    }
    return this.getFactory().createGeometryCollection(revGeoms)
  }

  compareToSameClass () {
    if (arguments.length === 1) {
      const o = arguments[0];
      const theseElements = new TreeSet(Arrays.asList(this._geometries));
      const otherElements = new TreeSet(Arrays.asList(o._geometries));
      return this.compare(theseElements, otherElements)
    } else if (arguments.length === 2) {
      const o = arguments[0]; const comp = arguments[1];
      const gc = o;
      const n1 = this.getNumGeometries();
      const n2 = gc.getNumGeometries();
      let i = 0;
      while (i < n1 && i < n2) {
        const thisGeom = this.getGeometryN(i);
        const otherGeom = gc.getGeometryN(i);
        const holeComp = thisGeom.compareToSameClass(otherGeom, comp);
        if (holeComp !== 0) return holeComp
        i++;
      }
      if (i < n1) return 1
      if (i < n2) return -1
      return 0
    }
  }

  apply () {
    if (hasInterface(arguments[0], CoordinateFilter)) {
      const filter = arguments[0];
      for (let i = 0; i < this._geometries.length; i++) {
        this._geometries[i].apply(filter);
      }
    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
      const filter = arguments[0];
      if (this._geometries.length === 0) return null
      for (let i = 0; i < this._geometries.length; i++) {
        this._geometries[i].apply(filter);
        if (filter.isDone()) {
          break
        }
      }
      if (filter.isGeometryChanged()) this.geometryChanged();
    } else if (hasInterface(arguments[0], GeometryFilter)) {
      const filter = arguments[0];
      filter.filter(this);
      for (let i = 0; i < this._geometries.length; i++) {
        this._geometries[i].apply(filter);
      }
    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
      const filter = arguments[0];
      filter.filter(this);
      for (let i = 0; i < this._geometries.length; i++) {
        this._geometries[i].apply(filter);
      }
    }
  }

  getBoundary () {
    this.checkNotGeometryCollection(this);
    Assert.shouldNeverReachHere();
    return null
  }

  getGeometryType () {
    return Geometry.TYPENAME_GEOMETRYCOLLECTION
  }

  copy () {
    const geometries = new Array(this._geometries.length).fill(null);
    for (let i = 0; i < geometries.length; i++) {
      geometries[i] = this._geometries[i].copy();
    }
    return new GeometryCollection(geometries, this._factory)
  }

  isEmpty () {
    for (let i = 0; i < this._geometries.length; i++) {
      if (!this._geometries[i].isEmpty()) {
        return false
      }
    }
    return true
  }

  getClass () {
    return GeometryCollection
  }

  get interfaces_ () {
    return []
  }
}
GeometryCollection.constructor_ = function () {
  this._geometries = null;
  if (arguments.length === 0) ; else if (arguments.length === 2) {
    let geometries = arguments[0]; const factory = arguments[1];
    Geometry.constructor_.call(this, factory);
    if (geometries === null) {
      geometries = [];
    }
    if (Geometry.hasNullElements(geometries)) {
      throw new IllegalArgumentException('geometries must not contain null elements')
    }
    this._geometries = geometries;
  }
};
GeometryCollection.serialVersionUID = -5694727726395021467;

class MultiLineString extends GeometryCollection {
  constructor () {
    super();
    MultiLineString.constructor_.apply(this, arguments);
  }

  equalsExact () {
    if (arguments.length === 2 && (typeof arguments[1] === 'number' && arguments[0] instanceof Geometry)) {
      const other = arguments[0]; const tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false
      }
      return super.equalsExact.call(this, other, tolerance)
    } else return super.equalsExact.apply(this, arguments)
  }

  getBoundaryDimension () {
    if (this.isClosed()) {
      return Dimension.FALSE
    }
    return 0
  }

  isClosed () {
    if (this.isEmpty()) {
      return false
    }
    for (let i = 0; i < this._geometries.length; i++) {
      if (!this._geometries[i].isClosed()) {
        return false
      }
    }
    return true
  }

  getTypeCode () {
    return Geometry.TYPECODE_MULTILINESTRING
  }

  getDimension () {
    return 1
  }

  reverse () {
    const nLines = this._geometries.length;
    const revLines = new Array(nLines).fill(null);
    for (let i = 0; i < this._geometries.length; i++) {
      revLines[nLines - 1 - i] = this._geometries[i].reverse();
    }
    return this.getFactory().createMultiLineString(revLines)
  }

  getBoundary () {
    return new BoundaryOp(this).getBoundary()
  }

  getGeometryType () {
    return Geometry.TYPENAME_MULTILINESTRING
  }

  copy () {
    const lineStrings = new Array(this._geometries.length).fill(null);
    for (let i = 0; i < lineStrings.length; i++) {
      lineStrings[i] = this._geometries[i].copy();
    }
    return new MultiLineString(lineStrings, this._factory)
  }

  getClass () {
    return MultiLineString
  }

  get interfaces_ () {
    return [Lineal]
  }
}
MultiLineString.constructor_ = function () {
  const lineStrings = arguments[0]; const factory = arguments[1];
  GeometryCollection.constructor_.call(this, lineStrings, factory);
};
MultiLineString.serialVersionUID = 8166665132445433741;

class BoundaryOp {
  constructor () {
    BoundaryOp.constructor_.apply(this, arguments);
  }

  static getBoundary () {
    if (arguments.length === 1) {
      const g = arguments[0];
      const bop = new BoundaryOp(g);
      return bop.getBoundary()
    } else if (arguments.length === 2) {
      const g = arguments[0]; const bnRule = arguments[1];
      const bop = new BoundaryOp(g, bnRule);
      return bop.getBoundary()
    }
  }

  boundaryMultiLineString (mLine) {
    if (this._geom.isEmpty()) {
      return this.getEmptyMultiPoint()
    }
    const bdyPts = this.computeBoundaryCoordinates(mLine);
    if (bdyPts.length === 1) {
      return this._geomFact.createPoint(bdyPts[0])
    }
    return this._geomFact.createMultiPointFromCoords(bdyPts)
  }

  getBoundary () {
    if (this._geom instanceof LineString) return this.boundaryLineString(this._geom)
    if (this._geom instanceof MultiLineString) return this.boundaryMultiLineString(this._geom)
    return this._geom.getBoundary()
  }

  boundaryLineString (line) {
    if (this._geom.isEmpty()) {
      return this.getEmptyMultiPoint()
    }
    if (line.isClosed()) {
      const closedEndpointOnBoundary = this._bnRule.isInBoundary(2);
      if (closedEndpointOnBoundary) {
        return line.getStartPoint()
      } else {
        return this._geomFact.createMultiPoint()
      }
    }
    return this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()])
  }

  getEmptyMultiPoint () {
    return this._geomFact.createMultiPoint()
  }

  computeBoundaryCoordinates (mLine) {
    const bdyPts = new ArrayList();
    this._endpointMap = new TreeMap();
    for (let i = 0; i < mLine.getNumGeometries(); i++) {
      const line = mLine.getGeometryN(i);
      if (line.getNumPoints() === 0) continue
      this.addEndpoint(line.getCoordinateN(0));
      this.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));
    }
    for (let it = this._endpointMap.entrySet().iterator(); it.hasNext();) {
      const entry = it.next();
      const counter = entry.getValue();
      const valence = counter.count;
      if (this._bnRule.isInBoundary(valence)) {
        bdyPts.add(entry.getKey());
      }
    }
    return CoordinateArrays.toCoordinateArray(bdyPts)
  }

  addEndpoint (pt) {
    let counter = this._endpointMap.get(pt);
    if (counter === null) {
      counter = new Counter();
      this._endpointMap.put(pt, counter);
    }
    counter.count++;
  }

  getClass () {
    return BoundaryOp
  }

  get interfaces_ () {
    return []
  }
}
BoundaryOp.constructor_ = function () {
  this._geom = null;
  this._geomFact = null;
  this._bnRule = null;
  this._endpointMap = null;
  if (arguments.length === 1) {
    const geom = arguments[0];
    BoundaryOp.constructor_.call(this, geom, BoundaryNodeRule.MOD2_BOUNDARY_RULE);
  } else if (arguments.length === 2) {
    const geom = arguments[0]; const bnRule = arguments[1];
    this._geom = geom;
    this._geomFact = geom.getFactory();
    this._bnRule = bnRule;
  }
};
class Counter {
  constructor () {
    Counter.constructor_.apply(this, arguments);
  }

  getClass () {
    return Counter
  }

  get interfaces_ () {
    return []
  }
}
Counter.constructor_ = function () {
  this.count = null;
};

class Length {
  constructor () {
    Length.constructor_.apply(this, arguments);
  }

  static ofLine (pts) {
    const n = pts.size();
    if (n <= 1) return 0.0
    let len = 0.0;
    const p = new Coordinate();
    pts.getCoordinate(0, p);
    let x0 = p.x;
    let y0 = p.y;
    for (let i = 1; i < n; i++) {
      pts.getCoordinate(i, p);
      const x1 = p.x;
      const y1 = p.y;
      const dx = x1 - x0;
      const dy = y1 - y0;
      len += Math.sqrt(dx * dx + dy * dy);
      x0 = x1;
      y0 = y1;
    }
    return len
  }

  getClass () {
    return Length
  }

  get interfaces_ () {
    return []
  }
}
Length.constructor_ = function () {};

function PrintStream () {}

function StringReader () {}

function DecimalFormat () {}

function ByteArrayOutputStream () {}

function IOException () {}

function LineNumberReader () {}

class StringUtil {
  constructor () {
    StringUtil.constructor_.apply(this, arguments);
  }

  static chars (c, n) {
    const ch = new Array(n).fill(null);
    for (let i = 0; i < n; i++) {
      ch[i] = c;
    }
    return new String(ch)
  }

  static getStackTrace () {
    if (arguments.length === 1) {
      const t = arguments[0];
      const os = new ByteArrayOutputStream();
      const ps = new PrintStream(os);
      t.printStackTrace(ps);
      return os.toString()
    } else if (arguments.length === 2) {
      const t = arguments[0]; const depth = arguments[1];
      let stackTrace = '';
      const stringReader = new StringReader(StringUtil.getStackTrace(t));
      const lineNumberReader = new LineNumberReader(stringReader);
      for (let i = 0; i < depth; i++) {
        try {
          stackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;
        } catch (e) {
          if (e instanceof IOException) {
            Assert.shouldNeverReachHere();
          } else throw e
        } finally {}
      }
      return stackTrace
    }
  }

  static split (s, separator) {
    const separatorlen = separator.length;
    const tokenList = new ArrayList();
    let tmpString = '' + s;
    let pos = tmpString.indexOf(separator);
    while (pos >= 0) {
      const token = tmpString.substring(0, pos);
      tokenList.add(token);
      tmpString = tmpString.substring(pos + separatorlen);
      pos = tmpString.indexOf(separator);
    }
    if (tmpString.length > 0) tokenList.add(tmpString);
    const res = new Array(tokenList.size()).fill(null);
    for (let i = 0; i < res.length; i++) {
      res[i] = tokenList.get(i);
    }
    return res
  }

  static toString () {
    if (arguments.length === 1 && typeof arguments[0] === 'number') {
      const d = arguments[0];
      return StringUtil.SIMPLE_ORDINATE_FORMAT.format(d)
    }
  }

  static spaces (n) {
    return StringUtil.chars(' ', n)
  }

  getClass () {
    return StringUtil
  }

  get interfaces_ () {
    return []
  }
}
StringUtil.constructor_ = function () {};
StringUtil.NEWLINE = System.getProperty('line.separator');
StringUtil.SIMPLE_ORDINATE_FORMAT = new DecimalFormat('0.#');

function StringBuilder (str) {
  this.str = str;
}

StringBuilder.prototype.append = function (e) {
  this.str += e;
};

StringBuilder.prototype.setCharAt = function (i, c) {
  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);
};

StringBuilder.prototype.toString = function (e) {
  return this.str
};

class CoordinateSequences {
  constructor () {
    CoordinateSequences.constructor_.apply(this, arguments);
  }

  static copyCoord (src, srcPos, dest, destPos) {
    const minDim = Math.min(src.getDimension(), dest.getDimension());
    for (let dim = 0; dim < minDim; dim++) {
      dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));
    }
  }

  static isRing (seq) {
    const n = seq.size();
    if (n === 0) return true
    if (n <= 3) return false
    return seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y)
  }

  static isEqual (cs1, cs2) {
    const cs1Size = cs1.size();
    const cs2Size = cs2.size();
    if (cs1Size !== cs2Size) return false
    const dim = Math.min(cs1.getDimension(), cs2.getDimension());
    for (let i = 0; i < cs1Size; i++) {
      for (let d = 0; d < dim; d++) {
        const v1 = cs1.getOrdinate(i, d);
        const v2 = cs2.getOrdinate(i, d);
        if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue
        if (Double.isNaN(v1) && Double.isNaN(v2)) continue
        return false
      }
    }
    return true
  }

  static extend (fact, seq, size) {
    const newseq = fact.create(size, seq.getDimension());
    const n = seq.size();
    CoordinateSequences.copy(seq, 0, newseq, 0, n);
    if (n > 0) {
      for (let i = n; i < size; i++) CoordinateSequences.copy(seq, n - 1, newseq, i, 1);
    }
    return newseq
  }

  static reverse (seq) {
    const last = seq.size() - 1;
    const mid = Math.trunc(last / 2);
    for (let i = 0; i <= mid; i++) {
      CoordinateSequences.swap(seq, i, last - i);
    }
  }

  static swap (seq, i, j) {
    if (i === j) return null
    for (let dim = 0; dim < seq.getDimension(); dim++) {
      const tmp = seq.getOrdinate(i, dim);
      seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));
      seq.setOrdinate(j, dim, tmp);
    }
  }

  static copy (src, srcPos, dest, destPos, length) {
    for (let i = 0; i < length; i++) {
      CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);
    }
  }

  static toString () {
    if (arguments.length === 1 && hasInterface(arguments[0], CoordinateSequence)) {
      const cs = arguments[0];
      const size = cs.size();
      if (size === 0) return '()'
      const dim = cs.getDimension();
      const builder = new StringBuilder();
      builder.append('(');
      for (let i = 0; i < size; i++) {
        if (i > 0) builder.append(' ');
        for (let d = 0; d < dim; d++) {
          if (d > 0) builder.append(',');
          builder.append(StringUtil.toString(cs.getOrdinate(i, d)));
        }
      }
      builder.append(')');
      return builder.toString()
    }
  }

  static ensureValidRing (fact, seq) {
    const n = seq.size();
    if (n === 0) return seq
    if (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4)
    const isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);
    if (isClosed) return seq
    return CoordinateSequences.createClosedRing(fact, seq, n + 1)
  }

  static createClosedRing (fact, seq, size) {
    const newseq = fact.create(size, seq.getDimension());
    const n = seq.size();
    CoordinateSequences.copy(seq, 0, newseq, 0, n);
    for (let i = n; i < size; i++) CoordinateSequences.copy(seq, 0, newseq, i, 1);
    return newseq
  }

  getClass () {
    return CoordinateSequences
  }

  get interfaces_ () {
    return []
  }
}
CoordinateSequences.constructor_ = function () {};

class LineString extends Geometry {
  constructor () {
    super();
    LineString.constructor_.apply(this, arguments);
  }

  computeEnvelopeInternal () {
    if (this.isEmpty()) {
      return new Envelope()
    }
    return this._points.expandEnvelope(new Envelope())
  }

  isRing () {
    return this.isClosed() && this.isSimple()
  }

  getCoordinates () {
    return this._points.toCoordinateArray()
  }

  equalsExact () {
    if (arguments.length === 2 && (typeof arguments[1] === 'number' && arguments[0] instanceof Geometry)) {
      const other = arguments[0]; const tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false
      }
      const otherLineString = other;
      if (this._points.size() !== otherLineString._points.size()) {
        return false
      }
      for (let i = 0; i < this._points.size(); i++) {
        if (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {
          return false
        }
      }
      return true
    } else return super.equalsExact.apply(this, arguments)
  }

  normalize () {
    for (let i = 0; i < Math.trunc(this._points.size() / 2); i++) {
      const j = this._points.size() - 1 - i;
      if (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {
        if (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {
          const copy = this._points.copy();
          CoordinateSequences.reverse(copy);
          this._points = copy;
        }
        return null
      }
    }
  }

  getCoordinate () {
    if (this.isEmpty()) return null
    return this._points.getCoordinate(0)
  }

  getBoundaryDimension () {
    if (this.isClosed()) {
      return Dimension.FALSE
    }
    return 0
  }

  isClosed () {
    if (this.isEmpty()) {
      return false
    }
    return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))
  }

  getEndPoint () {
    if (this.isEmpty()) {
      return null
    }
    return this.getPointN(this.getNumPoints() - 1)
  }

  getTypeCode () {
    return Geometry.TYPECODE_LINESTRING
  }

  getDimension () {
    return 1
  }

  getLength () {
    return Length.ofLine(this._points)
  }

  getNumPoints () {
    return this._points.size()
  }

  reverse () {
    const seq = this._points.copy();
    CoordinateSequences.reverse(seq);
    const revLine = this.getFactory().createLineString(seq);
    return revLine
  }

  compareToSameClass () {
    if (arguments.length === 1) {
      const o = arguments[0];
      const line = o;
      let i = 0;
      let j = 0;
      while (i < this._points.size() && j < line._points.size()) {
        const comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));
        if (comparison !== 0) {
          return comparison
        }
        i++;
        j++;
      }
      if (i < this._points.size()) {
        return 1
      }
      if (j < line._points.size()) {
        return -1
      }
      return 0
    } else if (arguments.length === 2) {
      const o = arguments[0]; const comp = arguments[1];
      const line = o;
      return comp.compare(this._points, line._points)
    }
  }

  apply () {
    if (hasInterface(arguments[0], CoordinateFilter)) {
      const filter = arguments[0];
      for (let i = 0; i < this._points.size(); i++) {
        filter.filter(this._points.getCoordinate(i));
      }
    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
      const filter = arguments[0];
      if (this._points.size() === 0) return null
      for (let i = 0; i < this._points.size(); i++) {
        filter.filter(this._points, i);
        if (filter.isDone()) break
      }
      if (filter.isGeometryChanged()) this.geometryChanged();
    } else if (hasInterface(arguments[0], GeometryFilter)) {
      const filter = arguments[0];
      filter.filter(this);
    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
      const filter = arguments[0];
      filter.filter(this);
    }
  }

  getBoundary () {
    return new BoundaryOp(this).getBoundary()
  }

  isEquivalentClass (other) {
    return other instanceof LineString
  }

  getCoordinateN (n) {
    return this._points.getCoordinate(n)
  }

  getGeometryType () {
    return Geometry.TYPENAME_LINESTRING
  }

  copy () {
    return new LineString(this._points.copy(), this._factory)
  }

  getCoordinateSequence () {
    return this._points
  }

  isEmpty () {
    return this._points.size() === 0
  }

  init (points) {
    if (points === null) {
      points = this.getFactory().getCoordinateSequenceFactory().create([]);
    }
    if (points.size() === 1) {
      throw new IllegalArgumentException('Invalid number of points in LineString (found ' + points.size() + ' - must be 0 or >= 2)')
    }
    this._points = points;
  }

  isCoordinate (pt) {
    for (let i = 0; i < this._points.size(); i++) {
      if (this._points.getCoordinate(i).equals(pt)) {
        return true
      }
    }
    return false
  }

  getStartPoint () {
    if (this.isEmpty()) {
      return null
    }
    return this.getPointN(0)
  }

  getPointN (n) {
    return this.getFactory().createPoint(this._points.getCoordinate(n))
  }

  getClass () {
    return LineString
  }

  get interfaces_ () {
    return [Lineal]
  }
}
LineString.constructor_ = function () {
  this._points = null;
  if (arguments.length === 0) ; else if (arguments.length === 2) {
    const points = arguments[0]; const factory = arguments[1];
    Geometry.constructor_.call(this, factory);
    this.init(points);
  }
};
LineString.serialVersionUID = 3110669828065365560;

class Puntal {
  constructor () {
    Puntal.constructor_.apply(this, arguments);
  }

  getClass () {
    return Puntal
  }

  get interfaces_ () {
    return []
  }
}
Puntal.constructor_ = function () {};

class Point extends Geometry {
  constructor () {
    super();
    Point.constructor_.apply(this, arguments);
  }

  computeEnvelopeInternal () {
    if (this.isEmpty()) {
      return new Envelope()
    }
    const env = new Envelope();
    env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));
    return env
  }

  getCoordinates () {
    return this.isEmpty() ? [] : [this.getCoordinate()]
  }

  equalsExact () {
    if (arguments.length === 2 && (typeof arguments[1] === 'number' && arguments[0] instanceof Geometry)) {
      const other = arguments[0]; const tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false
      }
      if (this.isEmpty() && other.isEmpty()) {
        return true
      }
      if (this.isEmpty() !== other.isEmpty()) {
        return false
      }
      return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance)
    } else return super.equalsExact.apply(this, arguments)
  }

  normalize () {}
  getCoordinate () {
    return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null
  }

  getBoundaryDimension () {
    return Dimension.FALSE
  }

  getTypeCode () {
    return Geometry.TYPECODE_POINT
  }

  getDimension () {
    return 0
  }

  getNumPoints () {
    return this.isEmpty() ? 0 : 1
  }

  reverse () {
    return this.copy()
  }

  getX () {
    if (this.getCoordinate() === null) {
      throw new IllegalStateException('getX called on empty Point')
    }
    return this.getCoordinate().x
  }

  compareToSameClass () {
    if (arguments.length === 1) {
      const other = arguments[0];
      const point = other;
      return this.getCoordinate().compareTo(point.getCoordinate())
    } else if (arguments.length === 2) {
      const other = arguments[0]; const comp = arguments[1];
      const point = other;
      return comp.compare(this._coordinates, point._coordinates)
    }
  }

  apply () {
    if (hasInterface(arguments[0], CoordinateFilter)) {
      const filter = arguments[0];
      if (this.isEmpty()) {
        return null
      }
      filter.filter(this.getCoordinate());
    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
      const filter = arguments[0];
      if (this.isEmpty()) return null
      filter.filter(this._coordinates, 0);
      if (filter.isGeometryChanged()) this.geometryChanged();
    } else if (hasInterface(arguments[0], GeometryFilter)) {
      const filter = arguments[0];
      filter.filter(this);
    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
      const filter = arguments[0];
      filter.filter(this);
    }
  }

  getBoundary () {
    return this.getFactory().createGeometryCollection()
  }

  getGeometryType () {
    return Geometry.TYPENAME_POINT
  }

  copy () {
    return new Point(this._coordinates.copy(), this._factory)
  }

  getCoordinateSequence () {
    return this._coordinates
  }

  getY () {
    if (this.getCoordinate() === null) {
      throw new IllegalStateException('getY called on empty Point')
    }
    return this.getCoordinate().y
  }

  isEmpty () {
    return this._coordinates.size() === 0
  }

  init (coordinates) {
    if (coordinates === null) {
      coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);
    }
    Assert.isTrue(coordinates.size() <= 1);
    this._coordinates = coordinates;
  }

  isSimple () {
    return true
  }

  getClass () {
    return Point
  }

  get interfaces_ () {
    return [Puntal]
  }
}
Point.constructor_ = function () {
  this._coordinates = null;
  const coordinates = arguments[0]; const factory = arguments[1];
  Geometry.constructor_.call(this, factory);
  this.init(coordinates);
};
Point.serialVersionUID = 4902022702746614570;

class Area {
  constructor () {
    Area.constructor_.apply(this, arguments);
  }

  static ofRing () {
    if (arguments[0] instanceof Array) {
      const ring = arguments[0];
      return Math.abs(Area.ofRingSigned(ring))
    } else if (hasInterface(arguments[0], CoordinateSequence)) {
      const ring = arguments[0];
      return Math.abs(Area.ofRingSigned(ring))
    }
  }

  static ofRingSigned () {
    if (arguments[0] instanceof Array) {
      const ring = arguments[0];
      if (ring.length < 3) return 0.0
      let sum = 0.0;
      const x0 = ring[0].x;
      for (let i = 1; i < ring.length - 1; i++) {
        const x = ring[i].x - x0;
        const y1 = ring[i + 1].y;
        const y2 = ring[i - 1].y;
        sum += x * (y2 - y1);
      }
      return sum / 2.0
    } else if (hasInterface(arguments[0], CoordinateSequence)) {
      const ring = arguments[0];
      const n = ring.size();
      if (n < 3) return 0.0
      const p0 = new Coordinate();
      const p1 = new Coordinate();
      const p2 = new Coordinate();
      ring.getCoordinate(0, p1);
      ring.getCoordinate(1, p2);
      const x0 = p1.x;
      p2.x -= x0;
      let sum = 0.0;
      for (let i = 1; i < n - 1; i++) {
        p0.y = p1.y;
        p1.x = p2.x;
        p1.y = p2.y;
        ring.getCoordinate(i + 1, p2);
        p2.x -= x0;
        sum += p1.x * (p0.y - p2.y);
      }
      return sum / 2.0
    }
  }

  getClass () {
    return Area
  }

  get interfaces_ () {
    return []
  }
}
Area.constructor_ = function () {};

function StringBuffer (str) {
  this.str = str;
}

StringBuffer.prototype.append = function (e) {
  this.str += e;
};

StringBuffer.prototype.setCharAt = function (i, c) {
  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);
};

StringBuffer.prototype.toString = function (e) {
  return this.str
};

function Integer (value) {
  this.value = value;
}

Integer.prototype.intValue = function () {
  return this.value
};
Integer.prototype.compareTo = function (o) {
  if (this.value < o) return -1
  if (this.value > o) return 1
  return 0
};

Integer.isNaN = n => Number.isNaN(n);

class DD {
  constructor () {
    DD.constructor_.apply(this, arguments);
  }

  static sqr (x) {
    return DD.valueOf(x).selfMultiply(x)
  }

  static valueOf () {
    if (typeof arguments[0] === 'string') {
      const str = arguments[0];
      return DD.parse(str)
    } else if (typeof arguments[0] === 'number') {
      const x = arguments[0];
      return new DD(x)
    }
  }

  static sqrt (x) {
    return DD.valueOf(x).sqrt()
  }

  static parse (str) {
    let i = 0;
    const strlen = str.length;
    while (Character.isWhitespace(str.charAt(i))) i++;
    let isNegative = false;
    if (i < strlen) {
      const signCh = str.charAt(i);
      if (signCh === '-' || signCh === '+') {
        i++;
        if (signCh === '-') isNegative = true;
      }
    }
    const val = new DD();
    let numDigits = 0;
    let numBeforeDec = 0;
    let exp = 0;
    while (true) {
      if (i >= strlen) break
      const ch = str.charAt(i);
      i++;
      if (Character.isDigit(ch)) {
        const d = ch - '0';
        val.selfMultiply(DD.TEN);
        val.selfAdd(d);
        numDigits++;
        continue
      }
      if (ch === '.') {
        numBeforeDec = numDigits;
        continue
      }
      if (ch === 'e' || ch === 'E') {
        const expStr = str.substring(i);
        try {
          exp = Integer.parseInt(expStr);
        } catch (ex) {
          if (ex instanceof NumberFormatException) {
            throw new NumberFormatException('Invalid exponent ' + expStr + ' in string ' + str)
          } else throw ex
        } finally {}
        break
      }
      throw new NumberFormatException("Unexpected character '" + ch + "' at position " + i + ' in string ' + str)
    }
    let val2 = val;
    const numDecPlaces = numDigits - numBeforeDec - exp;
    if (numDecPlaces === 0) {
      val2 = val;
    } else if (numDecPlaces > 0) {
      const scale = DD.TEN.pow(numDecPlaces);
      val2 = val.divide(scale);
    } else if (numDecPlaces < 0) {
      const scale = DD.TEN.pow(-numDecPlaces);
      val2 = val.multiply(scale);
    }
    if (isNegative) {
      return val2.negate()
    }
    return val2
  }

  static createNaN () {
    return new DD(Double.NaN, Double.NaN)
  }

  static copy (dd) {
    return new DD(dd)
  }

  static magnitude (x) {
    const xAbs = Math.abs(x);
    const xLog10 = Math.log(xAbs) / Math.log(10);
    let xMag = Math.trunc(Math.floor(xLog10));
    const xApprox = Math.pow(10, xMag);
    if (xApprox * 10 <= xAbs) xMag += 1;
    return xMag
  }

  static stringOfChar (ch, len) {
    const buf = new StringBuffer();
    for (let i = 0; i < len; i++) {
      buf.append(ch);
    }
    return buf.toString()
  }

  le (y) {
    return this._hi < y._hi || this._hi === y._hi && this._lo <= y._lo
  }

  extractSignificantDigits (insertDecimalPoint, magnitude) {
    let y = this.abs();
    let mag = DD.magnitude(y._hi);
    const scale = DD.TEN.pow(mag);
    y = y.divide(scale);
    if (y.gt(DD.TEN)) {
      y = y.divide(DD.TEN);
      mag += 1;
    } else if (y.lt(DD.ONE)) {
      y = y.multiply(DD.TEN);
      mag -= 1;
    }
    const decimalPointPos = mag + 1;
    const buf = new StringBuffer();
    const numDigits = DD.MAX_PRINT_DIGITS - 1;
    for (let i = 0; i <= numDigits; i++) {
      if (insertDecimalPoint && i === decimalPointPos) {
        buf.append('.');
      }
      const digit = Math.trunc(y._hi);
      if (digit < 0) {
        break
      }
      let rebiasBy10 = false;
      let digitChar = 0;
      if (digit > 9) {
        rebiasBy10 = true;
        digitChar = '9';
      } else {
        digitChar = '0' + digit;
      }
      buf.append(digitChar);
      y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);
      if (rebiasBy10) y.selfAdd(DD.TEN);
      let continueExtractingDigits = true;
      const remMag = DD.magnitude(y._hi);
      if (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;
      if (!continueExtractingDigits) break
    }
    magnitude[0] = mag;
    return buf.toString()
  }

  sqr () {
    return this.multiply(this)
  }

  doubleValue () {
    return this._hi + this._lo
  }

  subtract () {
    if (arguments[0] instanceof DD) {
      const y = arguments[0];
      return this.add(y.negate())
    } else if (typeof arguments[0] === 'number') {
      const y = arguments[0];
      return this.add(-y)
    }
  }

  equals () {
    if (arguments.length === 1 && arguments[0] instanceof DD) {
      const y = arguments[0];
      return this._hi === y._hi && this._lo === y._lo
    }
  }

  isZero () {
    return this._hi === 0.0 && this._lo === 0.0
  }

  selfSubtract () {
    if (arguments[0] instanceof DD) {
      const y = arguments[0];
      if (this.isNaN()) return this
      return this.selfAdd(-y._hi, -y._lo)
    } else if (typeof arguments[0] === 'number') {
      const y = arguments[0];
      if (this.isNaN()) return this
      return this.selfAdd(-y, 0.0)
    }
  }

  getSpecialNumberString () {
    if (this.isZero()) return '0.0'
    if (this.isNaN()) return 'NaN '
    return null
  }

  min (x) {
    if (this.le(x)) {
      return this
    } else {
      return x
    }
  }

  selfDivide () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof DD) {
        const y = arguments[0];
        return this.selfDivide(y._hi, y._lo)
      } else if (typeof arguments[0] === 'number') {
        const y = arguments[0];
        return this.selfDivide(y, 0.0)
      }
    } else if (arguments.length === 2) {
      const yhi = arguments[0]; const ylo = arguments[1];
      let hc = null; let tc = null; let hy = null; let ty = null; let C = null; let c = null; let U = null; let u = null;
      C = this._hi / yhi;
      c = DD.SPLIT * C;
      hc = c - C;
      u = DD.SPLIT * yhi;
      hc = c - hc;
      tc = C - hc;
      hy = u - yhi;
      U = C * yhi;
      hy = u - hy;
      ty = yhi - hy;
      u = hc * hy - U + hc * ty + tc * hy + tc * ty;
      c = (this._hi - U - u + this._lo - C * ylo) / yhi;
      u = C + c;
      this._hi = u;
      this._lo = C - u + c;
      return this
    }
  }

  dump () {
    return 'DD<' + this._hi + ', ' + this._lo + '>'
  }

  divide () {
    if (arguments[0] instanceof DD) {
      const y = arguments[0];
      let hc = null; let tc = null; let hy = null; let ty = null; let C = null; let c = null; let U = null; let u = null;
      C = this._hi / y._hi;
      c = DD.SPLIT * C;
      hc = c - C;
      u = DD.SPLIT * y._hi;
      hc = c - hc;
      tc = C - hc;
      hy = u - y._hi;
      U = C * y._hi;
      hy = u - hy;
      ty = y._hi - hy;
      u = hc * hy - U + hc * ty + tc * hy + tc * ty;
      c = (this._hi - U - u + this._lo - C * y._lo) / y._hi;
      u = C + c;
      const zhi = u;
      const zlo = C - u + c;
      return new DD(zhi, zlo)
    } else if (typeof arguments[0] === 'number') {
      const y = arguments[0];
      if (Double.isNaN(y)) return DD.createNaN()
      return DD.copy(this).selfDivide(y, 0.0)
    }
  }

  ge (y) {
    return this._hi > y._hi || this._hi === y._hi && this._lo >= y._lo
  }

  pow (exp) {
    if (exp === 0.0) return DD.valueOf(1.0)
    let r = new DD(this);
    let s = DD.valueOf(1.0);
    let n = Math.abs(exp);
    if (n > 1) {
      while (n > 0) {
        if (n % 2 === 1) {
          s.selfMultiply(r);
        }
        n /= 2;
        if (n > 0) r = r.sqr();
      }
    } else {
      s = r;
    }
    if (exp < 0) return s.reciprocal()
    return s
  }

  ceil () {
    if (this.isNaN()) return DD.NaN
    const fhi = Math.ceil(this._hi);
    let flo = 0.0;
    if (fhi === this._hi) {
      flo = Math.ceil(this._lo);
    }
    return new DD(fhi, flo)
  }

  compareTo (o) {
    const other = o;
    if (this._hi < other._hi) return -1
    if (this._hi > other._hi) return 1
    if (this._lo < other._lo) return -1
    if (this._lo > other._lo) return 1
    return 0
  }

  rint () {
    if (this.isNaN()) return this
    const plus5 = this.add(0.5);
    return plus5.floor()
  }

  setValue () {
    if (arguments[0] instanceof DD) {
      const value = arguments[0];
      this.init(value);
      return this
    } else if (typeof arguments[0] === 'number') {
      const value = arguments[0];
      this.init(value);
      return this
    }
  }

  max (x) {
    if (this.ge(x)) {
      return this
    } else {
      return x
    }
  }

  sqrt () {
    if (this.isZero()) return DD.valueOf(0.0)
    if (this.isNegative()) {
      return DD.NaN
    }
    const x = 1.0 / Math.sqrt(this._hi);
    const ax = this._hi * x;
    const axdd = DD.valueOf(ax);
    const diffSq = this.subtract(axdd.sqr());
    const d2 = diffSq._hi * (x * 0.5);
    return axdd.add(d2)
  }

  selfAdd () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof DD) {
        const y = arguments[0];
        return this.selfAdd(y._hi, y._lo)
      } else if (typeof arguments[0] === 'number') {
        const y = arguments[0];
        let H = null; let h = null; let S = null; let s = null; let e = null; let f = null;
        S = this._hi + y;
        e = S - this._hi;
        s = S - e;
        s = y - e + (this._hi - s);
        f = s + this._lo;
        H = S + f;
        h = f + (S - H);
        this._hi = H + h;
        this._lo = h + (H - this._hi);
        return this
      }
    } else if (arguments.length === 2) {
      const yhi = arguments[0]; const ylo = arguments[1];
      let H = null; let h = null; let T = null; let t = null; let S = null; let s = null; let e = null; let f = null;
      S = this._hi + yhi;
      T = this._lo + ylo;
      e = S - this._hi;
      f = T - this._lo;
      s = S - e;
      t = T - f;
      s = yhi - e + (this._hi - s);
      t = ylo - f + (this._lo - t);
      e = s + T;
      H = S + e;
      h = e + (S - H);
      e = t + h;
      const zhi = H + e;
      const zlo = e + (H - zhi);
      this._hi = zhi;
      this._lo = zlo;
      return this
    }
  }

  selfMultiply () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof DD) {
        const y = arguments[0];
        return this.selfMultiply(y._hi, y._lo)
      } else if (typeof arguments[0] === 'number') {
        const y = arguments[0];
        return this.selfMultiply(y, 0.0)
      }
    } else if (arguments.length === 2) {
      const yhi = arguments[0]; const ylo = arguments[1];
      let hx = null; let tx = null; let hy = null; let ty = null; let C = null; let c = null;
      C = DD.SPLIT * this._hi;
      hx = C - this._hi;
      c = DD.SPLIT * yhi;
      hx = C - hx;
      tx = this._hi - hx;
      hy = c - yhi;
      C = this._hi * yhi;
      hy = c - hy;
      ty = yhi - hy;
      c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);
      const zhi = C + c;
      hx = C - zhi;
      const zlo = c + hx;
      this._hi = zhi;
      this._lo = zlo;
      return this
    }
  }

  selfSqr () {
    return this.selfMultiply(this)
  }

  floor () {
    if (this.isNaN()) return DD.NaN
    const fhi = Math.floor(this._hi);
    let flo = 0.0;
    if (fhi === this._hi) {
      flo = Math.floor(this._lo);
    }
    return new DD(fhi, flo)
  }

  negate () {
    if (this.isNaN()) return this
    return new DD(-this._hi, -this._lo)
  }

  clone () {
    try {
      return null
    } catch (ex) {
      if (ex instanceof CloneNotSupportedException) {
        return null
      } else throw ex
    } finally {}
  }

  multiply () {
    if (arguments[0] instanceof DD) {
      const y = arguments[0];
      if (y.isNaN()) return DD.createNaN()
      return DD.copy(this).selfMultiply(y)
    } else if (typeof arguments[0] === 'number') {
      const y = arguments[0];
      if (Double.isNaN(y)) return DD.createNaN()
      return DD.copy(this).selfMultiply(y, 0.0)
    }
  }

  isNaN () {
    return Double.isNaN(this._hi)
  }

  intValue () {
    return Math.trunc(this._hi)
  }

  toString () {
    const mag = DD.magnitude(this._hi);
    if (mag >= -3 && mag <= 20) return this.toStandardNotation()
    return this.toSciNotation()
  }

  toStandardNotation () {
    const specialStr = this.getSpecialNumberString();
    if (specialStr !== null) return specialStr
    const magnitude = new Array(1).fill(null);
    const sigDigits = this.extractSignificantDigits(true, magnitude);
    const decimalPointPos = magnitude[0] + 1;
    let num = sigDigits;
    if (sigDigits.charAt(0) === '.') {
      num = '0' + sigDigits;
    } else if (decimalPointPos < 0) {
      num = '0.' + DD.stringOfChar('0', -decimalPointPos) + sigDigits;
    } else if (sigDigits.indexOf('.') === -1) {
      const numZeroes = decimalPointPos - sigDigits.length;
      const zeroes = DD.stringOfChar('0', numZeroes);
      num = sigDigits + zeroes + '.0';
    }
    if (this.isNegative()) return '-' + num
    return num
  }

  reciprocal () {
    let hc = null; let tc = null; let hy = null; let ty = null; let C = null; let c = null; let U = null; let u = null;
    C = 1.0 / this._hi;
    c = DD.SPLIT * C;
    hc = c - C;
    u = DD.SPLIT * this._hi;
    hc = c - hc;
    tc = C - hc;
    hy = u - this._hi;
    U = C * this._hi;
    hy = u - hy;
    ty = this._hi - hy;
    u = hc * hy - U + hc * ty + tc * hy + tc * ty;
    c = (1.0 - U - u - C * this._lo) / this._hi;
    const zhi = C + c;
    const zlo = C - zhi + c;
    return new DD(zhi, zlo)
  }

  toSciNotation () {
    if (this.isZero()) return DD.SCI_NOT_ZERO
    const specialStr = this.getSpecialNumberString();
    if (specialStr !== null) return specialStr
    const magnitude = new Array(1).fill(null);
    const digits = this.extractSignificantDigits(false, magnitude);
    const expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];
    if (digits.charAt(0) === '0') {
      throw new IllegalStateException('Found leading zero: ' + digits)
    }
    let trailingDigits = '';
    if (digits.length > 1) trailingDigits = digits.substring(1);
    const digitsWithDecimal = digits.charAt(0) + '.' + trailingDigits;
    if (this.isNegative()) return '-' + digitsWithDecimal + expStr
    return digitsWithDecimal + expStr
  }

  abs () {
    if (this.isNaN()) return DD.NaN
    if (this.isNegative()) return this.negate()
    return new DD(this)
  }

  isPositive () {
    return this._hi > 0.0 || this._hi === 0.0 && this._lo > 0.0
  }

  lt (y) {
    return this._hi < y._hi || this._hi === y._hi && this._lo < y._lo
  }

  add () {
    if (arguments[0] instanceof DD) {
      const y = arguments[0];
      return DD.copy(this).selfAdd(y)
    } else if (typeof arguments[0] === 'number') {
      const y = arguments[0];
      return DD.copy(this).selfAdd(y)
    }
  }

  init () {
    if (arguments.length === 1) {
      if (typeof arguments[0] === 'number') {
        const x = arguments[0];
        this._hi = x;
        this._lo = 0.0;
      } else if (arguments[0] instanceof DD) {
        const dd = arguments[0];
        this._hi = dd._hi;
        this._lo = dd._lo;
      }
    } else if (arguments.length === 2) {
      const hi = arguments[0]; const lo = arguments[1];
      this._hi = hi;
      this._lo = lo;
    }
  }

  gt (y) {
    return this._hi > y._hi || this._hi === y._hi && this._lo > y._lo
  }

  isNegative () {
    return this._hi < 0.0 || this._hi === 0.0 && this._lo < 0.0
  }

  trunc () {
    if (this.isNaN()) return DD.NaN
    if (this.isPositive()) return this.floor(); else return this.ceil()
  }

  signum () {
    if (this._hi > 0) return 1
    if (this._hi < 0) return -1
    if (this._lo > 0) return 1
    if (this._lo < 0) return -1
    return 0
  }

  getClass () {
    return DD
  }

  get interfaces_ () {
    return [Serializable, Comparable, Clonable]
  }
}
DD.constructor_ = function () {
  this._hi = 0.0;
  this._lo = 0.0;
  if (arguments.length === 0) {
    this.init(0.0);
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'number') {
      const x = arguments[0];
      this.init(x);
    } else if (arguments[0] instanceof DD) {
      const dd = arguments[0];
      this.init(dd);
    } else if (typeof arguments[0] === 'string') {
      const str = arguments[0];
      DD.constructor_.call(this, DD.parse(str));
    }
  } else if (arguments.length === 2) {
    const hi = arguments[0]; const lo = arguments[1];
    this.init(hi, lo);
  }
};
DD.PI = new DD(3.141592653589793116e+00, 1.224646799147353207e-16);
DD.TWO_PI = new DD(6.283185307179586232e+00, 2.449293598294706414e-16);
DD.PI_2 = new DD(1.570796326794896558e+00, 6.123233995736766036e-17);
DD.E = new DD(2.718281828459045091e+00, 1.445646891729250158e-16);
DD.NaN = new DD(Double.NaN, Double.NaN);
DD.EPS = 1.23259516440783e-32;
DD.SPLIT = 134217729.0;
DD.MAX_PRINT_DIGITS = 32;
DD.TEN = DD.valueOf(10.0);
DD.ONE = DD.valueOf(1.0);
DD.SCI_NOT_EXPONENT_CHAR = 'E';
DD.SCI_NOT_ZERO = '0.0E0';

class CGAlgorithmsDD {
  constructor () {
    CGAlgorithmsDD.constructor_.apply(this, arguments);
  }

  static orientationIndex (p1, p2, q) {
    const index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);
    if (index <= 1) return index
    const dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);
    const dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);
    const dx2 = DD.valueOf(q.x).selfAdd(-p2.x);
    const dy2 = DD.valueOf(q.y).selfAdd(-p2.y);
    return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum()
  }

  static signOfDet2x2 () {
    if (arguments[3] instanceof DD && (arguments[2] instanceof DD && (arguments[0] instanceof DD && arguments[1] instanceof DD))) {
      const x1 = arguments[0]; const y1 = arguments[1]; const x2 = arguments[2]; const y2 = arguments[3];
      const det = x1.multiply(y2).selfSubtract(y1.multiply(x2));
      return det.signum()
    } else if (typeof arguments[3] === 'number' && (typeof arguments[2] === 'number' && (typeof arguments[0] === 'number' && typeof arguments[1] === 'number'))) {
      const dx1 = arguments[0]; const dy1 = arguments[1]; const dx2 = arguments[2]; const dy2 = arguments[3];
      const x1 = DD.valueOf(dx1);
      const y1 = DD.valueOf(dy1);
      const x2 = DD.valueOf(dx2);
      const y2 = DD.valueOf(dy2);
      const det = x1.multiply(y2).selfSubtract(y1.multiply(x2));
      return det.signum()
    }
  }

  static intersection (p1, p2, q1, q2) {
    const denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));
    const denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));
    const denom = denom1.subtract(denom2);
    const numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
    const numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
    const numx = numx1.subtract(numx2);
    const fracP = numx.selfDivide(denom).doubleValue();
    const x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();
    const numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
    const numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
    const numy = numy1.subtract(numy2);
    const fracQ = numy.selfDivide(denom).doubleValue();
    const y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();
    return new Coordinate(x, y)
  }

  static orientationIndexFilter (pa, pb, pc) {
    let detsum = null;
    const detleft = (pa.x - pc.x) * (pb.y - pc.y);
    const detright = (pa.y - pc.y) * (pb.x - pc.x);
    const det = detleft - detright;
    if (detleft > 0.0) {
      if (detright <= 0.0) {
        return CGAlgorithmsDD.signum(det)
      } else {
        detsum = detleft + detright;
      }
    } else if (detleft < 0.0) {
      if (detright >= 0.0) {
        return CGAlgorithmsDD.signum(det)
      } else {
        detsum = -detleft - detright;
      }
    } else {
      return CGAlgorithmsDD.signum(det)
    }
    const errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;
    if (det >= errbound || -det >= errbound) {
      return CGAlgorithmsDD.signum(det)
    }
    return 2
  }

  static signum (x) {
    if (x > 0) return 1
    if (x < 0) return -1
    return 0
  }

  getClass () {
    return CGAlgorithmsDD
  }

  get interfaces_ () {
    return []
  }
}
CGAlgorithmsDD.constructor_ = function () {};
CGAlgorithmsDD.DP_SAFE_EPSILON = 1e-15;

class Orientation {
  constructor () {
    Orientation.constructor_.apply(this, arguments);
  }

  static index (p1, p2, q) {
    return CGAlgorithmsDD.orientationIndex(p1, p2, q)
  }

  static isCCW (ring) {
    const nPts = ring.length - 1;
    if (nPts < 3) throw new IllegalArgumentException('Ring has fewer than 4 points, so orientation cannot be determined')
    let hiPt = ring[0];
    let hiIndex = 0;
    for (let i = 1; i <= nPts; i++) {
      const p = ring[i];
      if (p.y > hiPt.y) {
        hiPt = p;
        hiIndex = i;
      }
    }
    let iPrev = hiIndex;
    do {
      iPrev = iPrev - 1;
      if (iPrev < 0) iPrev = nPts;
    } while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex)
    let iNext = hiIndex;
    do {
      iNext = (iNext + 1) % nPts;
    } while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex)
    const prev = ring[iPrev];
    const next = ring[iNext];
    if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false
    const disc = Orientation.index(prev, hiPt, next);
    let isCCW = null;
    if (disc === 0) {
      isCCW = prev.x > next.x;
    } else {
      isCCW = disc > 0;
    }
    return isCCW
  }

  getClass () {
    return Orientation
  }

  get interfaces_ () {
    return []
  }
}
Orientation.constructor_ = function () {};
Orientation.CLOCKWISE = -1;
Orientation.RIGHT = Orientation.CLOCKWISE;
Orientation.COUNTERCLOCKWISE = 1;
Orientation.LEFT = Orientation.COUNTERCLOCKWISE;
Orientation.COLLINEAR = 0;
Orientation.STRAIGHT = Orientation.COLLINEAR;

class Polygonal {
  constructor () {
    Polygonal.constructor_.apply(this, arguments);
  }

  getClass () {
    return Polygonal
  }

  get interfaces_ () {
    return []
  }
}
Polygonal.constructor_ = function () {};

class Polygon extends Geometry {
  constructor () {
    super();
    Polygon.constructor_.apply(this, arguments);
  }

  computeEnvelopeInternal () {
    return this._shell.getEnvelopeInternal()
  }

  getCoordinates () {
    if (this.isEmpty()) {
      return []
    }
    const coordinates = new Array(this.getNumPoints()).fill(null);
    let k = -1;
    const shellCoordinates = this._shell.getCoordinates();
    for (let x = 0; x < shellCoordinates.length; x++) {
      k++;
      coordinates[k] = shellCoordinates[x];
    }
    for (let i = 0; i < this._holes.length; i++) {
      const childCoordinates = this._holes[i].getCoordinates();
      for (let j = 0; j < childCoordinates.length; j++) {
        k++;
        coordinates[k] = childCoordinates[j];
      }
    }
    return coordinates
  }

  getArea () {
    let area = 0.0;
    area += Area.ofRing(this._shell.getCoordinateSequence());
    for (let i = 0; i < this._holes.length; i++) {
      area -= Area.ofRing(this._holes[i].getCoordinateSequence());
    }
    return area
  }

  isRectangle () {
    if (this.getNumInteriorRing() !== 0) return false
    if (this._shell === null) return false
    if (this._shell.getNumPoints() !== 5) return false
    const seq = this._shell.getCoordinateSequence();
    const env = this.getEnvelopeInternal();
    for (let i = 0; i < 5; i++) {
      const x = seq.getX(i);
      if (!(x === env.getMinX() || x === env.getMaxX())) return false
      const y = seq.getY(i);
      if (!(y === env.getMinY() || y === env.getMaxY())) return false
    }
    let prevX = seq.getX(0);
    let prevY = seq.getY(0);
    for (let i = 1; i <= 4; i++) {
      const x = seq.getX(i);
      const y = seq.getY(i);
      const xChanged = x !== prevX;
      const yChanged = y !== prevY;
      if (xChanged === yChanged) return false
      prevX = x;
      prevY = y;
    }
    return true
  }

  equalsExact () {
    if (arguments.length === 2 && (typeof arguments[1] === 'number' && arguments[0] instanceof Geometry)) {
      const other = arguments[0]; const tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false
      }
      const otherPolygon = other;
      const thisShell = this._shell;
      const otherPolygonShell = otherPolygon._shell;
      if (!thisShell.equalsExact(otherPolygonShell, tolerance)) {
        return false
      }
      if (this._holes.length !== otherPolygon._holes.length) {
        return false
      }
      for (let i = 0; i < this._holes.length; i++) {
        if (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {
          return false
        }
      }
      return true
    } else return super.equalsExact.apply(this, arguments)
  }

  normalize () {
    if (arguments.length === 0) {
      this.normalize(this._shell, true);
      for (let i = 0; i < this._holes.length; i++) {
        this.normalize(this._holes[i], false);
      }
      Arrays.sort(this._holes);
    } else if (arguments.length === 2) {
      const ring = arguments[0]; const clockwise = arguments[1];
      if (ring.isEmpty()) {
        return null
      }
      const uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);
      System.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);
      const minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());
      CoordinateArrays.scroll(uniqueCoordinates, minCoordinate);
      System.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);
      ring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];
      if (Orientation.isCCW(ring.getCoordinates()) === clockwise) {
        CoordinateArrays.reverse(ring.getCoordinates());
      }
    }
  }

  getCoordinate () {
    return this._shell.getCoordinate()
  }

  getNumInteriorRing () {
    return this._holes.length
  }

  getBoundaryDimension () {
    return 1
  }

  getTypeCode () {
    return Geometry.TYPECODE_POLYGON
  }

  getDimension () {
    return 2
  }

  getLength () {
    let len = 0.0;
    len += this._shell.getLength();
    for (let i = 0; i < this._holes.length; i++) {
      len += this._holes[i].getLength();
    }
    return len
  }

  getNumPoints () {
    let numPoints = this._shell.getNumPoints();
    for (let i = 0; i < this._holes.length; i++) {
      numPoints += this._holes[i].getNumPoints();
    }
    return numPoints
  }

  reverse () {
    const poly = this.copy();
    poly._shell = this._shell.copy().reverse();
    poly._holes = new Array(this._holes.length).fill(null);
    for (let i = 0; i < this._holes.length; i++) {
      poly._holes[i] = this._holes[i].copy().reverse();
    }
    return poly
  }

  convexHull () {
    return this.getExteriorRing().convexHull()
  }

  compareToSameClass () {
    if (arguments.length === 1) {
      const o = arguments[0];
      const thisShell = this._shell;
      const otherShell = o._shell;
      return thisShell.compareToSameClass(otherShell)
    } else if (arguments.length === 2) {
      const o = arguments[0]; const comp = arguments[1];
      const poly = o;
      const thisShell = this._shell;
      const otherShell = poly._shell;
      const shellComp = thisShell.compareToSameClass(otherShell, comp);
      if (shellComp !== 0) return shellComp
      const nHole1 = this.getNumInteriorRing();
      const nHole2 = poly.getNumInteriorRing();
      let i = 0;
      while (i < nHole1 && i < nHole2) {
        const thisHole = this.getInteriorRingN(i);
        const otherHole = poly.getInteriorRingN(i);
        const holeComp = thisHole.compareToSameClass(otherHole, comp);
        if (holeComp !== 0) return holeComp
        i++;
      }
      if (i < nHole1) return 1
      if (i < nHole2) return -1
      return 0
    }
  }

  apply () {
    if (hasInterface(arguments[0], CoordinateFilter)) {
      const filter = arguments[0];
      this._shell.apply(filter);
      for (let i = 0; i < this._holes.length; i++) {
        this._holes[i].apply(filter);
      }
    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
      const filter = arguments[0];
      this._shell.apply(filter);
      if (!filter.isDone()) {
        for (let i = 0; i < this._holes.length; i++) {
          this._holes[i].apply(filter);
          if (filter.isDone()) break
        }
      }
      if (filter.isGeometryChanged()) this.geometryChanged();
    } else if (hasInterface(arguments[0], GeometryFilter)) {
      const filter = arguments[0];
      filter.filter(this);
    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
      const filter = arguments[0];
      filter.filter(this);
      this._shell.apply(filter);
      for (let i = 0; i < this._holes.length; i++) {
        this._holes[i].apply(filter);
      }
    }
  }

  getBoundary () {
    if (this.isEmpty()) {
      return this.getFactory().createMultiLineString()
    }
    const rings = new Array(this._holes.length + 1).fill(null);
    rings[0] = this._shell;
    for (let i = 0; i < this._holes.length; i++) {
      rings[i + 1] = this._holes[i];
    }
    if (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence())
    return this.getFactory().createMultiLineString(rings)
  }

  getGeometryType () {
    return Geometry.TYPENAME_POLYGON
  }

  copy () {
    const shellCopy = this._shell.copy();
    const holeCopies = new Array(this._holes.length).fill(null);
    for (let i = 0; i < this._holes.length; i++) {
      holeCopies[i] = this._holes[i].copy();
    }
    return new Polygon(shellCopy, holeCopies, this._factory)
  }

  getExteriorRing () {
    return this._shell
  }

  isEmpty () {
    return this._shell.isEmpty()
  }

  getInteriorRingN (n) {
    return this._holes[n]
  }

  getClass () {
    return Polygon
  }

  get interfaces_ () {
    return [Polygonal]
  }
}
Polygon.constructor_ = function () {
  this._shell = null;
  this._holes = null;
  let shell = arguments[0]; let holes = arguments[1]; const factory = arguments[2];
  Geometry.constructor_.call(this, factory);
  if (shell === null) {
    shell = this.getFactory().createLinearRing();
  }
  if (holes === null) {
    holes = [];
  }
  if (Geometry.hasNullElements(holes)) {
    throw new IllegalArgumentException('holes must not contain null elements')
  }
  if (shell.isEmpty() && Geometry.hasNonEmptyElements(holes)) {
    throw new IllegalArgumentException('shell is empty but holes are not')
  }
  this._shell = shell;
  this._holes = holes;
};
Polygon.serialVersionUID = -3494792200821764533;

class MultiPoint extends GeometryCollection {
  constructor () {
    super();
    MultiPoint.constructor_.apply(this, arguments);
  }

  isValid () {
    return true
  }

  equalsExact () {
    if (arguments.length === 2 && (typeof arguments[1] === 'number' && arguments[0] instanceof Geometry)) {
      const other = arguments[0]; const tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false
      }
      return super.equalsExact.call(this, other, tolerance)
    } else return super.equalsExact.apply(this, arguments)
  }

  getCoordinate () {
    if (arguments.length === 1 && Number.isInteger(arguments[0])) {
      const n = arguments[0];
      return this._geometries[n].getCoordinate()
    } else return super.getCoordinate.apply(this, arguments)
  }

  getBoundaryDimension () {
    return Dimension.FALSE
  }

  getTypeCode () {
    return Geometry.TYPECODE_MULTIPOINT
  }

  getDimension () {
    return 0
  }

  getBoundary () {
    return this.getFactory().createGeometryCollection()
  }

  getGeometryType () {
    return Geometry.TYPENAME_MULTIPOINT
  }

  copy () {
    const points = new Array(this._geometries.length).fill(null);
    for (let i = 0; i < points.length; i++) {
      points[i] = this._geometries[i].copy();
    }
    return new MultiPoint(points, this._factory)
  }

  getClass () {
    return MultiPoint
  }

  get interfaces_ () {
    return [Puntal]
  }
}
MultiPoint.constructor_ = function () {
  const points = arguments[0]; const factory = arguments[1];
  GeometryCollection.constructor_.call(this, points, factory);
};
MultiPoint.serialVersionUID = -8048474874175355449;

class LinearRing extends LineString {
  constructor () {
    super();
    LinearRing.constructor_.apply(this, arguments);
  }

  getBoundaryDimension () {
    return Dimension.FALSE
  }

  isClosed () {
    if (this.isEmpty()) {
      return true
    }
    return super.isClosed.call(this)
  }

  getTypeCode () {
    return Geometry.TYPECODE_LINEARRING
  }

  reverse () {
    const seq = this._points.copy();
    CoordinateSequences.reverse(seq);
    const rev = this.getFactory().createLinearRing(seq);
    return rev
  }

  validateConstruction () {
    if (!this.isEmpty() && !super.isClosed.call(this)) {
      throw new IllegalArgumentException('Points of LinearRing do not form a closed linestring')
    }
    if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {
      throw new IllegalArgumentException('Invalid number of points in LinearRing (found ' + this.getCoordinateSequence().size() + ' - must be 0 or >= 4)')
    }
  }

  getGeometryType () {
    return Geometry.TYPENAME_LINEARRING
  }

  copy () {
    return new LinearRing(this._points.copy(), this._factory)
  }

  getClass () {
    return LinearRing
  }

  get interfaces_ () {
    return []
  }
}
LinearRing.constructor_ = function () {
  if (arguments[0] instanceof Array && arguments[1] instanceof GeometryFactory) {
    const points = arguments[0]; const factory = arguments[1];
    LinearRing.constructor_.call(this, factory.getCoordinateSequenceFactory().create(points), factory);
  } else if (hasInterface(arguments[0], CoordinateSequence) && arguments[1] instanceof GeometryFactory) {
    const points = arguments[0]; const factory = arguments[1];
    LineString.constructor_.call(this, points, factory);
    this.validateConstruction();
  }
};
LinearRing.MINIMUM_VALID_SIZE = 4;
LinearRing.serialVersionUID = -4261142084085851829;

class MultiPolygon extends GeometryCollection {
  constructor () {
    super();
    MultiPolygon.constructor_.apply(this, arguments);
  }

  equalsExact () {
    if (arguments.length === 2 && (typeof arguments[1] === 'number' && arguments[0] instanceof Geometry)) {
      const other = arguments[0]; const tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false
      }
      return super.equalsExact.call(this, other, tolerance)
    } else return super.equalsExact.apply(this, arguments)
  }

  getBoundaryDimension () {
    return 1
  }

  getTypeCode () {
    return Geometry.TYPECODE_MULTIPOLYGON
  }

  getDimension () {
    return 2
  }

  reverse () {
    const n = this._geometries.length;
    const revGeoms = new Array(n).fill(null);
    for (let i = 0; i < this._geometries.length; i++) {
      revGeoms[i] = this._geometries[i].reverse();
    }
    return this.getFactory().createMultiPolygon(revGeoms)
  }

  getBoundary () {
    if (this.isEmpty()) {
      return this.getFactory().createMultiLineString()
    }
    const allRings = new ArrayList();
    for (let i = 0; i < this._geometries.length; i++) {
      const polygon = this._geometries[i];
      const rings = polygon.getBoundary();
      for (let j = 0; j < rings.getNumGeometries(); j++) {
        allRings.add(rings.getGeometryN(j));
      }
    }
    const allRingsArray = new Array(allRings.size()).fill(null);
    return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray))
  }

  getGeometryType () {
    return Geometry.TYPENAME_MULTIPOLYGON
  }

  copy () {
    const polygons = new Array(this._geometries.length).fill(null);
    for (let i = 0; i < polygons.length; i++) {
      polygons[i] = this._geometries[i].copy();
    }
    return new MultiPolygon(polygons, this._factory)
  }

  getClass () {
    return MultiPolygon
  }

  get interfaces_ () {
    return [Polygonal]
  }
}
MultiPolygon.constructor_ = function () {
  const polygons = arguments[0]; const factory = arguments[1];
  GeometryCollection.constructor_.call(this, polygons, factory);
};
MultiPolygon.serialVersionUID = -551033529766975875;

class GeometryEditor {
  constructor () {
    GeometryEditor.constructor_.apply(this, arguments);
  }

  setCopyUserData (isUserDataCopied) {
    this._isUserDataCopied = isUserDataCopied;
  }

  edit (geometry, operation) {
    if (geometry === null) return null
    const result = this.editInternal(geometry, operation);
    if (this._isUserDataCopied) {
      result.setUserData(geometry.getUserData());
    }
    return result
  }

  editInternal (geometry, operation) {
    if (this._factory === null) this._factory = geometry.getFactory();
    if (geometry instanceof GeometryCollection) {
      return this.editGeometryCollection(geometry, operation)
    }
    if (geometry instanceof Polygon) {
      return this.editPolygon(geometry, operation)
    }
    if (geometry instanceof Point) {
      return operation.edit(geometry, this._factory)
    }
    if (geometry instanceof LineString) {
      return operation.edit(geometry, this._factory)
    }
    Assert.shouldNeverReachHere('Unsupported Geometry class: ' + geometry.getClass().getName());
    return null
  }

  editGeometryCollection (collection, operation) {
    const collectionForType = operation.edit(collection, this._factory);
    const geometries = new ArrayList();
    for (let i = 0; i < collectionForType.getNumGeometries(); i++) {
      const geometry = this.edit(collectionForType.getGeometryN(i), operation);
      if (geometry === null || geometry.isEmpty()) {
        continue
      }
      geometries.add(geometry);
    }
    if (collectionForType.getClass() === MultiPoint) {
      return this._factory.createMultiPoint(geometries.toArray([]))
    }
    if (collectionForType.getClass() === MultiLineString) {
      return this._factory.createMultiLineString(geometries.toArray([]))
    }
    if (collectionForType.getClass() === MultiPolygon) {
      return this._factory.createMultiPolygon(geometries.toArray([]))
    }
    return this._factory.createGeometryCollection(geometries.toArray([]))
  }

  editPolygon (polygon, operation) {
    let newPolygon = operation.edit(polygon, this._factory);
    if (newPolygon === null) newPolygon = this._factory.createPolygon();
    if (newPolygon.isEmpty()) {
      return newPolygon
    }
    const shell = this.edit(newPolygon.getExteriorRing(), operation);
    if (shell === null || shell.isEmpty()) {
      return this._factory.createPolygon()
    }
    const holes = new ArrayList();
    for (let i = 0; i < newPolygon.getNumInteriorRing(); i++) {
      const hole = this.edit(newPolygon.getInteriorRingN(i), operation);
      if (hole === null || hole.isEmpty()) {
        continue
      }
      holes.add(hole);
    }
    return this._factory.createPolygon(shell, holes.toArray([]))
  }

  getClass () {
    return GeometryEditor
  }

  get interfaces_ () {
    return []
  }
}
function GeometryEditorOperation () {}
GeometryEditor.GeometryEditorOperation = GeometryEditorOperation;
class NoOpGeometryOperation {
  constructor () {
    NoOpGeometryOperation.constructor_.apply(this, arguments);
  }

  edit (geometry, factory) {
    return geometry
  }

  getClass () {
    return NoOpGeometryOperation
  }

  get interfaces_ () {
    return [GeometryEditorOperation]
  }
}
NoOpGeometryOperation.constructor_ = function () {};
class CoordinateOperation {
  constructor () {
    CoordinateOperation.constructor_.apply(this, arguments);
  }

  edit (geometry, factory) {
    const coordinates = this.edit(geometry.getCoordinates(), geometry);
    if (geometry instanceof LinearRing) {
      if (coordinates === null) return factory.createLinearRing(); else return factory.createLinearRing(coordinates)
    }
    if (geometry instanceof LineString) {
      if (coordinates === null) return factory.createLineString(); else return factory.createLineString(coordinates)
    }
    if (geometry instanceof Point) {
      if (coordinates === null || coordinates.length === 0) return factory.createPoint(); else return factory.createPoint(coordinates[0])
    }
    return geometry
  }

  getClass () {
    return CoordinateOperation
  }

  get interfaces_ () {
    return [GeometryEditorOperation]
  }
}
CoordinateOperation.constructor_ = function () {};
class CoordinateSequenceOperation {
  constructor () {
    CoordinateSequenceOperation.constructor_.apply(this, arguments);
  }

  edit (geometry, factory) {
    if (geometry instanceof LinearRing) {
      return factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry))
    }
    if (geometry instanceof LineString) {
      return factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry))
    }
    if (geometry instanceof Point) {
      return factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry))
    }
    return geometry
  }

  getClass () {
    return CoordinateSequenceOperation
  }

  get interfaces_ () {
    return [GeometryEditorOperation]
  }
}
CoordinateSequenceOperation.constructor_ = function () {};
GeometryEditor.NoOpGeometryOperation = NoOpGeometryOperation;
GeometryEditor.CoordinateOperation = CoordinateOperation;
GeometryEditor.CoordinateSequenceOperation = CoordinateSequenceOperation;
GeometryEditor.constructor_ = function () {
  this._factory = null;
  this._isUserDataCopied = false;
  if (arguments.length === 0) ; else if (arguments.length === 1) {
    const factory = arguments[0];
    this._factory = factory;
  }
};

class CoordinateArraySequence {
  constructor () {
    CoordinateArraySequence.constructor_.apply(this, arguments);
  }

  setOrdinate (index, ordinateIndex, value) {
    switch (ordinateIndex) {
      case CoordinateSequence.X:
        this._coordinates[index].x = value;
        break
      case CoordinateSequence.Y:
        this._coordinates[index].y = value;
        break
      case CoordinateSequence.Z:
        this._coordinates[index].z = value;
        break
      default:
        throw new IllegalArgumentException('invalid ordinateIndex')
    }
  }

  size () {
    return this._coordinates.length
  }

  getOrdinate (index, ordinateIndex) {
    switch (ordinateIndex) {
      case CoordinateSequence.X:
        return this._coordinates[index].x
      case CoordinateSequence.Y:
        return this._coordinates[index].y
      case CoordinateSequence.Z:
        return this._coordinates[index].z
    }
    return Double.NaN
  }

  getCoordinate () {
    if (arguments.length === 1) {
      const i = arguments[0];
      return this._coordinates[i]
    } else if (arguments.length === 2) {
      const index = arguments[0]; const coord = arguments[1];
      coord.x = this._coordinates[index].x;
      coord.y = this._coordinates[index].y;
      coord.z = this._coordinates[index].z;
    }
  }

  getCoordinateCopy (i) {
    return new Coordinate(this._coordinates[i])
  }

  getDimension () {
    return this._dimension
  }

  getX (index) {
    return this._coordinates[index].x
  }

  expandEnvelope (env) {
    for (let i = 0; i < this._coordinates.length; i++) {
      env.expandToInclude(this._coordinates[i]);
    }
    return env
  }

  copy () {
    const cloneCoordinates = new Array(this.size()).fill(null);
    for (let i = 0; i < this._coordinates.length; i++) {
      cloneCoordinates[i] = this._coordinates[i].copy();
    }
    return new CoordinateArraySequence(cloneCoordinates, this._dimension)
  }

  toString () {
    if (this._coordinates.length > 0) {
      const strBuilder = new StringBuilder(17 * this._coordinates.length);
      strBuilder.append('(');
      strBuilder.append(this._coordinates[0]);
      for (let i = 1; i < this._coordinates.length; i++) {
        strBuilder.append(', ');
        strBuilder.append(this._coordinates[i]);
      }
      strBuilder.append(')');
      return strBuilder.toString()
    } else {
      return '()'
    }
  }

  getY (index) {
    return this._coordinates[index].y
  }

  toCoordinateArray () {
    return this._coordinates
  }

  getClass () {
    return CoordinateArraySequence
  }

  get interfaces_ () {
    return [CoordinateSequence, Serializable]
  }
}
CoordinateArraySequence.constructor_ = function () {
  this._dimension = 3;
  this._coordinates = null;
  if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      const coordinates = arguments[0];
      CoordinateArraySequence.constructor_.call(this, coordinates, 3);
    } else if (Number.isInteger(arguments[0])) {
      const size = arguments[0];
      this._coordinates = new Array(size).fill(null);
      for (let i = 0; i < size; i++) {
        this._coordinates[i] = new Coordinate();
      }
    } else if (hasInterface(arguments[0], CoordinateSequence)) {
      const coordSeq = arguments[0];
      if (coordSeq === null) {
        this._coordinates = new Array(0).fill(null);
        return null
      }
      this._dimension = coordSeq.getDimension();
      this._coordinates = new Array(coordSeq.size()).fill(null);
      for (let i = 0; i < this._coordinates.length; i++) {
        this._coordinates[i] = coordSeq.getCoordinateCopy(i);
      }
    }
  } else if (arguments.length === 2) {
    if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
      const coordinates = arguments[0]; const dimension = arguments[1];
      this._coordinates = coordinates;
      this._dimension = dimension;
      if (coordinates === null) this._coordinates = new Array(0).fill(null);
    } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
      const size = arguments[0]; const dimension = arguments[1];
      this._coordinates = new Array(size).fill(null);
      this._dimension = dimension;
      for (let i = 0; i < size; i++) {
        this._coordinates[i] = new Coordinate();
      }
    }
  }
};
CoordinateArraySequence.serialVersionUID = -915438501601840650;

class CoordinateArraySequenceFactory {
  constructor () {
    CoordinateArraySequenceFactory.constructor_.apply(this, arguments);
  }

  static instance () {
    return CoordinateArraySequenceFactory.instanceObject
  }

  readResolve () {
    return CoordinateArraySequenceFactory.instance()
  }

  create () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof Array) {
        const coordinates = arguments[0];
        return new CoordinateArraySequence(coordinates)
      } else if (hasInterface(arguments[0], CoordinateSequence)) {
        const coordSeq = arguments[0];
        return new CoordinateArraySequence(coordSeq)
      }
    } else if (arguments.length === 2) {
      const size = arguments[0]; let dimension = arguments[1];
      if (dimension > 3) dimension = 3;
      if (dimension < 2) return new CoordinateArraySequence(size)
      return new CoordinateArraySequence(size, dimension)
    }
  }

  getClass () {
    return CoordinateArraySequenceFactory
  }

  get interfaces_ () {
    return [CoordinateSequenceFactory, Serializable]
  }
}
CoordinateArraySequenceFactory.constructor_ = function () {};
CoordinateArraySequenceFactory.serialVersionUID = -4099577099607551657;
CoordinateArraySequenceFactory.instanceObject = new CoordinateArraySequenceFactory();

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html
 *
 * @extends {javascript.util.Map}
 * @constructor
 * @private
 */
function HashMap () {
  /**
   * @type {Object}
   * @private
  */
  this.map_ = new Map();
}
HashMap.prototype = new Map$1();

/**
 * @override
 */
HashMap.prototype.get = function (key) {
  return this.map_.get(key) || null
};

/**
 * @override
 */
HashMap.prototype.put = function (key, value) {
  this.map_.set(key, value);
  return value
};

/**
 * @override
 */
HashMap.prototype.values = function () {
  const arrayList = new ArrayList();
  const it = this.map_.values();
  let o = it.next();
  while (!o.done) {
    arrayList.add(o.value);
    o = it.next();
  }
  return arrayList
};

/**
 * @override
 */
HashMap.prototype.entrySet = function () {
  const hashSet = new HashSet();
  this.map_.entries().forEach(entry => hashSet.add(entry));
  return hashSet
};

/**
 * @override
 */
HashMap.prototype.size = function () {
  return this.map_.size()
};

class PrecisionModel {
  constructor () {
    PrecisionModel.constructor_.apply(this, arguments);
  }

  static mostPrecise (pm1, pm2) {
    if (pm1.compareTo(pm2) >= 0) return pm1
    return pm2
  }

  equals (other) {
    if (!(other instanceof PrecisionModel)) {
      return false
    }
    const otherPrecisionModel = other;
    return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale
  }

  compareTo (o) {
    const other = o;
    const sigDigits = this.getMaximumSignificantDigits();
    const otherSigDigits = other.getMaximumSignificantDigits();
    return new Integer(sigDigits).compareTo(new Integer(otherSigDigits))
  }

  getScale () {
    return this._scale
  }

  isFloating () {
    return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE
  }

  getType () {
    return this._modelType
  }

  toString () {
    let description = 'UNKNOWN';
    if (this._modelType === PrecisionModel.FLOATING) {
      description = 'Floating';
    } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
      description = 'Floating-Single';
    } else if (this._modelType === PrecisionModel.FIXED) {
      description = 'Fixed (Scale=' + this.getScale() + ')';
    }
    return description
  }

  makePrecise () {
    if (typeof arguments[0] === 'number') {
      const val = arguments[0];
      if (Double.isNaN(val)) return val
      if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
        const floatSingleVal = val;
        return floatSingleVal
      }
      if (this._modelType === PrecisionModel.FIXED) {
        return Math.round(val * this._scale) / this._scale
      }
      return val
    } else if (arguments[0] instanceof Coordinate) {
      const coord = arguments[0];
      if (this._modelType === PrecisionModel.FLOATING) return null
      coord.x = this.makePrecise(coord.x);
      coord.y = this.makePrecise(coord.y);
    }
  }

  getMaximumSignificantDigits () {
    let maxSigDigits = 16;
    if (this._modelType === PrecisionModel.FLOATING) {
      maxSigDigits = 16;
    } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
      maxSigDigits = 6;
    } else if (this._modelType === PrecisionModel.FIXED) {
      maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));
    }
    return maxSigDigits
  }

  setScale (scale) {
    this._scale = Math.abs(scale);
  }

  getClass () {
    return PrecisionModel
  }

  get interfaces_ () {
    return [Serializable, Comparable]
  }
}
class Type {
  constructor () {
    Type.constructor_.apply(this, arguments);
  }

  readResolve () {
    return Type.nameToTypeMap.get(this._name)
  }

  toString () {
    return this._name
  }

  getClass () {
    return Type
  }

  get interfaces_ () {
    return [Serializable]
  }
}
Type.constructor_ = function () {
  this._name = null;
  const name = arguments[0];
  this._name = name;
  Type.nameToTypeMap.put(name, this);
};
Type.serialVersionUID = -5528602631731589822;
Type.nameToTypeMap = new HashMap();
PrecisionModel.Type = Type;
PrecisionModel.constructor_ = function () {
  this._modelType = null;
  this._scale = null;
  if (arguments.length === 0) {
    this._modelType = PrecisionModel.FLOATING;
  } else if (arguments.length === 1) {
    if (arguments[0] instanceof Type) {
      const modelType = arguments[0];
      this._modelType = modelType;
      if (modelType === PrecisionModel.FIXED) {
        this.setScale(1.0);
      }
    } else if (typeof arguments[0] === 'number') {
      const scale = arguments[0];
      this._modelType = PrecisionModel.FIXED;
      this.setScale(scale);
    } else if (arguments[0] instanceof PrecisionModel) {
      const pm = arguments[0];
      this._modelType = pm._modelType;
      this._scale = pm._scale;
    }
  }
};
PrecisionModel.serialVersionUID = 7777263578777803835;
PrecisionModel.FIXED = new Type('FIXED');
PrecisionModel.FLOATING = new Type('FLOATING');
PrecisionModel.FLOATING_SINGLE = new Type('FLOATING SINGLE');
PrecisionModel.maximumPreciseValue = 9007199254740992.0;

class GeometryFactory {
  constructor () {
    GeometryFactory.constructor_.apply(this, arguments);
  }

  static toMultiPolygonArray (multiPolygons) {
    const multiPolygonArray = new Array(multiPolygons.size()).fill(null);
    return multiPolygons.toArray(multiPolygonArray)
  }

  static toGeometryArray (geometries) {
    if (geometries === null) return null
    const geometryArray = new Array(geometries.size()).fill(null);
    return geometries.toArray(geometryArray)
  }

  static getDefaultCoordinateSequenceFactory () {
    return CoordinateArraySequenceFactory.instance()
  }

  static toMultiLineStringArray (multiLineStrings) {
    const multiLineStringArray = new Array(multiLineStrings.size()).fill(null);
    return multiLineStrings.toArray(multiLineStringArray)
  }

  static toLineStringArray (lineStrings) {
    const lineStringArray = new Array(lineStrings.size()).fill(null);
    return lineStrings.toArray(lineStringArray)
  }

  static toMultiPointArray (multiPoints) {
    const multiPointArray = new Array(multiPoints.size()).fill(null);
    return multiPoints.toArray(multiPointArray)
  }

  static toLinearRingArray (linearRings) {
    const linearRingArray = new Array(linearRings.size()).fill(null);
    return linearRings.toArray(linearRingArray)
  }

  static toPointArray (points) {
    const pointArray = new Array(points.size()).fill(null);
    return points.toArray(pointArray)
  }

  static toPolygonArray (polygons) {
    const polygonArray = new Array(polygons.size()).fill(null);
    return polygons.toArray(polygonArray)
  }

  static createPointFromInternalCoord (coord, exemplar) {
    exemplar.getPrecisionModel().makePrecise(coord);
    return exemplar.getFactory().createPoint(coord)
  }

  toGeometry (envelope) {
    if (envelope.isNull()) {
      return this.createPoint()
    }
    if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {
      return this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()))
    }
    if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {
      return this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())])
    }
    return this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null)
  }

  createLineString () {
    if (arguments.length === 0) {
      return this.createLineString(this.getCoordinateSequenceFactory().create([]))
    } else if (arguments.length === 1) {
      if (arguments[0] instanceof Array) {
        const coordinates = arguments[0];
        return this.createLineString(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)
      } else if (hasInterface(arguments[0], CoordinateSequence)) {
        const coordinates = arguments[0];
        return new LineString(coordinates, this)
      }
    }
  }

  createMultiLineString () {
    if (arguments.length === 0) {
      return new MultiLineString(null, this)
    } else if (arguments.length === 1) {
      const lineStrings = arguments[0];
      return new MultiLineString(lineStrings, this)
    }
  }

  buildGeometry (geomList) {
    let geomClass = null;
    let isHeterogeneous = false;
    let hasGeometryCollection = false;
    for (let i = geomList.iterator(); i.hasNext();) {
      const geom = i.next();
      const partClass = geom.getClass();
      if (geomClass === null) {
        geomClass = partClass;
      }
      if (partClass !== geomClass) {
        isHeterogeneous = true;
      }
      if (geom instanceof GeometryCollection) hasGeometryCollection = true;
    }
    if (geomClass === null) {
      return this.createGeometryCollection()
    }
    if (isHeterogeneous || hasGeometryCollection) {
      return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList))
    }
    const geom0 = geomList.iterator().next();
    const isCollection = geomList.size() > 1;
    if (isCollection) {
      if (geom0 instanceof Polygon) {
        return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList))
      } else if (geom0 instanceof LineString) {
        return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList))
      } else if (geom0 instanceof Point) {
        return this.createMultiPoint(GeometryFactory.toPointArray(geomList))
      }
      Assert.shouldNeverReachHere('Unhandled class: ' + geom0.getClass().getName());
    }
    return geom0
  }

  createMultiPointFromCoords (coordinates) {
    return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)
  }

  createPoint () {
    if (arguments.length === 0) {
      return this.createPoint(this.getCoordinateSequenceFactory().create([]))
    } else if (arguments.length === 1) {
      if (arguments[0] instanceof Coordinate) {
        const coordinate = arguments[0];
        return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null)
      } else if (hasInterface(arguments[0], CoordinateSequence)) {
        const coordinates = arguments[0];
        return new Point(coordinates, this)
      }
    }
  }

  getCoordinateSequenceFactory () {
    return this._coordinateSequenceFactory
  }

  createPolygon () {
    if (arguments.length === 0) {
      return this.createPolygon(null, null)
    } else if (arguments.length === 1) {
      if (hasInterface(arguments[0], CoordinateSequence)) {
        const shell = arguments[0];
        return this.createPolygon(this.createLinearRing(shell))
      } else if (arguments[0] instanceof Array) {
        const shell = arguments[0];
        return this.createPolygon(this.createLinearRing(shell))
      } else if (arguments[0] instanceof LinearRing) {
        const shell = arguments[0];
        return this.createPolygon(shell, null)
      }
    } else if (arguments.length === 2) {
      const shell = arguments[0]; const holes = arguments[1];
      return new Polygon(shell, holes, this)
    }
  }

  getSRID () {
    return this._SRID
  }

  createGeometryCollection () {
    if (arguments.length === 0) {
      return new GeometryCollection(null, this)
    } else if (arguments.length === 1) {
      const geometries = arguments[0];
      return new GeometryCollection(geometries, this)
    }
  }

  createGeometry (g) {
    const editor = new GeometryEditor(this);
    return editor.edit(g, new CloneOp(this._coordinateSequenceFactory))
  }

  getPrecisionModel () {
    return this._precisionModel
  }

  createLinearRing () {
    if (arguments.length === 0) {
      return this.createLinearRing(this.getCoordinateSequenceFactory().create([]))
    } else if (arguments.length === 1) {
      if (arguments[0] instanceof Array) {
        const coordinates = arguments[0];
        return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)
      } else if (hasInterface(arguments[0], CoordinateSequence)) {
        const coordinates = arguments[0];
        return new LinearRing(coordinates, this)
      }
    }
  }

  createMultiPolygon () {
    if (arguments.length === 0) {
      return new MultiPolygon(null, this)
    } else if (arguments.length === 1) {
      const polygons = arguments[0];
      return new MultiPolygon(polygons, this)
    }
  }

  createMultiPoint () {
    if (arguments.length === 0) {
      return new MultiPoint(null, this)
    } else if (arguments.length === 1) {
      if (arguments[0] instanceof Array) {
        const point = arguments[0];
        return new MultiPoint(point, this)
      } else if (hasInterface(arguments[0], CoordinateSequence)) {
        const coordinates = arguments[0];
        if (coordinates === null) {
          return this.createMultiPoint(new Array(0).fill(null))
        }
        const points = new Array(coordinates.size()).fill(null);
        for (let i = 0; i < coordinates.size(); i++) {
          const ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension());
          CoordinateSequences.copy(coordinates, i, ptSeq, 0, 1);
          points[i] = this.createPoint(ptSeq);
        }
        return this.createMultiPoint(points)
      }
    }
  }

  getClass () {
    return GeometryFactory
  }

  get interfaces_ () {
    return [Serializable]
  }
}
class CloneOp extends GeometryEditor.CoordinateSequenceOperation {
  constructor () {
    super();
    CloneOp.constructor_.apply(this, arguments);
  }

  edit () {
    if (arguments.length === 2 && (arguments[1] instanceof Geometry && hasInterface(arguments[0], CoordinateSequence))) {
      const coordSeq = arguments[0];      return this.coordinateSequenceFactory.create(coordSeq)
    } else return super.edit.apply(this, arguments)
  }

  getClass () {
    return CloneOp
  }

  get interfaces_ () {
    return []
  }
}
CloneOp.constructor_ = function () {
  this.coordinateSequenceFactory = null;
  const coordinateSequenceFactory = arguments[0];
  this.coordinateSequenceFactory = coordinateSequenceFactory;
};
GeometryFactory.CloneOp = CloneOp;
GeometryFactory.constructor_ = function () {
  this._precisionModel = null;
  this._coordinateSequenceFactory = null;
  this._SRID = null;
  if (arguments.length === 0) {
    GeometryFactory.constructor_.call(this, new PrecisionModel(), 0);
  } else if (arguments.length === 1) {
    if (hasInterface(arguments[0], CoordinateSequenceFactory)) {
      const coordinateSequenceFactory = arguments[0];
      GeometryFactory.constructor_.call(this, new PrecisionModel(), 0, coordinateSequenceFactory);
    } else if (arguments[0] instanceof PrecisionModel) {
      const precisionModel = arguments[0];
      GeometryFactory.constructor_.call(this, precisionModel, 0, GeometryFactory.getDefaultCoordinateSequenceFactory());
    }
  } else if (arguments.length === 2) {
    const precisionModel = arguments[0]; const SRID = arguments[1];
    GeometryFactory.constructor_.call(this, precisionModel, SRID, GeometryFactory.getDefaultCoordinateSequenceFactory());
  } else if (arguments.length === 3) {
    const precisionModel = arguments[0]; const SRID = arguments[1]; const coordinateSequenceFactory = arguments[2];
    this._precisionModel = precisionModel;
    this._coordinateSequenceFactory = coordinateSequenceFactory;
    this._SRID = SRID;
  }
};
GeometryFactory.serialVersionUID = -6820524753094095635;

const geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];

/**
 * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON
 * NOTE: Adapted from OpenLayers 2.11 implementation.
 */

/**
 * Create a new parser for GeoJSON
 *
 * @param {GeometryFactory} geometryFactory
 * @return An instance of GeoJsonParser.
 * @constructor
 * @private
 */
class GeoJSONParser {
  constructor (geometryFactory) {
    this.geometryFactory = geometryFactory || new GeometryFactory();
  }

  /**
   * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries
   *
   * @param {}
   *          A GeoJSON object.
   * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.
   * @private
   */
  read (json) {
    let obj;
    if (typeof json === 'string') { obj = JSON.parse(json); } else { obj = json; }

    const type = obj.type;

    if (!parse$1[type]) { throw new Error('Unknown GeoJSON type: ' + obj.type) }

    if (geometryTypes.indexOf(type) !== -1) { return parse$1[type].call(this, obj.coordinates) } else if (type === 'GeometryCollection') { return parse$1[type].call(this, obj.geometries) }

    // feature or feature collection
    return parse$1[type].call(this, obj)
  }

  /**
   * Serialize a Geometry object into GeoJSON
   *
   * @param {Geometry}
   *          geometry A Geometry or array of Geometries.
   * @return {Object} A GeoJSON object represting the input Geometry/Geometries.
   * @private
   */
  write (geometry) {
    const type = geometry.getGeometryType();

    if (!extract$1[type]) { throw new Error('Geometry is not supported') }

    return extract$1[type].call(this, geometry)
  }
}

const parse$1 = {
  /**
   * Parse a GeoJSON Feature object
   *
   * @param {Object}
   *          obj Object to parse.
   *
   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.
   */
  Feature: function (obj) {
    const feature = {};

    for (const key in obj) { feature[key] = obj[key]; }

    if (obj.geometry) {
      const type = obj.geometry.type;
      if (!parse$1[type]) { throw new Error('Unknown GeoJSON type: ' + obj.type) }
      feature.geometry = this.read(obj.geometry);
    }

    if (obj.bbox) { feature.bbox = parse$1.bbox.call(this, obj.bbox); }

    return feature
  },

  /**
   * Parse a GeoJSON FeatureCollection object
   *
   * @param {Object}
   *          obj Object to parse.
   *
   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.
   */
  FeatureCollection: function (obj) {
    const featureCollection = {};

    if (obj.features) {
      featureCollection.features = [];

      for (let i = 0; i < obj.features.length; ++i) { featureCollection.features.push(this.read(obj.features[i])); }
    }

    if (obj.bbox) { featureCollection.bbox = this.parse.bbox.call(this, obj.bbox); }

    return featureCollection
  },

  /**
   * Convert the ordinates in an array to an array of Coordinates
   *
   * @param {Array}
   *          array Array with {Number}s.
   *
   * @return {Array} Array with Coordinates.
   */
  coordinates: function (array) {
    const coordinates = [];
    for (let i = 0; i < array.length; ++i) {
      const sub = array[i];
      coordinates.push(new Coordinate(sub[0], sub[1]));
    }
    return coordinates
  },

  /**
   * Convert the bbox to a LinearRing
   *
   * @param {Array}
   *          array Array with [xMin, yMin, xMax, yMax].
   *
   * @return {Array} Array with Coordinates.
   */
  bbox: function (array) {
    return this.geometryFactory.createLinearRing([
      new Coordinate(array[0], array[1]),
      new Coordinate(array[2], array[1]),
      new Coordinate(array[2], array[3]),
      new Coordinate(array[0], array[3]),
      new Coordinate(array[0], array[1])
    ])
  },

  /**
   * Convert an Array with ordinates to a Point
   *
   * @param {Array}
   *          array Array with ordinates.
   *
   * @return {Point} Point.
   */
  Point: function (array) {
    const coordinate = new Coordinate(array[0], array[1]);
    return this.geometryFactory.createPoint(coordinate)
  },

  /**
   * Convert an Array with coordinates to a MultiPoint
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {MultiPoint} MultiPoint.
   */
  MultiPoint: function (array) {
    const points = [];
    for (let i = 0; i < array.length; ++i) { points.push(parse$1.Point.call(this, array[i])); }
    return this.geometryFactory.createMultiPoint(points)
  },

  /**
   * Convert an Array with coordinates to a LineString
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {LineString} LineString.
   */
  LineString: function (array) {
    const coordinates = parse$1.coordinates.call(this, array);
    return this.geometryFactory.createLineString(coordinates)
  },

  /**
   * Convert an Array with coordinates to a MultiLineString
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {MultiLineString} MultiLineString.
   */
  MultiLineString: function (array) {
    const lineStrings = [];
    for (let i = 0; i < array.length; ++i) { lineStrings.push(parse$1.LineString.call(this, array[i])); }
    return this.geometryFactory.createMultiLineString(lineStrings)
  },

  /**
   * Convert an Array to a Polygon
   *
   * @param {Array}
   *          array Array with shell and holes.
   *
   * @return {Polygon} Polygon.
   */
  Polygon: function (array) {
    const shellCoordinates = parse$1.coordinates.call(this, array[0]);
    const shell = this.geometryFactory.createLinearRing(shellCoordinates);
    const holes = [];
    for (let i = 1; i < array.length; ++i) {
      const hole = array[i];
      const coordinates = parse$1.coordinates.call(this, hole);
      const linearRing = this.geometryFactory.createLinearRing(coordinates);
      holes.push(linearRing);
    }
    return this.geometryFactory.createPolygon(shell, holes)
  },

  /**
   * Convert an Array to a MultiPolygon
   *
   * @param {Array}
   *          array Array of arrays with shell and rings.
   *
   * @return {MultiPolygon} MultiPolygon.
   */
  MultiPolygon: function (array) {
    const polygons = [];
    for (let i = 0; i < array.length; ++i) {
      const polygon = array[i];
      polygons.push(parse$1.Polygon.call(this, polygon));
    }
    return this.geometryFactory.createMultiPolygon(polygons)
  },

  /**
   * Convert an Array to a GeometryCollection
   *
   * @param {Array}
   *          array Array of GeoJSON geometries.
   *
   * @return {GeometryCollection} GeometryCollection.
   */
  GeometryCollection: function (array) {
    const geometries = [];
    for (let i = 0; i < array.length; ++i) {
      const geometry = array[i];
      geometries.push(this.read(geometry));
    }
    return this.geometryFactory.createGeometryCollection(geometries)
  }
};

const extract$1 = {
  /**
   * Convert a Coordinate to an Array
   *
   * @param {Coordinate}
   *          coordinate Coordinate to convert.
   *
   * @return {Array} Array of ordinates.
   */
  coordinate: function (coordinate) {
    return [coordinate.x, coordinate.y]
  },

  /**
   * Convert a Point to a GeoJSON object
   *
   * @param {Point}
   *          point Point to convert.
   *
   * @return {Array} Array of 2 ordinates (paired to a coordinate).
   */
  Point: function (point) {
    const array = extract$1.coordinate.call(this, point.getCoordinate());
    return {
      type: 'Point',
      coordinates: array
    }
  },

  /**
   * Convert a MultiPoint to a GeoJSON object
   *
   * @param {MultiPoint}
   *          multipoint MultiPoint to convert.
   *
   * @return {Array} Array of coordinates.
   */
  MultiPoint: function (multipoint) {
    const array = [];
    for (let i = 0; i < multipoint._geometries.length; ++i) {
      const point = multipoint._geometries[i];
      const geoJson = extract$1.Point.call(this, point);
      array.push(geoJson.coordinates);
    }
    return {
      type: 'MultiPoint',
      coordinates: array
    }
  },

  /**
   * Convert a LineString to a GeoJSON object
   *
   * @param {LineString}
   *          linestring LineString to convert.
   *
   * @return {Array} Array of coordinates.
   */
  LineString: function (linestring) {
    const array = [];
    const coordinates = linestring.getCoordinates();
    for (let i = 0; i < coordinates.length; ++i) {
      const coordinate = coordinates[i];
      array.push(extract$1.coordinate.call(this, coordinate));
    }
    return {
      type: 'LineString',
      coordinates: array
    }
  },

  /**
   * Convert a MultiLineString to a GeoJSON object
   *
   * @param {MultiLineString}
   *          multilinestring MultiLineString to convert.
   *
   * @return {Array} Array of Array of coordinates.
   */
  MultiLineString: function (multilinestring) {
    const array = [];
    for (let i = 0; i < multilinestring._geometries.length; ++i) {
      const linestring = multilinestring._geometries[i];
      const geoJson = extract$1.LineString.call(this, linestring);
      array.push(geoJson.coordinates);
    }
    return {
      type: 'MultiLineString',
      coordinates: array
    }
  },

  /**
   * Convert a Polygon to a GeoJSON object
   *
   * @param {Polygon}
   *          polygon Polygon to convert.
   *
   * @return {Array} Array with shell, holes.
   */
  Polygon: function (polygon) {
    const array = [];
    const shellGeoJson = extract$1.LineString.call(this, polygon._shell);
    array.push(shellGeoJson.coordinates);
    for (let i = 0; i < polygon._holes.length; ++i) {
      const hole = polygon._holes[i];
      const holeGeoJson = extract$1.LineString.call(this, hole);
      array.push(holeGeoJson.coordinates);
    }
    return {
      type: 'Polygon',
      coordinates: array
    }
  },

  /**
   * Convert a MultiPolygon to a GeoJSON object
   *
   * @param {MultiPolygon}
   *          multipolygon MultiPolygon to convert.
   *
   * @return {Array} Array of polygons.
   */
  MultiPolygon: function (multipolygon) {
    const array = [];
    for (let i = 0; i < multipolygon._geometries.length; ++i) {
      const polygon = multipolygon._geometries[i];
      const geoJson = extract$1.Polygon.call(this, polygon);
      array.push(geoJson.coordinates);
    }
    return {
      type: 'MultiPolygon',
      coordinates: array
    }
  },

  /**
   * Convert a GeometryCollection to a GeoJSON object
   *
   * @param {GeometryCollection}
   *          collection GeometryCollection to convert.
   *
   * @return {Array} Array of geometries.
   */
  GeometryCollection: function (collection) {
    const array = [];
    for (let i = 0; i < collection._geometries.length; ++i) {
      const geometry = collection._geometries[i];
      const type = geometry.getGeometryType();
      array.push(extract$1[type].call(this, geometry));
    }
    return {
      type: 'GeometryCollection',
      geometries: array
    }
  }
};

/**
 * @module org/locationtech/jts/io/GeoJSONReader
 */

/**
 * Converts a geometry in GeoJSON to a {@link Geometry}.
 */
class GeoJSONReader {
  /**
   * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,
   * to allow it to create <code>Geometry</code> objects of the appropriate
   * implementation. In particular, the <code>GeometryFactory</code> determines
   * the <code>PrecisionModel</code> and <code>SRID</code> that is used.
   *
   * @param {GeometryFactory} geometryFactory
   */
  constructor (geometryFactory) {
    this.parser = new GeoJSONParser(geometryFactory || new GeometryFactory());
  }

  /**
   * Reads a GeoJSON representation of a {@link Geometry}
   *
   * Will also parse GeoJSON Features/FeatureCollections as custom objects.
   *
   * @param {Object|String} geoJson a GeoJSON Object or String.
   * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>
   * @memberof module:org/locationtech/jts/io/GeoJSONReader#
   */
  read (geoJson) {
    const geometry = this.parser.read(geoJson);
    return geometry
  }
}

/**
 * @module org/locationtech/jts/io/GeoJSONWriter
 */

/**
 * Writes the GeoJSON representation of a {@link Geometry}. The
 * The GeoJSON format is defined <A
 * HREF="http://geojson.org/geojson-spec.html">here</A>.
 */
class GeoJSONWriter {
  /**
   * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision
   * model. Only the maximum number of decimal places necessary to represent the
   * ordinates to the required precision will be output.
   *
   * @param {GeometryFactory} geometryFactory
   * @constructor
   */
  constructor () {
    this.parser = new GeoJSONParser(this.geometryFactory);
  }

  /**
   * Converts a <code>Geometry</code> to its GeoJSON representation.
   *
   * @param {Geometry}
   *          geometry a <code>Geometry</code> to process.
   * @return {Object} The GeoJSON representation of the Geometry.
   * @memberof module:org/locationtech/jts/io/GeoJSONWriter#
   */
  write (geometry) {
    return this.parser.write(geometry)
  }
}

class BufferParameters {
  constructor () {
    BufferParameters.constructor_.apply(this, arguments);
  }

  static bufferDistanceError (quadSegs) {
    const alpha = Math.PI / 2.0 / quadSegs;
    return 1 - Math.cos(alpha / 2.0)
  }

  getEndCapStyle () {
    return this._endCapStyle
  }

  isSingleSided () {
    return this._isSingleSided
  }

  setQuadrantSegments (quadSegs) {
    this._quadrantSegments = quadSegs;
    if (this._quadrantSegments === 0) this._joinStyle = BufferParameters.JOIN_BEVEL;
    if (this._quadrantSegments < 0) {
      this._joinStyle = BufferParameters.JOIN_MITRE;
      this._mitreLimit = Math.abs(this._quadrantSegments);
    }
    if (quadSegs <= 0) {
      this._quadrantSegments = 1;
    }
    if (this._joinStyle !== BufferParameters.JOIN_ROUND) {
      this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
    }
  }

  getJoinStyle () {
    return this._joinStyle
  }

  setJoinStyle (joinStyle) {
    this._joinStyle = joinStyle;
  }

  setSimplifyFactor (simplifyFactor) {
    this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;
  }

  getSimplifyFactor () {
    return this._simplifyFactor
  }

  getQuadrantSegments () {
    return this._quadrantSegments
  }

  setEndCapStyle (endCapStyle) {
    this._endCapStyle = endCapStyle;
  }

  getMitreLimit () {
    return this._mitreLimit
  }

  setMitreLimit (mitreLimit) {
    this._mitreLimit = mitreLimit;
  }

  setSingleSided (isSingleSided) {
    this._isSingleSided = isSingleSided;
  }

  getClass () {
    return BufferParameters
  }

  get interfaces_ () {
    return []
  }
}
BufferParameters.constructor_ = function () {
  this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
  this._endCapStyle = BufferParameters.CAP_ROUND;
  this._joinStyle = BufferParameters.JOIN_ROUND;
  this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;
  this._isSingleSided = false;
  this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;
  if (arguments.length === 0) ; else if (arguments.length === 1) {
    const quadrantSegments = arguments[0];
    this.setQuadrantSegments(quadrantSegments);
  } else if (arguments.length === 2) {
    const quadrantSegments = arguments[0]; const endCapStyle = arguments[1];
    this.setQuadrantSegments(quadrantSegments);
    this.setEndCapStyle(endCapStyle);
  } else if (arguments.length === 4) {
    const quadrantSegments = arguments[0]; const endCapStyle = arguments[1]; const joinStyle = arguments[2]; const mitreLimit = arguments[3];
    this.setQuadrantSegments(quadrantSegments);
    this.setEndCapStyle(endCapStyle);
    this.setJoinStyle(joinStyle);
    this.setMitreLimit(mitreLimit);
  }
};
BufferParameters.CAP_ROUND = 1;
BufferParameters.CAP_FLAT = 2;
BufferParameters.CAP_SQUARE = 3;
BufferParameters.JOIN_ROUND = 1;
BufferParameters.JOIN_MITRE = 2;
BufferParameters.JOIN_BEVEL = 3;
BufferParameters.DEFAULT_QUADRANT_SEGMENTS = 8;
BufferParameters.DEFAULT_MITRE_LIMIT = 5.0;
BufferParameters.DEFAULT_SIMPLIFY_FACTOR = 0.01;

class Location {
  constructor () {
    Location.constructor_.apply(this, arguments);
  }

  static toLocationSymbol (locationValue) {
    switch (locationValue) {
      case Location.EXTERIOR:
        return 'e'
      case Location.BOUNDARY:
        return 'b'
      case Location.INTERIOR:
        return 'i'
      case Location.NONE:
        return '-'
    }
    throw new IllegalArgumentException('Unknown location value: ' + locationValue)
  }

  getClass () {
    return Location
  }

  get interfaces_ () {
    return []
  }
}
Location.constructor_ = function () {};
Location.INTERIOR = 0;
Location.BOUNDARY = 1;
Location.EXTERIOR = 2;
Location.NONE = -1;

class Position {
  constructor () {
    Position.constructor_.apply(this, arguments);
  }

  static opposite (position) {
    if (position === Position.LEFT) return Position.RIGHT
    if (position === Position.RIGHT) return Position.LEFT
    return position
  }

  getClass () {
    return Position
  }

  get interfaces_ () {
    return []
  }
}
Position.constructor_ = function () {};
Position.ON = 0;
Position.LEFT = 1;
Position.RIGHT = 2;

/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function EmptyStackException (message) {
  this.message = message || '';
}EmptyStackException.prototype = new Error();

/**
 * @type {string}
 */
EmptyStackException.prototype.name = 'EmptyStackException';

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html
 *
 * @extends {List}
 * @constructor
 * @private
 */
function Stack () {
  /**
   * @type {Array}
   * @private
   */
  this.array_ = [];
}Stack.prototype = new List();

/**
 * @override
 */
Stack.prototype.add = function (e) {
  this.array_.push(e);
  return true
};

/**
 * @override
 */
Stack.prototype.get = function (index) {
  if (index < 0 || index >= this.size()) {
    throw new IndexOutOfBoundsException()
  }

  return this.array_[index]
};

/**
 * Pushes an item onto the top of this stack.
 * @param {Object} e
 * @return {Object}
 */
Stack.prototype.push = function (e) {
  this.array_.push(e);
  return e
};

/**
 * Pushes an item onto the top of this stack.
 * @param {Object} e
 * @return {Object}
 */
Stack.prototype.pop = function (e) {
  if (this.array_.length === 0) {
    throw new EmptyStackException()
  }

  return this.array_.pop()
};

/**
 * Looks at the object at the top of this stack without removing it from the
 * stack.
 * @return {Object}
 */
Stack.prototype.peek = function () {
  if (this.array_.length === 0) {
    throw new EmptyStackException()
  }

  return this.array_[this.array_.length - 1]
};

/**
 * Tests if this stack is empty.
 * @return {boolean} true if and only if this stack contains no items; false
 *         otherwise.
 */
Stack.prototype.empty = function () {
  if (this.array_.length === 0) {
    return true
  } else {
    return false
  }
};

/**
 * @return {boolean}
 */
Stack.prototype.isEmpty = function () {
  return this.empty()
};

/**
 * Returns the 1-based position where an object is on this stack. If the object
 * o occurs as an item in this stack, this method returns the distance from the
 * top of the stack of the occurrence nearest the top of the stack; the topmost
 * item on the stack is considered to be at distance 1. The equals method is
 * used to compare o to the items in this stack.
 *
 * NOTE: does not currently actually use equals. (=== is used)
 *
 * @param {Object} o
 * @return {number} the 1-based position from the top of the stack where the
 *         object is located; the return value -1 indicates that the object is
 *         not on the stack.
 */
Stack.prototype.search = function (o) {
  return this.array_.indexOf(o)
};

/**
 * @return {number}
 * @export
 */
Stack.prototype.size = function () {
  return this.array_.length
};

/**
 * @return {Array}
 */
Stack.prototype.toArray = function () {
  var array = [];

  for (var i = 0, len = this.array_.length; i < len; i++) {
    array.push(this.array_[i]);
  }

  return array
};

class RightmostEdgeFinder {
  constructor () {
    RightmostEdgeFinder.constructor_.apply(this, arguments);
  }

  getCoordinate () {
    return this._minCoord
  }

  getRightmostSide (de, index) {
    let side = this.getRightmostSideOfSegment(de, index);
    if (side < 0) side = this.getRightmostSideOfSegment(de, index - 1);
    if (side < 0) {
      this._minCoord = null;
      this.checkForRightmostCoordinate(de);
    }
    return side
  }

  findRightmostEdgeAtVertex () {
    const pts = this._minDe.getEdge().getCoordinates();
    Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, 'rightmost point expected to be interior vertex of edge');
    const pPrev = pts[this._minIndex - 1];
    const pNext = pts[this._minIndex + 1];
    const orientation = Orientation.index(this._minCoord, pNext, pPrev);
    let usePrev = false;
    if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === Orientation.COUNTERCLOCKWISE) {
      usePrev = true;
    } else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === Orientation.CLOCKWISE) {
      usePrev = true;
    }
    if (usePrev) {
      this._minIndex = this._minIndex - 1;
    }
  }

  getRightmostSideOfSegment (de, i) {
    const e = de.getEdge();
    const coord = e.getCoordinates();
    if (i < 0 || i + 1 >= coord.length) return -1
    if (coord[i].y === coord[i + 1].y) return -1
    let pos = Position.LEFT;
    if (coord[i].y < coord[i + 1].y) pos = Position.RIGHT;
    return pos
  }

  getEdge () {
    return this._orientedDe
  }

  checkForRightmostCoordinate (de) {
    const coord = de.getEdge().getCoordinates();
    for (let i = 0; i < coord.length - 1; i++) {
      if (this._minCoord === null || coord[i].x > this._minCoord.x) {
        this._minDe = de;
        this._minIndex = i;
        this._minCoord = coord[i];
      }
    }
  }

  findRightmostEdgeAtNode () {
    const node = this._minDe.getNode();
    const star = node.getEdges();
    this._minDe = star.getRightmostEdge();
    if (!this._minDe.isForward()) {
      this._minDe = this._minDe.getSym();
      this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;
    }
  }

  findEdge (dirEdgeList) {
    for (let i = dirEdgeList.iterator(); i.hasNext();) {
      const de = i.next();
      if (!de.isForward()) continue
      this.checkForRightmostCoordinate(de);
    }
    Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), 'inconsistency in rightmost processing');
    if (this._minIndex === 0) {
      this.findRightmostEdgeAtNode();
    } else {
      this.findRightmostEdgeAtVertex();
    }
    this._orientedDe = this._minDe;
    const rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);
    if (rightmostSide === Position.LEFT) {
      this._orientedDe = this._minDe.getSym();
    }
  }

  getClass () {
    return RightmostEdgeFinder
  }

  get interfaces_ () {
    return []
  }
}
RightmostEdgeFinder.constructor_ = function () {
  this._minIndex = -1;
  this._minCoord = null;
  this._minDe = null;
  this._orientedDe = null;
};

class TopologyException extends RuntimeException {
  constructor () {
    if (arguments.length === 1) {
      const msg = arguments[0];
      super(msg);
      RuntimeException.call(this, msg);
    } else if (arguments.length === 2) {
      const msg = arguments[0]; const pt = arguments[1];
      super(TopologyException.msgWithCoord(msg, pt));
      this.name = 'TopologyException';
      this.pt = new Coordinate(pt);
    } else {
      throw Error()
    }
  }

  getCoordinate () {
    return this.pt
  }

  get interfaces_ () {
    return []
  }

  getClass () {
    return TopologyException
  }

  static msgWithCoord (msg, pt) {
    if (pt !== null) return msg + ' [ ' + pt + ' ]'
    return msg
  }
}

function LinkedList () {
  this.array_ = [];
}
LinkedList.prototype.addLast = function (e) {
  this.array_.push(e);
};
LinkedList.prototype.removeFirst = function () {
  return this.array_.shift()
};
LinkedList.prototype.isEmpty = function () {
  return this.array_.length === 0
};

class BufferSubgraph {
  constructor () {
    BufferSubgraph.constructor_.apply(this, arguments);
  }

  clearVisitedEdges () {
    for (let it = this._dirEdgeList.iterator(); it.hasNext();) {
      const de = it.next();
      de.setVisited(false);
    }
  }

  getRightmostCoordinate () {
    return this._rightMostCoord
  }

  computeNodeDepth (n) {
    let startEdge = null;
    for (let i = n.getEdges().iterator(); i.hasNext();) {
      const de = i.next();
      if (de.isVisited() || de.getSym().isVisited()) {
        startEdge = de;
        break
      }
    }
    if (startEdge === null) throw new TopologyException('unable to find edge to compute depths at ' + n.getCoordinate())
    n.getEdges().computeDepths(startEdge);
    for (let i = n.getEdges().iterator(); i.hasNext();) {
      const de = i.next();
      de.setVisited(true);
      this.copySymDepths(de);
    }
  }

  computeDepth (outsideDepth) {
    this.clearVisitedEdges();
    const de = this._finder.getEdge();
    de.getNode();
    de.getLabel();
    de.setEdgeDepths(Position.RIGHT, outsideDepth);
    this.copySymDepths(de);
    this.computeDepths(de);
  }

  create (node) {
    this.addReachable(node);
    this._finder.findEdge(this._dirEdgeList);
    this._rightMostCoord = this._finder.getCoordinate();
  }

  findResultEdges () {
    for (let it = this._dirEdgeList.iterator(); it.hasNext();) {
      const de = it.next();
      if (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {
        de.setInResult(true);
      }
    }
  }

  computeDepths (startEdge) {
    const nodesVisited = new HashSet();
    const nodeQueue = new LinkedList();
    const startNode = startEdge.getNode();
    nodeQueue.addLast(startNode);
    nodesVisited.add(startNode);
    startEdge.setVisited(true);
    while (!nodeQueue.isEmpty()) {
      const n = nodeQueue.removeFirst();
      nodesVisited.add(n);
      this.computeNodeDepth(n);
      for (let i = n.getEdges().iterator(); i.hasNext();) {
        const de = i.next();
        const sym = de.getSym();
        if (sym.isVisited()) continue
        const adjNode = sym.getNode();
        if (!nodesVisited.contains(adjNode)) {
          nodeQueue.addLast(adjNode);
          nodesVisited.add(adjNode);
        }
      }
    }
  }

  compareTo (o) {
    const graph = o;
    if (this._rightMostCoord.x < graph._rightMostCoord.x) {
      return -1
    }
    if (this._rightMostCoord.x > graph._rightMostCoord.x) {
      return 1
    }
    return 0
  }

  getEnvelope () {
    if (this._env === null) {
      const edgeEnv = new Envelope();
      for (let it = this._dirEdgeList.iterator(); it.hasNext();) {
        const dirEdge = it.next();
        const pts = dirEdge.getEdge().getCoordinates();
        for (let i = 0; i < pts.length - 1; i++) {
          edgeEnv.expandToInclude(pts[i]);
        }
      }
      this._env = edgeEnv;
    }
    return this._env
  }

  addReachable (startNode) {
    const nodeStack = new Stack();
    nodeStack.add(startNode);
    while (!nodeStack.empty()) {
      const node = nodeStack.pop();
      this.add(node, nodeStack);
    }
  }

  copySymDepths (de) {
    const sym = de.getSym();
    sym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));
    sym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));
  }

  add (node, nodeStack) {
    node.setVisited(true);
    this._nodes.add(node);
    for (let i = node.getEdges().iterator(); i.hasNext();) {
      const de = i.next();
      this._dirEdgeList.add(de);
      const sym = de.getSym();
      const symNode = sym.getNode();
      if (!symNode.isVisited()) nodeStack.push(symNode);
    }
  }

  getNodes () {
    return this._nodes
  }

  getDirectedEdges () {
    return this._dirEdgeList
  }

  getClass () {
    return BufferSubgraph
  }

  get interfaces_ () {
    return [Comparable]
  }
}
BufferSubgraph.constructor_ = function () {
  this._finder = null;
  this._dirEdgeList = new ArrayList();
  this._nodes = new ArrayList();
  this._rightMostCoord = null;
  this._env = null;
  this._finder = new RightmostEdgeFinder();
};

function Exception () {}

class NotRepresentableException extends Exception {
  constructor () {
    super();
    NotRepresentableException.constructor_.apply(this, arguments);
  }

  getClass () {
    return NotRepresentableException
  }

  get interfaces_ () {
    return []
  }
}
NotRepresentableException.constructor_ = function () {
  Exception.constructor_.call(this, 'Projective point not representable on the Cartesian plane.');
};

class HCoordinate {
  constructor () {
    HCoordinate.constructor_.apply(this, arguments);
  }

  static intersection (p1, p2, q1, q2) {
    const px = p1.y - p2.y;
    const py = p2.x - p1.x;
    const pw = p1.x * p2.y - p2.x * p1.y;
    const qx = q1.y - q2.y;
    const qy = q2.x - q1.x;
    const qw = q1.x * q2.y - q2.x * q1.y;
    const x = py * qw - qy * pw;
    const y = qx * pw - px * qw;
    const w = px * qy - qx * py;
    const xInt = x / w;
    const yInt = y / w;
    if (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) {
      throw new NotRepresentableException()
    }
    return new Coordinate(xInt, yInt)
  }

  getY () {
    const a = this.y / this.w;
    if (Double.isNaN(a) || Double.isInfinite(a)) {
      throw new NotRepresentableException()
    }
    return a
  }

  getX () {
    const a = this.x / this.w;
    if (Double.isNaN(a) || Double.isInfinite(a)) {
      throw new NotRepresentableException()
    }
    return a
  }

  getCoordinate () {
    const p = new Coordinate();
    p.x = this.getX();
    p.y = this.getY();
    return p
  }

  getClass () {
    return HCoordinate
  }

  get interfaces_ () {
    return []
  }
}
HCoordinate.constructor_ = function () {
  this.x = null;
  this.y = null;
  this.w = null;
  if (arguments.length === 0) {
    this.x = 0.0;
    this.y = 0.0;
    this.w = 1.0;
  } else if (arguments.length === 1) {
    const p = arguments[0];
    this.x = p.x;
    this.y = p.y;
    this.w = 1.0;
  } else if (arguments.length === 2) {
    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
      const _x = arguments[0]; const _y = arguments[1];
      this.x = _x;
      this.y = _y;
      this.w = 1.0;
    } else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {
      const p1 = arguments[0]; const p2 = arguments[1];
      this.x = p1.y * p2.w - p2.y * p1.w;
      this.y = p2.x * p1.w - p1.x * p2.w;
      this.w = p1.x * p2.y - p2.x * p1.y;
    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
      const p1 = arguments[0]; const p2 = arguments[1];
      this.x = p1.y - p2.y;
      this.y = p2.x - p1.x;
      this.w = p1.x * p2.y - p2.x * p1.y;
    }
  } else if (arguments.length === 3) {
    const _x = arguments[0]; const _y = arguments[1]; const _w = arguments[2];
    this.x = _x;
    this.y = _y;
    this.w = _w;
  } else if (arguments.length === 4) {
    const p1 = arguments[0]; const p2 = arguments[1]; const q1 = arguments[2]; const q2 = arguments[3];
    const px = p1.y - p2.y;
    const py = p2.x - p1.x;
    const pw = p1.x * p2.y - p2.x * p1.y;
    const qx = q1.y - q2.y;
    const qy = q2.x - q1.x;
    const qw = q1.x * q2.y - q2.x * q1.y;
    this.x = py * qw - qy * pw;
    this.y = qx * pw - px * qw;
    this.w = px * qy - qx * py;
  }
};

class Distance {
  constructor () {
    Distance.constructor_.apply(this, arguments);
  }

  static segmentToSegment (A, B, C, D) {
    if (A.equals(B)) return Distance.pointToSegment(A, C, D)
    if (C.equals(D)) return Distance.pointToSegment(D, A, B)
    let noIntersection = false;
    if (!Envelope.intersects(A, B, C, D)) {
      noIntersection = true;
    } else {
      const denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);
      if (denom === 0) {
        noIntersection = true;
      } else {
        const r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);
        const s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);
        const s = s_num / denom;
        const r = r_num / denom;
        if (r < 0 || r > 1 || s < 0 || s > 1) {
          noIntersection = true;
        }
      }
    }
    if (noIntersection) {
      return MathUtil.min(Distance.pointToSegment(A, C, D), Distance.pointToSegment(B, C, D), Distance.pointToSegment(C, A, B), Distance.pointToSegment(D, A, B))
    }
    return 0.0
  }

  static pointToSegment (p, A, B) {
    if (A.x === B.x && A.y === B.y) return p.distance(A)
    const len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
    const r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2;
    if (r <= 0.0) return p.distance(A)
    if (r >= 1.0) return p.distance(B)
    const s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
    return Math.abs(s) * Math.sqrt(len2)
  }

  static pointToLinePerpendicular (p, A, B) {
    const len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
    const s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
    return Math.abs(s) * Math.sqrt(len2)
  }

  static pointToSegmentString (p, line) {
    if (line.length === 0) throw new IllegalArgumentException('Line array must contain at least one vertex')
    let minDistance = p.distance(line[0]);
    for (let i = 0; i < line.length - 1; i++) {
      const dist = Distance.pointToSegment(p, line[i], line[i + 1]);
      if (dist < minDistance) {
        minDistance = dist;
      }
    }
    return minDistance
  }

  getClass () {
    return Distance
  }

  get interfaces_ () {
    return []
  }
}
Distance.constructor_ = function () {};

const regExes = {
  typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
  emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/,
  spaces: /\s+/,
  parenComma: /\)\s*,\s*\(/,
  doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/, // can't use {2} here
  trimParens: /^\s*\(?(.*?)\)?\s*$/
};

/**
 * Class for reading and writing Well-Known Text.
 *
 * NOTE: Adapted from OpenLayers 2.11 implementation.
 */

class WKTParser {
  /** Create a new parser for WKT
   *
   * @param {GeometryFactory} geometryFactory
   * @return An instance of WKTParser.
   * @private
   */
  constructor (geometryFactory) {
    this.geometryFactory = geometryFactory || new GeometryFactory();
    this.precisionModel = this.geometryFactory.getPrecisionModel();
  }

  /**
   * Deserialize a WKT string and return a geometry. Supports WKT for POINT,
   * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,
   * and GEOMETRYCOLLECTION.
   *
   * @param {String} wkt A WKT string.
   * @return {Geometry} A geometry instance.
   * @private
   */
  read (wkt) {
    var geometry, type, str;
    wkt = wkt.replace(/[\n\r]/g, ' ');
    var matches = regExes.typeStr.exec(wkt);
    if (wkt.search('EMPTY') !== -1) {
      matches = regExes.emptyTypeStr.exec(wkt);
      matches[2] = undefined;
    }
    if (matches) {
      type = matches[1].toLowerCase();
      str = matches[2];
      if (parse[type]) {
        geometry = parse[type].call(this, str);
      }
    }

    if (geometry === undefined) throw new Error('Could not parse WKT ' + wkt)

    return geometry
  }

  /**
   * Serialize a geometry into a WKT string.
   *
   * @param {Geometry} geometry A feature or array of features.
   * @return {String} The WKT string representation of the input geometries.
   * @private
   */
  write (geometry) {
    return this.extractGeometry(geometry)
  }

  /**
   * Entry point to construct the WKT for a single Geometry object.
   *
   * @param {Geometry} geometry
   * @return {String} A WKT string of representing the geometry.
   * @private
   */
  extractGeometry (geometry) {
    var type = geometry.getGeometryType().toLowerCase();
    if (!extract[type]) {
      return null
    }
    var wktType = type.toUpperCase();
    var data;
    if (geometry.isEmpty()) {
      data = wktType + ' EMPTY';
    } else {
      data = wktType + '(' + extract[type].call(this, geometry) + ')';
    }
    return data
  }
}

/**
 * Object with properties corresponding to the geometry types. Property values
 * are functions that do the actual data extraction.
 * @private
 */
const extract = {
  coordinate (coordinate) {
    this.precisionModel.makePrecise(coordinate);
    return coordinate.x + ' ' + coordinate.y
  },

  /**
   * Return a space delimited string of point coordinates.
   *
   * @param {Point}
   *          point
   * @return {String} A string of coordinates representing the point.
   */
  point (point) {
    return extract.coordinate.call(this, point._coordinates._coordinates[0])
  },

  /**
   * Return a comma delimited string of point coordinates from a multipoint.
   *
   * @param {MultiPoint}
   *          multipoint
   * @return {String} A string of point coordinate strings representing the
   *         multipoint.
   */
  multipoint (multipoint) {
    var array = [];
    for (let i = 0, len = multipoint._geometries.length; i < len; ++i) {
      array.push('(' + extract.point.call(this, multipoint._geometries[i]) + ')');
    }
    return array.join(',')
  },

  /**
   * Return a comma delimited string of point coordinates from a line.
   *
   * @param {LineString} linestring
   * @return {String} A string of point coordinate strings representing the linestring.
   */
  linestring (linestring) {
    var array = [];
    for (let i = 0, len = linestring._points._coordinates.length; i < len; ++i) {
      array.push(extract.coordinate.call(this, linestring._points._coordinates[i]));
    }
    return array.join(',')
  },

  linearring (linearring) {
    var array = [];
    for (let i = 0, len = linearring._points._coordinates.length; i < len; ++i) {
      array.push(extract.coordinate.call(this, linearring._points._coordinates[i]));
    }
    return array.join(',')
  },

  /**
   * Return a comma delimited string of linestring strings from a
   * multilinestring.
   *
   * @param {MultiLineString} multilinestring
   * @return {String} A string of of linestring strings representing the multilinestring.
   */
  multilinestring (multilinestring) {
    var array = [];
    for (let i = 0, len = multilinestring._geometries.length; i < len; ++i) {
      array.push('(' +
        extract.linestring.call(this, multilinestring._geometries[i]) +
        ')');
    }
    return array.join(',')
  },

  /**
   * Return a comma delimited string of linear ring arrays from a polygon.
   *
   * @param {Polygon} polygon
   * @return {String} An array of linear ring arrays representing the polygon.
   */
  polygon (polygon) {
    var array = [];
    array.push('(' + extract.linestring.call(this, polygon._shell) + ')');
    for (let i = 0, len = polygon._holes.length; i < len; ++i) {
      array.push('(' + extract.linestring.call(this, polygon._holes[i]) + ')');
    }
    return array.join(',')
  },

  /**
   * Return an array of polygon arrays from a multipolygon.
   *
   * @param {MultiPolygon} multipolygon
   * @return {String} An array of polygon arrays representing the multipolygon.
   */
  multipolygon (multipolygon) {
    var array = [];
    for (let i = 0, len = multipolygon._geometries.length; i < len; ++i) {
      array.push('(' + extract.polygon.call(this, multipolygon._geometries[i]) + ')');
    }
    return array.join(',')
  },

  /**
   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an
   * geometrycollection.
   *
   * @param {GeometryCollection} collection
   * @return {String} internal WKT representation of the collection.
   */
  geometrycollection (collection) {
    var array = [];
    for (let i = 0, len = collection._geometries.length; i < len; ++i) {
      array.push(this.extractGeometry(collection._geometries[i]));
    }
    return array.join(',')
  }
};

/**
 * Object with properties corresponding to the geometry types. Property values
 * are functions that do the actual parsing.
 * @private
 */
const parse = {

  coord (str) {
    var coords = str.trim().split(regExes.spaces);
    var coord = new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1]));
    this.precisionModel.makePrecise(coord);
    return coord
  },

  /**
   * Return point geometry given a point WKT fragment.
   *
   * @param {String} str A WKT fragment representing the point.
   * @return {Point} A point geometry.
   * @private
   */
  point (str) {
    if (str === undefined) { return this.geometryFactory.createPoint() }
    return this.geometryFactory.createPoint(parse.coord.call(this, str))
  },

  /**
   * Return a multipoint geometry given a multipoint WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multipoint.
   * @return {Point} A multipoint feature.
   * @private
   */
  multipoint (str) {
    if (str === undefined) { return this.geometryFactory.createMultiPoint() }
    var point;
    var points = str.trim().split(',');
    var components = [];
    for (let i = 0, len = points.length; i < len; ++i) {
      point = points[i].replace(regExes.trimParens, '$1');
      components.push(parse.point.call(this, point));
    }
    return this.geometryFactory.createMultiPoint(components)
  },

  /**
   * Return a linestring geometry given a linestring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the linestring.
   * @return {LineString} A linestring geometry.
   * @private
   */
  linestring (str) {
    if (str === undefined) {
      return this.geometryFactory.createLineString()
    }

    var points = str.trim().split(',');
    var components = [];
    for (let i = 0, len = points.length; i < len; ++i) {
      components.push(parse.coord.call(this, points[i]));
    }
    return this.geometryFactory.createLineString(components)
  },

  /**
   * Return a linearring geometry given a linearring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the linearring.
   * @return {LinearRing} A linearring geometry.
   * @private
   */
  linearring (str) {
    if (str === undefined) {
      return this.geometryFactory.createLinearRing()
    }

    var points = str.trim().split(',');
    var components = [];
    for (let i = 0, len = points.length; i < len; ++i) {
      components.push(parse.coord.call(this, points[i]));
    }
    return this.geometryFactory.createLinearRing(components)
  },

  /**
   * Return a multilinestring geometry given a multilinestring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multilinestring.
   * @return {MultiLineString} A multilinestring geometry.
   * @private
   */
  multilinestring (str) {
    if (str === undefined) {
      return this.geometryFactory.createMultiLineString()
    }

    var line;
    var lines = str.trim().split(regExes.parenComma);
    var components = [];
    for (let i = 0, len = lines.length; i < len; ++i) {
      line = lines[i].replace(regExes.trimParens, '$1');
      components.push(parse.linestring.call(this, line));
    }
    return this.geometryFactory.createMultiLineString(components)
  },

  /**
   * Return a polygon geometry given a polygon WKT fragment.
   *
   * @param {String} str A WKT fragment representing the polygon.
   * @return {Polygon} A polygon geometry.
   * @private
   */
  polygon (str) {
    if (str === undefined) {
      return this.geometryFactory.createPolygon()
    }

    var ring, linestring, linearring;
    var rings = str.trim().split(regExes.parenComma);
    var shell;
    var holes = [];
    for (let i = 0, len = rings.length; i < len; ++i) {
      ring = rings[i].replace(regExes.trimParens, '$1');
      linestring = parse.linestring.call(this, ring);
      linearring = this.geometryFactory.createLinearRing(linestring._points);
      if (i === 0) {
        shell = linearring;
      } else {
        holes.push(linearring);
      }
    }
    return this.geometryFactory.createPolygon(shell, holes)
  },

  /**
   * Return a multipolygon geometry given a multipolygon WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multipolygon.
   * @return {MultiPolygon} A multipolygon geometry.
   * @private
   */
  multipolygon (str) {
    if (str === undefined) {
      return this.geometryFactory.createMultiPolygon()
    }

    var polygon;
    var polygons = str.trim().split(regExes.doubleParenComma);
    var components = [];
    for (let i = 0, len = polygons.length; i < len; ++i) {
      polygon = polygons[i].replace(regExes.trimParens, '$1');
      components.push(parse.polygon.call(this, polygon));
    }
    return this.geometryFactory.createMultiPolygon(components)
  },

  /**
   * Return a geometrycollection given a geometrycollection WKT fragment.
   *
   * @param {String} str A WKT fragment representing the geometrycollection.
   * @return {GeometryCollection}
   * @private
   */
  geometrycollection (str) {
    if (str === undefined) {
      return this.geometryFactory.createGeometryCollection()
    }

    // separate components of the collection with |
    str = str.replace(/,\s*([A-Za-z])/g, '|$1');
    var wktArray = str.trim().split('|');
    var components = [];
    for (let i = 0, len = wktArray.length; i < len; ++i) {
      components.push(this.read(wktArray[i]));
    }
    return this.geometryFactory.createGeometryCollection(components)
  }
};

/**
 * @module org/locationtech/jts/io/WKTWriter
 */

/**
 * Writes the Well-Known Text representation of a {@link Geometry}. The
 * Well-Known Text format is defined in the <A
 * HREF="http://www.opengis.org/techno/specs.htm"> OGC Simple Features
 * Specification for SQL</A>.
 * <p>
 * The <code>WKTWriter</code> outputs coordinates rounded to the precision
 * model. Only the maximum number of decimal places necessary to represent the
 * ordinates to the required precision will be output.
 * <p>
 * The SFS WKT spec does not define a special tag for {@link LinearRing}s.
 * Under the spec, rings are output as <code>LINESTRING</code>s.
 */
class WKTWriter {
  /**
   * @param {GeometryFactory} geometryFactory
   */
  constructor (geometryFactory) {
    this.parser = new WKTParser(geometryFactory);
  }

  /**
   * Converts a <code>Geometry</code> to its Well-known Text representation.
   *
   * @param {Geometry} geometry a <code>Geometry</code> to process.
   * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple
   *         Features Specification).
   * @memberof module:org/locationtech/jts/io/WKTWriter#
   */
  write (geometry) {
    return this.parser.write(geometry)
  }

  /**
   * Generates the WKT for a <tt>LINESTRING</tt> specified by two
   * {@link Coordinate}s.
   *
   * @param p0 the first coordinate.
   * @param p1 the second coordinate.
   *
   * @return the WKT.
   * @private
   */
  static toLineString (p0, p1) {
    if (arguments.length !== 2) {
      throw new Error('Not implemented')
    }

    return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )'
  }
}

class LineIntersector {
  constructor () {
    LineIntersector.constructor_.apply(this, arguments);
  }

  static computeEdgeDistance (p, p0, p1) {
    const dx = Math.abs(p1.x - p0.x);
    const dy = Math.abs(p1.y - p0.y);
    let dist = -1.0;
    if (p.equals(p0)) {
      dist = 0.0;
    } else if (p.equals(p1)) {
      if (dx > dy) dist = dx; else dist = dy;
    } else {
      const pdx = Math.abs(p.x - p0.x);
      const pdy = Math.abs(p.y - p0.y);
      if (dx > dy) dist = pdx; else dist = pdy;
      if (dist === 0.0 && !p.equals(p0)) {
        dist = Math.max(pdx, pdy);
      }
    }
    Assert.isTrue(!(dist === 0.0 && !p.equals(p0)), 'Bad distance calculation');
    return dist
  }

  static nonRobustComputeEdgeDistance (p, p1, p2) {
    const dx = p.x - p1.x;
    const dy = p.y - p1.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    Assert.isTrue(!(dist === 0.0 && !p.equals(p1)), 'Invalid distance calculation');
    return dist
  }

  getIndexAlongSegment (segmentIndex, intIndex) {
    this.computeIntLineIndex();
    return this._intLineIndex[segmentIndex][intIndex]
  }

  getTopologySummary () {
    const catBuilder = new StringBuilder();
    if (this.isEndPoint()) catBuilder.append(' endpoint');
    if (this._isProper) catBuilder.append(' proper');
    if (this.isCollinear()) catBuilder.append(' collinear');
    return catBuilder.toString()
  }

  computeIntersection (p1, p2, p3, p4) {
    this._inputLines[0][0] = p1;
    this._inputLines[0][1] = p2;
    this._inputLines[1][0] = p3;
    this._inputLines[1][1] = p4;
    this._result = this.computeIntersect(p1, p2, p3, p4);
  }

  getIntersectionNum () {
    return this._result
  }

  computeIntLineIndex () {
    if (arguments.length === 0) {
      if (this._intLineIndex === null) {
        this._intLineIndex = Array(2).fill().map(() => Array(2));
        this.computeIntLineIndex(0);
        this.computeIntLineIndex(1);
      }
    } else if (arguments.length === 1) {
      const segmentIndex = arguments[0];
      const dist0 = this.getEdgeDistance(segmentIndex, 0);
      const dist1 = this.getEdgeDistance(segmentIndex, 1);
      if (dist0 > dist1) {
        this._intLineIndex[segmentIndex][0] = 0;
        this._intLineIndex[segmentIndex][1] = 1;
      } else {
        this._intLineIndex[segmentIndex][0] = 1;
        this._intLineIndex[segmentIndex][1] = 0;
      }
    }
  }

  isProper () {
    return this.hasIntersection() && this._isProper
  }

  setPrecisionModel (precisionModel) {
    this._precisionModel = precisionModel;
  }

  isInteriorIntersection () {
    if (arguments.length === 0) {
      if (this.isInteriorIntersection(0)) return true
      if (this.isInteriorIntersection(1)) return true
      return false
    } else if (arguments.length === 1) {
      const inputLineIndex = arguments[0];
      for (let i = 0; i < this._result; i++) {
        if (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) {
          return true
        }
      }
      return false
    }
  }

  getIntersection (intIndex) {
    return this._intPt[intIndex]
  }

  isEndPoint () {
    return this.hasIntersection() && !this._isProper
  }

  hasIntersection () {
    return this._result !== LineIntersector.NO_INTERSECTION
  }

  getEdgeDistance (segmentIndex, intIndex) {
    const dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);
    return dist
  }

  isCollinear () {
    return this._result === LineIntersector.COLLINEAR_INTERSECTION
  }

  toString () {
    return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + ' - ' + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary()
  }

  getEndpoint (segmentIndex, ptIndex) {
    return this._inputLines[segmentIndex][ptIndex]
  }

  isIntersection (pt) {
    for (let i = 0; i < this._result; i++) {
      if (this._intPt[i].equals2D(pt)) {
        return true
      }
    }
    return false
  }

  getIntersectionAlongSegment (segmentIndex, intIndex) {
    this.computeIntLineIndex();
    return this._intPt[this._intLineIndex[segmentIndex][intIndex]]
  }

  getClass () {
    return LineIntersector
  }

  get interfaces_ () {
    return []
  }
}
LineIntersector.constructor_ = function () {
  this._result = null;
  this._inputLines = Array(2).fill().map(() => Array(2));
  this._intPt = new Array(2).fill(null);
  this._intLineIndex = null;
  this._isProper = null;
  this._pa = null;
  this._pb = null;
  this._precisionModel = null;
  this._intPt[0] = new Coordinate();
  this._intPt[1] = new Coordinate();
  this._pa = this._intPt[0];
  this._pb = this._intPt[1];
  this._result = 0;
};
LineIntersector.DONT_INTERSECT = 0;
LineIntersector.DO_INTERSECT = 1;
LineIntersector.COLLINEAR = 2;
LineIntersector.NO_INTERSECTION = 0;
LineIntersector.POINT_INTERSECTION = 1;
LineIntersector.COLLINEAR_INTERSECTION = 2;

class RobustLineIntersector extends LineIntersector {
  constructor () {
    super();
    RobustLineIntersector.constructor_.apply(this, arguments);
  }

  static nearestEndpoint (p1, p2, q1, q2) {
    let nearestPt = p1;
    let minDist = Distance.pointToSegment(p1, q1, q2);
    let dist = Distance.pointToSegment(p2, q1, q2);
    if (dist < minDist) {
      minDist = dist;
      nearestPt = p2;
    }
    dist = Distance.pointToSegment(q1, p1, p2);
    if (dist < minDist) {
      minDist = dist;
      nearestPt = q1;
    }
    dist = Distance.pointToSegment(q2, p1, p2);
    if (dist < minDist) {
      minDist = dist;
      nearestPt = q2;
    }
    return nearestPt
  }

  isInSegmentEnvelopes (intPt) {
    const env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);
    const env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);
    return env0.contains(intPt) && env1.contains(intPt)
  }

  computeIntersection () {
    if (arguments.length === 3) {
      const p = arguments[0]; const p1 = arguments[1]; const p2 = arguments[2];
      this._isProper = false;
      if (Envelope.intersects(p1, p2, p)) {
        if (Orientation.index(p1, p2, p) === 0 && Orientation.index(p2, p1, p) === 0) {
          this._isProper = true;
          if (p.equals(p1) || p.equals(p2)) {
            this._isProper = false;
          }
          this._result = LineIntersector.POINT_INTERSECTION;
          return null
        }
      }
      this._result = LineIntersector.NO_INTERSECTION;
    } else return super.computeIntersection.apply(this, arguments)
  }

  normalizeToMinimum (n1, n2, n3, n4, normPt) {
    normPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);
    normPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);
    n1.x -= normPt.x;
    n1.y -= normPt.y;
    n2.x -= normPt.x;
    n2.y -= normPt.y;
    n3.x -= normPt.x;
    n3.y -= normPt.y;
    n4.x -= normPt.x;
    n4.y -= normPt.y;
  }

  safeHCoordinateIntersection (p1, p2, q1, q2) {
    let intPt = null;
    try {
      intPt = HCoordinate.intersection(p1, p2, q1, q2);
    } catch (e) {
      if (e instanceof NotRepresentableException) {
        intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);
      } else throw e
    } finally {}
    return intPt
  }

  intersection (p1, p2, q1, q2) {
    let intPt = this.intersectionWithNormalization(p1, p2, q1, q2);
    if (!this.isInSegmentEnvelopes(intPt)) {
      intPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));
    }
    if (this._precisionModel !== null) {
      this._precisionModel.makePrecise(intPt);
    }
    return intPt
  }

  smallestInAbsValue (x1, x2, x3, x4) {
    let x = x1;
    let xabs = Math.abs(x);
    if (Math.abs(x2) < xabs) {
      x = x2;
      xabs = Math.abs(x2);
    }
    if (Math.abs(x3) < xabs) {
      x = x3;
      xabs = Math.abs(x3);
    }
    if (Math.abs(x4) < xabs) {
      x = x4;
    }
    return x
  }

  checkDD (p1, p2, q1, q2, intPt) {
    const intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);
    const isIn = this.isInSegmentEnvelopes(intPtDD);
    System.out.println('DD in env = ' + isIn + '  --------------------- ' + intPtDD);
    if (intPt.distance(intPtDD) > 0.0001) {
      System.out.println('Distance = ' + intPt.distance(intPtDD));
    }
  }

  intersectionWithNormalization (p1, p2, q1, q2) {
    const n1 = new Coordinate(p1);
    const n2 = new Coordinate(p2);
    const n3 = new Coordinate(q1);
    const n4 = new Coordinate(q2);
    const normPt = new Coordinate();
    this.normalizeToEnvCentre(n1, n2, n3, n4, normPt);
    const intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);
    intPt.x += normPt.x;
    intPt.y += normPt.y;
    return intPt
  }

  computeCollinearIntersection (p1, p2, q1, q2) {
    const p1q1p2 = Envelope.intersects(p1, p2, q1);
    const p1q2p2 = Envelope.intersects(p1, p2, q2);
    const q1p1q2 = Envelope.intersects(q1, q2, p1);
    const q1p2q2 = Envelope.intersects(q1, q2, p2);
    if (p1q1p2 && p1q2p2) {
      this._intPt[0] = q1;
      this._intPt[1] = q2;
      return LineIntersector.COLLINEAR_INTERSECTION
    }
    if (q1p1q2 && q1p2q2) {
      this._intPt[0] = p1;
      this._intPt[1] = p2;
      return LineIntersector.COLLINEAR_INTERSECTION
    }
    if (p1q1p2 && q1p1q2) {
      this._intPt[0] = q1;
      this._intPt[1] = p1;
      return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION
    }
    if (p1q1p2 && q1p2q2) {
      this._intPt[0] = q1;
      this._intPt[1] = p2;
      return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION
    }
    if (p1q2p2 && q1p1q2) {
      this._intPt[0] = q2;
      this._intPt[1] = p1;
      return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION
    }
    if (p1q2p2 && q1p2q2) {
      this._intPt[0] = q2;
      this._intPt[1] = p2;
      return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION
    }
    return LineIntersector.NO_INTERSECTION
  }

  normalizeToEnvCentre (n00, n01, n10, n11, normPt) {
    const minX0 = n00.x < n01.x ? n00.x : n01.x;
    const minY0 = n00.y < n01.y ? n00.y : n01.y;
    const maxX0 = n00.x > n01.x ? n00.x : n01.x;
    const maxY0 = n00.y > n01.y ? n00.y : n01.y;
    const minX1 = n10.x < n11.x ? n10.x : n11.x;
    const minY1 = n10.y < n11.y ? n10.y : n11.y;
    const maxX1 = n10.x > n11.x ? n10.x : n11.x;
    const maxY1 = n10.y > n11.y ? n10.y : n11.y;
    const intMinX = minX0 > minX1 ? minX0 : minX1;
    const intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;
    const intMinY = minY0 > minY1 ? minY0 : minY1;
    const intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;
    const intMidX = (intMinX + intMaxX) / 2.0;
    const intMidY = (intMinY + intMaxY) / 2.0;
    normPt.x = intMidX;
    normPt.y = intMidY;
    n00.x -= normPt.x;
    n00.y -= normPt.y;
    n01.x -= normPt.x;
    n01.y -= normPt.y;
    n10.x -= normPt.x;
    n10.y -= normPt.y;
    n11.x -= normPt.x;
    n11.y -= normPt.y;
  }

  computeIntersect (p1, p2, q1, q2) {
    this._isProper = false;
    if (!Envelope.intersects(p1, p2, q1, q2)) return LineIntersector.NO_INTERSECTION
    const Pq1 = Orientation.index(p1, p2, q1);
    const Pq2 = Orientation.index(p1, p2, q2);
    if (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {
      return LineIntersector.NO_INTERSECTION
    }
    const Qp1 = Orientation.index(q1, q2, p1);
    const Qp2 = Orientation.index(q1, q2, p2);
    if (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {
      return LineIntersector.NO_INTERSECTION
    }
    const collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;
    if (collinear) {
      return this.computeCollinearIntersection(p1, p2, q1, q2)
    }
    if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {
      this._isProper = false;
      if (p1.equals2D(q1) || p1.equals2D(q2)) {
        this._intPt[0] = p1;
      } else if (p2.equals2D(q1) || p2.equals2D(q2)) {
        this._intPt[0] = p2;
      } else if (Pq1 === 0) {
        this._intPt[0] = new Coordinate(q1);
      } else if (Pq2 === 0) {
        this._intPt[0] = new Coordinate(q2);
      } else if (Qp1 === 0) {
        this._intPt[0] = new Coordinate(p1);
      } else if (Qp2 === 0) {
        this._intPt[0] = new Coordinate(p2);
      }
    } else {
      this._isProper = true;
      this._intPt[0] = this.intersection(p1, p2, q1, q2);
    }
    return LineIntersector.POINT_INTERSECTION
  }

  getClass () {
    return RobustLineIntersector
  }

  get interfaces_ () {
    return []
  }
}
RobustLineIntersector.constructor_ = function () {};

class RayCrossingCounter {
  constructor () {
    RayCrossingCounter.constructor_.apply(this, arguments);
  }

  static locatePointInRing () {
    if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {
      const p = arguments[0]; const ring = arguments[1];
      const counter = new RayCrossingCounter(p);
      const p1 = new Coordinate();
      const p2 = new Coordinate();
      for (let i = 1; i < ring.size(); i++) {
        ring.getCoordinate(i, p1);
        ring.getCoordinate(i - 1, p2);
        counter.countSegment(p1, p2);
        if (counter.isOnSegment()) return counter.getLocation()
      }
      return counter.getLocation()
    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {
      const p = arguments[0]; const ring = arguments[1];
      const counter = new RayCrossingCounter(p);
      for (let i = 1; i < ring.length; i++) {
        const p1 = ring[i];
        const p2 = ring[i - 1];
        counter.countSegment(p1, p2);
        if (counter.isOnSegment()) return counter.getLocation()
      }
      return counter.getLocation()
    }
  }

  countSegment (p1, p2) {
    if (p1.x < this._p.x && p2.x < this._p.x) return null
    if (this._p.x === p2.x && this._p.y === p2.y) {
      this._isPointOnSegment = true;
      return null
    }
    if (p1.y === this._p.y && p2.y === this._p.y) {
      let minx = p1.x;
      let maxx = p2.x;
      if (minx > maxx) {
        minx = p2.x;
        maxx = p1.x;
      }
      if (this._p.x >= minx && this._p.x <= maxx) {
        this._isPointOnSegment = true;
      }
      return null
    }
    if (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {
      let orient = Orientation.index(p1, p2, this._p);
      if (orient === Orientation.COLLINEAR) {
        this._isPointOnSegment = true;
        return null
      }
      if (p2.y < p1.y) {
        orient = -orient;
      }
      if (orient === Orientation.LEFT) {
        this._crossingCount++;
      }
    }
  }

  isPointInPolygon () {
    return this.getLocation() !== Location.EXTERIOR
  }

  getLocation () {
    if (this._isPointOnSegment) return Location.BOUNDARY
    if (this._crossingCount % 2 === 1) {
      return Location.INTERIOR
    }
    return Location.EXTERIOR
  }

  isOnSegment () {
    return this._isPointOnSegment
  }

  getClass () {
    return RayCrossingCounter
  }

  get interfaces_ () {
    return []
  }
}
RayCrossingCounter.constructor_ = function () {
  this._p = null;
  this._crossingCount = 0;
  this._isPointOnSegment = false;
  const p = arguments[0];
  this._p = p;
};

class PointLocation {
  constructor () {
    PointLocation.constructor_.apply(this, arguments);
  }

  static isOnLine () {
    if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {
      const p = arguments[0]; const line = arguments[1];
      const lineIntersector = new RobustLineIntersector();
      const p0 = new Coordinate();
      const p1 = new Coordinate();
      const n = line.size();
      for (let i = 1; i < n; i++) {
        line.getCoordinate(i - 1, p0);
        line.getCoordinate(i, p1);
        lineIntersector.computeIntersection(p, p0, p1);
        if (lineIntersector.hasIntersection()) {
          return true
        }
      }
      return false
    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {
      const p = arguments[0]; const line = arguments[1];
      const lineIntersector = new RobustLineIntersector();
      for (let i = 1; i < line.length; i++) {
        const p0 = line[i - 1];
        const p1 = line[i];
        lineIntersector.computeIntersection(p, p0, p1);
        if (lineIntersector.hasIntersection()) {
          return true
        }
      }
      return false
    }
  }

  static locateInRing (p, ring) {
    return RayCrossingCounter.locatePointInRing(p, ring)
  }

  static isInRing (p, ring) {
    return PointLocation.locateInRing(p, ring) !== Location.EXTERIOR
  }

  getClass () {
    return PointLocation
  }

  get interfaces_ () {
    return []
  }
}
PointLocation.constructor_ = function () {};

class TopologyLocation {
  constructor () {
    TopologyLocation.constructor_.apply(this, arguments);
  }

  setAllLocations (locValue) {
    for (let i = 0; i < this.location.length; i++) {
      this.location[i] = locValue;
    }
  }

  isNull () {
    for (let i = 0; i < this.location.length; i++) {
      if (this.location[i] !== Location.NONE) return false
    }
    return true
  }

  setAllLocationsIfNull (locValue) {
    for (let i = 0; i < this.location.length; i++) {
      if (this.location[i] === Location.NONE) this.location[i] = locValue;
    }
  }

  isLine () {
    return this.location.length === 1
  }

  merge (gl) {
    if (gl.location.length > this.location.length) {
      const newLoc = new Array(3).fill(null);
      newLoc[Position.ON] = this.location[Position.ON];
      newLoc[Position.LEFT] = Location.NONE;
      newLoc[Position.RIGHT] = Location.NONE;
      this.location = newLoc;
    }
    for (let i = 0; i < this.location.length; i++) {
      if (this.location[i] === Location.NONE && i < gl.location.length) this.location[i] = gl.location[i];
    }
  }

  getLocations () {
    return this.location
  }

  flip () {
    if (this.location.length <= 1) return null
    const temp = this.location[Position.LEFT];
    this.location[Position.LEFT] = this.location[Position.RIGHT];
    this.location[Position.RIGHT] = temp;
  }

  toString () {
    const buf = new StringBuffer();
    if (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));
    buf.append(Location.toLocationSymbol(this.location[Position.ON]));
    if (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));
    return buf.toString()
  }

  setLocations (on, left, right) {
    this.location[Position.ON] = on;
    this.location[Position.LEFT] = left;
    this.location[Position.RIGHT] = right;
  }

  get (posIndex) {
    if (posIndex < this.location.length) return this.location[posIndex]
    return Location.NONE
  }

  isArea () {
    return this.location.length > 1
  }

  isAnyNull () {
    for (let i = 0; i < this.location.length; i++) {
      if (this.location[i] === Location.NONE) return true
    }
    return false
  }

  setLocation () {
    if (arguments.length === 1) {
      const locValue = arguments[0];
      this.setLocation(Position.ON, locValue);
    } else if (arguments.length === 2) {
      const locIndex = arguments[0]; const locValue = arguments[1];
      this.location[locIndex] = locValue;
    }
  }

  init (size) {
    this.location = new Array(size).fill(null);
    this.setAllLocations(Location.NONE);
  }

  isEqualOnSide (le, locIndex) {
    return this.location[locIndex] === le.location[locIndex]
  }

  allPositionsEqual (loc) {
    for (let i = 0; i < this.location.length; i++) {
      if (this.location[i] !== loc) return false
    }
    return true
  }

  getClass () {
    return TopologyLocation
  }

  get interfaces_ () {
    return []
  }
}
TopologyLocation.constructor_ = function () {
  this.location = null;
  if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      const location = arguments[0];
      this.init(location.length);
    } else if (Number.isInteger(arguments[0])) {
      const on = arguments[0];
      this.init(1);
      this.location[Position.ON] = on;
    } else if (arguments[0] instanceof TopologyLocation) {
      const gl = arguments[0];
      this.init(gl.location.length);
      if (gl !== null) {
        for (let i = 0; i < this.location.length; i++) {
          this.location[i] = gl.location[i];
        }
      }
    }
  } else if (arguments.length === 3) {
    const on = arguments[0]; const left = arguments[1]; const right = arguments[2];
    this.init(3);
    this.location[Position.ON] = on;
    this.location[Position.LEFT] = left;
    this.location[Position.RIGHT] = right;
  }
};

class Label$1 {
  constructor () {
    Label$1.constructor_.apply(this, arguments);
  }

  static toLineLabel (label) {
    const lineLabel = new Label$1(Location.NONE);
    for (let i = 0; i < 2; i++) {
      lineLabel.setLocation(i, label.getLocation(i));
    }
    return lineLabel
  }

  getGeometryCount () {
    let count = 0;
    if (!this.elt[0].isNull()) count++;
    if (!this.elt[1].isNull()) count++;
    return count
  }

  setAllLocations (geomIndex, location) {
    this.elt[geomIndex].setAllLocations(location);
  }

  isNull (geomIndex) {
    return this.elt[geomIndex].isNull()
  }

  setAllLocationsIfNull () {
    if (arguments.length === 1) {
      const location = arguments[0];
      this.setAllLocationsIfNull(0, location);
      this.setAllLocationsIfNull(1, location);
    } else if (arguments.length === 2) {
      const geomIndex = arguments[0]; const location = arguments[1];
      this.elt[geomIndex].setAllLocationsIfNull(location);
    }
  }

  isLine (geomIndex) {
    return this.elt[geomIndex].isLine()
  }

  merge (lbl) {
    for (let i = 0; i < 2; i++) {
      if (this.elt[i] === null && lbl.elt[i] !== null) {
        this.elt[i] = new TopologyLocation(lbl.elt[i]);
      } else {
        this.elt[i].merge(lbl.elt[i]);
      }
    }
  }

  flip () {
    this.elt[0].flip();
    this.elt[1].flip();
  }

  getLocation () {
    if (arguments.length === 1) {
      const geomIndex = arguments[0];
      return this.elt[geomIndex].get(Position.ON)
    } else if (arguments.length === 2) {
      const geomIndex = arguments[0]; const posIndex = arguments[1];
      return this.elt[geomIndex].get(posIndex)
    }
  }

  toString () {
    const buf = new StringBuffer();
    if (this.elt[0] !== null) {
      buf.append('A:');
      buf.append(this.elt[0].toString());
    }
    if (this.elt[1] !== null) {
      buf.append(' B:');
      buf.append(this.elt[1].toString());
    }
    return buf.toString()
  }

  isArea () {
    if (arguments.length === 0) {
      return this.elt[0].isArea() || this.elt[1].isArea()
    } else if (arguments.length === 1) {
      const geomIndex = arguments[0];
      return this.elt[geomIndex].isArea()
    }
  }

  isAnyNull (geomIndex) {
    return this.elt[geomIndex].isAnyNull()
  }

  setLocation () {
    if (arguments.length === 2) {
      const geomIndex = arguments[0]; const location = arguments[1];
      this.elt[geomIndex].setLocation(Position.ON, location);
    } else if (arguments.length === 3) {
      const geomIndex = arguments[0]; const posIndex = arguments[1]; const location = arguments[2];
      this.elt[geomIndex].setLocation(posIndex, location);
    }
  }

  isEqualOnSide (lbl, side) {
    return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side)
  }

  allPositionsEqual (geomIndex, loc) {
    return this.elt[geomIndex].allPositionsEqual(loc)
  }

  toLine (geomIndex) {
    if (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);
  }

  getClass () {
    return Label$1
  }

  get interfaces_ () {
    return []
  }
}
Label$1.constructor_ = function () {
  this.elt = new Array(2).fill(null);
  if (arguments.length === 1) {
    if (Number.isInteger(arguments[0])) {
      const onLoc = arguments[0];
      this.elt[0] = new TopologyLocation(onLoc);
      this.elt[1] = new TopologyLocation(onLoc);
    } else if (arguments[0] instanceof Label$1) {
      const lbl = arguments[0];
      this.elt[0] = new TopologyLocation(lbl.elt[0]);
      this.elt[1] = new TopologyLocation(lbl.elt[1]);
    }
  } else if (arguments.length === 2) {
    const geomIndex = arguments[0]; const onLoc = arguments[1];
    this.elt[0] = new TopologyLocation(Location.NONE);
    this.elt[1] = new TopologyLocation(Location.NONE);
    this.elt[geomIndex].setLocation(onLoc);
  } else if (arguments.length === 3) {
    const onLoc = arguments[0]; const leftLoc = arguments[1]; const rightLoc = arguments[2];
    this.elt[0] = new TopologyLocation(onLoc, leftLoc, rightLoc);
    this.elt[1] = new TopologyLocation(onLoc, leftLoc, rightLoc);
  } else if (arguments.length === 4) {
    const geomIndex = arguments[0]; const onLoc = arguments[1]; const leftLoc = arguments[2]; const rightLoc = arguments[3];
    this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
    this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
    this.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc);
  }
};

class EdgeRing {
  constructor () {
    EdgeRing.constructor_.apply(this, arguments);
  }

  computeRing () {
    if (this._ring !== null) return null
    const coord = new Array(this._pts.size()).fill(null);
    for (let i = 0; i < this._pts.size(); i++) {
      coord[i] = this._pts.get(i);
    }
    this._ring = this._geometryFactory.createLinearRing(coord);
    this._isHole = Orientation.isCCW(this._ring.getCoordinates());
  }

  isIsolated () {
    return this._label.getGeometryCount() === 1
  }

  computePoints (start) {
    this._startDe = start;
    let de = start;
    let isFirstEdge = true;
    do {
      if (de === null) throw new TopologyException('Found null DirectedEdge')
      if (de.getEdgeRing() === this) throw new TopologyException('Directed Edge visited twice during ring-building at ' + de.getCoordinate())
      this._edges.add(de);
      const label = de.getLabel();
      Assert.isTrue(label.isArea());
      this.mergeLabel(label);
      this.addPoints(de.getEdge(), de.isForward(), isFirstEdge);
      isFirstEdge = false;
      this.setEdgeRing(de, this);
      de = this.getNext(de);
    } while (de !== this._startDe)
  }

  getLinearRing () {
    return this._ring
  }

  getCoordinate (i) {
    return this._pts.get(i)
  }

  computeMaxNodeDegree () {
    this._maxNodeDegree = 0;
    let de = this._startDe;
    do {
      const node = de.getNode();
      const degree = node.getEdges().getOutgoingDegree(this);
      if (degree > this._maxNodeDegree) this._maxNodeDegree = degree;
      de = this.getNext(de);
    } while (de !== this._startDe)
    this._maxNodeDegree *= 2;
  }

  addPoints (edge, isForward, isFirstEdge) {
    const edgePts = edge.getCoordinates();
    if (isForward) {
      let startIndex = 1;
      if (isFirstEdge) startIndex = 0;
      for (let i = startIndex; i < edgePts.length; i++) {
        this._pts.add(edgePts[i]);
      }
    } else {
      let startIndex = edgePts.length - 2;
      if (isFirstEdge) startIndex = edgePts.length - 1;
      for (let i = startIndex; i >= 0; i--) {
        this._pts.add(edgePts[i]);
      }
    }
  }

  isHole () {
    return this._isHole
  }

  setInResult () {
    let de = this._startDe;
    do {
      de.getEdge().setInResult(true);
      de = de.getNext();
    } while (de !== this._startDe)
  }

  containsPoint (p) {
    const shell = this.getLinearRing();
    const env = shell.getEnvelopeInternal();
    if (!env.contains(p)) return false
    if (!PointLocation.isInRing(p, shell.getCoordinates())) return false
    for (let i = this._holes.iterator(); i.hasNext();) {
      const hole = i.next();
      if (hole.containsPoint(p)) return false
    }
    return true
  }

  addHole (ring) {
    this._holes.add(ring);
  }

  isShell () {
    return this._shell === null
  }

  getLabel () {
    return this._label
  }

  getEdges () {
    return this._edges
  }

  getMaxNodeDegree () {
    if (this._maxNodeDegree < 0) this.computeMaxNodeDegree();
    return this._maxNodeDegree
  }

  getShell () {
    return this._shell
  }

  mergeLabel () {
    if (arguments.length === 1) {
      const deLabel = arguments[0];
      this.mergeLabel(deLabel, 0);
      this.mergeLabel(deLabel, 1);
    } else if (arguments.length === 2) {
      const deLabel = arguments[0]; const geomIndex = arguments[1];
      const loc = deLabel.getLocation(geomIndex, Position.RIGHT);
      if (loc === Location.NONE) return null
      if (this._label.getLocation(geomIndex) === Location.NONE) {
        this._label.setLocation(geomIndex, loc);
        return null
      }
    }
  }

  setShell (shell) {
    this._shell = shell;
    if (shell !== null) shell.addHole(this);
  }

  toPolygon (geometryFactory) {
    const holeLR = new Array(this._holes.size()).fill(null);
    for (let i = 0; i < this._holes.size(); i++) {
      holeLR[i] = this._holes.get(i).getLinearRing();
    }
    const poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);
    return poly
  }

  getClass () {
    return EdgeRing
  }

  get interfaces_ () {
    return []
  }
}
EdgeRing.constructor_ = function () {
  this._startDe = null;
  this._maxNodeDegree = -1;
  this._edges = new ArrayList();
  this._pts = new ArrayList();
  this._label = new Label$1(Location.NONE);
  this._ring = null;
  this._isHole = null;
  this._shell = null;
  this._holes = new ArrayList();
  this._geometryFactory = null;
  if (arguments.length === 0) ; else if (arguments.length === 2) {
    const start = arguments[0]; const geometryFactory = arguments[1];
    this._geometryFactory = geometryFactory;
    this.computePoints(start);
    this.computeRing();
  }
};

class MinimalEdgeRing extends EdgeRing {
  constructor () {
    super();
    MinimalEdgeRing.constructor_.apply(this, arguments);
  }

  setEdgeRing (de, er) {
    de.setMinEdgeRing(er);
  }

  getNext (de) {
    return de.getNextMin()
  }

  getClass () {
    return MinimalEdgeRing
  }

  get interfaces_ () {
    return []
  }
}
MinimalEdgeRing.constructor_ = function () {
  const start = arguments[0]; const geometryFactory = arguments[1];
  EdgeRing.constructor_.call(this, start, geometryFactory);
};

class MaximalEdgeRing extends EdgeRing {
  constructor () {
    super();
    MaximalEdgeRing.constructor_.apply(this, arguments);
  }

  buildMinimalRings () {
    const minEdgeRings = new ArrayList();
    let de = this._startDe;
    do {
      if (de.getMinEdgeRing() === null) {
        const minEr = new MinimalEdgeRing(de, this._geometryFactory);
        minEdgeRings.add(minEr);
      }
      de = de.getNext();
    } while (de !== this._startDe)
    return minEdgeRings
  }

  setEdgeRing (de, er) {
    de.setEdgeRing(er);
  }

  linkDirectedEdgesForMinimalEdgeRings () {
    let de = this._startDe;
    do {
      const node = de.getNode();
      node.getEdges().linkMinimalDirectedEdges(this);
      de = de.getNext();
    } while (de !== this._startDe)
  }

  getNext (de) {
    return de.getNext()
  }

  getClass () {
    return MaximalEdgeRing
  }

  get interfaces_ () {
    return []
  }
}
MaximalEdgeRing.constructor_ = function () {
  const start = arguments[0]; const geometryFactory = arguments[1];
  EdgeRing.constructor_.call(this, start, geometryFactory);
};

class GraphComponent {
  constructor () {
    GraphComponent.constructor_.apply(this, arguments);
  }

  setVisited (isVisited) {
    this._isVisited = isVisited;
  }

  setInResult (isInResult) {
    this._isInResult = isInResult;
  }

  isCovered () {
    return this._isCovered
  }

  isCoveredSet () {
    return this._isCoveredSet
  }

  setLabel (label) {
    this._label = label;
  }

  getLabel () {
    return this._label
  }

  setCovered (isCovered) {
    this._isCovered = isCovered;
    this._isCoveredSet = true;
  }

  updateIM (im) {
    Assert.isTrue(this._label.getGeometryCount() >= 2, 'found partial label');
    this.computeIM(im);
  }

  isInResult () {
    return this._isInResult
  }

  isVisited () {
    return this._isVisited
  }

  getClass () {
    return GraphComponent
  }

  get interfaces_ () {
    return []
  }
}
GraphComponent.constructor_ = function () {
  this._label = null;
  this._isInResult = false;
  this._isCovered = false;
  this._isCoveredSet = false;
  this._isVisited = false;
  if (arguments.length === 0) ; else if (arguments.length === 1) {
    const label = arguments[0];
    this._label = label;
  }
};

class Node extends GraphComponent {
  constructor () {
    super();
    Node.constructor_.apply(this, arguments);
  }

  isIncidentEdgeInResult () {
    for (let it = this.getEdges().getEdges().iterator(); it.hasNext();) {
      const de = it.next();
      if (de.getEdge().isInResult()) return true
    }
    return false
  }

  isIsolated () {
    return this._label.getGeometryCount() === 1
  }

  getCoordinate () {
    return this._coord
  }

  print (out) {
    out.println('node ' + this._coord + ' lbl: ' + this._label);
  }

  computeIM (im) {}
  computeMergedLocation (label2, eltIndex) {
    let loc = Location.NONE;
    loc = this._label.getLocation(eltIndex);
    if (!label2.isNull(eltIndex)) {
      const nLoc = label2.getLocation(eltIndex);
      if (loc !== Location.BOUNDARY) loc = nLoc;
    }
    return loc
  }

  setLabel () {
    if (arguments.length === 2 && (Number.isInteger(arguments[1]) && Number.isInteger(arguments[0]))) {
      const argIndex = arguments[0]; const onLocation = arguments[1];
      if (this._label === null) {
        this._label = new Label$1(argIndex, onLocation);
      } else this._label.setLocation(argIndex, onLocation);
    } else return super.setLabel.apply(this, arguments)
  }

  getEdges () {
    return this._edges
  }

  mergeLabel () {
    if (arguments[0] instanceof Node) {
      const n = arguments[0];
      this.mergeLabel(n._label);
    } else if (arguments[0] instanceof Label$1) {
      const label2 = arguments[0];
      for (let i = 0; i < 2; i++) {
        const loc = this.computeMergedLocation(label2, i);
        const thisLoc = this._label.getLocation(i);
        if (thisLoc === Location.NONE) this._label.setLocation(i, loc);
      }
    }
  }

  add (e) {
    this._edges.insert(e);
    e.setNode(this);
  }

  setLabelBoundary (argIndex) {
    if (this._label === null) return null
    let loc = Location.NONE;
    if (this._label !== null) loc = this._label.getLocation(argIndex);
    let newLoc = null;
    switch (loc) {
      case Location.BOUNDARY:
        newLoc = Location.INTERIOR;
        break
      case Location.INTERIOR:
        newLoc = Location.BOUNDARY;
        break
      default:
        newLoc = Location.BOUNDARY;
        break
    }
    this._label.setLocation(argIndex, newLoc);
  }

  getClass () {
    return Node
  }

  get interfaces_ () {
    return []
  }
}
Node.constructor_ = function () {
  this._coord = null;
  this._edges = null;
  const coord = arguments[0]; const edges = arguments[1];
  this._coord = coord;
  this._edges = edges;
  this._label = new Label$1(0, Location.NONE);
};

class NodeMap {
  constructor () {
    NodeMap.constructor_.apply(this, arguments);
  }

  find (coord) {
    return this.nodeMap.get(coord)
  }

  addNode () {
    if (arguments[0] instanceof Coordinate) {
      const coord = arguments[0];
      let node = this.nodeMap.get(coord);
      if (node === null) {
        node = this.nodeFact.createNode(coord);
        this.nodeMap.put(coord, node);
      }
      return node
    } else if (arguments[0] instanceof Node) {
      const n = arguments[0];
      const node = this.nodeMap.get(n.getCoordinate());
      if (node === null) {
        this.nodeMap.put(n.getCoordinate(), n);
        return n
      }
      node.mergeLabel(n);
      return node
    }
  }

  print (out) {
    for (let it = this.iterator(); it.hasNext();) {
      const n = it.next();
      n.print(out);
    }
  }

  iterator () {
    return this.nodeMap.values().iterator()
  }

  values () {
    return this.nodeMap.values()
  }

  getBoundaryNodes (geomIndex) {
    const bdyNodes = new ArrayList();
    for (let i = this.iterator(); i.hasNext();) {
      const node = i.next();
      if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) bdyNodes.add(node);
    }
    return bdyNodes
  }

  add (e) {
    const p = e.getCoordinate();
    const n = this.addNode(p);
    n.add(e);
  }

  getClass () {
    return NodeMap
  }

  get interfaces_ () {
    return []
  }
}
NodeMap.constructor_ = function () {
  this.nodeMap = new TreeMap();
  this.nodeFact = null;
  const nodeFact = arguments[0];
  this.nodeFact = nodeFact;
};

class Quadrant {
  constructor () {
    Quadrant.constructor_.apply(this, arguments);
  }

  static isNorthern (quad) {
    return quad === Quadrant.NE || quad === Quadrant.NW
  }

  static isOpposite (quad1, quad2) {
    if (quad1 === quad2) return false
    const diff = (quad1 - quad2 + 4) % 4;
    if (diff === 2) return true
    return false
  }

  static commonHalfPlane (quad1, quad2) {
    if (quad1 === quad2) return quad1
    const diff = (quad1 - quad2 + 4) % 4;
    if (diff === 2) return -1
    const min = quad1 < quad2 ? quad1 : quad2;
    const max = quad1 > quad2 ? quad1 : quad2;
    if (min === 0 && max === 3) return 3
    return min
  }

  static isInHalfPlane (quad, halfPlane) {
    if (halfPlane === Quadrant.SE) {
      return quad === Quadrant.SE || quad === Quadrant.SW
    }
    return quad === halfPlane || quad === halfPlane + 1
  }

  static quadrant () {
    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
      const dx = arguments[0]; const dy = arguments[1];
      if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the quadrant for point ( ' + dx + ', ' + dy + ' )')
      if (dx >= 0.0) {
        if (dy >= 0.0) return Quadrant.NE; else return Quadrant.SE
      } else {
        if (dy >= 0.0) return Quadrant.NW; else return Quadrant.SW
      }
    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
      const p0 = arguments[0]; const p1 = arguments[1];
      if (p1.x === p0.x && p1.y === p0.y) throw new IllegalArgumentException('Cannot compute the quadrant for two identical points ' + p0)
      if (p1.x >= p0.x) {
        if (p1.y >= p0.y) return Quadrant.NE; else return Quadrant.SE
      } else {
        if (p1.y >= p0.y) return Quadrant.NW; else return Quadrant.SW
      }
    }
  }

  getClass () {
    return Quadrant
  }

  get interfaces_ () {
    return []
  }
}
Quadrant.constructor_ = function () {};
Quadrant.NE = 0;
Quadrant.NW = 1;
Quadrant.SW = 2;
Quadrant.SE = 3;

class EdgeEnd {
  constructor () {
    EdgeEnd.constructor_.apply(this, arguments);
  }

  compareDirection (e) {
    if (this._dx === e._dx && this._dy === e._dy) return 0
    if (this._quadrant > e._quadrant) return 1
    if (this._quadrant < e._quadrant) return -1
    return Orientation.index(e._p0, e._p1, this._p1)
  }

  getDy () {
    return this._dy
  }

  getCoordinate () {
    return this._p0
  }

  setNode (node) {
    this._node = node;
  }

  print (out) {
    const angle = Math.atan2(this._dy, this._dx);
    const className = this.getClass().getName();
    const lastDotPos = className.lastIndexOf('.');
    const name = className.substring(lastDotPos + 1);
    out.print('  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label);
  }

  compareTo (obj) {
    const e = obj;
    return this.compareDirection(e)
  }

  getDirectedCoordinate () {
    return this._p1
  }

  getDx () {
    return this._dx
  }

  getLabel () {
    return this._label
  }

  getEdge () {
    return this._edge
  }

  getQuadrant () {
    return this._quadrant
  }

  getNode () {
    return this._node
  }

  toString () {
    const angle = Math.atan2(this._dy, this._dx);
    const className = this.getClass().getName();
    const lastDotPos = className.lastIndexOf('.');
    const name = className.substring(lastDotPos + 1);
    return '  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label
  }

  computeLabel (boundaryNodeRule) {}
  init (p0, p1) {
    this._p0 = p0;
    this._p1 = p1;
    this._dx = p1.x - p0.x;
    this._dy = p1.y - p0.y;
    this._quadrant = Quadrant.quadrant(this._dx, this._dy);
    Assert.isTrue(!(this._dx === 0 && this._dy === 0), 'EdgeEnd with identical endpoints found');
  }

  getClass () {
    return EdgeEnd
  }

  get interfaces_ () {
    return [Comparable]
  }
}
EdgeEnd.constructor_ = function () {
  this._edge = null;
  this._label = null;
  this._node = null;
  this._p0 = null;
  this._p1 = null;
  this._dx = null;
  this._dy = null;
  this._quadrant = null;
  if (arguments.length === 1) {
    const edge = arguments[0];
    this._edge = edge;
  } else if (arguments.length === 3) {
    const edge = arguments[0]; const p0 = arguments[1]; const p1 = arguments[2];
    EdgeEnd.constructor_.call(this, edge, p0, p1, null);
  } else if (arguments.length === 4) {
    const edge = arguments[0]; const p0 = arguments[1]; const p1 = arguments[2]; const label = arguments[3];
    EdgeEnd.constructor_.call(this, edge);
    this.init(p0, p1);
    this._label = label;
  }
};

class DirectedEdge extends EdgeEnd {
  constructor () {
    super();
    DirectedEdge.constructor_.apply(this, arguments);
  }

  static depthFactor (currLocation, nextLocation) {
    if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) return 1; else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) return -1
    return 0
  }

  getNextMin () {
    return this._nextMin
  }

  getDepth (position) {
    return this._depth[position]
  }

  setVisited (isVisited) {
    this._isVisited = isVisited;
  }

  computeDirectedLabel () {
    this._label = new Label$1(this._edge.getLabel());
    if (!this._isForward) this._label.flip();
  }

  getNext () {
    return this._next
  }

  setDepth (position, depthVal) {
    if (this._depth[position] !== -999) {
      if (this._depth[position] !== depthVal) throw new TopologyException('assigned depths do not match', this.getCoordinate())
    }
    this._depth[position] = depthVal;
  }

  isInteriorAreaEdge () {
    let isInteriorAreaEdge = true;
    for (let i = 0; i < 2; i++) {
      if (!(this._label.isArea(i) && this._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {
        isInteriorAreaEdge = false;
      }
    }
    return isInteriorAreaEdge
  }

  setNextMin (nextMin) {
    this._nextMin = nextMin;
  }

  print (out) {
    super.print.call(this, out);
    out.print(' ' + this._depth[Position.LEFT] + '/' + this._depth[Position.RIGHT]);
    out.print(' (' + this.getDepthDelta() + ')');
    if (this._isInResult) out.print(' inResult');
  }

  setMinEdgeRing (minEdgeRing) {
    this._minEdgeRing = minEdgeRing;
  }

  isLineEdge () {
    const isLine = this._label.isLine(0) || this._label.isLine(1);
    const isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);
    const isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);
    return isLine && isExteriorIfArea0 && isExteriorIfArea1
  }

  setEdgeRing (edgeRing) {
    this._edgeRing = edgeRing;
  }

  getMinEdgeRing () {
    return this._minEdgeRing
  }

  getDepthDelta () {
    let depthDelta = this._edge.getDepthDelta();
    if (!this._isForward) depthDelta = -depthDelta;
    return depthDelta
  }

  setInResult (isInResult) {
    this._isInResult = isInResult;
  }

  getSym () {
    return this._sym
  }

  isForward () {
    return this._isForward
  }

  getEdge () {
    return this._edge
  }

  printEdge (out) {
    this.print(out);
    out.print(' ');
    if (this._isForward) this._edge.print(out); else this._edge.printReverse(out);
  }

  setSym (de) {
    this._sym = de;
  }

  setVisitedEdge (isVisited) {
    this.setVisited(isVisited);
    this._sym.setVisited(isVisited);
  }

  setEdgeDepths (position, depth) {
    let depthDelta = this.getEdge().getDepthDelta();
    if (!this._isForward) depthDelta = -depthDelta;
    let directionFactor = 1;
    if (position === Position.LEFT) directionFactor = -1;
    const oppositePos = Position.opposite(position);
    const delta = depthDelta * directionFactor;
    const oppositeDepth = depth + delta;
    this.setDepth(position, depth);
    this.setDepth(oppositePos, oppositeDepth);
  }

  getEdgeRing () {
    return this._edgeRing
  }

  isInResult () {
    return this._isInResult
  }

  setNext (next) {
    this._next = next;
  }

  isVisited () {
    return this._isVisited
  }

  getClass () {
    return DirectedEdge
  }

  get interfaces_ () {
    return []
  }
}
DirectedEdge.constructor_ = function () {
  this._isForward = null;
  this._isInResult = false;
  this._isVisited = false;
  this._sym = null;
  this._next = null;
  this._nextMin = null;
  this._edgeRing = null;
  this._minEdgeRing = null;
  this._depth = [0, -999, -999];
  const edge = arguments[0]; const isForward = arguments[1];
  EdgeEnd.constructor_.call(this, edge);
  this._isForward = isForward;
  if (isForward) {
    this.init(edge.getCoordinate(0), edge.getCoordinate(1));
  } else {
    const n = edge.getNumPoints() - 1;
    this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));
  }
  this.computeDirectedLabel();
};

class NodeFactory {
  constructor () {
    NodeFactory.constructor_.apply(this, arguments);
  }

  createNode (coord) {
    return new Node(coord, null)
  }

  getClass () {
    return NodeFactory
  }

  get interfaces_ () {
    return []
  }
}
NodeFactory.constructor_ = function () {};

class PlanarGraph {
  constructor () {
    PlanarGraph.constructor_.apply(this, arguments);
  }

  static linkResultDirectedEdges (nodes) {
    for (let nodeit = nodes.iterator(); nodeit.hasNext();) {
      const node = nodeit.next();
      node.getEdges().linkResultDirectedEdges();
    }
  }

  printEdges (out) {
    out.println('Edges:');
    for (let i = 0; i < this._edges.size(); i++) {
      out.println('edge ' + i + ':');
      const e = this._edges.get(i);
      e.print(out);
      e.eiList.print(out);
    }
  }

  find (coord) {
    return this._nodes.find(coord)
  }

  addNode () {
    if (arguments[0] instanceof Node) {
      const node = arguments[0];
      return this._nodes.addNode(node)
    } else if (arguments[0] instanceof Coordinate) {
      const coord = arguments[0];
      return this._nodes.addNode(coord)
    }
  }

  getNodeIterator () {
    return this._nodes.iterator()
  }

  linkResultDirectedEdges () {
    for (let nodeit = this._nodes.iterator(); nodeit.hasNext();) {
      const node = nodeit.next();
      node.getEdges().linkResultDirectedEdges();
    }
  }

  debugPrintln (o) {
    System.out.println(o);
  }

  isBoundaryNode (geomIndex, coord) {
    const node = this._nodes.find(coord);
    if (node === null) return false
    const label = node.getLabel();
    if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) return true
    return false
  }

  linkAllDirectedEdges () {
    for (let nodeit = this._nodes.iterator(); nodeit.hasNext();) {
      const node = nodeit.next();
      node.getEdges().linkAllDirectedEdges();
    }
  }

  matchInSameDirection (p0, p1, ep0, ep1) {
    if (!p0.equals(ep0)) return false
    if (Orientation.index(p0, p1, ep1) === Orientation.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) return true
    return false
  }

  getEdgeEnds () {
    return this._edgeEndList
  }

  debugPrint (o) {
    System.out.print(o);
  }

  getEdgeIterator () {
    return this._edges.iterator()
  }

  findEdgeInSameDirection (p0, p1) {
    for (let i = 0; i < this._edges.size(); i++) {
      const e = this._edges.get(i);
      const eCoord = e.getCoordinates();
      if (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e
      if (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e
    }
    return null
  }

  insertEdge (e) {
    this._edges.add(e);
  }

  findEdgeEnd (e) {
    for (let i = this.getEdgeEnds().iterator(); i.hasNext();) {
      const ee = i.next();
      if (ee.getEdge() === e) return ee
    }
    return null
  }

  addEdges (edgesToAdd) {
    for (let it = edgesToAdd.iterator(); it.hasNext();) {
      const e = it.next();
      this._edges.add(e);
      const de1 = new DirectedEdge(e, true);
      const de2 = new DirectedEdge(e, false);
      de1.setSym(de2);
      de2.setSym(de1);
      this.add(de1);
      this.add(de2);
    }
  }

  add (e) {
    this._nodes.add(e);
    this._edgeEndList.add(e);
  }

  getNodes () {
    return this._nodes.values()
  }

  findEdge (p0, p1) {
    for (let i = 0; i < this._edges.size(); i++) {
      const e = this._edges.get(i);
      const eCoord = e.getCoordinates();
      if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e
    }
    return null
  }

  getClass () {
    return PlanarGraph
  }

  get interfaces_ () {
    return []
  }
}
PlanarGraph.constructor_ = function () {
  this._edges = new ArrayList();
  this._nodes = null;
  this._edgeEndList = new ArrayList();
  if (arguments.length === 0) {
    this._nodes = new NodeMap(new NodeFactory());
  } else if (arguments.length === 1) {
    const nodeFact = arguments[0];
    this._nodes = new NodeMap(nodeFact);
  }
};

class PolygonBuilder {
  constructor () {
    PolygonBuilder.constructor_.apply(this, arguments);
  }

  sortShellsAndHoles (edgeRings, shellList, freeHoleList) {
    for (let it = edgeRings.iterator(); it.hasNext();) {
      const er = it.next();
      if (er.isHole()) {
        freeHoleList.add(er);
      } else {
        shellList.add(er);
      }
    }
  }

  computePolygons (shellList) {
    const resultPolyList = new ArrayList();
    for (let it = shellList.iterator(); it.hasNext();) {
      const er = it.next();
      const poly = er.toPolygon(this._geometryFactory);
      resultPolyList.add(poly);
    }
    return resultPolyList
  }

  placeFreeHoles (shellList, freeHoleList) {
    for (let it = freeHoleList.iterator(); it.hasNext();) {
      const hole = it.next();
      if (hole.getShell() === null) {
        const shell = this.findEdgeRingContaining(hole, shellList);
        if (shell === null) throw new TopologyException('unable to assign hole to a shell', hole.getCoordinate(0))
        hole.setShell(shell);
      }
    }
  }

  buildMinimalEdgeRings (maxEdgeRings, shellList, freeHoleList) {
    const edgeRings = new ArrayList();
    for (let it = maxEdgeRings.iterator(); it.hasNext();) {
      const er = it.next();
      if (er.getMaxNodeDegree() > 2) {
        er.linkDirectedEdgesForMinimalEdgeRings();
        const minEdgeRings = er.buildMinimalRings();
        const shell = this.findShell(minEdgeRings);
        if (shell !== null) {
          this.placePolygonHoles(shell, minEdgeRings);
          shellList.add(shell);
        } else {
          freeHoleList.addAll(minEdgeRings);
        }
      } else {
        edgeRings.add(er);
      }
    }
    return edgeRings
  }

  containsPoint (p) {
    for (let it = this._shellList.iterator(); it.hasNext();) {
      const er = it.next();
      if (er.containsPoint(p)) return true
    }
    return false
  }

  buildMaximalEdgeRings (dirEdges) {
    const maxEdgeRings = new ArrayList();
    for (let it = dirEdges.iterator(); it.hasNext();) {
      const de = it.next();
      if (de.isInResult() && de.getLabel().isArea()) {
        if (de.getEdgeRing() === null) {
          const er = new MaximalEdgeRing(de, this._geometryFactory);
          maxEdgeRings.add(er);
          er.setInResult();
        }
      }
    }
    return maxEdgeRings
  }

  placePolygonHoles (shell, minEdgeRings) {
    for (let it = minEdgeRings.iterator(); it.hasNext();) {
      const er = it.next();
      if (er.isHole()) {
        er.setShell(shell);
      }
    }
  }

  getPolygons () {
    const resultPolyList = this.computePolygons(this._shellList);
    return resultPolyList
  }

  findEdgeRingContaining (testEr, shellList) {
    const testRing = testEr.getLinearRing();
    const testEnv = testRing.getEnvelopeInternal();
    const testPt = testRing.getCoordinateN(0);
    let minShell = null;
    let minEnv = null;
    for (let it = shellList.iterator(); it.hasNext();) {
      const tryShell = it.next();
      const tryRing = tryShell.getLinearRing();
      const tryEnv = tryRing.getEnvelopeInternal();
      if (minShell !== null) minEnv = minShell.getLinearRing().getEnvelopeInternal();
      let isContained = false;
      if (tryEnv.contains(testEnv) && PointLocation.isInRing(testPt, tryRing.getCoordinates())) isContained = true;
      if (isContained) {
        if (minShell === null || minEnv.contains(tryEnv)) {
          minShell = tryShell;
        }
      }
    }
    return minShell
  }

  findShell (minEdgeRings) {
    let shellCount = 0;
    let shell = null;
    for (let it = minEdgeRings.iterator(); it.hasNext();) {
      const er = it.next();
      if (!er.isHole()) {
        shell = er;
        shellCount++;
      }
    }
    Assert.isTrue(shellCount <= 1, 'found two shells in MinimalEdgeRing list');
    return shell
  }

  add () {
    if (arguments.length === 1) {
      const graph = arguments[0];
      this.add(graph.getEdgeEnds(), graph.getNodes());
    } else if (arguments.length === 2) {
      const dirEdges = arguments[0]; const nodes = arguments[1];
      PlanarGraph.linkResultDirectedEdges(nodes);
      const maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);
      const freeHoleList = new ArrayList();
      const edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);
      this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);
      this.placeFreeHoles(this._shellList, freeHoleList);
    }
  }

  getClass () {
    return PolygonBuilder
  }

  get interfaces_ () {
    return []
  }
}
PolygonBuilder.constructor_ = function () {
  this._geometryFactory = null;
  this._shellList = new ArrayList();
  const geometryFactory = arguments[0];
  this._geometryFactory = geometryFactory;
};

class Boundable {
  constructor () {
    Boundable.constructor_.apply(this, arguments);
  }

  getBounds () {}
  getClass () {
    return Boundable
  }

  get interfaces_ () {
    return []
  }
}
Boundable.constructor_ = function () {};

class ItemBoundable {
  constructor () {
    ItemBoundable.constructor_.apply(this, arguments);
  }

  getItem () {
    return this._item
  }

  getBounds () {
    return this._bounds
  }

  getClass () {
    return ItemBoundable
  }

  get interfaces_ () {
    return [Boundable, Serializable]
  }
}
ItemBoundable.constructor_ = function () {
  this._bounds = null;
  this._item = null;
  const bounds = arguments[0]; const item = arguments[1];
  this._bounds = bounds;
  this._item = item;
};

class PriorityQueue {
  constructor () {
    PriorityQueue.constructor_.apply(this, arguments);
  }

  poll () {
    if (this.isEmpty()) return null
    const minItem = this._items.get(1);
    this._items.set(1, this._items.get(this._size));
    this._size -= 1;
    this.reorder(1);
    return minItem
  }

  size () {
    return this._size
  }

  reorder (hole) {
    let child = null;
    const tmp = this._items.get(hole);
    for (; hole * 2 <= this._size; hole = child) {
      child = hole * 2;
      if (child !== this._size && this._items.get(child + 1).compareTo(this._items.get(child)) < 0) child++;
      if (this._items.get(child).compareTo(tmp) < 0) this._items.set(hole, this._items.get(child)); else break
    }
    this._items.set(hole, tmp);
  }

  clear () {
    this._size = 0;
    this._items.clear();
  }

  peek () {
    if (this.isEmpty()) return null
    const minItem = this._items.get(1);
    return minItem
  }

  isEmpty () {
    return this._size === 0
  }

  add (x) {
    this._items.add(null);
    this._size += 1;
    let hole = this._size;
    this._items.set(0, x);
    for (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {
      this._items.set(hole, this._items.get(Math.trunc(hole / 2)));
    }
    this._items.set(hole, x);
  }

  getClass () {
    return PriorityQueue
  }

  get interfaces_ () {
    return []
  }
}
PriorityQueue.constructor_ = function () {
  this._size = null;
  this._items = null;
  this._size = 0;
  this._items = new ArrayList();
  this._items.add(null);
};

class SpatialIndex {
  constructor () {
    SpatialIndex.constructor_.apply(this, arguments);
  }

  insert (itemEnv, item) {}
  remove (itemEnv, item) {}
  query () {
  }

  getClass () {
    return SpatialIndex
  }

  get interfaces_ () {
    return []
  }
}
SpatialIndex.constructor_ = function () {};

class AbstractNode {
  constructor () {
    AbstractNode.constructor_.apply(this, arguments);
  }

  getLevel () {
    return this._level
  }

  size () {
    return this._childBoundables.size()
  }

  getChildBoundables () {
    return this._childBoundables
  }

  addChildBoundable (childBoundable) {
    Assert.isTrue(this._bounds === null);
    this._childBoundables.add(childBoundable);
  }

  isEmpty () {
    return this._childBoundables.isEmpty()
  }

  getBounds () {
    if (this._bounds === null) {
      this._bounds = this.computeBounds();
    }
    return this._bounds
  }

  getClass () {
    return AbstractNode
  }

  get interfaces_ () {
    return [Boundable, Serializable]
  }
}
AbstractNode.constructor_ = function () {
  this._childBoundables = new ArrayList();
  this._bounds = null;
  this._level = null;
  if (arguments.length === 0) ; else if (arguments.length === 1) {
    const level = arguments[0];
    this._level = level;
  }
};
AbstractNode.serialVersionUID = 6493722185909573708;

const Collections = {
  reverseOrder: function () {
    return {
      compare (a, b) {
        return b.compareTo(a)
      }
    }
  },
  min: function (l) {
    Collections.sort(l);
    return l.get(0)
  },
  sort: function (l, c) {
    const a = l.toArray();
    if (c) {
      Arrays.sort(a, c);
    } else {
      Arrays.sort(a);
    }
    const i = l.iterator();
    for (let pos = 0, alen = a.length; pos < alen; pos++) {
      i.next();
      i.set(a[pos]);
    }
  },
  singletonList: function (o) {
    const arrayList = new ArrayList();
    arrayList.add(o);
    return arrayList
  }
};

class BoundablePair {
  constructor () {
    BoundablePair.constructor_.apply(this, arguments);
  }

  static area (b) {
    return b.getBounds().getArea()
  }

  static isComposite (item) {
    return item instanceof AbstractNode
  }

  expandToQueue (priQ, minDistance) {
    const isComp1 = BoundablePair.isComposite(this._boundable1);
    const isComp2 = BoundablePair.isComposite(this._boundable2);
    if (isComp1 && isComp2) {
      if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {
        this.expand(this._boundable1, this._boundable2, priQ, minDistance);
        return null
      } else {
        this.expand(this._boundable2, this._boundable1, priQ, minDistance);
        return null
      }
    } else if (isComp1) {
      this.expand(this._boundable1, this._boundable2, priQ, minDistance);
      return null
    } else if (isComp2) {
      this.expand(this._boundable2, this._boundable1, priQ, minDistance);
      return null
    }
    throw new IllegalArgumentException('neither boundable is composite')
  }

  isLeaves () {
    return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2))
  }

  compareTo (o) {
    const nd = o;
    if (this._distance < nd._distance) return -1
    if (this._distance > nd._distance) return 1
    return 0
  }

  expand (bndComposite, bndOther, priQ, minDistance) {
    const children = bndComposite.getChildBoundables();
    for (let i = children.iterator(); i.hasNext();) {
      const child = i.next();
      const bp = new BoundablePair(child, bndOther, this._itemDistance);
      if (bp.getDistance() < minDistance) {
        priQ.add(bp);
      }
    }
  }

  getBoundable (i) {
    if (i === 0) return this._boundable1
    return this._boundable2
  }

  getDistance () {
    return this._distance
  }

  distance () {
    if (this.isLeaves()) {
      return this._itemDistance.distance(this._boundable1, this._boundable2)
    }
    return this._boundable1.getBounds().distance(this._boundable2.getBounds())
  }

  getClass () {
    return BoundablePair
  }

  get interfaces_ () {
    return [Comparable]
  }
}
BoundablePair.constructor_ = function () {
  this._boundable1 = null;
  this._boundable2 = null;
  this._distance = null;
  this._itemDistance = null;
  const boundable1 = arguments[0]; const boundable2 = arguments[1]; const itemDistance = arguments[2];
  this._boundable1 = boundable1;
  this._boundable2 = boundable2;
  this._itemDistance = itemDistance;
  this._distance = this.distance();
};

class ItemVisitor {
  constructor () {
    ItemVisitor.constructor_.apply(this, arguments);
  }

  visitItem (item) {}
  getClass () {
    return ItemVisitor
  }

  get interfaces_ () {
    return []
  }
}
ItemVisitor.constructor_ = function () {};

class AbstractSTRtree {
  constructor () {
    AbstractSTRtree.constructor_.apply(this, arguments);
  }

  static compareDoubles (a, b) {
    return a > b ? 1 : a < b ? -1 : 0
  }

  queryInternal () {
    if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
      const searchBounds = arguments[0]; const node = arguments[1]; const visitor = arguments[2];
      const childBoundables = node.getChildBoundables();
      for (let i = 0; i < childBoundables.size(); i++) {
        const childBoundable = childBoundables.get(i);
        if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {
          continue
        }
        if (childBoundable instanceof AbstractNode) {
          this.queryInternal(searchBounds, childBoundable, visitor);
        } else if (childBoundable instanceof ItemBoundable) {
          visitor.visitItem(childBoundable.getItem());
        } else {
          Assert.shouldNeverReachHere();
        }
      }
    } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
      const searchBounds = arguments[0]; const node = arguments[1]; const matches = arguments[2];
      const childBoundables = node.getChildBoundables();
      for (let i = 0; i < childBoundables.size(); i++) {
        const childBoundable = childBoundables.get(i);
        if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {
          continue
        }
        if (childBoundable instanceof AbstractNode) {
          this.queryInternal(searchBounds, childBoundable, matches);
        } else if (childBoundable instanceof ItemBoundable) {
          matches.add(childBoundable.getItem());
        } else {
          Assert.shouldNeverReachHere();
        }
      }
    }
  }

  getNodeCapacity () {
    return this._nodeCapacity
  }

  lastNode (nodes) {
    return nodes.get(nodes.size() - 1)
  }

  size () {
    if (arguments.length === 0) {
      if (this.isEmpty()) {
        return 0
      }
      this.build();
      return this.size(this._root)
    } else if (arguments.length === 1) {
      const node = arguments[0];
      let size = 0;
      for (let i = node.getChildBoundables().iterator(); i.hasNext();) {
        const childBoundable = i.next();
        if (childBoundable instanceof AbstractNode) {
          size += this.size(childBoundable);
        } else if (childBoundable instanceof ItemBoundable) {
          size += 1;
        }
      }
      return size
    }
  }

  removeItem (node, item) {
    let childToRemove = null;
    for (let i = node.getChildBoundables().iterator(); i.hasNext();) {
      const childBoundable = i.next();
      if (childBoundable instanceof ItemBoundable) {
        if (childBoundable.getItem() === item) childToRemove = childBoundable;
      }
    }
    if (childToRemove !== null) {
      node.getChildBoundables().remove(childToRemove);
      return true
    }
    return false
  }

  itemsTree () {
    if (arguments.length === 0) {
      this.build();
      const valuesTree = this.itemsTree(this._root);
      if (valuesTree === null) return new ArrayList()
      return valuesTree
    } else if (arguments.length === 1) {
      const node = arguments[0];
      const valuesTreeForNode = new ArrayList();
      for (let i = node.getChildBoundables().iterator(); i.hasNext();) {
        const childBoundable = i.next();
        if (childBoundable instanceof AbstractNode) {
          const valuesTreeForChild = this.itemsTree(childBoundable);
          if (valuesTreeForChild !== null) valuesTreeForNode.add(valuesTreeForChild);
        } else if (childBoundable instanceof ItemBoundable) {
          valuesTreeForNode.add(childBoundable.getItem());
        } else {
          Assert.shouldNeverReachHere();
        }
      }
      if (valuesTreeForNode.size() <= 0) return null
      return valuesTreeForNode
    }
  }

  insert (bounds, item) {
    Assert.isTrue(!this._built, 'Cannot insert items into an STR packed R-tree after it has been built.');
    this._itemBoundables.add(new ItemBoundable(bounds, item));
  }

  boundablesAtLevel () {
    if (arguments.length === 1) {
      const level = arguments[0];
      const boundables = new ArrayList();
      this.boundablesAtLevel(level, this._root, boundables);
      return boundables
    } else if (arguments.length === 3) {
      const level = arguments[0]; const top = arguments[1]; const boundables = arguments[2];
      Assert.isTrue(level > -2);
      if (top.getLevel() === level) {
        boundables.add(top);
        return null
      }
      for (let i = top.getChildBoundables().iterator(); i.hasNext();) {
        const boundable = i.next();
        if (boundable instanceof AbstractNode) {
          this.boundablesAtLevel(level, boundable, boundables);
        } else {
          Assert.isTrue(boundable instanceof ItemBoundable);
          if (level === -1) {
            boundables.add(boundable);
          }
        }
      }
      return null
    }
  }

  query () {
    if (arguments.length === 1) {
      const searchBounds = arguments[0];
      this.build();
      const matches = new ArrayList();
      if (this.isEmpty()) {
        return matches
      }
      if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
        this.queryInternal(searchBounds, this._root, matches);
      }
      return matches
    } else if (arguments.length === 2) {
      const searchBounds = arguments[0]; const visitor = arguments[1];
      this.build();
      if (this.isEmpty()) {
        return null
      }
      if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
        this.queryInternal(searchBounds, this._root, visitor);
      }
    }
  }

  build () {
    if (this._built) return null
    this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);
    this._itemBoundables = null;
    this._built = true;
  }

  getRoot () {
    this.build();
    return this._root
  }

  remove () {
    if (arguments.length === 2) {
      const searchBounds = arguments[0]; const item = arguments[1];
      this.build();
      if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
        return this.remove(searchBounds, this._root, item)
      }
      return false
    } else if (arguments.length === 3) {
      const searchBounds = arguments[0]; const node = arguments[1]; const item = arguments[2];
      let found = this.removeItem(node, item);
      if (found) return true
      let childToPrune = null;
      for (let i = node.getChildBoundables().iterator(); i.hasNext();) {
        const childBoundable = i.next();
        if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {
          continue
        }
        if (childBoundable instanceof AbstractNode) {
          found = this.remove(searchBounds, childBoundable, item);
          if (found) {
            childToPrune = childBoundable;
            break
          }
        }
      }
      if (childToPrune !== null) {
        if (childToPrune.getChildBoundables().isEmpty()) {
          node.getChildBoundables().remove(childToPrune);
        }
      }
      return found
    }
  }

  createHigherLevels (boundablesOfALevel, level) {
    Assert.isTrue(!boundablesOfALevel.isEmpty());
    const parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);
    if (parentBoundables.size() === 1) {
      return parentBoundables.get(0)
    }
    return this.createHigherLevels(parentBoundables, level + 1)
  }

  depth () {
    if (arguments.length === 0) {
      if (this.isEmpty()) {
        return 0
      }
      this.build();
      return this.depth(this._root)
    } else if (arguments.length === 1) {
      const node = arguments[0];
      let maxChildDepth = 0;
      for (let i = node.getChildBoundables().iterator(); i.hasNext();) {
        const childBoundable = i.next();
        if (childBoundable instanceof AbstractNode) {
          const childDepth = this.depth(childBoundable);
          if (childDepth > maxChildDepth) maxChildDepth = childDepth;
        }
      }
      return maxChildDepth + 1
    }
  }

  createParentBoundables (childBoundables, newLevel) {
    Assert.isTrue(!childBoundables.isEmpty());
    const parentBoundables = new ArrayList();
    parentBoundables.add(this.createNode(newLevel));
    const sortedChildBoundables = new ArrayList(childBoundables);
    Collections.sort(sortedChildBoundables, this.getComparator());
    for (let i = sortedChildBoundables.iterator(); i.hasNext();) {
      const childBoundable = i.next();
      if (this.lastNode(parentBoundables).getChildBoundables().size() === this.getNodeCapacity()) {
        parentBoundables.add(this.createNode(newLevel));
      }
      this.lastNode(parentBoundables).addChildBoundable(childBoundable);
    }
    return parentBoundables
  }

  isEmpty () {
    if (!this._built) return this._itemBoundables.isEmpty()
    return this._root.isEmpty()
  }

  getClass () {
    return AbstractSTRtree
  }

  get interfaces_ () {
    return [Serializable]
  }
}
function IntersectsOp$1 () {}
AbstractSTRtree.IntersectsOp = IntersectsOp$1;
AbstractSTRtree.constructor_ = function () {
  this._root = null;
  this._built = false;
  this._itemBoundables = new ArrayList();
  this._nodeCapacity = null;
  if (arguments.length === 0) {
    AbstractSTRtree.constructor_.call(this, AbstractSTRtree.DEFAULT_NODE_CAPACITY);
  } else if (arguments.length === 1) {
    const nodeCapacity = arguments[0];
    Assert.isTrue(nodeCapacity > 1, 'Node capacity must be greater than 1');
    this._nodeCapacity = nodeCapacity;
  }
};
AbstractSTRtree.serialVersionUID = -3886435814360241337;
AbstractSTRtree.DEFAULT_NODE_CAPACITY = 10;

class ItemDistance {
  constructor () {
    ItemDistance.constructor_.apply(this, arguments);
  }

  distance (item1, item2) {}
  getClass () {
    return ItemDistance
  }

  get interfaces_ () {
    return []
  }
}
ItemDistance.constructor_ = function () {};

class STRtree extends AbstractSTRtree {
  constructor () {
    super();
    STRtree.constructor_.apply(this, arguments);
  }

  static centreX (e) {
    return STRtree.avg(e.getMinX(), e.getMaxX())
  }

  static avg (a, b) {
    return (a + b) / 2
  }

  static getItems (kNearestNeighbors) {
    const items = new Array(kNearestNeighbors.size()).fill(null);
    let count = 0;
    while (!kNearestNeighbors.isEmpty()) {
      const bp = kNearestNeighbors.poll();
      items[count] = bp.getBoundable(0).getItem();
      count++;
    }
    return items
  }

  static centreY (e) {
    return STRtree.avg(e.getMinY(), e.getMaxY())
  }

  createParentBoundablesFromVerticalSlices (verticalSlices, newLevel) {
    Assert.isTrue(verticalSlices.length > 0);
    const parentBoundables = new ArrayList();
    for (let i = 0; i < verticalSlices.length; i++) {
      parentBoundables.addAll(this.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));
    }
    return parentBoundables
  }

  createNode (level) {
    return new STRtreeNode(level)
  }

  size () {
    if (arguments.length === 0) {
      return super.size.call(this)
    } else return super.size.apply(this, arguments)
  }

  insert () {
    if (arguments.length === 2 && (arguments[1] instanceof Object && arguments[0] instanceof Envelope)) {
      const itemEnv = arguments[0]; const item = arguments[1];
      if (itemEnv.isNull()) {
        return null
      }
      super.insert.call(this, itemEnv, item);
    } else return super.insert.apply(this, arguments)
  }

  getIntersectsOp () {
    return STRtree.intersectsOp
  }

  verticalSlices (childBoundables, sliceCount) {
    const sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));
    const slices = new Array(sliceCount).fill(null);
    const i = childBoundables.iterator();
    for (let j = 0; j < sliceCount; j++) {
      slices[j] = new ArrayList();
      let boundablesAddedToSlice = 0;
      while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {
        const childBoundable = i.next();
        slices[j].add(childBoundable);
        boundablesAddedToSlice++;
      }
    }
    return slices
  }

  query () {
    if (arguments.length === 1) {
      const searchEnv = arguments[0];
      return super.query.call(this, searchEnv)
    } else if (arguments.length === 2) {
      const searchEnv = arguments[0]; const visitor = arguments[1];
      super.query.call(this, searchEnv, visitor);
    }
  }

  getComparator () {
    return STRtree.yComparator
  }

  createParentBoundablesFromVerticalSlice (childBoundables, newLevel) {
    return super.createParentBoundables.call(this, childBoundables, newLevel)
  }

  remove () {
    if (arguments.length === 2 && (arguments[1] instanceof Object && arguments[0] instanceof Envelope)) {
      const itemEnv = arguments[0]; const item = arguments[1];
      return super.remove.call(this, itemEnv, item)
    } else return super.remove.apply(this, arguments)
  }

  depth () {
    if (arguments.length === 0) {
      return super.depth.call(this)
    } else return super.depth.apply(this, arguments)
  }

  createParentBoundables (childBoundables, newLevel) {
    Assert.isTrue(!childBoundables.isEmpty());
    const minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));
    const sortedChildBoundables = new ArrayList(childBoundables);
    Collections.sort(sortedChildBoundables, STRtree.xComparator);
    const verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));
    return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel)
  }

  nearestNeighbour () {
    if (arguments.length === 1) {
      if (hasInterface(arguments[0], ItemDistance)) {
        const itemDist = arguments[0];
        const bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);
        return this.nearestNeighbour(bp)
      } else if (arguments[0] instanceof BoundablePair) {
        const initBndPair = arguments[0];
        return this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY)
      }
    } else if (arguments.length === 2) {
      if (arguments[0] instanceof STRtree && hasInterface(arguments[1], ItemDistance)) {
        const tree = arguments[0]; const itemDist = arguments[1];
        const bp = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist);
        return this.nearestNeighbour(bp)
      } else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === 'number') {
        const initBndPair = arguments[0]; const maxDistance = arguments[1];
        let distanceLowerBound = maxDistance;
        let minPair = null;
        const priQ = new PriorityQueue();
        priQ.add(initBndPair);
        while (!priQ.isEmpty() && distanceLowerBound > 0.0) {
          const bndPair = priQ.poll();
          const currentDistance = bndPair.getDistance();
          if (currentDistance >= distanceLowerBound) break
          if (bndPair.isLeaves()) {
            distanceLowerBound = currentDistance;
            minPair = bndPair;
          } else {
            bndPair.expandToQueue(priQ, distanceLowerBound);
          }
        }
        return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()]
      } else if (arguments[0] instanceof BoundablePair && Number.isInteger(arguments[1])) {
        const initBndPair = arguments[0]; const k = arguments[1];
        return this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY, k)
      }
    } else if (arguments.length === 3) {
      if (hasInterface(arguments[2], ItemDistance) && (arguments[0] instanceof Envelope && arguments[1] instanceof Object)) {
        const env = arguments[0]; const item = arguments[1]; const itemDist = arguments[2];
        const bnd = new ItemBoundable(env, item);
        const bp = new BoundablePair(this.getRoot(), bnd, itemDist);
        return this.nearestNeighbour(bp)[0]
      } else if (Number.isInteger(arguments[2]) && (arguments[0] instanceof BoundablePair && typeof arguments[1] === 'number')) {
        const initBndPair = arguments[0]; const maxDistance = arguments[1]; const k = arguments[2];
        let distanceLowerBound = maxDistance;
        const priQ = new PriorityQueue();
        priQ.add(initBndPair);
        const kNearestNeighbors = new PriorityQueue();
        while (!priQ.isEmpty() && distanceLowerBound >= 0.0) {
          const bndPair = priQ.poll();
          const currentDistance = bndPair.getDistance();
          if (currentDistance >= distanceLowerBound) {
            break
          }
          if (bndPair.isLeaves()) {
            if (kNearestNeighbors.size() < k) {
              kNearestNeighbors.add(bndPair);
            } else {
              const bp1 = kNearestNeighbors.peek();
              if (bp1.getDistance() > currentDistance) {
                kNearestNeighbors.poll();
                kNearestNeighbors.add(bndPair);
              }
              const bp2 = kNearestNeighbors.peek();
              distanceLowerBound = bp2.getDistance();
            }
          } else {
            bndPair.expandToQueue(priQ, distanceLowerBound);
          }
        }
        return STRtree.getItems(kNearestNeighbors)
      }
    } else if (arguments.length === 4) {
      const env = arguments[0]; const item = arguments[1]; const itemDist = arguments[2]; const k = arguments[3];
      const bnd = new ItemBoundable(env, item);
      const bp = new BoundablePair(this.getRoot(), bnd, itemDist);
      return this.nearestNeighbour(bp, k)
    }
  }

  getClass () {
    return STRtree
  }

  get interfaces_ () {
    return [SpatialIndex, Serializable]
  }
}
class STRtreeNode extends AbstractNode {
  constructor () {
    super();
    STRtreeNode.constructor_.apply(this, arguments);
  }

  computeBounds () {
    let bounds = null;
    for (let i = this.getChildBoundables().iterator(); i.hasNext();) {
      const childBoundable = i.next();
      if (bounds === null) {
        bounds = new Envelope(childBoundable.getBounds());
      } else {
        bounds.expandToInclude(childBoundable.getBounds());
      }
    }
    return bounds
  }

  getClass () {
    return STRtreeNode
  }

  get interfaces_ () {
    return []
  }
}
STRtreeNode.constructor_ = function () {
  const level = arguments[0];
  AbstractNode.constructor_.call(this, level);
};
STRtree.STRtreeNode = STRtreeNode;
STRtree.constructor_ = function () {
  if (arguments.length === 0) {
    STRtree.constructor_.call(this, STRtree.DEFAULT_NODE_CAPACITY);
  } else if (arguments.length === 1) {
    const nodeCapacity = arguments[0];
    AbstractSTRtree.constructor_.call(this, nodeCapacity);
  }
};
STRtree.serialVersionUID = 259274702368956900;
STRtree.xComparator = new (class {
  get interfaces_ () {
    return [Comparator]
  }

  compare (o1, o2) {
    return AbstractSTRtree.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()))
  }
})();
STRtree.yComparator = new (class {
  get interfaces_ () {
    return [Comparator]
  }

  compare (o1, o2) {
    return AbstractSTRtree.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()))
  }
})();
STRtree.intersectsOp = new (class {
  get interfaces_ () {
    return [IntersectsOp]
  }

  intersects (aBounds, bBounds) {
    return aBounds.intersects(bBounds)
  }
})();
STRtree.DEFAULT_NODE_CAPACITY = 10;

class SegmentPointComparator {
  constructor () {
    SegmentPointComparator.constructor_.apply(this, arguments);
  }

  static relativeSign (x0, x1) {
    if (x0 < x1) return -1
    if (x0 > x1) return 1
    return 0
  }

  static compare (octant, p0, p1) {
    if (p0.equals2D(p1)) return 0
    const xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);
    const ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);
    switch (octant) {
      case 0:
        return SegmentPointComparator.compareValue(xSign, ySign)
      case 1:
        return SegmentPointComparator.compareValue(ySign, xSign)
      case 2:
        return SegmentPointComparator.compareValue(ySign, -xSign)
      case 3:
        return SegmentPointComparator.compareValue(-xSign, ySign)
      case 4:
        return SegmentPointComparator.compareValue(-xSign, -ySign)
      case 5:
        return SegmentPointComparator.compareValue(-ySign, -xSign)
      case 6:
        return SegmentPointComparator.compareValue(-ySign, xSign)
      case 7:
        return SegmentPointComparator.compareValue(xSign, -ySign)
    }
    Assert.shouldNeverReachHere('invalid octant value');
    return 0
  }

  static compareValue (compareSign0, compareSign1) {
    if (compareSign0 < 0) return -1
    if (compareSign0 > 0) return 1
    if (compareSign1 < 0) return -1
    if (compareSign1 > 0) return 1
    return 0
  }

  getClass () {
    return SegmentPointComparator
  }

  get interfaces_ () {
    return []
  }
}
SegmentPointComparator.constructor_ = function () {};

class SegmentNode {
  constructor () {
    SegmentNode.constructor_.apply(this, arguments);
  }

  getCoordinate () {
    return this.coord
  }

  print (out) {
    out.print(this.coord);
    out.print(' seg # = ' + this.segmentIndex);
  }

  compareTo (obj) {
    const other = obj;
    if (this.segmentIndex < other.segmentIndex) return -1
    if (this.segmentIndex > other.segmentIndex) return 1
    if (this.coord.equals2D(other.coord)) return 0
    return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord)
  }

  isEndPoint (maxSegmentIndex) {
    if (this.segmentIndex === 0 && !this._isInterior) return true
    if (this.segmentIndex === maxSegmentIndex) return true
    return false
  }

  isInterior () {
    return this._isInterior
  }

  getClass () {
    return SegmentNode
  }

  get interfaces_ () {
    return [Comparable]
  }
}
SegmentNode.constructor_ = function () {
  this._segString = null;
  this.coord = null;
  this.segmentIndex = null;
  this._segmentOctant = null;
  this._isInterior = null;
  const segString = arguments[0]; const coord = arguments[1]; const segmentIndex = arguments[2]; const segmentOctant = arguments[3];
  this._segString = segString;
  this.coord = new Coordinate(coord);
  this.segmentIndex = segmentIndex;
  this._segmentOctant = segmentOctant;
  this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));
};

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html
 * @constructor
 * @private
 */
function Iterator () {}
/**
 * Returns true if the iteration has more elements.
 * @return {boolean}
 */
Iterator.prototype.hasNext = function () {};

/**
 * Returns the next element in the iteration.
 * @return {Object}
 */
Iterator.prototype.next = function () {};

/**
 * Removes from the underlying collection the last element returned by the
 * iterator (optional operation).
 */
Iterator.prototype.remove = function () {};

class SegmentNodeList {
  constructor () {
    SegmentNodeList.constructor_.apply(this, arguments);
  }

  getSplitCoordinates () {
    const coordList = new CoordinateList();
    this.addEndpoints();
    const it = this.iterator();
    let eiPrev = it.next();
    while (it.hasNext()) {
      const ei = it.next();
      this.addEdgeCoordinates(eiPrev, ei, coordList);
      eiPrev = ei;
    }
    return coordList.toCoordinateArray()
  }

  addCollapsedNodes () {
    const collapsedVertexIndexes = new ArrayList();
    this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);
    this.findCollapsesFromExistingVertices(collapsedVertexIndexes);
    for (let it = collapsedVertexIndexes.iterator(); it.hasNext();) {
      const vertexIndex = it.next().intValue();
      this.add(this._edge.getCoordinate(vertexIndex), vertexIndex);
    }
  }

  print (out) {
    out.println('Intersections:');
    for (let it = this.iterator(); it.hasNext();) {
      const ei = it.next();
      ei.print(out);
    }
  }

  findCollapsesFromExistingVertices (collapsedVertexIndexes) {
    for (let i = 0; i < this._edge.size() - 2; i++) {
      const p0 = this._edge.getCoordinate(i);
      this._edge.getCoordinate(i + 1);
      const p2 = this._edge.getCoordinate(i + 2);
      if (p0.equals2D(p2)) {
        collapsedVertexIndexes.add(new Integer(i + 1));
      }
    }
  }

  addEdgeCoordinates (ei0, ei1, coordList) {
    ei1.segmentIndex - ei0.segmentIndex + 2;
    const lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
    const useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
    coordList.add(new Coordinate(ei0.coord), false);
    for (let i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
      coordList.add(this._edge.getCoordinate(i));
    }
    if (useIntPt1) {
      coordList.add(new Coordinate(ei1.coord));
    }
  }

  iterator () {
    return this._nodeMap.values().iterator()
  }

  addSplitEdges (edgeList) {
    this.addEndpoints();
    this.addCollapsedNodes();
    const it = this.iterator();
    let eiPrev = it.next();
    while (it.hasNext()) {
      const ei = it.next();
      const newEdge = this.createSplitEdge(eiPrev, ei);
      edgeList.add(newEdge);
      eiPrev = ei;
    }
  }

  findCollapseIndex (ei0, ei1, collapsedVertexIndex) {
    if (!ei0.coord.equals2D(ei1.coord)) return false
    let numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;
    if (!ei1.isInterior()) {
      numVerticesBetween--;
    }
    if (numVerticesBetween === 1) {
      collapsedVertexIndex[0] = ei0.segmentIndex + 1;
      return true
    }
    return false
  }

  findCollapsesFromInsertedNodes (collapsedVertexIndexes) {
    const collapsedVertexIndex = new Array(1).fill(null);
    const it = this.iterator();
    let eiPrev = it.next();
    while (it.hasNext()) {
      const ei = it.next();
      const isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);
      if (isCollapsed) collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0]));
      eiPrev = ei;
    }
  }

  getEdge () {
    return this._edge
  }

  addEndpoints () {
    const maxSegIndex = this._edge.size() - 1;
    this.add(this._edge.getCoordinate(0), 0);
    this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);
  }

  createSplitEdge (ei0, ei1) {
    let npts = ei1.segmentIndex - ei0.segmentIndex + 2;
    const lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
    const useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
    if (!useIntPt1) {
      npts--;
    }
    const pts = new Array(npts).fill(null);
    let ipt = 0;
    pts[ipt++] = new Coordinate(ei0.coord);
    for (let i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
      pts[ipt++] = this._edge.getCoordinate(i);
    }
    if (useIntPt1) pts[ipt] = new Coordinate(ei1.coord);
    return new NodedSegmentString(pts, this._edge.getData())
  }

  add (intPt, segmentIndex) {
    const eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));
    const ei = this._nodeMap.get(eiNew);
    if (ei !== null) {
      Assert.isTrue(ei.coord.equals2D(intPt), 'Found equal nodes with different coordinates');
      return ei
    }
    this._nodeMap.put(eiNew, eiNew);
    return eiNew
  }

  checkSplitEdgesCorrectness (splitEdges) {
    const edgePts = this._edge.getCoordinates();
    const split0 = splitEdges.get(0);
    const pt0 = split0.getCoordinate(0);
    if (!pt0.equals2D(edgePts[0])) throw new RuntimeException('bad split edge start point at ' + pt0)
    const splitn = splitEdges.get(splitEdges.size() - 1);
    const splitnPts = splitn.getCoordinates();
    const ptn = splitnPts[splitnPts.length - 1];
    if (!ptn.equals2D(edgePts[edgePts.length - 1])) throw new RuntimeException('bad split edge end point at ' + ptn)
  }

  getClass () {
    return SegmentNodeList
  }

  get interfaces_ () {
    return []
  }
}
SegmentNodeList.constructor_ = function () {
  this._nodeMap = new TreeMap();
  this._edge = null;
  const edge = arguments[0];
  this._edge = edge;
};

class Octant {
  constructor () {
    Octant.constructor_.apply(this, arguments);
  }

  static octant () {
    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
      const dx = arguments[0]; const dy = arguments[1];
      if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the octant for point ( ' + dx + ', ' + dy + ' )')
      const adx = Math.abs(dx);
      const ady = Math.abs(dy);
      if (dx >= 0) {
        if (dy >= 0) {
          if (adx >= ady) return 0; else return 1
        } else {
          if (adx >= ady) return 7; else return 6
        }
      } else {
        if (dy >= 0) {
          if (adx >= ady) return 3; else return 2
        } else {
          if (adx >= ady) return 4; else return 5
        }
      }
    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
      const p0 = arguments[0]; const p1 = arguments[1];
      const dx = p1.x - p0.x;
      const dy = p1.y - p0.y;
      if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the octant for two identical points ' + p0)
      return Octant.octant(dx, dy)
    }
  }

  getClass () {
    return Octant
  }

  get interfaces_ () {
    return []
  }
}
Octant.constructor_ = function () {};

class SegmentString {
  constructor () {
    SegmentString.constructor_.apply(this, arguments);
  }

  getCoordinates () {}
  size () {}
  getCoordinate (i) {}
  isClosed () {}
  setData (data) {}
  getData () {}
  getClass () {
    return SegmentString
  }

  get interfaces_ () {
    return []
  }
}
SegmentString.constructor_ = function () {};

class NodableSegmentString {
  constructor () {
    NodableSegmentString.constructor_.apply(this, arguments);
  }

  addIntersection (intPt, segmentIndex) {}
  getClass () {
    return NodableSegmentString
  }

  get interfaces_ () {
    return [SegmentString]
  }
}
NodableSegmentString.constructor_ = function () {};

class NodedSegmentString {
  constructor () {
    NodedSegmentString.constructor_.apply(this, arguments);
  }

  static getNodedSubstrings () {
    if (arguments.length === 1) {
      const segStrings = arguments[0];
      const resultEdgelist = new ArrayList();
      NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);
      return resultEdgelist
    } else if (arguments.length === 2) {
      const segStrings = arguments[0]; const resultEdgelist = arguments[1];
      for (let i = segStrings.iterator(); i.hasNext();) {
        const ss = i.next();
        ss.getNodeList().addSplitEdges(resultEdgelist);
      }
    }
  }

  getCoordinates () {
    return this._pts
  }

  size () {
    return this._pts.length
  }

  getCoordinate (i) {
    return this._pts[i]
  }

  isClosed () {
    return this._pts[0].equals(this._pts[this._pts.length - 1])
  }

  getSegmentOctant (index) {
    if (index === this._pts.length - 1) return -1
    return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1))
  }

  setData (data) {
    this._data = data;
  }

  safeOctant (p0, p1) {
    if (p0.equals2D(p1)) return 0
    return Octant.octant(p0, p1)
  }

  getData () {
    return this._data
  }

  addIntersection () {
    if (arguments.length === 2) {
      const intPt = arguments[0]; const segmentIndex = arguments[1];
      this.addIntersectionNode(intPt, segmentIndex);
    } else if (arguments.length === 4) {
      const li = arguments[0]; const segmentIndex = arguments[1]; const intIndex = arguments[3];
      const intPt = new Coordinate(li.getIntersection(intIndex));
      this.addIntersection(intPt, segmentIndex);
    }
  }

  toString () {
    return WKTWriter.toLineString(new CoordinateArraySequence(this._pts))
  }

  getNodeList () {
    return this._nodeList
  }

  addIntersectionNode (intPt, segmentIndex) {
    let normalizedSegmentIndex = segmentIndex;
    const nextSegIndex = normalizedSegmentIndex + 1;
    if (nextSegIndex < this._pts.length) {
      const nextPt = this._pts[nextSegIndex];
      if (intPt.equals2D(nextPt)) {
        normalizedSegmentIndex = nextSegIndex;
      }
    }
    const ei = this._nodeList.add(intPt, normalizedSegmentIndex);
    return ei
  }

  addIntersections (li, segmentIndex, geomIndex) {
    for (let i = 0; i < li.getIntersectionNum(); i++) {
      this.addIntersection(li, segmentIndex, geomIndex, i);
    }
  }

  getClass () {
    return NodedSegmentString
  }

  get interfaces_ () {
    return [NodableSegmentString]
  }
}
NodedSegmentString.constructor_ = function () {
  this._nodeList = new SegmentNodeList(this);
  this._pts = null;
  this._data = null;
  const pts = arguments[0]; const data = arguments[1];
  this._pts = pts;
  this._data = data;
};

class LineSegment {
  constructor () {
    LineSegment.constructor_.apply(this, arguments);
  }

  static midPoint (p0, p1) {
    return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2)
  }

  minX () {
    return Math.min(this.p0.x, this.p1.x)
  }

  orientationIndex () {
    if (arguments[0] instanceof LineSegment) {
      const seg = arguments[0];
      const orient0 = Orientation.index(this.p0, this.p1, seg.p0);
      const orient1 = Orientation.index(this.p0, this.p1, seg.p1);
      if (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1)
      if (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1)
      return 0
    } else if (arguments[0] instanceof Coordinate) {
      const p = arguments[0];
      return Orientation.index(this.p0, this.p1, p)
    }
  }

  toGeometry (geomFactory) {
    return geomFactory.createLineString([this.p0, this.p1])
  }

  isVertical () {
    return this.p0.x === this.p1.x
  }

  equals (o) {
    if (!(o instanceof LineSegment)) {
      return false
    }
    const other = o;
    return this.p0.equals(other.p0) && this.p1.equals(other.p1)
  }

  intersection (line) {
    const li = new RobustLineIntersector();
    li.computeIntersection(this.p0, this.p1, line.p0, line.p1);
    if (li.hasIntersection()) return li.getIntersection(0)
    return null
  }

  project () {
    if (arguments[0] instanceof Coordinate) {
      const p = arguments[0];
      if (p.equals(this.p0) || p.equals(this.p1)) return new Coordinate(p)
      const r = this.projectionFactor(p);
      const coord = new Coordinate();
      coord.x = this.p0.x + r * (this.p1.x - this.p0.x);
      coord.y = this.p0.y + r * (this.p1.y - this.p0.y);
      return coord
    } else if (arguments[0] instanceof LineSegment) {
      const seg = arguments[0];
      const pf0 = this.projectionFactor(seg.p0);
      const pf1 = this.projectionFactor(seg.p1);
      if (pf0 >= 1.0 && pf1 >= 1.0) return null
      if (pf0 <= 0.0 && pf1 <= 0.0) return null
      let newp0 = this.project(seg.p0);
      if (pf0 < 0.0) newp0 = this.p0;
      if (pf0 > 1.0) newp0 = this.p1;
      let newp1 = this.project(seg.p1);
      if (pf1 < 0.0) newp1 = this.p0;
      if (pf1 > 1.0) newp1 = this.p1;
      return new LineSegment(newp0, newp1)
    }
  }

  normalize () {
    if (this.p1.compareTo(this.p0) < 0) this.reverse();
  }

  angle () {
    return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)
  }

  getCoordinate (i) {
    if (i === 0) return this.p0
    return this.p1
  }

  distancePerpendicular (p) {
    return Distance.pointToLinePerpendicular(p, this.p0, this.p1)
  }

  minY () {
    return Math.min(this.p0.y, this.p1.y)
  }

  midPoint () {
    return LineSegment.midPoint(this.p0, this.p1)
  }

  projectionFactor (p) {
    if (p.equals(this.p0)) return 0.0
    if (p.equals(this.p1)) return 1.0
    const dx = this.p1.x - this.p0.x;
    const dy = this.p1.y - this.p0.y;
    const len = dx * dx + dy * dy;
    if (len <= 0.0) return Double.NaN
    const r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;
    return r
  }

  closestPoints (line) {
    const intPt = this.intersection(line);
    if (intPt !== null) {
      return [intPt, intPt]
    }
    const closestPt = new Array(2).fill(null);
    let minDistance = Double.MAX_VALUE;
    let dist = null;
    const close00 = this.closestPoint(line.p0);
    minDistance = close00.distance(line.p0);
    closestPt[0] = close00;
    closestPt[1] = line.p0;
    const close01 = this.closestPoint(line.p1);
    dist = close01.distance(line.p1);
    if (dist < minDistance) {
      minDistance = dist;
      closestPt[0] = close01;
      closestPt[1] = line.p1;
    }
    const close10 = line.closestPoint(this.p0);
    dist = close10.distance(this.p0);
    if (dist < minDistance) {
      minDistance = dist;
      closestPt[0] = this.p0;
      closestPt[1] = close10;
    }
    const close11 = line.closestPoint(this.p1);
    dist = close11.distance(this.p1);
    if (dist < minDistance) {
      minDistance = dist;
      closestPt[0] = this.p1;
      closestPt[1] = close11;
    }
    return closestPt
  }

  closestPoint (p) {
    const factor = this.projectionFactor(p);
    if (factor > 0 && factor < 1) {
      return this.project(p)
    }
    const dist0 = this.p0.distance(p);
    const dist1 = this.p1.distance(p);
    if (dist0 < dist1) return this.p0
    return this.p1
  }

  maxX () {
    return Math.max(this.p0.x, this.p1.x)
  }

  getLength () {
    return this.p0.distance(this.p1)
  }

  compareTo (o) {
    const other = o;
    const comp0 = this.p0.compareTo(other.p0);
    if (comp0 !== 0) return comp0
    return this.p1.compareTo(other.p1)
  }

  reverse () {
    const temp = this.p0;
    this.p0 = this.p1;
    this.p1 = temp;
  }

  equalsTopo (other) {
    return this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0)
  }

  lineIntersection (line) {
    try {
      const intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);
      return intPt
    } catch (ex) {
      if (ex instanceof NotRepresentableException) ; else throw ex
    } finally {}
    return null
  }

  maxY () {
    return Math.max(this.p0.y, this.p1.y)
  }

  pointAlongOffset (segmentLengthFraction, offsetDistance) {
    const segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
    const segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
    const dx = this.p1.x - this.p0.x;
    const dy = this.p1.y - this.p0.y;
    const len = Math.sqrt(dx * dx + dy * dy);
    let ux = 0.0;
    let uy = 0.0;
    if (offsetDistance !== 0.0) {
      if (len <= 0.0) throw new IllegalStateException('Cannot compute offset from zero-length line segment')
      ux = offsetDistance * dx / len;
      uy = offsetDistance * dy / len;
    }
    const offsetx = segx - uy;
    const offsety = segy + ux;
    const coord = new Coordinate(offsetx, offsety);
    return coord
  }

  setCoordinates () {
    if (arguments.length === 1) {
      const ls = arguments[0];
      this.setCoordinates(ls.p0, ls.p1);
    } else if (arguments.length === 2) {
      const p0 = arguments[0]; const p1 = arguments[1];
      this.p0.x = p0.x;
      this.p0.y = p0.y;
      this.p1.x = p1.x;
      this.p1.y = p1.y;
    }
  }

  segmentFraction (inputPt) {
    let segFrac = this.projectionFactor(inputPt);
    if (segFrac < 0.0) segFrac = 0.0; else if (segFrac > 1.0 || Double.isNaN(segFrac)) segFrac = 1.0;
    return segFrac
  }

  toString () {
    return 'LINESTRING( ' + this.p0.x + ' ' + this.p0.y + ', ' + this.p1.x + ' ' + this.p1.y + ')'
  }

  isHorizontal () {
    return this.p0.y === this.p1.y
  }

  distance () {
    if (arguments[0] instanceof LineSegment) {
      const ls = arguments[0];
      return Distance.segmentToSegment(this.p0, this.p1, ls.p0, ls.p1)
    } else if (arguments[0] instanceof Coordinate) {
      const p = arguments[0];
      return Distance.pointToSegment(p, this.p0, this.p1)
    }
  }

  pointAlong (segmentLengthFraction) {
    const coord = new Coordinate();
    coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
    coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
    return coord
  }

  hashCode () {
    let bits0 = java.lang.Double.doubleToLongBits(this.p0.x);
    bits0 ^= java.lang.Double.doubleToLongBits(this.p0.y) * 31;
    const hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);
    let bits1 = java.lang.Double.doubleToLongBits(this.p1.x);
    bits1 ^= java.lang.Double.doubleToLongBits(this.p1.y) * 31;
    const hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);
    return hash0 ^ hash1
  }

  getClass () {
    return LineSegment
  }

  get interfaces_ () {
    return [Comparable, Serializable]
  }
}
LineSegment.constructor_ = function () {
  this.p0 = null;
  this.p1 = null;
  if (arguments.length === 0) {
    LineSegment.constructor_.call(this, new Coordinate(), new Coordinate());
  } else if (arguments.length === 1) {
    const ls = arguments[0];
    LineSegment.constructor_.call(this, ls.p0, ls.p1);
  } else if (arguments.length === 2) {
    const p0 = arguments[0]; const p1 = arguments[1];
    this.p0 = p0;
    this.p1 = p1;
  } else if (arguments.length === 4) {
    const x0 = arguments[0]; const y0 = arguments[1]; const x1 = arguments[2]; const y1 = arguments[3];
    LineSegment.constructor_.call(this, new Coordinate(x0, y0), new Coordinate(x1, y1));
  }
};
LineSegment.serialVersionUID = 3252005833466256227;

class MonotoneChainOverlapAction {
  constructor () {
    MonotoneChainOverlapAction.constructor_.apply(this, arguments);
  }

  overlap () {
    if (arguments.length === 2) ; else if (arguments.length === 4) {
      const mc1 = arguments[0]; const start1 = arguments[1]; const mc2 = arguments[2]; const start2 = arguments[3];
      mc1.getLineSegment(start1, this._overlapSeg1);
      mc2.getLineSegment(start2, this._overlapSeg2);
      this.overlap(this._overlapSeg1, this._overlapSeg2);
    }
  }

  getClass () {
    return MonotoneChainOverlapAction
  }

  get interfaces_ () {
    return []
  }
}
MonotoneChainOverlapAction.constructor_ = function () {
  this._overlapSeg1 = new LineSegment();
  this._overlapSeg2 = new LineSegment();
};

class MonotoneChain {
  constructor () {
    MonotoneChain.constructor_.apply(this, arguments);
  }

  getLineSegment (index, ls) {
    ls.p0 = this._pts[index];
    ls.p1 = this._pts[index + 1];
  }

  computeSelect (searchEnv, start0, end0, mcs) {
    const p0 = this._pts[start0];
    const p1 = this._pts[end0];
    if (end0 - start0 === 1) {
      mcs.select(this, start0);
      return null
    }
    if (!searchEnv.intersects(p0, p1)) return null
    const mid = Math.trunc((start0 + end0) / 2);
    if (start0 < mid) {
      this.computeSelect(searchEnv, start0, mid, mcs);
    }
    if (mid < end0) {
      this.computeSelect(searchEnv, mid, end0, mcs);
    }
  }

  getCoordinates () {
    const coord = new Array(this._end - this._start + 1).fill(null);
    let index = 0;
    for (let i = this._start; i <= this._end; i++) {
      coord[index++] = this._pts[i];
    }
    return coord
  }

  computeOverlaps () {
    if (arguments.length === 2) {
      const mc = arguments[0]; const mco = arguments[1];
      this.computeOverlaps(this._start, this._end, mc, mc._start, mc._end, mco);
    } else if (arguments.length === 6) {
      const start0 = arguments[0]; const end0 = arguments[1]; const mc = arguments[2]; const start1 = arguments[3]; const end1 = arguments[4]; const mco = arguments[5];
      if (end0 - start0 === 1 && end1 - start1 === 1) {
        mco.overlap(this, start0, mc, start1);
        return null
      }
      if (!this.overlaps(start0, end0, mc, start1, end1)) return null
      const mid0 = Math.trunc((start0 + end0) / 2);
      const mid1 = Math.trunc((start1 + end1) / 2);
      if (start0 < mid0) {
        if (start1 < mid1) this.computeOverlaps(start0, mid0, mc, start1, mid1, mco);
        if (mid1 < end1) this.computeOverlaps(start0, mid0, mc, mid1, end1, mco);
      }
      if (mid0 < end0) {
        if (start1 < mid1) this.computeOverlaps(mid0, end0, mc, start1, mid1, mco);
        if (mid1 < end1) this.computeOverlaps(mid0, end0, mc, mid1, end1, mco);
      }
    }
  }

  setId (id) {
    this._id = id;
  }

  select (searchEnv, mcs) {
    this.computeSelect(searchEnv, this._start, this._end, mcs);
  }

  getEnvelope () {
    if (this._env === null) {
      const p0 = this._pts[this._start];
      const p1 = this._pts[this._end];
      this._env = new Envelope(p0, p1);
    }
    return this._env
  }

  overlaps (start0, end0, mc, start1, end1) {
    return Envelope.intersects(this._pts[start0], this._pts[end0], mc._pts[start1], mc._pts[end1])
  }

  getEndIndex () {
    return this._end
  }

  getStartIndex () {
    return this._start
  }

  getContext () {
    return this._context
  }

  getId () {
    return this._id
  }

  getClass () {
    return MonotoneChain
  }

  get interfaces_ () {
    return []
  }
}
MonotoneChain.constructor_ = function () {
  this._pts = null;
  this._start = null;
  this._end = null;
  this._env = null;
  this._context = null;
  this._id = null;
  const pts = arguments[0]; const start = arguments[1]; const end = arguments[2]; const context = arguments[3];
  this._pts = pts;
  this._start = start;
  this._end = end;
  this._context = context;
};

class MonotoneChainBuilder {
  constructor () {
    MonotoneChainBuilder.constructor_.apply(this, arguments);
  }

  static getChainStartIndices (pts) {
    let start = 0;
    const startIndexList = new ArrayList();
    startIndexList.add(new Integer(start));
    do {
      const last = MonotoneChainBuilder.findChainEnd(pts, start);
      startIndexList.add(new Integer(last));
      start = last;
    } while (start < pts.length - 1)
    const startIndex = MonotoneChainBuilder.toIntArray(startIndexList);
    return startIndex
  }

  static findChainEnd (pts, start) {
    let safeStart = start;
    while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {
      safeStart++;
    }
    if (safeStart >= pts.length - 1) {
      return pts.length - 1
    }
    const chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);
    let last = start + 1;
    while (last < pts.length) {
      if (!pts[last - 1].equals2D(pts[last])) {
        const quad = Quadrant.quadrant(pts[last - 1], pts[last]);
        if (quad !== chainQuad) break
      }
      last++;
    }
    return last - 1
  }

  static getChains () {
    if (arguments.length === 1) {
      const pts = arguments[0];
      return MonotoneChainBuilder.getChains(pts, null)
    } else if (arguments.length === 2) {
      const pts = arguments[0]; const context = arguments[1];
      const mcList = new ArrayList();
      const startIndex = MonotoneChainBuilder.getChainStartIndices(pts);
      for (let i = 0; i < startIndex.length - 1; i++) {
        const mc = new MonotoneChain(pts, startIndex[i], startIndex[i + 1], context);
        mcList.add(mc);
      }
      return mcList
    }
  }

  static toIntArray (list) {
    const array = new Array(list.size()).fill(null);
    for (let i = 0; i < array.length; i++) {
      array[i] = list.get(i).intValue();
    }
    return array
  }

  getClass () {
    return MonotoneChainBuilder
  }

  get interfaces_ () {
    return []
  }
}
MonotoneChainBuilder.constructor_ = function () {};

class Noder {
  constructor () {
    Noder.constructor_.apply(this, arguments);
  }

  computeNodes (segStrings) {}
  getNodedSubstrings () {}
  getClass () {
    return Noder
  }

  get interfaces_ () {
    return []
  }
}
Noder.constructor_ = function () {};

class SinglePassNoder {
  constructor () {
    SinglePassNoder.constructor_.apply(this, arguments);
  }

  setSegmentIntersector (segInt) {
    this._segInt = segInt;
  }

  getClass () {
    return SinglePassNoder
  }

  get interfaces_ () {
    return [Noder]
  }
}
SinglePassNoder.constructor_ = function () {
  this._segInt = null;
  if (arguments.length === 0) ; else if (arguments.length === 1) {
    const segInt = arguments[0];
    this.setSegmentIntersector(segInt);
  }
};

class MCIndexNoder extends SinglePassNoder {
  constructor () {
    super();
    MCIndexNoder.constructor_.apply(this, arguments);
  }

  getMonotoneChains () {
    return this._monoChains
  }

  getNodedSubstrings () {
    return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)
  }

  getIndex () {
    return this._index
  }

  add (segStr) {
    const segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);
    for (let i = segChains.iterator(); i.hasNext();) {
      const mc = i.next();
      mc.setId(this._idCounter++);
      this._index.insert(mc.getEnvelope(), mc);
      this._monoChains.add(mc);
    }
  }

  computeNodes (inputSegStrings) {
    this._nodedSegStrings = inputSegStrings;
    for (let i = inputSegStrings.iterator(); i.hasNext();) {
      this.add(i.next());
    }
    this.intersectChains();
  }

  intersectChains () {
    const overlapAction = new SegmentOverlapAction(this._segInt);
    for (let i = this._monoChains.iterator(); i.hasNext();) {
      const queryChain = i.next();
      const overlapChains = this._index.query(queryChain.getEnvelope());
      for (let j = overlapChains.iterator(); j.hasNext();) {
        const testChain = j.next();
        if (testChain.getId() > queryChain.getId()) {
          queryChain.computeOverlaps(testChain, overlapAction);
          this._nOverlaps++;
        }
        if (this._segInt.isDone()) return null
      }
    }
  }

  getClass () {
    return MCIndexNoder
  }

  get interfaces_ () {
    return []
  }
}
class SegmentOverlapAction extends MonotoneChainOverlapAction {
  constructor () {
    super();
    SegmentOverlapAction.constructor_.apply(this, arguments);
  }

  overlap () {
    if (arguments.length === 4) {
      const mc1 = arguments[0]; const start1 = arguments[1]; const mc2 = arguments[2]; const start2 = arguments[3];
      const ss1 = mc1.getContext();
      const ss2 = mc2.getContext();
      this._si.processIntersections(ss1, start1, ss2, start2);
    } else return super.overlap.apply(this, arguments)
  }

  getClass () {
    return SegmentOverlapAction
  }

  get interfaces_ () {
    return []
  }
}
SegmentOverlapAction.constructor_ = function () {
  this._si = null;
  const si = arguments[0];
  this._si = si;
};
MCIndexNoder.SegmentOverlapAction = SegmentOverlapAction;
MCIndexNoder.constructor_ = function () {
  this._monoChains = new ArrayList();
  this._index = new STRtree();
  this._idCounter = 0;
  this._nodedSegStrings = null;
  this._nOverlaps = 0;
  if (arguments.length === 0) ; else if (arguments.length === 1) {
    const si = arguments[0];
    SinglePassNoder.constructor_.call(this, si);
  }
};

class BufferInputLineSimplifier {
  constructor () {
    BufferInputLineSimplifier.constructor_.apply(this, arguments);
  }

  static simplify (inputLine, distanceTol) {
    const simp = new BufferInputLineSimplifier(inputLine);
    return simp.simplify(distanceTol)
  }

  isDeletable (i0, i1, i2, distanceTol) {
    const p0 = this._inputLine[i0];
    const p1 = this._inputLine[i1];
    const p2 = this._inputLine[i2];
    if (!this.isConcave(p0, p1, p2)) return false
    if (!this.isShallow(p0, p1, p2, distanceTol)) return false
    return this.isShallowSampled(p0, p1, i0, i2, distanceTol)
  }

  deleteShallowConcavities () {
    let index = 1;
    this._inputLine.length - 1;
    let midIndex = this.findNextNonDeletedIndex(index);
    let lastIndex = this.findNextNonDeletedIndex(midIndex);
    let isChanged = false;
    while (lastIndex < this._inputLine.length) {
      let isMiddleVertexDeleted = false;
      if (this.isDeletable(index, midIndex, lastIndex, this._distanceTol)) {
        this._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;
        isMiddleVertexDeleted = true;
        isChanged = true;
      }
      if (isMiddleVertexDeleted) index = lastIndex; else index = midIndex;
      midIndex = this.findNextNonDeletedIndex(index);
      lastIndex = this.findNextNonDeletedIndex(midIndex);
    }
    return isChanged
  }

  isShallowConcavity (p0, p1, p2, distanceTol) {
    const orientation = Orientation.index(p0, p1, p2);
    const isAngleToSimplify = orientation === this._angleOrientation;
    if (!isAngleToSimplify) return false
    const dist = Distance.pointToSegment(p1, p0, p2);
    return dist < distanceTol
  }

  isShallowSampled (p0, p2, i0, i2, distanceTol) {
    let inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);
    if (inc <= 0) inc = 1;
    for (let i = i0; i < i2; i += inc) {
      if (!this.isShallow(p0, p2, this._inputLine[i], distanceTol)) return false
    }
    return true
  }

  isConcave (p0, p1, p2) {
    const orientation = Orientation.index(p0, p1, p2);
    const isConcave = orientation === this._angleOrientation;
    return isConcave
  }

  simplify (distanceTol) {
    this._distanceTol = Math.abs(distanceTol);
    if (distanceTol < 0) this._angleOrientation = Orientation.CLOCKWISE;
    this._isDeleted = new Array(this._inputLine.length).fill(null);
    let isChanged = false;
    do {
      isChanged = this.deleteShallowConcavities();
    } while (isChanged)
    return this.collapseLine()
  }

  findNextNonDeletedIndex (index) {
    let next = index + 1;
    while (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) next++;
    return next
  }

  isShallow (p0, p1, p2, distanceTol) {
    const dist = Distance.pointToSegment(p1, p0, p2);
    return dist < distanceTol
  }

  collapseLine () {
    const coordList = new CoordinateList();
    for (let i = 0; i < this._inputLine.length; i++) {
      if (this._isDeleted[i] !== BufferInputLineSimplifier.DELETE) coordList.add(this._inputLine[i]);
    }
    return coordList.toCoordinateArray()
  }

  getClass () {
    return BufferInputLineSimplifier
  }

  get interfaces_ () {
    return []
  }
}
BufferInputLineSimplifier.constructor_ = function () {
  this._inputLine = null;
  this._distanceTol = null;
  this._isDeleted = null;
  this._angleOrientation = Orientation.COUNTERCLOCKWISE;
  const inputLine = arguments[0];
  this._inputLine = inputLine;
};
BufferInputLineSimplifier.INIT = 0;
BufferInputLineSimplifier.DELETE = 1;
BufferInputLineSimplifier.KEEP = 1;
BufferInputLineSimplifier.NUM_PTS_TO_CHECK = 10;

class OffsetSegmentString {
  constructor () {
    OffsetSegmentString.constructor_.apply(this, arguments);
  }

  getCoordinates () {
    const coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);
    return coord
  }

  setPrecisionModel (precisionModel) {
    this._precisionModel = precisionModel;
  }

  addPt (pt) {
    const bufPt = new Coordinate(pt);
    this._precisionModel.makePrecise(bufPt);
    if (this.isRedundant(bufPt)) return null
    this._ptList.add(bufPt);
  }

  reverse () {}
  addPts (pt, isForward) {
    if (isForward) {
      for (let i = 0; i < pt.length; i++) {
        this.addPt(pt[i]);
      }
    } else {
      for (let i = pt.length - 1; i >= 0; i--) {
        this.addPt(pt[i]);
      }
    }
  }

  isRedundant (pt) {
    if (this._ptList.size() < 1) return false
    const lastPt = this._ptList.get(this._ptList.size() - 1);
    const ptDist = pt.distance(lastPt);
    if (ptDist < this._minimimVertexDistance) return true
    return false
  }

  toString () {
    const fact = new GeometryFactory();
    const line = fact.createLineString(this.getCoordinates());
    return line.toString()
  }

  closeRing () {
    if (this._ptList.size() < 1) return null
    const startPt = new Coordinate(this._ptList.get(0));
    const lastPt = this._ptList.get(this._ptList.size() - 1);
    if (this._ptList.size() >= 2) this._ptList.get(this._ptList.size() - 2);
    if (startPt.equals(lastPt)) return null
    this._ptList.add(startPt);
  }

  setMinimumVertexDistance (minimimVertexDistance) {
    this._minimimVertexDistance = minimimVertexDistance;
  }

  getClass () {
    return OffsetSegmentString
  }

  get interfaces_ () {
    return []
  }
}
OffsetSegmentString.constructor_ = function () {
  this._ptList = null;
  this._precisionModel = null;
  this._minimimVertexDistance = 0.0;
  this._ptList = new ArrayList();
};
OffsetSegmentString.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);

class Angle {
  constructor () {
    Angle.constructor_.apply(this, arguments);
  }

  static toDegrees (radians) {
    return radians * 180 / Math.PI
  }

  static normalize (angle) {
    while (angle > Math.PI) angle -= Angle.PI_TIMES_2;
    while (angle <= -Math.PI) angle += Angle.PI_TIMES_2;
    return angle
  }

  static angle () {
    if (arguments.length === 1) {
      const p = arguments[0];
      return Math.atan2(p.y, p.x)
    } else if (arguments.length === 2) {
      const p0 = arguments[0]; const p1 = arguments[1];
      const dx = p1.x - p0.x;
      const dy = p1.y - p0.y;
      return Math.atan2(dy, dx)
    }
  }

  static isAcute (p0, p1, p2) {
    const dx0 = p0.x - p1.x;
    const dy0 = p0.y - p1.y;
    const dx1 = p2.x - p1.x;
    const dy1 = p2.y - p1.y;
    const dotprod = dx0 * dx1 + dy0 * dy1;
    return dotprod > 0
  }

  static isObtuse (p0, p1, p2) {
    const dx0 = p0.x - p1.x;
    const dy0 = p0.y - p1.y;
    const dx1 = p2.x - p1.x;
    const dy1 = p2.y - p1.y;
    const dotprod = dx0 * dx1 + dy0 * dy1;
    return dotprod < 0
  }

  static interiorAngle (p0, p1, p2) {
    const anglePrev = Angle.angle(p1, p0);
    const angleNext = Angle.angle(p1, p2);
    return Math.abs(angleNext - anglePrev)
  }

  static normalizePositive (angle) {
    if (angle < 0.0) {
      while (angle < 0.0) angle += Angle.PI_TIMES_2;
      if (angle >= Angle.PI_TIMES_2) angle = 0.0;
    } else {
      while (angle >= Angle.PI_TIMES_2) angle -= Angle.PI_TIMES_2;
      if (angle < 0.0) angle = 0.0;
    }
    return angle
  }

  static angleBetween (tip1, tail, tip2) {
    const a1 = Angle.angle(tail, tip1);
    const a2 = Angle.angle(tail, tip2);
    return Angle.diff(a1, a2)
  }

  static diff (ang1, ang2) {
    let delAngle = null;
    if (ang1 < ang2) {
      delAngle = ang2 - ang1;
    } else {
      delAngle = ang1 - ang2;
    }
    if (delAngle > Math.PI) {
      delAngle = 2 * Math.PI - delAngle;
    }
    return delAngle
  }

  static toRadians (angleDegrees) {
    return angleDegrees * Math.PI / 180.0
  }

  static getTurn (ang1, ang2) {
    const crossproduct = Math.sin(ang2 - ang1);
    if (crossproduct > 0) {
      return Angle.COUNTERCLOCKWISE
    }
    if (crossproduct < 0) {
      return Angle.CLOCKWISE
    }
    return Angle.NONE
  }

  static angleBetweenOriented (tip1, tail, tip2) {
    const a1 = Angle.angle(tail, tip1);
    const a2 = Angle.angle(tail, tip2);
    const angDel = a2 - a1;
    if (angDel <= -Math.PI) return angDel + Angle.PI_TIMES_2
    if (angDel > Math.PI) return angDel - Angle.PI_TIMES_2
    return angDel
  }

  getClass () {
    return Angle
  }

  get interfaces_ () {
    return []
  }
}
Angle.constructor_ = function () {};
Angle.PI_TIMES_2 = 2.0 * Math.PI;
Angle.PI_OVER_2 = Math.PI / 2.0;
Angle.PI_OVER_4 = Math.PI / 4.0;
Angle.COUNTERCLOCKWISE = Orientation.COUNTERCLOCKWISE;
Angle.CLOCKWISE = Orientation.CLOCKWISE;
Angle.NONE = Orientation.COLLINEAR;

class OffsetSegmentGenerator {
  constructor () {
    OffsetSegmentGenerator.constructor_.apply(this, arguments);
  }

  addNextSegment (p, addStartPoint) {
    this._s0 = this._s1;
    this._s1 = this._s2;
    this._s2 = p;
    this._seg0.setCoordinates(this._s0, this._s1);
    this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);
    this._seg1.setCoordinates(this._s1, this._s2);
    this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);
    if (this._s1.equals(this._s2)) return null
    const orientation = Orientation.index(this._s0, this._s1, this._s2);
    const outsideTurn = orientation === Orientation.CLOCKWISE && this._side === Position.LEFT || orientation === Orientation.COUNTERCLOCKWISE && this._side === Position.RIGHT;
    if (orientation === 0) {
      this.addCollinear(addStartPoint);
    } else if (outsideTurn) {
      this.addOutsideTurn(orientation, addStartPoint);
    } else {
      this.addInsideTurn(orientation, addStartPoint);
    }
  }

  addLineEndCap (p0, p1) {
    const seg = new LineSegment(p0, p1);
    const offsetL = new LineSegment();
    this.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);
    const offsetR = new LineSegment();
    this.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);
    const dx = p1.x - p0.x;
    const dy = p1.y - p0.y;
    const angle = Math.atan2(dy, dx);
    switch (this._bufParams.getEndCapStyle()) {
      case BufferParameters.CAP_ROUND:
        this._segList.addPt(offsetL.p1);
        this.addDirectedFillet(p1, angle + Math.PI / 2, angle - Math.PI / 2, Orientation.CLOCKWISE, this._distance);
        this._segList.addPt(offsetR.p1);
        break
      case BufferParameters.CAP_FLAT:
        this._segList.addPt(offsetL.p1);
        this._segList.addPt(offsetR.p1);
        break
      case BufferParameters.CAP_SQUARE:
        const squareCapSideOffset = new Coordinate();
        squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);
        squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);
        const squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);
        const squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);
        this._segList.addPt(squareCapLOffset);
        this._segList.addPt(squareCapROffset);
        break
    }
  }

  getCoordinates () {
    const pts = this._segList.getCoordinates();
    return pts
  }

  addMitreJoin (p, offset0, offset1, distance) {
    let isMitreWithinLimit = true;
    let intPt = null;
    try {
      intPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);
      const mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);
      if (mitreRatio > this._bufParams.getMitreLimit()) isMitreWithinLimit = false;
    } catch (ex) {
      if (ex instanceof NotRepresentableException) {
        intPt = new Coordinate(0, 0);
        isMitreWithinLimit = false;
      } else throw ex
    } finally {}
    if (isMitreWithinLimit) {
      this._segList.addPt(intPt);
    } else {
      this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());
    }
  }

  addOutsideTurn (orientation, addStartPoint) {
    if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {
      this._segList.addPt(this._offset0.p1);
      return null
    }
    if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
      this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);
    } else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {
      this.addBevelJoin(this._offset0, this._offset1);
    } else {
      if (addStartPoint) this._segList.addPt(this._offset0.p1);
      this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);
      this._segList.addPt(this._offset1.p0);
    }
  }

  createSquare (p) {
    this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));
    this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));
    this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));
    this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));
    this._segList.closeRing();
  }

  addSegments (pt, isForward) {
    this._segList.addPts(pt, isForward);
  }

  addFirstSegment () {
    this._segList.addPt(this._offset1.p0);
  }

  addCornerFillet (p, p0, p1, direction, radius) {
    const dx0 = p0.x - p.x;
    const dy0 = p0.y - p.y;
    let startAngle = Math.atan2(dy0, dx0);
    const dx1 = p1.x - p.x;
    const dy1 = p1.y - p.y;
    const endAngle = Math.atan2(dy1, dx1);
    if (direction === Orientation.CLOCKWISE) {
      if (startAngle <= endAngle) startAngle += 2.0 * Math.PI;
    } else {
      if (startAngle >= endAngle) startAngle -= 2.0 * Math.PI;
    }
    this._segList.addPt(p0);
    this.addDirectedFillet(p, startAngle, endAngle, direction, radius);
    this._segList.addPt(p1);
  }

  addLastSegment () {
    this._segList.addPt(this._offset1.p1);
  }

  initSideSegments (s1, s2, side) {
    this._s1 = s1;
    this._s2 = s2;
    this._side = side;
    this._seg1.setCoordinates(s1, s2);
    this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);
  }

  addLimitedMitreJoin (offset0, offset1, distance, mitreLimit) {
    const basePt = this._seg0.p1;
    const ang0 = Angle.angle(basePt, this._seg0.p0);
    Angle.angle(basePt, this._seg1.p1);
    const angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);
    const angDiffHalf = angDiff / 2;
    const midAng = Angle.normalize(ang0 + angDiffHalf);
    const mitreMidAng = Angle.normalize(midAng + Math.PI);
    const mitreDist = mitreLimit * distance;
    const bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));
    const bevelHalfLen = distance - bevelDelta;
    const bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);
    const bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);
    const bevelMidPt = new Coordinate(bevelMidX, bevelMidY);
    const mitreMidLine = new LineSegment(basePt, bevelMidPt);
    const bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);
    const bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);
    if (this._side === Position.LEFT) {
      this._segList.addPt(bevelEndLeft);
      this._segList.addPt(bevelEndRight);
    } else {
      this._segList.addPt(bevelEndRight);
      this._segList.addPt(bevelEndLeft);
    }
  }

  addDirectedFillet (p, startAngle, endAngle, direction, radius) {
    const directionFactor = direction === Orientation.CLOCKWISE ? -1 : 1;
    const totalAngle = Math.abs(startAngle - endAngle);
    const nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);
    if (nSegs < 1) return null
    let initAngle = null; let currAngleInc = null;
    initAngle = 0.0;
    currAngleInc = totalAngle / nSegs;
    let currAngle = initAngle;
    const pt = new Coordinate();
    while (currAngle < totalAngle) {
      const angle = startAngle + directionFactor * currAngle;
      pt.x = p.x + radius * Math.cos(angle);
      pt.y = p.y + radius * Math.sin(angle);
      this._segList.addPt(pt);
      currAngle += currAngleInc;
    }
  }

  computeOffsetSegment (seg, side, distance, offset) {
    const sideSign = side === Position.LEFT ? 1 : -1;
    const dx = seg.p1.x - seg.p0.x;
    const dy = seg.p1.y - seg.p0.y;
    const len = Math.sqrt(dx * dx + dy * dy);
    const ux = sideSign * distance * dx / len;
    const uy = sideSign * distance * dy / len;
    offset.p0.x = seg.p0.x - uy;
    offset.p0.y = seg.p0.y + ux;
    offset.p1.x = seg.p1.x - uy;
    offset.p1.y = seg.p1.y + ux;
  }

  addInsideTurn (orientation, addStartPoint) {
    this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);
    if (this._li.hasIntersection()) {
      this._segList.addPt(this._li.getIntersection(0));
    } else {
      this._hasNarrowConcaveAngle = true;
      if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {
        this._segList.addPt(this._offset0.p1);
      } else {
        this._segList.addPt(this._offset0.p1);
        if (this._closingSegLengthFactor > 0) {
          const mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
          this._segList.addPt(mid0);
          const mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
          this._segList.addPt(mid1);
        } else {
          this._segList.addPt(this._s1);
        }
        this._segList.addPt(this._offset1.p0);
      }
    }
  }

  createCircle (p) {
    const pt = new Coordinate(p.x + this._distance, p.y);
    this._segList.addPt(pt);
    this.addDirectedFillet(p, 0.0, 2.0 * Math.PI, -1, this._distance);
    this._segList.closeRing();
  }

  addBevelJoin (offset0, offset1) {
    this._segList.addPt(offset0.p1);
    this._segList.addPt(offset1.p0);
  }

  init (distance) {
    this._distance = distance;
    this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));
    this._segList = new OffsetSegmentString();
    this._segList.setPrecisionModel(this._precisionModel);
    this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
  }

  addCollinear (addStartPoint) {
    this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
    const numInt = this._li.getIntersectionNum();
    if (numInt >= 2) {
      if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
        if (addStartPoint) this._segList.addPt(this._offset0.p1);
        this._segList.addPt(this._offset1.p0);
      } else {
        this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, Orientation.CLOCKWISE, this._distance);
      }
    }
  }

  closeRing () {
    this._segList.closeRing();
  }

  hasNarrowConcaveAngle () {
    return this._hasNarrowConcaveAngle
  }

  getClass () {
    return OffsetSegmentGenerator
  }

  get interfaces_ () {
    return []
  }
}
OffsetSegmentGenerator.constructor_ = function () {
  this._maxCurveSegmentError = 0.0;
  this._filletAngleQuantum = null;
  this._closingSegLengthFactor = 1;
  this._segList = null;
  this._distance = 0.0;
  this._precisionModel = null;
  this._bufParams = null;
  this._li = null;
  this._s0 = null;
  this._s1 = null;
  this._s2 = null;
  this._seg0 = new LineSegment();
  this._seg1 = new LineSegment();
  this._offset0 = new LineSegment();
  this._offset1 = new LineSegment();
  this._side = 0;
  this._hasNarrowConcaveAngle = false;
  const precisionModel = arguments[0]; const bufParams = arguments[1]; const distance = arguments[2];
  this._precisionModel = precisionModel;
  this._bufParams = bufParams;
  this._li = new RobustLineIntersector();
  this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();
  if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;
  this.init(distance);
};
OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR = 1.0E-3;
OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-3;
OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-6;
OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR = 80;

class OffsetCurveBuilder {
  constructor () {
    OffsetCurveBuilder.constructor_.apply(this, arguments);
  }

  static copyCoordinates (pts) {
    const copy = new Array(pts.length).fill(null);
    for (let i = 0; i < copy.length; i++) {
      copy[i] = new Coordinate(pts[i]);
    }
    return copy
  }

  getOffsetCurve (inputPts, distance) {
    this._distance = distance;
    if (distance === 0.0) return null
    const isRightSide = distance < 0.0;
    const posDistance = Math.abs(distance);
    const segGen = this.getSegGen(posDistance);
    if (inputPts.length <= 1) {
      this.computePointCurve(inputPts[0], segGen);
    } else {
      this.computeOffsetCurve(inputPts, isRightSide, segGen);
    }
    const curvePts = segGen.getCoordinates();
    if (isRightSide) CoordinateArrays.reverse(curvePts);
    return curvePts
  }

  computeSingleSidedBufferCurve (inputPts, isRightSide, segGen) {
    const distTol = this.simplifyTolerance(this._distance);
    if (isRightSide) {
      segGen.addSegments(inputPts, true);
      const simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
      const n2 = simp2.length - 1;
      segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
      segGen.addFirstSegment();
      for (let i = n2 - 2; i >= 0; i--) {
        segGen.addNextSegment(simp2[i], true);
      }
    } else {
      segGen.addSegments(inputPts, false);
      const simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
      const n1 = simp1.length - 1;
      segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
      segGen.addFirstSegment();
      for (let i = 2; i <= n1; i++) {
        segGen.addNextSegment(simp1[i], true);
      }
    }
    segGen.addLastSegment();
    segGen.closeRing();
  }

  computeRingBufferCurve (inputPts, side, segGen) {
    let distTol = this.simplifyTolerance(this._distance);
    if (side === Position.RIGHT) distTol = -distTol;
    const simp = BufferInputLineSimplifier.simplify(inputPts, distTol);
    const n = simp.length - 1;
    segGen.initSideSegments(simp[n - 1], simp[0], side);
    for (let i = 1; i <= n; i++) {
      const addStartPoint = i !== 1;
      segGen.addNextSegment(simp[i], addStartPoint);
    }
    segGen.closeRing();
  }

  computeLineBufferCurve (inputPts, segGen) {
    const distTol = this.simplifyTolerance(this._distance);
    const simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
    const n1 = simp1.length - 1;
    segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
    for (let i = 2; i <= n1; i++) {
      segGen.addNextSegment(simp1[i], true);
    }
    segGen.addLastSegment();
    segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);
    const simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
    const n2 = simp2.length - 1;
    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
    for (let i = n2 - 2; i >= 0; i--) {
      segGen.addNextSegment(simp2[i], true);
    }
    segGen.addLastSegment();
    segGen.addLineEndCap(simp2[1], simp2[0]);
    segGen.closeRing();
  }

  computePointCurve (pt, segGen) {
    switch (this._bufParams.getEndCapStyle()) {
      case BufferParameters.CAP_ROUND:
        segGen.createCircle(pt);
        break
      case BufferParameters.CAP_SQUARE:
        segGen.createSquare(pt);
        break
    }
  }

  getLineCurve (inputPts, distance) {
    this._distance = distance;
    if (distance < 0.0 && !this._bufParams.isSingleSided()) return null
    if (distance === 0.0) return null
    const posDistance = Math.abs(distance);
    const segGen = this.getSegGen(posDistance);
    if (inputPts.length <= 1) {
      this.computePointCurve(inputPts[0], segGen);
    } else {
      if (this._bufParams.isSingleSided()) {
        const isRightSide = distance < 0.0;
        this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);
      } else this.computeLineBufferCurve(inputPts, segGen);
    }
    const lineCoord = segGen.getCoordinates();
    return lineCoord
  }

  getBufferParameters () {
    return this._bufParams
  }

  simplifyTolerance (bufDistance) {
    return bufDistance * this._bufParams.getSimplifyFactor()
  }

  getRingCurve (inputPts, side, distance) {
    this._distance = distance;
    if (inputPts.length <= 2) return this.getLineCurve(inputPts, distance)
    if (distance === 0.0) {
      return OffsetCurveBuilder.copyCoordinates(inputPts)
    }
    const segGen = this.getSegGen(distance);
    this.computeRingBufferCurve(inputPts, side, segGen);
    return segGen.getCoordinates()
  }

  computeOffsetCurve (inputPts, isRightSide, segGen) {
    const distTol = this.simplifyTolerance(this._distance);
    if (isRightSide) {
      const simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
      const n2 = simp2.length - 1;
      segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
      segGen.addFirstSegment();
      for (let i = n2 - 2; i >= 0; i--) {
        segGen.addNextSegment(simp2[i], true);
      }
    } else {
      const simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
      const n1 = simp1.length - 1;
      segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
      segGen.addFirstSegment();
      for (let i = 2; i <= n1; i++) {
        segGen.addNextSegment(simp1[i], true);
      }
    }
    segGen.addLastSegment();
  }

  getSegGen (distance) {
    return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance)
  }

  getClass () {
    return OffsetCurveBuilder
  }

  get interfaces_ () {
    return []
  }
}
OffsetCurveBuilder.constructor_ = function () {
  this._distance = 0.0;
  this._precisionModel = null;
  this._bufParams = null;
  const precisionModel = arguments[0]; const bufParams = arguments[1];
  this._precisionModel = precisionModel;
  this._bufParams = bufParams;
};

class SubgraphDepthLocater {
  constructor () {
    SubgraphDepthLocater.constructor_.apply(this, arguments);
  }

  findStabbedSegments () {
    if (arguments.length === 1) {
      const stabbingRayLeftPt = arguments[0];
      const stabbedSegments = new ArrayList();
      for (let i = this._subgraphs.iterator(); i.hasNext();) {
        const bsg = i.next();
        const env = bsg.getEnvelope();
        if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) continue
        this.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);
      }
      return stabbedSegments
    } else if (arguments.length === 3) {
      if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge)) {
        const stabbingRayLeftPt = arguments[0]; const dirEdge = arguments[1]; const stabbedSegments = arguments[2];
        const pts = dirEdge.getEdge().getCoordinates();
        for (let i = 0; i < pts.length - 1; i++) {
          this._seg.p0 = pts[i];
          this._seg.p1 = pts[i + 1];
          if (this._seg.p0.y > this._seg.p1.y) this._seg.reverse();
          const maxx = Math.max(this._seg.p0.x, this._seg.p1.x);
          if (maxx < stabbingRayLeftPt.x) continue
          if (this._seg.isHorizontal()) continue
          if (stabbingRayLeftPt.y < this._seg.p0.y || stabbingRayLeftPt.y > this._seg.p1.y) continue
          if (Orientation.index(this._seg.p0, this._seg.p1, stabbingRayLeftPt) === Orientation.RIGHT) continue
          let depth = dirEdge.getDepth(Position.LEFT);
          if (!this._seg.p0.equals(pts[i])) depth = dirEdge.getDepth(Position.RIGHT);
          const ds = new DepthSegment(this._seg, depth);
          stabbedSegments.add(ds);
        }
      } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && hasInterface(arguments[1], List))) {
        const stabbingRayLeftPt = arguments[0]; const dirEdges = arguments[1]; const stabbedSegments = arguments[2];
        for (let i = dirEdges.iterator(); i.hasNext();) {
          const de = i.next();
          if (!de.isForward()) continue
          this.findStabbedSegments(stabbingRayLeftPt, de, stabbedSegments);
        }
      }
    }
  }

  getDepth (p) {
    const stabbedSegments = this.findStabbedSegments(p);
    if (stabbedSegments.size() === 0) return 0
    const ds = Collections.min(stabbedSegments);
    return ds._leftDepth
  }

  getClass () {
    return SubgraphDepthLocater
  }

  get interfaces_ () {
    return []
  }
}
class DepthSegment {
  constructor () {
    DepthSegment.constructor_.apply(this, arguments);
  }

  compareTo (obj) {
    const other = obj;
    if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) return 1
    if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) return -1
    let orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);
    if (orientIndex !== 0) return orientIndex
    orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);
    if (orientIndex !== 0) return orientIndex
    return this._upwardSeg.compareTo(other._upwardSeg)
  }

  compareX (seg0, seg1) {
    const compare0 = seg0.p0.compareTo(seg1.p0);
    if (compare0 !== 0) return compare0
    return seg0.p1.compareTo(seg1.p1)
  }

  toString () {
    return this._upwardSeg.toString()
  }

  getClass () {
    return DepthSegment
  }

  get interfaces_ () {
    return [Comparable]
  }
}
DepthSegment.constructor_ = function () {
  this._upwardSeg = null;
  this._leftDepth = null;
  const seg = arguments[0]; const depth = arguments[1];
  this._upwardSeg = new LineSegment(seg);
  this._leftDepth = depth;
};
SubgraphDepthLocater.DepthSegment = DepthSegment;
SubgraphDepthLocater.constructor_ = function () {
  this._subgraphs = null;
  this._seg = new LineSegment();
  const subgraphs = arguments[0];
  this._subgraphs = subgraphs;
};

class Triangle {
  constructor () {
    Triangle.constructor_.apply(this, arguments);
  }

  static area (a, b, c) {
    return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2)
  }

  static signedArea (a, b, c) {
    return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2
  }

  static det (m00, m01, m10, m11) {
    return m00 * m11 - m01 * m10
  }

  static interpolateZ (p, v0, v1, v2) {
    const x0 = v0.x;
    const y0 = v0.y;
    const a = v1.x - x0;
    const b = v2.x - x0;
    const c = v1.y - y0;
    const d = v2.y - y0;
    const det = a * d - b * c;
    const dx = p.x - x0;
    const dy = p.y - y0;
    const t = (d * dx - b * dy) / det;
    const u = (-c * dx + a * dy) / det;
    const z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);
    return z
  }

  static longestSideLength (a, b, c) {
    const lenAB = a.distance(b);
    const lenBC = b.distance(c);
    const lenCA = c.distance(a);
    let maxLen = lenAB;
    if (lenBC > maxLen) maxLen = lenBC;
    if (lenCA > maxLen) maxLen = lenCA;
    return maxLen
  }

  static isAcute (a, b, c) {
    if (!Angle.isAcute(a, b, c)) return false
    if (!Angle.isAcute(b, c, a)) return false
    if (!Angle.isAcute(c, a, b)) return false
    return true
  }

  static circumcentre (a, b, c) {
    const cx = c.x;
    const cy = c.y;
    const ax = a.x - cx;
    const ay = a.y - cy;
    const bx = b.x - cx;
    const by = b.y - cy;
    const denom = 2 * Triangle.det(ax, ay, bx, by);
    const numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
    const numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
    const ccx = cx - numx / denom;
    const ccy = cy + numy / denom;
    return new Coordinate(ccx, ccy)
  }

  static perpendicularBisector (a, b) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);
    const l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);
    return new HCoordinate(l1, l2)
  }

  static angleBisector (a, b, c) {
    const len0 = b.distance(a);
    const len2 = b.distance(c);
    const frac = len0 / (len0 + len2);
    const dx = c.x - a.x;
    const dy = c.y - a.y;
    const splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);
    return splitPt
  }

  static area3D (a, b, c) {
    const ux = b.x - a.x;
    const uy = b.y - a.y;
    const uz = b.z - a.z;
    const vx = c.x - a.x;
    const vy = c.y - a.y;
    const vz = c.z - a.z;
    const crossx = uy * vz - uz * vy;
    const crossy = uz * vx - ux * vz;
    const crossz = ux * vy - uy * vx;
    const absSq = crossx * crossx + crossy * crossy + crossz * crossz;
    const area3D = Math.sqrt(absSq) / 2;
    return area3D
  }

  static centroid (a, b, c) {
    const x = (a.x + b.x + c.x) / 3;
    const y = (a.y + b.y + c.y) / 3;
    return new Coordinate(x, y)
  }

  static inCentre (a, b, c) {
    const len0 = b.distance(c);
    const len1 = a.distance(c);
    const len2 = a.distance(b);
    const circum = len0 + len1 + len2;
    const inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;
    const inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;
    return new Coordinate(inCentreX, inCentreY)
  }

  area () {
    return Triangle.area(this.p0, this.p1, this.p2)
  }

  signedArea () {
    return Triangle.signedArea(this.p0, this.p1, this.p2)
  }

  interpolateZ (p) {
    if (p === null) throw new IllegalArgumentException('Supplied point is null.')
    return Triangle.interpolateZ(p, this.p0, this.p1, this.p2)
  }

  longestSideLength () {
    return Triangle.longestSideLength(this.p0, this.p1, this.p2)
  }

  isAcute () {
    return Triangle.isAcute(this.p0, this.p1, this.p2)
  }

  circumcentre () {
    return Triangle.circumcentre(this.p0, this.p1, this.p2)
  }

  area3D () {
    return Triangle.area3D(this.p0, this.p1, this.p2)
  }

  centroid () {
    return Triangle.centroid(this.p0, this.p1, this.p2)
  }

  inCentre () {
    return Triangle.inCentre(this.p0, this.p1, this.p2)
  }

  getClass () {
    return Triangle
  }

  get interfaces_ () {
    return []
  }
}
Triangle.constructor_ = function () {
  this.p0 = null;
  this.p1 = null;
  this.p2 = null;
  const p0 = arguments[0]; const p1 = arguments[1]; const p2 = arguments[2];
  this.p0 = p0;
  this.p1 = p1;
  this.p2 = p2;
};

class OffsetCurveSetBuilder {
  constructor () {
    OffsetCurveSetBuilder.constructor_.apply(this, arguments);
  }

  addPoint (p) {
    if (this._distance <= 0.0) return null
    const coord = p.getCoordinates();
    const curve = this._curveBuilder.getLineCurve(coord, this._distance);
    this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
  }

  addPolygon (p) {
    let offsetDistance = this._distance;
    let offsetSide = Position.LEFT;
    if (this._distance < 0.0) {
      offsetDistance = -this._distance;
      offsetSide = Position.RIGHT;
    }
    const shell = p.getExteriorRing();
    const shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());
    if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) return null
    if (this._distance <= 0.0 && shellCoord.length < 3) return null
    this.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);
    for (let i = 0; i < p.getNumInteriorRing(); i++) {
      const hole = p.getInteriorRingN(i);
      const holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());
      if (this._distance > 0.0 && this.isErodedCompletely(hole, -this._distance)) continue
      this.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);
    }
  }

  isTriangleErodedCompletely (triangleCoord, bufferDistance) {
    const tri = new Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2]);
    const inCentre = tri.inCentre();
    const distToCentre = Distance.pointToSegment(inCentre, tri.p0, tri.p1);
    return distToCentre < Math.abs(bufferDistance)
  }

  addLineString (line) {
    if (this._distance <= 0.0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null
    const coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
    const curve = this._curveBuilder.getLineCurve(coord, this._distance);
    this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
  }

  addCurve (coord, leftLoc, rightLoc) {
    if (coord === null || coord.length < 2) return null
    const e = new NodedSegmentString(coord, new Label$1(0, Location.BOUNDARY, leftLoc, rightLoc));
    this._curveList.add(e);
  }

  getCurves () {
    this.add(this._inputGeom);
    return this._curveList
  }

  addPolygonRing (coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {
    if (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) return null
    let leftLoc = cwLeftLoc;
    let rightLoc = cwRightLoc;
    if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && Orientation.isCCW(coord)) {
      leftLoc = cwRightLoc;
      rightLoc = cwLeftLoc;
      side = Position.opposite(side);
    }
    const curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);
    this.addCurve(curve, leftLoc, rightLoc);
  }

  add (g) {
    if (g.isEmpty()) return null
    if (g instanceof Polygon) this.addPolygon(g); else if (g instanceof LineString) this.addLineString(g); else if (g instanceof Point) this.addPoint(g); else if (g instanceof MultiPoint) this.addCollection(g); else if (g instanceof MultiLineString) this.addCollection(g); else if (g instanceof MultiPolygon) this.addCollection(g); else if (g instanceof GeometryCollection) this.addCollection(g); else throw new UnsupportedOperationException(g.getClass().getName())
  }

  isErodedCompletely (ring, bufferDistance) {
    const ringCoord = ring.getCoordinates();
    if (ringCoord.length < 4) return bufferDistance < 0
    if (ringCoord.length === 4) return this.isTriangleErodedCompletely(ringCoord, bufferDistance)
    const env = ring.getEnvelopeInternal();
    const envMinDimension = Math.min(env.getHeight(), env.getWidth());
    if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) return true
    return false
  }

  addCollection (gc) {
    for (let i = 0; i < gc.getNumGeometries(); i++) {
      const g = gc.getGeometryN(i);
      this.add(g);
    }
  }

  getClass () {
    return OffsetCurveSetBuilder
  }

  get interfaces_ () {
    return []
  }
}
OffsetCurveSetBuilder.constructor_ = function () {
  this._inputGeom = null;
  this._distance = null;
  this._curveBuilder = null;
  this._curveList = new ArrayList();
  const inputGeom = arguments[0]; const distance = arguments[1]; const curveBuilder = arguments[2];
  this._inputGeom = inputGeom;
  this._distance = distance;
  this._curveBuilder = curveBuilder;
};

class PointOnGeometryLocator {
  constructor () {
    PointOnGeometryLocator.constructor_.apply(this, arguments);
  }

  locate (p) {}
  getClass () {
    return PointOnGeometryLocator
  }

  get interfaces_ () {
    return []
  }
}
PointOnGeometryLocator.constructor_ = function () {};

class GeometryCollectionIterator {
  constructor () {
    GeometryCollectionIterator.constructor_.apply(this, arguments);
  }

  static isAtomic (geom) {
    return !(geom instanceof GeometryCollection)
  }

  next () {
    if (this._atStart) {
      this._atStart = false;
      if (GeometryCollectionIterator.isAtomic(this._parent)) this._index++;
      return this._parent
    }
    if (this._subcollectionIterator !== null) {
      if (this._subcollectionIterator.hasNext()) {
        return this._subcollectionIterator.next()
      } else {
        this._subcollectionIterator = null;
      }
    }
    if (this._index >= this._max) {
      throw new NoSuchElementException()
    }
    const obj = this._parent.getGeometryN(this._index++);
    if (obj instanceof GeometryCollection) {
      this._subcollectionIterator = new GeometryCollectionIterator(obj);
      return this._subcollectionIterator.next()
    }
    return obj
  }

  remove () {
    throw new UnsupportedOperationException(this.getClass().getName())
  }

  hasNext () {
    if (this._atStart) {
      return true
    }
    if (this._subcollectionIterator !== null) {
      if (this._subcollectionIterator.hasNext()) {
        return true
      }
      this._subcollectionIterator = null;
    }
    if (this._index >= this._max) {
      return false
    }
    return true
  }

  getClass () {
    return GeometryCollectionIterator
  }

  get interfaces_ () {
    return [Iterator]
  }
}
GeometryCollectionIterator.constructor_ = function () {
  this._parent = null;
  this._atStart = null;
  this._max = null;
  this._index = null;
  this._subcollectionIterator = null;
  const parent = arguments[0];
  this._parent = parent;
  this._atStart = true;
  this._index = 0;
  this._max = parent.getNumGeometries();
};

class SimplePointInAreaLocator {
  constructor () {
    SimplePointInAreaLocator.constructor_.apply(this, arguments);
  }

  static locatePointInPolygon (p, poly) {
    if (poly.isEmpty()) return Location.EXTERIOR
    const shell = poly.getExteriorRing();
    const shellLoc = SimplePointInAreaLocator.locatePointInRing(p, shell);
    if (shellLoc !== Location.INTERIOR) return shellLoc
    for (let i = 0; i < poly.getNumInteriorRing(); i++) {
      const hole = poly.getInteriorRingN(i);
      const holeLoc = SimplePointInAreaLocator.locatePointInRing(p, hole);
      if (holeLoc === Location.BOUNDARY) return Location.BOUNDARY
      if (holeLoc === Location.INTERIOR) return Location.EXTERIOR
    }
    return Location.INTERIOR
  }

  static locatePointInRing (p, ring) {
    if (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR
    return PointLocation.locateInRing(p, ring.getCoordinates())
  }

  static containsPointInPolygon (p, poly) {
    return Location.EXTERIOR !== SimplePointInAreaLocator.locatePointInPolygon(p, poly)
  }

  static locateInGeometry (p, geom) {
    if (geom instanceof Polygon) {
      return SimplePointInAreaLocator.locatePointInPolygon(p, geom)
    } else if (geom instanceof GeometryCollection) {
      const geomi = new GeometryCollectionIterator(geom);
      while (geomi.hasNext()) {
        const g2 = geomi.next();
        if (g2 !== geom) {
          const loc = SimplePointInAreaLocator.locateInGeometry(p, g2);
          if (loc !== Location.EXTERIOR) return loc
        }
      }
    }
    return Location.EXTERIOR
  }

  static locate (p, geom) {
    if (geom.isEmpty()) return Location.EXTERIOR
    return SimplePointInAreaLocator.locateInGeometry(p, geom)
  }

  locate (p) {
    return SimplePointInAreaLocator.locate(p, this._geom)
  }

  getClass () {
    return SimplePointInAreaLocator
  }

  get interfaces_ () {
    return [PointOnGeometryLocator]
  }
}
SimplePointInAreaLocator.constructor_ = function () {
  this._geom = null;
  const geom = arguments[0];
  this._geom = geom;
};

class EdgeEndStar {
  constructor () {
    EdgeEndStar.constructor_.apply(this, arguments);
  }

  getNextCW (ee) {
    this.getEdges();
    const i = this._edgeList.indexOf(ee);
    let iNextCW = i - 1;
    if (i === 0) iNextCW = this._edgeList.size() - 1;
    return this._edgeList.get(iNextCW)
  }

  propagateSideLabels (geomIndex) {
    let startLoc = Location.NONE;
    for (let it = this.iterator(); it.hasNext();) {
      const e = it.next();
      const label = e.getLabel();
      if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) startLoc = label.getLocation(geomIndex, Position.LEFT);
    }
    if (startLoc === Location.NONE) return null
    let currLoc = startLoc;
    for (let it = this.iterator(); it.hasNext();) {
      const e = it.next();
      const label = e.getLabel();
      if (label.getLocation(geomIndex, Position.ON) === Location.NONE) label.setLocation(geomIndex, Position.ON, currLoc);
      if (label.isArea(geomIndex)) {
        const leftLoc = label.getLocation(geomIndex, Position.LEFT);
        const rightLoc = label.getLocation(geomIndex, Position.RIGHT);
        if (rightLoc !== Location.NONE) {
          if (rightLoc !== currLoc) throw new TopologyException('side location conflict', e.getCoordinate())
          if (leftLoc === Location.NONE) {
            Assert.shouldNeverReachHere('found single null side (at ' + e.getCoordinate() + ')');
          }
          currLoc = leftLoc;
        } else {
          Assert.isTrue(label.getLocation(geomIndex, Position.LEFT) === Location.NONE, 'found single null side');
          label.setLocation(geomIndex, Position.RIGHT, currLoc);
          label.setLocation(geomIndex, Position.LEFT, currLoc);
        }
      }
    }
  }

  getCoordinate () {
    const it = this.iterator();
    if (!it.hasNext()) return null
    const e = it.next();
    return e.getCoordinate()
  }

  print (out) {
    System.out.println('EdgeEndStar:   ' + this.getCoordinate());
    for (let it = this.iterator(); it.hasNext();) {
      const e = it.next();
      e.print(out);
    }
  }

  isAreaLabelsConsistent (geomGraph) {
    this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());
    return this.checkAreaLabelsConsistent(0)
  }

  checkAreaLabelsConsistent (geomIndex) {
    const edges = this.getEdges();
    if (edges.size() <= 0) return true
    const lastEdgeIndex = edges.size() - 1;
    const startLabel = edges.get(lastEdgeIndex).getLabel();
    const startLoc = startLabel.getLocation(geomIndex, Position.LEFT);
    Assert.isTrue(startLoc !== Location.NONE, 'Found unlabelled area edge');
    let currLoc = startLoc;
    for (let it = this.iterator(); it.hasNext();) {
      const e = it.next();
      const label = e.getLabel();
      Assert.isTrue(label.isArea(geomIndex), 'Found non-area edge');
      const leftLoc = label.getLocation(geomIndex, Position.LEFT);
      const rightLoc = label.getLocation(geomIndex, Position.RIGHT);
      if (leftLoc === rightLoc) {
        return false
      }
      if (rightLoc !== currLoc) {
        return false
      }
      currLoc = leftLoc;
    }
    return true
  }

  findIndex (eSearch) {
    this.iterator();
    for (let i = 0; i < this._edgeList.size(); i++) {
      const e = this._edgeList.get(i);
      if (e === eSearch) return i
    }
    return -1
  }

  iterator () {
    return this.getEdges().iterator()
  }

  getEdges () {
    if (this._edgeList === null) {
      this._edgeList = new ArrayList(this._edgeMap.values());
    }
    return this._edgeList
  }

  getLocation (geomIndex, p, geom) {
    if (this._ptInAreaLocation[geomIndex] === Location.NONE) {
      this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());
    }
    return this._ptInAreaLocation[geomIndex]
  }

  toString () {
    const buf = new StringBuffer();
    buf.append('EdgeEndStar:   ' + this.getCoordinate());
    buf.append('\n');
    for (let it = this.iterator(); it.hasNext();) {
      const e = it.next();
      buf.append(e);
      buf.append('\n');
    }
    return buf.toString()
  }

  computeEdgeEndLabels (boundaryNodeRule) {
    for (let it = this.iterator(); it.hasNext();) {
      const ee = it.next();
      ee.computeLabel(boundaryNodeRule);
    }
  }

  computeLabelling (geomGraph) {
    this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());
    this.propagateSideLabels(0);
    this.propagateSideLabels(1);
    const hasDimensionalCollapseEdge = [false, false];
    for (let it = this.iterator(); it.hasNext();) {
      const e = it.next();
      const label = e.getLabel();
      for (let geomi = 0; geomi < 2; geomi++) {
        if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;
      }
    }
    for (let it = this.iterator(); it.hasNext();) {
      const e = it.next();
      const label = e.getLabel();
      for (let geomi = 0; geomi < 2; geomi++) {
        if (label.isAnyNull(geomi)) {
          let loc = Location.NONE;
          if (hasDimensionalCollapseEdge[geomi]) {
            loc = Location.EXTERIOR;
          } else {
            const p = e.getCoordinate();
            loc = this.getLocation(geomi, p, geomGraph);
          }
          label.setAllLocationsIfNull(geomi, loc);
        }
      }
    }
  }

  getDegree () {
    return this._edgeMap.size()
  }

  insertEdgeEnd (e, obj) {
    this._edgeMap.put(e, obj);
    this._edgeList = null;
  }

  getClass () {
    return EdgeEndStar
  }

  get interfaces_ () {
    return []
  }
}
EdgeEndStar.constructor_ = function () {
  this._edgeMap = new TreeMap();
  this._edgeList = null;
  this._ptInAreaLocation = [Location.NONE, Location.NONE];
};

class DirectedEdgeStar extends EdgeEndStar {
  constructor () {
    super();
    DirectedEdgeStar.constructor_.apply(this, arguments);
  }

  linkResultDirectedEdges () {
    this.getResultAreaEdges();
    let firstOut = null;
    let incoming = null;
    let state = this._SCANNING_FOR_INCOMING;
    for (let i = 0; i < this._resultAreaEdgeList.size(); i++) {
      const nextOut = this._resultAreaEdgeList.get(i);
      const nextIn = nextOut.getSym();
      if (!nextOut.getLabel().isArea()) continue
      if (firstOut === null && nextOut.isInResult()) firstOut = nextOut;
      switch (state) {
        case this._SCANNING_FOR_INCOMING:
          if (!nextIn.isInResult()) continue
          incoming = nextIn;
          state = this._LINKING_TO_OUTGOING;
          break
        case this._LINKING_TO_OUTGOING:
          if (!nextOut.isInResult()) continue
          incoming.setNext(nextOut);
          state = this._SCANNING_FOR_INCOMING;
          break
      }
    }
    if (state === this._LINKING_TO_OUTGOING) {
      if (firstOut === null) throw new TopologyException('no outgoing dirEdge found', this.getCoordinate())
      Assert.isTrue(firstOut.isInResult(), 'unable to link last incoming dirEdge');
      incoming.setNext(firstOut);
    }
  }

  insert (ee) {
    const de = ee;
    this.insertEdgeEnd(de, de);
  }

  getRightmostEdge () {
    const edges = this.getEdges();
    const size = edges.size();
    if (size < 1) return null
    const de0 = edges.get(0);
    if (size === 1) return de0
    const deLast = edges.get(size - 1);
    const quad0 = de0.getQuadrant();
    const quad1 = deLast.getQuadrant();
    if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) return de0; else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) return deLast; else {
      if (de0.getDy() !== 0) return de0; else if (deLast.getDy() !== 0) return deLast
    }
    Assert.shouldNeverReachHere('found two horizontal edges incident on node');
    return null
  }

  print (out) {
    System.out.println('DirectedEdgeStar: ' + this.getCoordinate());
    for (let it = this.iterator(); it.hasNext();) {
      const de = it.next();
      out.print('out ');
      de.print(out);
      out.println();
      out.print('in ');
      de.getSym().print(out);
      out.println();
    }
  }

  getResultAreaEdges () {
    if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList
    this._resultAreaEdgeList = new ArrayList();
    for (let it = this.iterator(); it.hasNext();) {
      const de = it.next();
      if (de.isInResult() || de.getSym().isInResult()) this._resultAreaEdgeList.add(de);
    }
    return this._resultAreaEdgeList
  }

  updateLabelling (nodeLabel) {
    for (let it = this.iterator(); it.hasNext();) {
      const de = it.next();
      const label = de.getLabel();
      label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));
      label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));
    }
  }

  linkAllDirectedEdges () {
    this.getEdges();
    let prevOut = null;
    let firstIn = null;
    for (let i = this._edgeList.size() - 1; i >= 0; i--) {
      const nextOut = this._edgeList.get(i);
      const nextIn = nextOut.getSym();
      if (firstIn === null) firstIn = nextIn;
      if (prevOut !== null) nextIn.setNext(prevOut);
      prevOut = nextOut;
    }
    firstIn.setNext(prevOut);
  }

  computeDepths () {
    if (arguments.length === 1) {
      const de = arguments[0];
      const edgeIndex = this.findIndex(de);
      const startDepth = de.getDepth(Position.LEFT);
      const targetLastDepth = de.getDepth(Position.RIGHT);
      const nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);
      const lastDepth = this.computeDepths(0, edgeIndex, nextDepth);
      if (lastDepth !== targetLastDepth) throw new TopologyException('depth mismatch at ' + de.getCoordinate())
    } else if (arguments.length === 3) {
      const startIndex = arguments[0]; const endIndex = arguments[1]; const startDepth = arguments[2];
      let currDepth = startDepth;
      for (let i = startIndex; i < endIndex; i++) {
        const nextDe = this._edgeList.get(i);
        nextDe.setEdgeDepths(Position.RIGHT, currDepth);
        currDepth = nextDe.getDepth(Position.LEFT);
      }
      return currDepth
    }
  }

  mergeSymLabels () {
    for (let it = this.iterator(); it.hasNext();) {
      const de = it.next();
      const label = de.getLabel();
      label.merge(de.getSym().getLabel());
    }
  }

  linkMinimalDirectedEdges (er) {
    let firstOut = null;
    let incoming = null;
    let state = this._SCANNING_FOR_INCOMING;
    for (let i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {
      const nextOut = this._resultAreaEdgeList.get(i);
      const nextIn = nextOut.getSym();
      if (firstOut === null && nextOut.getEdgeRing() === er) firstOut = nextOut;
      switch (state) {
        case this._SCANNING_FOR_INCOMING:
          if (nextIn.getEdgeRing() !== er) continue
          incoming = nextIn;
          state = this._LINKING_TO_OUTGOING;
          break
        case this._LINKING_TO_OUTGOING:
          if (nextOut.getEdgeRing() !== er) continue
          incoming.setNextMin(nextOut);
          state = this._SCANNING_FOR_INCOMING;
          break
      }
    }
    if (state === this._LINKING_TO_OUTGOING) {
      Assert.isTrue(firstOut !== null, 'found null for first outgoing dirEdge');
      Assert.isTrue(firstOut.getEdgeRing() === er, 'unable to link last incoming dirEdge');
      incoming.setNextMin(firstOut);
    }
  }

  getOutgoingDegree () {
    if (arguments.length === 0) {
      let degree = 0;
      for (let it = this.iterator(); it.hasNext();) {
        const de = it.next();
        if (de.isInResult()) degree++;
      }
      return degree
    } else if (arguments.length === 1) {
      const er = arguments[0];
      let degree = 0;
      for (let it = this.iterator(); it.hasNext();) {
        const de = it.next();
        if (de.getEdgeRing() === er) degree++;
      }
      return degree
    }
  }

  getLabel () {
    return this._label
  }

  findCoveredLineEdges () {
    let startLoc = Location.NONE;
    for (let it = this.iterator(); it.hasNext();) {
      const nextOut = it.next();
      const nextIn = nextOut.getSym();
      if (!nextOut.isLineEdge()) {
        if (nextOut.isInResult()) {
          startLoc = Location.INTERIOR;
          break
        }
        if (nextIn.isInResult()) {
          startLoc = Location.EXTERIOR;
          break
        }
      }
    }
    if (startLoc === Location.NONE) return null
    let currLoc = startLoc;
    for (let it = this.iterator(); it.hasNext();) {
      const nextOut = it.next();
      const nextIn = nextOut.getSym();
      if (nextOut.isLineEdge()) {
        nextOut.getEdge().setCovered(currLoc === Location.INTERIOR);
      } else {
        if (nextOut.isInResult()) currLoc = Location.EXTERIOR;
        if (nextIn.isInResult()) currLoc = Location.INTERIOR;
      }
    }
  }

  computeLabelling (geom) {
    super.computeLabelling.call(this, geom);
    this._label = new Label$1(Location.NONE);
    for (let it = this.iterator(); it.hasNext();) {
      const ee = it.next();
      const e = ee.getEdge();
      const eLabel = e.getLabel();
      for (let i = 0; i < 2; i++) {
        const eLoc = eLabel.getLocation(i);
        if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) this._label.setLocation(i, Location.INTERIOR);
      }
    }
  }

  getClass () {
    return DirectedEdgeStar
  }

  get interfaces_ () {
    return []
  }
}
DirectedEdgeStar.constructor_ = function () {
  this._resultAreaEdgeList = null;
  this._label = null;
  this._SCANNING_FOR_INCOMING = 1;
  this._LINKING_TO_OUTGOING = 2;
};

class OverlayNodeFactory extends NodeFactory {
  constructor () {
    super();
    OverlayNodeFactory.constructor_.apply(this, arguments);
  }

  createNode (coord) {
    return new Node(coord, new DirectedEdgeStar())
  }

  getClass () {
    return OverlayNodeFactory
  }

  get interfaces_ () {
    return []
  }
}
OverlayNodeFactory.constructor_ = function () {};

class OrientedCoordinateArray {
  constructor () {
    OrientedCoordinateArray.constructor_.apply(this, arguments);
  }

  static orientation (pts) {
    return CoordinateArrays.increasingDirection(pts) === 1
  }

  static compareOriented (pts1, orientation1, pts2, orientation2) {
    const dir1 = orientation1 ? 1 : -1;
    const dir2 = orientation2 ? 1 : -1;
    const limit1 = orientation1 ? pts1.length : -1;
    const limit2 = orientation2 ? pts2.length : -1;
    let i1 = orientation1 ? 0 : pts1.length - 1;
    let i2 = orientation2 ? 0 : pts2.length - 1;
    while (true) {
      const compPt = pts1[i1].compareTo(pts2[i2]);
      if (compPt !== 0) return compPt
      i1 += dir1;
      i2 += dir2;
      const done1 = i1 === limit1;
      const done2 = i2 === limit2;
      if (done1 && !done2) return -1
      if (!done1 && done2) return 1
      if (done1 && done2) return 0
    }
  }

  compareTo (o1) {
    const oca = o1;
    const comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);
    return comp
  }

  getClass () {
    return OrientedCoordinateArray
  }

  get interfaces_ () {
    return [Comparable]
  }
}
OrientedCoordinateArray.constructor_ = function () {
  this._pts = null;
  this._orientation = null;
  const pts = arguments[0];
  this._pts = pts;
  this._orientation = OrientedCoordinateArray.orientation(pts);
};

class EdgeList {
  constructor () {
    EdgeList.constructor_.apply(this, arguments);
  }

  print (out) {
    out.print('MULTILINESTRING ( ');
    for (let j = 0; j < this._edges.size(); j++) {
      const e = this._edges.get(j);
      if (j > 0) out.print(',');
      out.print('(');
      const pts = e.getCoordinates();
      for (let i = 0; i < pts.length; i++) {
        if (i > 0) out.print(',');
        out.print(pts[i].x + ' ' + pts[i].y);
      }
      out.println(')');
    }
    out.print(')  ');
  }

  addAll (edgeColl) {
    for (let i = edgeColl.iterator(); i.hasNext();) {
      this.add(i.next());
    }
  }

  findEdgeIndex (e) {
    for (let i = 0; i < this._edges.size(); i++) {
      if (this._edges.get(i).equals(e)) return i
    }
    return -1
  }

  iterator () {
    return this._edges.iterator()
  }

  getEdges () {
    return this._edges
  }

  get (i) {
    return this._edges.get(i)
  }

  findEqualEdge (e) {
    const oca = new OrientedCoordinateArray(e.getCoordinates());
    const matchEdge = this._ocaMap.get(oca);
    return matchEdge
  }

  add (e) {
    this._edges.add(e);
    const oca = new OrientedCoordinateArray(e.getCoordinates());
    this._ocaMap.put(oca, e);
  }

  getClass () {
    return EdgeList
  }

  get interfaces_ () {
    return []
  }
}
EdgeList.constructor_ = function () {
  this._edges = new ArrayList();
  this._ocaMap = new TreeMap();
};

class SegmentIntersector {
  constructor () {
    SegmentIntersector.constructor_.apply(this, arguments);
  }

  processIntersections (e0, segIndex0, e1, segIndex1) {}
  isDone () {}
  getClass () {
    return SegmentIntersector
  }

  get interfaces_ () {
    return []
  }
}
SegmentIntersector.constructor_ = function () {};

class IntersectionAdder {
  constructor () {
    IntersectionAdder.constructor_.apply(this, arguments);
  }

  static isAdjacentSegments (i1, i2) {
    return Math.abs(i1 - i2) === 1
  }

  isTrivialIntersection (e0, segIndex0, e1, segIndex1) {
    if (e0 === e1) {
      if (this._li.getIntersectionNum() === 1) {
        if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) return true
        if (e0.isClosed()) {
          const maxSegIndex = e0.size() - 1;
          if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {
            return true
          }
        }
      }
    }
    return false
  }

  getProperIntersectionPoint () {
    return this._properIntersectionPoint
  }

  hasProperInteriorIntersection () {
    return this._hasProperInterior
  }

  getLineIntersector () {
    return this._li
  }

  hasProperIntersection () {
    return this._hasProper
  }

  processIntersections (e0, segIndex0, e1, segIndex1) {
    if (e0 === e1 && segIndex0 === segIndex1) return null
    this.numTests++;
    const p00 = e0.getCoordinates()[segIndex0];
    const p01 = e0.getCoordinates()[segIndex0 + 1];
    const p10 = e1.getCoordinates()[segIndex1];
    const p11 = e1.getCoordinates()[segIndex1 + 1];
    this._li.computeIntersection(p00, p01, p10, p11);
    if (this._li.hasIntersection()) {
      this.numIntersections++;
      if (this._li.isInteriorIntersection()) {
        this.numInteriorIntersections++;
        this._hasInterior = true;
      }
      if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
        this._hasIntersection = true;
        e0.addIntersections(this._li, segIndex0, 0);
        e1.addIntersections(this._li, segIndex1, 1);
        if (this._li.isProper()) {
          this.numProperIntersections++;
          this._hasProper = true;
          this._hasProperInterior = true;
        }
      }
    }
  }

  hasIntersection () {
    return this._hasIntersection
  }

  isDone () {
    return false
  }

  hasInteriorIntersection () {
    return this._hasInterior
  }

  getClass () {
    return IntersectionAdder
  }

  get interfaces_ () {
    return [SegmentIntersector]
  }
}
IntersectionAdder.constructor_ = function () {
  this._hasIntersection = false;
  this._hasProper = false;
  this._hasProperInterior = false;
  this._hasInterior = false;
  this._properIntersectionPoint = null;
  this._li = null;
  this._isSelfIntersection = null;
  this.numIntersections = 0;
  this.numInteriorIntersections = 0;
  this.numProperIntersections = 0;
  this.numTests = 0;
  const li = arguments[0];
  this._li = li;
};

class EdgeIntersection {
  constructor () {
    EdgeIntersection.constructor_.apply(this, arguments);
  }

  getSegmentIndex () {
    return this.segmentIndex
  }

  getCoordinate () {
    return this.coord
  }

  print (out) {
    out.print(this.coord);
    out.print(' seg # = ' + this.segmentIndex);
    out.println(' dist = ' + this.dist);
  }

  compareTo (obj) {
    const other = obj;
    return this.compare(other.segmentIndex, other.dist)
  }

  isEndPoint (maxSegmentIndex) {
    if (this.segmentIndex === 0 && this.dist === 0.0) return true
    if (this.segmentIndex === maxSegmentIndex) return true
    return false
  }

  toString () {
    return this.coord + ' seg # = ' + this.segmentIndex + ' dist = ' + this.dist
  }

  getDistance () {
    return this.dist
  }

  compare (segmentIndex, dist) {
    if (this.segmentIndex < segmentIndex) return -1
    if (this.segmentIndex > segmentIndex) return 1
    if (this.dist < dist) return -1
    if (this.dist > dist) return 1
    return 0
  }

  getClass () {
    return EdgeIntersection
  }

  get interfaces_ () {
    return [Comparable]
  }
}
EdgeIntersection.constructor_ = function () {
  this.coord = null;
  this.segmentIndex = null;
  this.dist = null;
  const coord = arguments[0]; const segmentIndex = arguments[1]; const dist = arguments[2];
  this.coord = new Coordinate(coord);
  this.segmentIndex = segmentIndex;
  this.dist = dist;
};

class EdgeIntersectionList {
  constructor () {
    EdgeIntersectionList.constructor_.apply(this, arguments);
  }

  print (out) {
    out.println('Intersections:');
    for (let it = this.iterator(); it.hasNext();) {
      const ei = it.next();
      ei.print(out);
    }
  }

  iterator () {
    return this._nodeMap.values().iterator()
  }

  addSplitEdges (edgeList) {
    this.addEndpoints();
    const it = this.iterator();
    let eiPrev = it.next();
    while (it.hasNext()) {
      const ei = it.next();
      const newEdge = this.createSplitEdge(eiPrev, ei);
      edgeList.add(newEdge);
      eiPrev = ei;
    }
  }

  addEndpoints () {
    const maxSegIndex = this.edge.pts.length - 1;
    this.add(this.edge.pts[0], 0, 0.0);
    this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);
  }

  createSplitEdge (ei0, ei1) {
    let npts = ei1.segmentIndex - ei0.segmentIndex + 2;
    const lastSegStartPt = this.edge.pts[ei1.segmentIndex];
    const useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);
    if (!useIntPt1) {
      npts--;
    }
    const pts = new Array(npts).fill(null);
    let ipt = 0;
    pts[ipt++] = new Coordinate(ei0.coord);
    for (let i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
      pts[ipt++] = this.edge.pts[i];
    }
    if (useIntPt1) pts[ipt] = ei1.coord;
    return new Edge(pts, new Label$1(this.edge._label))
  }

  add (intPt, segmentIndex, dist) {
    const eiNew = new EdgeIntersection(intPt, segmentIndex, dist);
    const ei = this._nodeMap.get(eiNew);
    if (ei !== null) {
      return ei
    }
    this._nodeMap.put(eiNew, eiNew);
    return eiNew
  }

  isIntersection (pt) {
    for (let it = this.iterator(); it.hasNext();) {
      const ei = it.next();
      if (ei.coord.equals(pt)) return true
    }
    return false
  }

  getClass () {
    return EdgeIntersectionList
  }

  get interfaces_ () {
    return []
  }
}
EdgeIntersectionList.constructor_ = function () {
  this._nodeMap = new TreeMap();
  this.edge = null;
  const edge = arguments[0];
  this.edge = edge;
};

class IntersectionMatrix {
  constructor () {
    IntersectionMatrix.constructor_.apply(this, arguments);
  }

  static matches () {
    if (Number.isInteger(arguments[0]) && typeof arguments[1] === 'string') {
      const actualDimensionValue = arguments[0]; const requiredDimensionSymbol = arguments[1];
      if (requiredDimensionSymbol === Dimension.SYM_DONTCARE) {
        return true
      }
      if (requiredDimensionSymbol === Dimension.SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE)) {
        return true
      }
      if (requiredDimensionSymbol === Dimension.SYM_FALSE && actualDimensionValue === Dimension.FALSE) {
        return true
      }
      if (requiredDimensionSymbol === Dimension.SYM_P && actualDimensionValue === Dimension.P) {
        return true
      }
      if (requiredDimensionSymbol === Dimension.SYM_L && actualDimensionValue === Dimension.L) {
        return true
      }
      if (requiredDimensionSymbol === Dimension.SYM_A && actualDimensionValue === Dimension.A) {
        return true
      }
      return false
    } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'string') {
      const actualDimensionSymbols = arguments[0]; const requiredDimensionSymbols = arguments[1];
      const m = new IntersectionMatrix(actualDimensionSymbols);
      return m.matches(requiredDimensionSymbols)
    }
  }

  static isTrue (actualDimensionValue) {
    if (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE) {
      return true
    }
    return false
  }

  isIntersects () {
    return !this.isDisjoint()
  }

  isCovers () {
    const hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);
    return hasPointInCommon && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE
  }

  isCoveredBy () {
    const hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);
    return hasPointInCommon && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE
  }

  set () {
    if (arguments.length === 1) {
      const dimensionSymbols = arguments[0];
      for (let i = 0; i < dimensionSymbols.length; i++) {
        const row = Math.trunc(i / 3);
        const col = i % 3;
        this._matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols.charAt(i));
      }
    } else if (arguments.length === 3) {
      const row = arguments[0]; const column = arguments[1]; const dimensionValue = arguments[2];
      this._matrix[row][column] = dimensionValue;
    }
  }

  isContains () {
    return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE
  }

  setAtLeast () {
    if (arguments.length === 1) {
      const minimumDimensionSymbols = arguments[0];
      for (let i = 0; i < minimumDimensionSymbols.length; i++) {
        const row = Math.trunc(i / 3);
        const col = i % 3;
        this.setAtLeast(row, col, Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)));
      }
    } else if (arguments.length === 3) {
      const row = arguments[0]; const column = arguments[1]; const minimumDimensionValue = arguments[2];
      if (this._matrix[row][column] < minimumDimensionValue) {
        this._matrix[row][column] = minimumDimensionValue;
      }
    }
  }

  setAtLeastIfValid (row, column, minimumDimensionValue) {
    if (row >= 0 && column >= 0) {
      this.setAtLeast(row, column, minimumDimensionValue);
    }
  }

  isWithin () {
    return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE
  }

  isTouches (dimensionOfGeometryA, dimensionOfGeometryB) {
    if (dimensionOfGeometryA > dimensionOfGeometryB) {
      return this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA)
    }
    if (dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L) {
      return this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && (IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]))
    }
    return false
  }

  isOverlaps (dimensionOfGeometryA, dimensionOfGeometryB) {
    if (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A) {
      return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR])
    }
    if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {
      return this._matrix[Location.INTERIOR][Location.INTERIOR] === 1 && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR])
    }
    return false
  }

  isEquals (dimensionOfGeometryA, dimensionOfGeometryB) {
    if (dimensionOfGeometryA !== dimensionOfGeometryB) {
      return false
    }
    return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE
  }

  toString () {
    const builder = new StringBuilder('123456789');
    for (let ai = 0; ai < 3; ai++) {
      for (let bi = 0; bi < 3; bi++) {
        builder.setCharAt(3 * ai + bi, Dimension.toDimensionSymbol(this._matrix[ai][bi]));
      }
    }
    return builder.toString()
  }

  setAll (dimensionValue) {
    for (let ai = 0; ai < 3; ai++) {
      for (let bi = 0; bi < 3; bi++) {
        this._matrix[ai][bi] = dimensionValue;
      }
    }
  }

  get (row, column) {
    return this._matrix[row][column]
  }

  transpose () {
    let temp = this._matrix[1][0];
    this._matrix[1][0] = this._matrix[0][1];
    this._matrix[0][1] = temp;
    temp = this._matrix[2][0];
    this._matrix[2][0] = this._matrix[0][2];
    this._matrix[0][2] = temp;
    temp = this._matrix[2][1];
    this._matrix[2][1] = this._matrix[1][2];
    this._matrix[1][2] = temp;
    return this
  }

  matches (requiredDimensionSymbols) {
    if (requiredDimensionSymbols.length !== 9) {
      throw new IllegalArgumentException('Should be length 9: ' + requiredDimensionSymbols)
    }
    for (let ai = 0; ai < 3; ai++) {
      for (let bi = 0; bi < 3; bi++) {
        if (!IntersectionMatrix.matches(this._matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) {
          return false
        }
      }
    }
    return true
  }

  add (im) {
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        this.setAtLeast(i, j, im.get(i, j));
      }
    }
  }

  isDisjoint () {
    return this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.INTERIOR][Location.BOUNDARY] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.BOUNDARY] === Dimension.FALSE
  }

  isCrosses (dimensionOfGeometryA, dimensionOfGeometryB) {
    if (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A) {
      return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR])
    }
    if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.L) {
      return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR])
    }
    if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {
      return this._matrix[Location.INTERIOR][Location.INTERIOR] === 0
    }
    return false
  }

  getClass () {
    return IntersectionMatrix
  }

  get interfaces_ () {
    return [Clonable]
  }
}
IntersectionMatrix.constructor_ = function () {
  this._matrix = null;
  if (arguments.length === 0) {
    this._matrix = Array(3).fill().map(() => Array(3));
    this.setAll(Dimension.FALSE);
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'string') {
      const elements = arguments[0];
      IntersectionMatrix.constructor_.call(this);
      this.set(elements);
    } else if (arguments[0] instanceof IntersectionMatrix) {
      const other = arguments[0];
      IntersectionMatrix.constructor_.call(this);
      this._matrix[Location.INTERIOR][Location.INTERIOR] = other._matrix[Location.INTERIOR][Location.INTERIOR];
      this._matrix[Location.INTERIOR][Location.BOUNDARY] = other._matrix[Location.INTERIOR][Location.BOUNDARY];
      this._matrix[Location.INTERIOR][Location.EXTERIOR] = other._matrix[Location.INTERIOR][Location.EXTERIOR];
      this._matrix[Location.BOUNDARY][Location.INTERIOR] = other._matrix[Location.BOUNDARY][Location.INTERIOR];
      this._matrix[Location.BOUNDARY][Location.BOUNDARY] = other._matrix[Location.BOUNDARY][Location.BOUNDARY];
      this._matrix[Location.BOUNDARY][Location.EXTERIOR] = other._matrix[Location.BOUNDARY][Location.EXTERIOR];
      this._matrix[Location.EXTERIOR][Location.INTERIOR] = other._matrix[Location.EXTERIOR][Location.INTERIOR];
      this._matrix[Location.EXTERIOR][Location.BOUNDARY] = other._matrix[Location.EXTERIOR][Location.BOUNDARY];
      this._matrix[Location.EXTERIOR][Location.EXTERIOR] = other._matrix[Location.EXTERIOR][Location.EXTERIOR];
    }
  }
};

class MonotoneChainIndexer {
  constructor () {
    MonotoneChainIndexer.constructor_.apply(this, arguments);
  }

  static toIntArray (list) {
    const array = new Array(list.size()).fill(null);
    for (let i = 0; i < array.length; i++) {
      array[i] = list.get(i).intValue();
    }
    return array
  }

  getChainStartIndices (pts) {
    let start = 0;
    const startIndexList = new ArrayList();
    startIndexList.add(new Integer(start));
    do {
      const last = this.findChainEnd(pts, start);
      startIndexList.add(new Integer(last));
      start = last;
    } while (start < pts.length - 1)
    const startIndex = MonotoneChainIndexer.toIntArray(startIndexList);
    return startIndex
  }

  findChainEnd (pts, start) {
    const chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);
    let last = start + 1;
    while (last < pts.length) {
      const quad = Quadrant.quadrant(pts[last - 1], pts[last]);
      if (quad !== chainQuad) break
      last++;
    }
    return last - 1
  }

  getClass () {
    return MonotoneChainIndexer
  }

  get interfaces_ () {
    return []
  }
}
MonotoneChainIndexer.constructor_ = function () {};

class MonotoneChainEdge {
  constructor () {
    MonotoneChainEdge.constructor_.apply(this, arguments);
  }

  getCoordinates () {
    return this.pts
  }

  getMaxX (chainIndex) {
    const x1 = this.pts[this.startIndex[chainIndex]].x;
    const x2 = this.pts[this.startIndex[chainIndex + 1]].x;
    return x1 > x2 ? x1 : x2
  }

  getMinX (chainIndex) {
    const x1 = this.pts[this.startIndex[chainIndex]].x;
    const x2 = this.pts[this.startIndex[chainIndex + 1]].x;
    return x1 < x2 ? x1 : x2
  }

  computeIntersectsForChain () {
    if (arguments.length === 4) {
      const chainIndex0 = arguments[0]; const mce = arguments[1]; const chainIndex1 = arguments[2]; const si = arguments[3];
      this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);
    } else if (arguments.length === 6) {
      const start0 = arguments[0]; const end0 = arguments[1]; const mce = arguments[2]; const start1 = arguments[3]; const end1 = arguments[4]; const ei = arguments[5];
      if (end0 - start0 === 1 && end1 - start1 === 1) {
        ei.addIntersections(this.e, start0, mce.e, start1);
        return null
      }
      if (!this.overlaps(start0, end0, mce, start1, end1)) return null
      const mid0 = Math.trunc((start0 + end0) / 2);
      const mid1 = Math.trunc((start1 + end1) / 2);
      if (start0 < mid0) {
        if (start1 < mid1) this.computeIntersectsForChain(start0, mid0, mce, start1, mid1, ei);
        if (mid1 < end1) this.computeIntersectsForChain(start0, mid0, mce, mid1, end1, ei);
      }
      if (mid0 < end0) {
        if (start1 < mid1) this.computeIntersectsForChain(mid0, end0, mce, start1, mid1, ei);
        if (mid1 < end1) this.computeIntersectsForChain(mid0, end0, mce, mid1, end1, ei);
      }
    }
  }

  overlaps (start0, end0, mce, start1, end1) {
    return Envelope.intersects(this.pts[start0], this.pts[end0], mce.pts[start1], mce.pts[end1])
  }

  getStartIndexes () {
    return this.startIndex
  }

  computeIntersects (mce, si) {
    for (let i = 0; i < this.startIndex.length - 1; i++) {
      for (let j = 0; j < mce.startIndex.length - 1; j++) {
        this.computeIntersectsForChain(i, mce, j, si);
      }
    }
  }

  getClass () {
    return MonotoneChainEdge
  }

  get interfaces_ () {
    return []
  }
}
MonotoneChainEdge.constructor_ = function () {
  this.e = null;
  this.pts = null;
  this.startIndex = null;
  const e = arguments[0];
  this.e = e;
  this.pts = e.getCoordinates();
  const mcb = new MonotoneChainIndexer();
  this.startIndex = mcb.getChainStartIndices(this.pts);
};

class Depth {
  constructor () {
    Depth.constructor_.apply(this, arguments);
  }

  static depthAtLocation (location) {
    if (location === Location.EXTERIOR) return 0
    if (location === Location.INTERIOR) return 1
    return Depth.NULL_VALUE
  }

  getDepth (geomIndex, posIndex) {
    return this._depth[geomIndex][posIndex]
  }

  setDepth (geomIndex, posIndex, depthValue) {
    this._depth[geomIndex][posIndex] = depthValue;
  }

  isNull () {
    if (arguments.length === 0) {
      for (let i = 0; i < 2; i++) {
        for (let j = 0; j < 3; j++) {
          if (this._depth[i][j] !== Depth.NULL_VALUE) return false
        }
      }
      return true
    } else if (arguments.length === 1) {
      const geomIndex = arguments[0];
      return this._depth[geomIndex][1] === Depth.NULL_VALUE
    } else if (arguments.length === 2) {
      const geomIndex = arguments[0]; const posIndex = arguments[1];
      return this._depth[geomIndex][posIndex] === Depth.NULL_VALUE
    }
  }

  normalize () {
    for (let i = 0; i < 2; i++) {
      if (!this.isNull(i)) {
        let minDepth = this._depth[i][1];
        if (this._depth[i][2] < minDepth) minDepth = this._depth[i][2];
        if (minDepth < 0) minDepth = 0;
        for (let j = 1; j < 3; j++) {
          let newValue = 0;
          if (this._depth[i][j] > minDepth) newValue = 1;
          this._depth[i][j] = newValue;
        }
      }
    }
  }

  getDelta (geomIndex) {
    return this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT]
  }

  getLocation (geomIndex, posIndex) {
    if (this._depth[geomIndex][posIndex] <= 0) return Location.EXTERIOR
    return Location.INTERIOR
  }

  toString () {
    return 'A: ' + this._depth[0][1] + ',' + this._depth[0][2] + ' B: ' + this._depth[1][1] + ',' + this._depth[1][2]
  }

  add () {
    if (arguments.length === 1) {
      const lbl = arguments[0];
      for (let i = 0; i < 2; i++) {
        for (let j = 1; j < 3; j++) {
          const loc = lbl.getLocation(i, j);
          if (loc === Location.EXTERIOR || loc === Location.INTERIOR) {
            if (this.isNull(i, j)) {
              this._depth[i][j] = Depth.depthAtLocation(loc);
            } else this._depth[i][j] += Depth.depthAtLocation(loc);
          }
        }
      }
    } else if (arguments.length === 3) {
      const geomIndex = arguments[0]; const posIndex = arguments[1]; const location = arguments[2];
      if (location === Location.INTERIOR) this._depth[geomIndex][posIndex]++;
    }
  }

  getClass () {
    return Depth
  }

  get interfaces_ () {
    return []
  }
}
Depth.constructor_ = function () {
  this._depth = Array(2).fill().map(() => Array(3));
  for (let i = 0; i < 2; i++) {
    for (let j = 0; j < 3; j++) {
      this._depth[i][j] = Depth.NULL_VALUE;
    }
  }
};
Depth.NULL_VALUE = -1;

class Edge extends GraphComponent {
  constructor () {
    super();
    Edge.constructor_.apply(this, arguments);
  }

  static updateIM () {
    if (arguments.length === 2 && (arguments[1] instanceof IntersectionMatrix && arguments[0] instanceof Label$1)) {
      const label = arguments[0]; const im = arguments[1];
      im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);
      if (label.isArea()) {
        im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);
        im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);
      }
    } else return super.updateIM.apply(this, arguments)
  }

  getDepth () {
    return this._depth
  }

  getCollapsedEdge () {
    const newPts = new Array(2).fill(null);
    newPts[0] = this.pts[0];
    newPts[1] = this.pts[1];
    const newe = new Edge(newPts, Label$1.toLineLabel(this._label));
    return newe
  }

  isIsolated () {
    return this._isIsolated
  }

  getCoordinates () {
    return this.pts
  }

  setIsolated (isIsolated) {
    this._isIsolated = isIsolated;
  }

  setName (name) {
    this._name = name;
  }

  equals (o) {
    if (!(o instanceof Edge)) return false
    const e = o;
    if (this.pts.length !== e.pts.length) return false
    let isEqualForward = true;
    let isEqualReverse = true;
    let iRev = this.pts.length;
    for (let i = 0; i < this.pts.length; i++) {
      if (!this.pts[i].equals2D(e.pts[i])) {
        isEqualForward = false;
      }
      if (!this.pts[i].equals2D(e.pts[--iRev])) {
        isEqualReverse = false;
      }
      if (!isEqualForward && !isEqualReverse) return false
    }
    return true
  }

  getCoordinate () {
    if (arguments.length === 0) {
      if (this.pts.length > 0) return this.pts[0]
      return null
    } else if (arguments.length === 1) {
      const i = arguments[0];
      return this.pts[i]
    }
  }

  print (out) {
    out.print('edge ' + this._name + ': ');
    out.print('LINESTRING (');
    for (let i = 0; i < this.pts.length; i++) {
      if (i > 0) out.print(',');
      out.print(this.pts[i].x + ' ' + this.pts[i].y);
    }
    out.print(')  ' + this._label + ' ' + this._depthDelta);
  }

  computeIM (im) {
    Edge.updateIM(this._label, im);
  }

  isCollapsed () {
    if (!this._label.isArea()) return false
    if (this.pts.length !== 3) return false
    if (this.pts[0].equals(this.pts[2])) return true
    return false
  }

  isClosed () {
    return this.pts[0].equals(this.pts[this.pts.length - 1])
  }

  getMaximumSegmentIndex () {
    return this.pts.length - 1
  }

  getDepthDelta () {
    return this._depthDelta
  }

  getNumPoints () {
    return this.pts.length
  }

  printReverse (out) {
    out.print('edge ' + this._name + ': ');
    for (let i = this.pts.length - 1; i >= 0; i--) {
      out.print(this.pts[i] + ' ');
    }
    out.println('');
  }

  getMonotoneChainEdge () {
    if (this._mce === null) this._mce = new MonotoneChainEdge(this);
    return this._mce
  }

  getEnvelope () {
    if (this._env === null) {
      this._env = new Envelope();
      for (let i = 0; i < this.pts.length; i++) {
        this._env.expandToInclude(this.pts[i]);
      }
    }
    return this._env
  }

  addIntersection (li, segmentIndex, geomIndex, intIndex) {
    const intPt = new Coordinate(li.getIntersection(intIndex));
    let normalizedSegmentIndex = segmentIndex;
    let dist = li.getEdgeDistance(geomIndex, intIndex);
    const nextSegIndex = normalizedSegmentIndex + 1;
    if (nextSegIndex < this.pts.length) {
      const nextPt = this.pts[nextSegIndex];
      if (intPt.equals2D(nextPt)) {
        normalizedSegmentIndex = nextSegIndex;
        dist = 0.0;
      }
    }
    this.eiList.add(intPt, normalizedSegmentIndex, dist);
  }

  toString () {
    const builder = new StringBuilder();
    builder.append('edge ' + this._name + ': ');
    builder.append('LINESTRING (');
    for (let i = 0; i < this.pts.length; i++) {
      if (i > 0) builder.append(',');
      builder.append(this.pts[i].x + ' ' + this.pts[i].y);
    }
    builder.append(')  ' + this._label + ' ' + this._depthDelta);
    return builder.toString()
  }

  isPointwiseEqual (e) {
    if (this.pts.length !== e.pts.length) return false
    for (let i = 0; i < this.pts.length; i++) {
      if (!this.pts[i].equals2D(e.pts[i])) {
        return false
      }
    }
    return true
  }

  setDepthDelta (depthDelta) {
    this._depthDelta = depthDelta;
  }

  getEdgeIntersectionList () {
    return this.eiList
  }

  addIntersections (li, segmentIndex, geomIndex) {
    for (let i = 0; i < li.getIntersectionNum(); i++) {
      this.addIntersection(li, segmentIndex, geomIndex, i);
    }
  }

  getClass () {
    return Edge
  }

  get interfaces_ () {
    return []
  }
}
Edge.constructor_ = function () {
  this.pts = null;
  this._env = null;
  this.eiList = new EdgeIntersectionList(this);
  this._name = null;
  this._mce = null;
  this._isIsolated = true;
  this._depth = new Depth();
  this._depthDelta = 0;
  if (arguments.length === 1) {
    const pts = arguments[0];
    Edge.constructor_.call(this, pts, null);
  } else if (arguments.length === 2) {
    const pts = arguments[0]; const label = arguments[1];
    this.pts = pts;
    this._label = label;
  }
};

class BufferBuilder {
  constructor () {
    BufferBuilder.constructor_.apply(this, arguments);
  }

  static depthDelta (label) {
    const lLoc = label.getLocation(0, Position.LEFT);
    const rLoc = label.getLocation(0, Position.RIGHT);
    if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) return 1; else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) return -1
    return 0
  }

  static convertSegStrings (it) {
    const fact = new GeometryFactory();
    const lines = new ArrayList();
    while (it.hasNext()) {
      const ss = it.next();
      const line = fact.createLineString(ss.getCoordinates());
      lines.add(line);
    }
    return fact.buildGeometry(lines)
  }

  setWorkingPrecisionModel (pm) {
    this._workingPrecisionModel = pm;
  }

  insertUniqueEdge (e) {
    const existingEdge = this._edgeList.findEqualEdge(e);
    if (existingEdge !== null) {
      const existingLabel = existingEdge.getLabel();
      let labelToMerge = e.getLabel();
      if (!existingEdge.isPointwiseEqual(e)) {
        labelToMerge = new Label$1(e.getLabel());
        labelToMerge.flip();
      }
      existingLabel.merge(labelToMerge);
      const mergeDelta = BufferBuilder.depthDelta(labelToMerge);
      const existingDelta = existingEdge.getDepthDelta();
      const newDelta = existingDelta + mergeDelta;
      existingEdge.setDepthDelta(newDelta);
    } else {
      this._edgeList.add(e);
      e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));
    }
  }

  buildSubgraphs (subgraphList, polyBuilder) {
    const processedGraphs = new ArrayList();
    for (let i = subgraphList.iterator(); i.hasNext();) {
      const subgraph = i.next();
      const p = subgraph.getRightmostCoordinate();
      const locater = new SubgraphDepthLocater(processedGraphs);
      const outsideDepth = locater.getDepth(p);
      subgraph.computeDepth(outsideDepth);
      subgraph.findResultEdges();
      processedGraphs.add(subgraph);
      polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());
    }
  }

  createSubgraphs (graph) {
    const subgraphList = new ArrayList();
    for (let i = graph.getNodes().iterator(); i.hasNext();) {
      const node = i.next();
      if (!node.isVisited()) {
        const subgraph = new BufferSubgraph();
        subgraph.create(node);
        subgraphList.add(subgraph);
      }
    }
    Collections.sort(subgraphList, Collections.reverseOrder());
    return subgraphList
  }

  createEmptyResultGeometry () {
    const emptyGeom = this._geomFact.createPolygon();
    return emptyGeom
  }

  getNoder (precisionModel) {
    if (this._workingNoder !== null) return this._workingNoder
    const noder = new MCIndexNoder();
    const li = new RobustLineIntersector();
    li.setPrecisionModel(precisionModel);
    noder.setSegmentIntersector(new IntersectionAdder(li));
    return noder
  }

  buffer (g, distance) {
    let precisionModel = this._workingPrecisionModel;
    if (precisionModel === null) precisionModel = g.getPrecisionModel();
    this._geomFact = g.getFactory();
    const curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);
    const curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);
    const bufferSegStrList = curveSetBuilder.getCurves();
    if (bufferSegStrList.size() <= 0) {
      return this.createEmptyResultGeometry()
    }
    this.computeNodedEdges(bufferSegStrList, precisionModel);
    this._graph = new PlanarGraph(new OverlayNodeFactory());
    this._graph.addEdges(this._edgeList.getEdges());
    const subgraphList = this.createSubgraphs(this._graph);
    const polyBuilder = new PolygonBuilder(this._geomFact);
    this.buildSubgraphs(subgraphList, polyBuilder);
    const resultPolyList = polyBuilder.getPolygons();
    if (resultPolyList.size() <= 0) {
      return this.createEmptyResultGeometry()
    }
    const resultGeom = this._geomFact.buildGeometry(resultPolyList);
    return resultGeom
  }

  computeNodedEdges (bufferSegStrList, precisionModel) {
    const noder = this.getNoder(precisionModel);
    noder.computeNodes(bufferSegStrList);
    const nodedSegStrings = noder.getNodedSubstrings();
    for (let i = nodedSegStrings.iterator(); i.hasNext();) {
      const segStr = i.next();
      const pts = segStr.getCoordinates();
      if (pts.length === 2 && pts[0].equals2D(pts[1])) continue
      const oldLabel = segStr.getData();
      const edge = new Edge(segStr.getCoordinates(), new Label$1(oldLabel));
      this.insertUniqueEdge(edge);
    }
  }

  setNoder (noder) {
    this._workingNoder = noder;
  }

  getClass () {
    return BufferBuilder
  }

  get interfaces_ () {
    return []
  }
}
BufferBuilder.constructor_ = function () {
  this._bufParams = null;
  this._workingPrecisionModel = null;
  this._workingNoder = null;
  this._geomFact = null;
  this._graph = null;
  this._edgeList = new EdgeList();
  const bufParams = arguments[0];
  this._bufParams = bufParams;
};

class ScaledNoder {
  constructor () {
    ScaledNoder.constructor_.apply(this, arguments);
  }

  rescale () {
    if (hasInterface(arguments[0], Collection)) {
      const segStrings = arguments[0];
      for (let i = segStrings.iterator(); i.hasNext();) {
        const ss = i.next();
        this.rescale(ss.getCoordinates());
      }
    } else if (arguments[0] instanceof Array) {
      const pts = arguments[0];
      if (pts.length === 2) {
        new Coordinate(pts[0]);
        new Coordinate(pts[1]);
      }
      for (let i = 0; i < pts.length; i++) {
        pts[i].x = pts[i].x / this._scaleFactor + this._offsetX;
        pts[i].y = pts[i].y / this._scaleFactor + this._offsetY;
      }
      if (pts.length === 2 && pts[0].equals2D(pts[1])) {
        System.out.println(pts);
      }
    }
  }

  scale () {
    if (hasInterface(arguments[0], Collection)) {
      const segStrings = arguments[0];
      const nodedSegmentStrings = new ArrayList(segStrings.size());
      for (let i = segStrings.iterator(); i.hasNext();) {
        const ss = i.next();
        nodedSegmentStrings.add(new NodedSegmentString(this.scale(ss.getCoordinates()), ss.getData()));
      }
      return nodedSegmentStrings
    } else if (arguments[0] instanceof Array) {
      const pts = arguments[0];
      const roundPts = new Array(pts.length).fill(null);
      for (let i = 0; i < pts.length; i++) {
        roundPts[i] = new Coordinate(Math.round((pts[i].x - this._offsetX) * this._scaleFactor), Math.round((pts[i].y - this._offsetY) * this._scaleFactor), pts[i].z);
      }
      const roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);
      return roundPtsNoDup
    }
  }

  isIntegerPrecision () {
    return this._scaleFactor === 1.0
  }

  getNodedSubstrings () {
    const splitSS = this._noder.getNodedSubstrings();
    if (this._isScaled) this.rescale(splitSS);
    return splitSS
  }

  computeNodes (inputSegStrings) {
    let intSegStrings = inputSegStrings;
    if (this._isScaled) intSegStrings = this.scale(inputSegStrings);
    this._noder.computeNodes(intSegStrings);
  }

  getClass () {
    return ScaledNoder
  }

  get interfaces_ () {
    return [Noder]
  }
}
ScaledNoder.constructor_ = function () {
  this._noder = null;
  this._scaleFactor = null;
  this._offsetX = null;
  this._offsetY = null;
  this._isScaled = false;
  if (arguments.length === 2) {
    const noder = arguments[0]; const scaleFactor = arguments[1];
    ScaledNoder.constructor_.call(this, noder, scaleFactor, 0, 0);
  } else if (arguments.length === 4) {
    const noder = arguments[0]; const scaleFactor = arguments[1];    this._noder = noder;
    this._scaleFactor = scaleFactor;
    this._isScaled = !this.isIntegerPrecision();
  }
};

class NodingValidator {
  constructor () {
    NodingValidator.constructor_.apply(this, arguments);
  }

  checkEndPtVertexIntersections () {
    if (arguments.length === 0) {
      for (let i = this._segStrings.iterator(); i.hasNext();) {
        const ss = i.next();
        const pts = ss.getCoordinates();
        this.checkEndPtVertexIntersections(pts[0], this._segStrings);
        this.checkEndPtVertexIntersections(pts[pts.length - 1], this._segStrings);
      }
    } else if (arguments.length === 2) {
      const testPt = arguments[0]; const segStrings = arguments[1];
      for (let i = segStrings.iterator(); i.hasNext();) {
        const ss = i.next();
        const pts = ss.getCoordinates();
        for (let j = 1; j < pts.length - 1; j++) {
          if (pts[j].equals(testPt)) throw new RuntimeException('found endpt/interior pt intersection at index ' + j + ' :pt ' + testPt)
        }
      }
    }
  }

  checkInteriorIntersections () {
    if (arguments.length === 0) {
      for (let i = this._segStrings.iterator(); i.hasNext();) {
        const ss0 = i.next();
        for (let j = this._segStrings.iterator(); j.hasNext();) {
          const ss1 = j.next();
          this.checkInteriorIntersections(ss0, ss1);
        }
      }
    } else if (arguments.length === 2) {
      const ss0 = arguments[0]; const ss1 = arguments[1];
      const pts0 = ss0.getCoordinates();
      const pts1 = ss1.getCoordinates();
      for (let i0 = 0; i0 < pts0.length - 1; i0++) {
        for (let i1 = 0; i1 < pts1.length - 1; i1++) {
          this.checkInteriorIntersections(ss0, i0, ss1, i1);
        }
      }
    } else if (arguments.length === 4) {
      const e0 = arguments[0]; const segIndex0 = arguments[1]; const e1 = arguments[2]; const segIndex1 = arguments[3];
      if (e0 === e1 && segIndex0 === segIndex1) return null
      const p00 = e0.getCoordinates()[segIndex0];
      const p01 = e0.getCoordinates()[segIndex0 + 1];
      const p10 = e1.getCoordinates()[segIndex1];
      const p11 = e1.getCoordinates()[segIndex1 + 1];
      this._li.computeIntersection(p00, p01, p10, p11);
      if (this._li.hasIntersection()) {
        if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {
          throw new RuntimeException('found non-noded intersection at ' + p00 + '-' + p01 + ' and ' + p10 + '-' + p11)
        }
      }
    }
  }

  checkValid () {
    this.checkEndPtVertexIntersections();
    this.checkInteriorIntersections();
    this.checkCollapses();
  }

  checkCollapses () {
    if (arguments.length === 0) {
      for (let i = this._segStrings.iterator(); i.hasNext();) {
        const ss = i.next();
        this.checkCollapses(ss);
      }
    } else if (arguments.length === 1) {
      const ss = arguments[0];
      const pts = ss.getCoordinates();
      for (let i = 0; i < pts.length - 2; i++) {
        this.checkCollapse(pts[i], pts[i + 1], pts[i + 2]);
      }
    }
  }

  hasInteriorIntersection (li, p0, p1) {
    for (let i = 0; i < li.getIntersectionNum(); i++) {
      const intPt = li.getIntersection(i);
      if (!(intPt.equals(p0) || intPt.equals(p1))) return true
    }
    return false
  }

  checkCollapse (p0, p1, p2) {
    if (p0.equals(p2)) throw new RuntimeException('found non-noded collapse at ' + NodingValidator.fact.createLineString([p0, p1, p2]))
  }

  getClass () {
    return NodingValidator
  }

  get interfaces_ () {
    return []
  }
}
NodingValidator.constructor_ = function () {
  this._li = new RobustLineIntersector();
  this._segStrings = null;
  const segStrings = arguments[0];
  this._segStrings = segStrings;
};
NodingValidator.fact = new GeometryFactory();

class HotPixel {
  constructor () {
    HotPixel.constructor_.apply(this, arguments);
  }

  intersectsScaled (p0, p1) {
    const segMinx = Math.min(p0.x, p1.x);
    const segMaxx = Math.max(p0.x, p1.x);
    const segMiny = Math.min(p0.y, p1.y);
    const segMaxy = Math.max(p0.y, p1.y);
    const isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;
    if (isOutsidePixelEnv) return false
    const intersects = this.intersectsToleranceSquare(p0, p1);
    Assert.isTrue(!(isOutsidePixelEnv && intersects), 'Found bad envelope test');
    return intersects
  }

  initCorners (pt) {
    const tolerance = 0.5;
    this._minx = pt.x - tolerance;
    this._maxx = pt.x + tolerance;
    this._miny = pt.y - tolerance;
    this._maxy = pt.y + tolerance;
    this._corner[0] = new Coordinate(this._maxx, this._maxy);
    this._corner[1] = new Coordinate(this._minx, this._maxy);
    this._corner[2] = new Coordinate(this._minx, this._miny);
    this._corner[3] = new Coordinate(this._maxx, this._miny);
  }

  intersects (p0, p1) {
    if (this._scaleFactor === 1.0) return this.intersectsScaled(p0, p1)
    this.copyScaled(p0, this._p0Scaled);
    this.copyScaled(p1, this._p1Scaled);
    return this.intersectsScaled(this._p0Scaled, this._p1Scaled)
  }

  scale (val) {
    return Math.round(val * this._scaleFactor)
  }

  getCoordinate () {
    return this._originalPt
  }

  copyScaled (p, pScaled) {
    pScaled.x = this.scale(p.x);
    pScaled.y = this.scale(p.y);
  }

  getSafeEnvelope () {
    if (this._safeEnv === null) {
      const safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
      this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);
    }
    return this._safeEnv
  }

  intersectsPixelClosure (p0, p1) {
    this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
    if (this._li.hasIntersection()) return true
    this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
    if (this._li.hasIntersection()) return true
    this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
    if (this._li.hasIntersection()) return true
    this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
    if (this._li.hasIntersection()) return true
    return false
  }

  intersectsToleranceSquare (p0, p1) {
    let intersectsLeft = false;
    let intersectsBottom = false;
    this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
    if (this._li.isProper()) return true
    this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
    if (this._li.isProper()) return true
    if (this._li.hasIntersection()) intersectsLeft = true;
    this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
    if (this._li.isProper()) return true
    if (this._li.hasIntersection()) intersectsBottom = true;
    this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
    if (this._li.isProper()) return true
    if (intersectsLeft && intersectsBottom) return true
    if (p0.equals(this._pt)) return true
    if (p1.equals(this._pt)) return true
    return false
  }

  addSnappedNode (segStr, segIndex) {
    const p0 = segStr.getCoordinate(segIndex);
    const p1 = segStr.getCoordinate(segIndex + 1);
    if (this.intersects(p0, p1)) {
      segStr.addIntersection(this.getCoordinate(), segIndex);
      return true
    }
    return false
  }

  getClass () {
    return HotPixel
  }

  get interfaces_ () {
    return []
  }
}
HotPixel.constructor_ = function () {
  this._li = null;
  this._pt = null;
  this._originalPt = null;
  this._ptScaled = null;
  this._p0Scaled = null;
  this._p1Scaled = null;
  this._scaleFactor = null;
  this._minx = null;
  this._maxx = null;
  this._miny = null;
  this._maxy = null;
  this._corner = new Array(4).fill(null);
  this._safeEnv = null;
  const pt = arguments[0]; const scaleFactor = arguments[1]; const li = arguments[2];
  this._originalPt = pt;
  this._pt = pt;
  this._scaleFactor = scaleFactor;
  this._li = li;
  if (scaleFactor <= 0) throw new IllegalArgumentException('Scale factor must be non-zero')
  if (scaleFactor !== 1.0) {
    this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));
    this._p0Scaled = new Coordinate();
    this._p1Scaled = new Coordinate();
  }
  this.initCorners(this._pt);
};
HotPixel.SAFE_ENV_EXPANSION_FACTOR = 0.75;

class MonotoneChainSelectAction {
  constructor () {
    MonotoneChainSelectAction.constructor_.apply(this, arguments);
  }

  select () {
    if (arguments.length === 1) ; else if (arguments.length === 2) {
      const mc = arguments[0]; const startIndex = arguments[1];
      mc.getLineSegment(startIndex, this.selectedSegment);
      this.select(this.selectedSegment);
    }
  }

  getClass () {
    return MonotoneChainSelectAction
  }

  get interfaces_ () {
    return []
  }
}
MonotoneChainSelectAction.constructor_ = function () {
  this.selectedSegment = new LineSegment();
};

class MCIndexPointSnapper {
  constructor () {
    MCIndexPointSnapper.constructor_.apply(this, arguments);
  }

  snap () {
    if (arguments.length === 1) {
      const hotPixel = arguments[0];
      return this.snap(hotPixel, null, -1)
    } else if (arguments.length === 3) {
      const hotPixel = arguments[0]; const parentEdge = arguments[1]; const hotPixelVertexIndex = arguments[2];
      const pixelEnv = hotPixel.getSafeEnvelope();
      const hotPixelSnapAction = new HotPixelSnapAction(hotPixel, parentEdge, hotPixelVertexIndex);
      this._index.query(pixelEnv, new (class {
        get interfaces_ () {
          return [ItemVisitor]
        }

        visitItem (item) {
          const testChain = item;
          testChain.select(pixelEnv, hotPixelSnapAction);
        }
      })());
      return hotPixelSnapAction.isNodeAdded()
    }
  }

  getClass () {
    return MCIndexPointSnapper
  }

  get interfaces_ () {
    return []
  }
}
class HotPixelSnapAction extends MonotoneChainSelectAction {
  constructor () {
    super();
    HotPixelSnapAction.constructor_.apply(this, arguments);
  }

  isNodeAdded () {
    return this._isNodeAdded
  }

  select () {
    if (arguments.length === 2 && (Number.isInteger(arguments[1]) && arguments[0] instanceof MonotoneChain)) {
      const mc = arguments[0]; const startIndex = arguments[1];
      const ss = mc.getContext();
      if (this._parentEdge !== null) {
        if (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) return null
      }
      this._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);
    } else return super.select.apply(this, arguments)
  }

  getClass () {
    return HotPixelSnapAction
  }

  get interfaces_ () {
    return []
  }
}
HotPixelSnapAction.constructor_ = function () {
  this._hotPixel = null;
  this._parentEdge = null;
  this._hotPixelVertexIndex = null;
  this._isNodeAdded = false;
  const hotPixel = arguments[0]; const parentEdge = arguments[1]; const hotPixelVertexIndex = arguments[2];
  this._hotPixel = hotPixel;
  this._parentEdge = parentEdge;
  this._hotPixelVertexIndex = hotPixelVertexIndex;
};
MCIndexPointSnapper.HotPixelSnapAction = HotPixelSnapAction;
MCIndexPointSnapper.constructor_ = function () {
  this._index = null;
  const index = arguments[0];
  this._index = index;
};

class InteriorIntersectionFinderAdder {
  constructor () {
    InteriorIntersectionFinderAdder.constructor_.apply(this, arguments);
  }

  processIntersections (e0, segIndex0, e1, segIndex1) {
    if (e0 === e1 && segIndex0 === segIndex1) return null
    const p00 = e0.getCoordinates()[segIndex0];
    const p01 = e0.getCoordinates()[segIndex0 + 1];
    const p10 = e1.getCoordinates()[segIndex1];
    const p11 = e1.getCoordinates()[segIndex1 + 1];
    this._li.computeIntersection(p00, p01, p10, p11);
    if (this._li.hasIntersection()) {
      if (this._li.isInteriorIntersection()) {
        for (let intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {
          this._interiorIntersections.add(this._li.getIntersection(intIndex));
        }
        e0.addIntersections(this._li, segIndex0, 0);
        e1.addIntersections(this._li, segIndex1, 1);
      }
    }
  }

  isDone () {
    return false
  }

  getInteriorIntersections () {
    return this._interiorIntersections
  }

  getClass () {
    return InteriorIntersectionFinderAdder
  }

  get interfaces_ () {
    return [SegmentIntersector]
  }
}
InteriorIntersectionFinderAdder.constructor_ = function () {
  this._li = null;
  this._interiorIntersections = null;
  const li = arguments[0];
  this._li = li;
  this._interiorIntersections = new ArrayList();
};

class MCIndexSnapRounder {
  constructor () {
    MCIndexSnapRounder.constructor_.apply(this, arguments);
  }

  checkCorrectness (inputSegmentStrings) {
    const resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);
    const nv = new NodingValidator(resultSegStrings);
    try {
      nv.checkValid();
    } catch (ex) {
      if (ex instanceof Exception) {
        ex.printStackTrace();
      } else throw ex
    } finally {}
  }

  getNodedSubstrings () {
    return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)
  }

  snapRound (segStrings, li) {
    const intersections = this.findInteriorIntersections(segStrings, li);
    this.computeIntersectionSnaps(intersections);
    this.computeVertexSnaps(segStrings);
  }

  findInteriorIntersections (segStrings, li) {
    const intFinderAdder = new InteriorIntersectionFinderAdder(li);
    this._noder.setSegmentIntersector(intFinderAdder);
    this._noder.computeNodes(segStrings);
    return intFinderAdder.getInteriorIntersections()
  }

  computeVertexSnaps () {
    if (hasInterface(arguments[0], Collection)) {
      const edges = arguments[0];
      for (let i0 = edges.iterator(); i0.hasNext();) {
        const edge0 = i0.next();
        this.computeVertexSnaps(edge0);
      }
    } else if (arguments[0] instanceof NodedSegmentString) {
      const e = arguments[0];
      const pts0 = e.getCoordinates();
      for (let i = 0; i < pts0.length; i++) {
        const hotPixel = new HotPixel(pts0[i], this._scaleFactor, this._li);
        const isNodeAdded = this._pointSnapper.snap(hotPixel, e, i);
        if (isNodeAdded) {
          e.addIntersection(pts0[i], i);
        }
      }
    }
  }

  computeNodes (inputSegmentStrings) {
    this._nodedSegStrings = inputSegmentStrings;
    this._noder = new MCIndexNoder();
    this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());
    this.snapRound(inputSegmentStrings, this._li);
  }

  computeIntersectionSnaps (snapPts) {
    for (let it = snapPts.iterator(); it.hasNext();) {
      const snapPt = it.next();
      const hotPixel = new HotPixel(snapPt, this._scaleFactor, this._li);
      this._pointSnapper.snap(hotPixel);
    }
  }

  getClass () {
    return MCIndexSnapRounder
  }

  get interfaces_ () {
    return [Noder]
  }
}
MCIndexSnapRounder.constructor_ = function () {
  this._pm = null;
  this._li = null;
  this._scaleFactor = null;
  this._noder = null;
  this._pointSnapper = null;
  this._nodedSegStrings = null;
  const pm = arguments[0];
  this._pm = pm;
  this._li = new RobustLineIntersector();
  this._li.setPrecisionModel(pm);
  this._scaleFactor = pm.getScale();
};

class BufferOp {
  constructor () {
    BufferOp.constructor_.apply(this, arguments);
  }

  static bufferOp () {
    if (arguments.length === 2) {
      const g = arguments[0]; const distance = arguments[1];
      const gBuf = new BufferOp(g);
      const geomBuf = gBuf.getResultGeometry(distance);
      return geomBuf
    } else if (arguments.length === 3) {
      if (Number.isInteger(arguments[2]) && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {
        const g = arguments[0]; const distance = arguments[1]; const quadrantSegments = arguments[2];
        const bufOp = new BufferOp(g);
        bufOp.setQuadrantSegments(quadrantSegments);
        const geomBuf = bufOp.getResultGeometry(distance);
        return geomBuf
      } else if (arguments[2] instanceof BufferParameters && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {
        const g = arguments[0]; const distance = arguments[1]; const params = arguments[2];
        const bufOp = new BufferOp(g, params);
        const geomBuf = bufOp.getResultGeometry(distance);
        return geomBuf
      }
    } else if (arguments.length === 4) {
      const g = arguments[0]; const distance = arguments[1]; const quadrantSegments = arguments[2]; const endCapStyle = arguments[3];
      const bufOp = new BufferOp(g);
      bufOp.setQuadrantSegments(quadrantSegments);
      bufOp.setEndCapStyle(endCapStyle);
      const geomBuf = bufOp.getResultGeometry(distance);
      return geomBuf
    }
  }

  static precisionScaleFactor (g, distance, maxPrecisionDigits) {
    const env = g.getEnvelopeInternal();
    const envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));
    const expandByDistance = distance > 0.0 ? distance : 0.0;
    const bufEnvMax = envMax + 2 * expandByDistance;
    const bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);
    const minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;
    const scaleFactor = Math.pow(10.0, minUnitLog10);
    return scaleFactor
  }

  bufferFixedPrecision (fixedPM) {
    const noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());
    const bufBuilder = new BufferBuilder(this._bufParams);
    bufBuilder.setWorkingPrecisionModel(fixedPM);
    bufBuilder.setNoder(noder);
    this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
  }

  bufferReducedPrecision () {
    if (arguments.length === 0) {
      for (let precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {
        try {
          this.bufferReducedPrecision(precDigits);
        } catch (ex) {
          if (ex instanceof TopologyException) {
            this._saveException = ex;
          } else throw ex
        } finally {}
        if (this._resultGeometry !== null) return null
      }
      throw this._saveException
    } else if (arguments.length === 1) {
      const precisionDigits = arguments[0];
      const sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);
      const fixedPM = new PrecisionModel(sizeBasedScaleFactor);
      this.bufferFixedPrecision(fixedPM);
    }
  }

  computeGeometry () {
    this.bufferOriginalPrecision();
    if (this._resultGeometry !== null) return null
    const argPM = this._argGeom.getFactory().getPrecisionModel();
    if (argPM.getType() === PrecisionModel.FIXED) this.bufferFixedPrecision(argPM); else this.bufferReducedPrecision();
  }

  setQuadrantSegments (quadrantSegments) {
    this._bufParams.setQuadrantSegments(quadrantSegments);
  }

  bufferOriginalPrecision () {
    try {
      const bufBuilder = new BufferBuilder(this._bufParams);
      this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
    } catch (ex) {
      if (ex instanceof RuntimeException) {
        this._saveException = ex;
      } else throw ex
    } finally {}
  }

  getResultGeometry (distance) {
    this._distance = distance;
    this.computeGeometry();
    return this._resultGeometry
  }

  setEndCapStyle (endCapStyle) {
    this._bufParams.setEndCapStyle(endCapStyle);
  }

  getClass () {
    return BufferOp
  }

  get interfaces_ () {
    return []
  }
}
BufferOp.constructor_ = function () {
  this._argGeom = null;
  this._distance = null;
  this._bufParams = new BufferParameters();
  this._resultGeometry = null;
  this._saveException = null;
  if (arguments.length === 1) {
    const g = arguments[0];
    this._argGeom = g;
  } else if (arguments.length === 2) {
    const g = arguments[0]; const bufParams = arguments[1];
    this._argGeom = g;
    this._bufParams = bufParams;
  }
};
BufferOp.CAP_ROUND = BufferParameters.CAP_ROUND;
BufferOp.CAP_BUTT = BufferParameters.CAP_FLAT;
BufferOp.CAP_FLAT = BufferParameters.CAP_FLAT;
BufferOp.CAP_SQUARE = BufferParameters.CAP_SQUARE;
BufferOp.MAX_PRECISION_DIGITS = 12;

var MapUtil = /*#__PURE__*/function () {
  function MapUtil(map) {
    var _this = this;

    _classCallCheck(this, MapUtil);

    _defineProperty$1(this, "sources", {});

    _defineProperty$1(this, "initBufferLayers", function () {
      _this.clearSourceData(Constants.LINES_BUFFER_LAYER_ID);

      _this.clearSourceData(Constants.POINTS_BUFFER_LAYER_ID);

      _this.initAdvanceSearchLinesBuffer();

      _this.initAdvanceSearchPointsBuffer();
    });

    _defineProperty$1(this, "initGeofenceLayers", function () {
      _this.clearSourceData(Constants.GEOFENCE_LINES_BUFFER_LAYER_ID);

      _this.clearSourceData(Constants.GEOFENCE_POINTS_BUFFER_LAYER_ID);

      _this.initGeofenceLinesBuffer();

      _this.initGeofencePointsBuffer();
    });

    _defineProperty$1(this, "initBlockadeLayers", function () {
      _this.clearSourceData(Constants.BLOCKADE_LINES_BUFFER_LAYER_ID);

      _this.clearSourceData(Constants.BLOCKADE_POINTS_BUFFER_LAYER_ID);

      _this.initBlockadeLinesBuffer();

      _this.initBlockadePointsBuffer();
    });

    _defineProperty$1(this, "initAdvanceSearchLinesBuffer", function () {
      _this.initSource(Constants.LINES_BUFFER_LAYER_ID);

      _this.addLayerBelowLabel({
        'id': Constants.LINES_BUFFER_LAYER_ID,
        'type': 'fill',
        'source': Constants.LINES_BUFFER_LAYER_ID,
        'layout': {},
        'paint': {
          'fill-color': ['case', ['boolean', ['!=', ['feature-state', 'color'], null], false], ['feature-state', 'color'], ['get', 'color']],
          'fill-opacity': ['case', ['boolean', ['!=', ['feature-state', 'polygonOpacity'], null], false], ['feature-state', 'polygonOpacity'], ['get', 'polygonOpacity']]
        }
      });
    });

    _defineProperty$1(this, "initAdvanceSearchPointsBuffer", function () {
      _this.initSource(Constants.POINTS_BUFFER_LAYER_ID);

      _this.addLayerBelowLabel({
        'id': Constants.POINTS_BUFFER_LAYER_ID,
        'type': 'fill',
        'source': Constants.POINTS_BUFFER_LAYER_ID,
        'layout': {},
        'paint': {
          'fill-color': ['case', ['boolean', ['!=', ['feature-state', 'color'], null], false], ['feature-state', 'color'], ['get', 'color']],
          'fill-opacity': ['case', ['boolean', ['!=', ['feature-state', 'polygonOpacity'], null], false], ['feature-state', 'polygonOpacity'], ['get', 'polygonOpacity']]
        }
      });
    });

    _defineProperty$1(this, "initGeofenceLinesBuffer", function () {
      _this.initSource(Constants.GEOFENCE_LINES_BUFFER_LAYER_ID);

      _this.addLayerBelowLabel({
        'id': Constants.GEOFENCE_LINES_BUFFER_LAYER_ID,
        'type': 'fill',
        'source': Constants.GEOFENCE_LINES_BUFFER_LAYER_ID,
        'layout': {},
        'paint': {
          'fill-color': ['case', ['boolean', ['!=', ['feature-state', 'color'], null], false], ['feature-state', 'color'], ['get', 'color']],
          'fill-opacity': ['case', ['boolean', ['!=', ['feature-state', 'polygonOpacity'], null], false], ['feature-state', 'polygonOpacity'], ['get', 'polygonOpacity']]
        }
      });
    });

    _defineProperty$1(this, "initGeofencePointsBuffer", function () {
      _this.initSource(Constants.GEOFENCE_POINTS_BUFFER_LAYER_ID);

      _this.addLayerBelowLabel({
        'id': Constants.GEOFENCE_POINTS_BUFFER_LAYER_ID,
        'type': 'fill',
        'source': Constants.GEOFENCE_POINTS_BUFFER_LAYER_ID,
        'layout': {},
        'paint': {
          'fill-color': ['case', ['boolean', ['!=', ['feature-state', 'color'], null], false], ['feature-state', 'color'], ['get', 'color']],
          'fill-opacity': ['case', ['boolean', ['!=', ['feature-state', 'polygonOpacity'], null], false], ['feature-state', 'polygonOpacity'], ['get', 'polygonOpacity']]
        }
      });
    });

    _defineProperty$1(this, "initBlockadeLinesBuffer", function () {
      _this.initSource(Constants.BLOCKADE_LINES_BUFFER_LAYER_ID);

      _this.addLayerBelowLabel({
        'id': Constants.BLOCKADE_LINES_BUFFER_LAYER_ID,
        'type': 'fill',
        'source': Constants.BLOCKADE_LINES_BUFFER_LAYER_ID,
        'layout': {},
        'paint': {
          'fill-color': ['case', ['boolean', ['!=', ['feature-state', 'color'], null], false], ['feature-state', 'color'], ['get', 'color']],
          'fill-opacity': ['case', ['boolean', ['!=', ['feature-state', 'polygonOpacity'], null], false], ['feature-state', 'polygonOpacity'], ['get', 'polygonOpacity']]
        }
      });
    });

    _defineProperty$1(this, "initBlockadePointsBuffer", function () {
      _this.initSource(Constants.BLOCKADE_POINTS_BUFFER_LAYER_ID);

      _this.addLayerBelowLabel({
        'id': Constants.BLOCKADE_POINTS_BUFFER_LAYER_ID,
        'type': 'fill',
        'source': Constants.BLOCKADE_POINTS_BUFFER_LAYER_ID,
        'layout': {},
        'paint': {
          'fill-color': ['case', ['boolean', ['!=', ['feature-state', 'color'], null], false], ['feature-state', 'color'], ['get', 'color']],
          'fill-opacity': ['case', ['boolean', ['!=', ['feature-state', 'polygonOpacity'], null], false], ['feature-state', 'polygonOpacity'], ['get', 'polygonOpacity']]
        }
      });
    });

    _defineProperty$1(this, "drawMyMapOnDragObjectTypeLines", function (coords, color) {
      var data = {
        'type': 'Feature',
        'properties': {
          'color': color
        },
        'geometry': {
          'type': 'LineString',
          'coordinates': coords
        }
      };

      _this.setSourceData(Constants.DRAG_MAP_OBJECT_LINE_LAYER_ID, data);
    });

    _defineProperty$1(this, "drawMyMapObjectTypePolygons", function (polygons) {
      if (polygons && polygons.length) {
        var features = [];

        var _iterator = _createForOfIteratorHelper(polygons),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var polygon = _step.value;
            var feature = {
              'type': 'Feature',
              'geometry': {
                'type': 'Polygon',
                'coordinates': [polygon.coords]
              },
              'properties': {
                'mapObjectId': polygon.mapObject.id,
                'color': polygon.mapObject.customStyle && polygon.mapObject.customStyle.color !== undefined ? polygon.mapObject.customStyle.color : Constants.MAP_OBJECT_POLYGON_COLOR,
                'polygonOpacity': polygon.mapObject.customStyle && polygon.mapObject.customStyle.polygonOpacity !== undefined ? parseFloat(polygon.mapObject.customStyle.polygonOpacity) : Constants.MAP_OBJECT_POLYGON_OPACITY
              }
            };
            features.push(feature);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        var data = {
          'type': 'FeatureCollection',
          'features': features
        };

        _this.setSourceData(Constants.MAP_OBJECT_POLYGONS_LAYER_ID, data);
      } else {
        _this.clearSourceData(Constants.MAP_OBJECT_POLYGONS_LAYER_ID);
      }
    });

    _defineProperty$1(this, "drawMyMapObjectTypeGeofencePolygons", function (polygons) {
      if (polygons && polygons.length) {
        var features = [];

        var _iterator2 = _createForOfIteratorHelper(polygons),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var polygon = _step2.value;
            var feature = {
              'type': 'Feature',
              'geometry': {
                'type': 'Polygon',
                'coordinates': [polygon.coords]
              },
              'properties': {
                'mapObjectId': polygon.mapObject.id,
                'color': polygon.mapObject.customStyle && polygon.mapObject.customStyle.color !== undefined ? polygon.mapObject.customStyle.color : Constants.MAP_OBJECT.MAP_OBJECT_GEOFENCE_POLYGON_COLOR,
                'polygonOpacity': polygon.mapObject.customStyle && polygon.mapObject.customStyle.polygonOpacity !== undefined ? parseFloat(polygon.mapObject.customStyle.polygonOpacity) : Constants.MAP_OBJECT_POLYGON_OPACITY
              }
            };
            features.push(feature);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        var data = {
          'type': 'FeatureCollection',
          'features': features
        };

        _this.setSourceData(Constants.MAP_OBJECT_GEOFENCE_POLYGONS_LAYER_ID, data);
      } else {
        _this.clearSourceData(Constants.MAP_OBJECT_GEOFENCE_POLYGONS_LAYER_ID);
      }
    });

    _defineProperty$1(this, "drawMapObjectTypeLinesBuffer", function (polygons) {
      if (polygons && polygons.length) {
        var features = [];

        var _iterator3 = _createForOfIteratorHelper(polygons),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var polygon = _step3.value;
            var feature = {
              'type': 'Feature',
              'geometry': {
                'type': 'Polygon',
                'coordinates': [polygon.coords]
              },
              'properties': {
                'mapObjectId': polygon.mapObject.id,
                'color': polygon.mapObject.customStyle && polygon.mapObject.customStyle.color !== undefined ? polygon.mapObject.customStyle.color : Constants.MAP_OBJECT_POLYGON_COLOR,
                'polygonOpacity': polygon.mapObject.customStyle && polygon.mapObject.customStyle.polygonOpacity !== undefined ? parseFloat(polygon.mapObject.customStyle.polygonOpacity) : Constants.MAP_OBJECT_POLYGON_OPACITY
              }
            };
            features.push(feature);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        var data = {
          'type': 'FeatureCollection',
          'features': features
        };

        _this.setSourceData(Constants.LINES_BUFFER_LAYER_ID, data);
      } else {
        _this.clearSourceData(Constants.LINES_BUFFER_LAYER_ID);
      }
    });

    _defineProperty$1(this, "drawMapObjectTypePointsBuffer", function (polygons) {
      if (polygons && polygons.length) {
        var features = [];

        var _iterator4 = _createForOfIteratorHelper(polygons),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var polygon = _step4.value;
            var feature = {
              'type': 'Feature',
              'geometry': {
                'type': 'Polygon',
                'coordinates': [polygon.coords]
              },
              'properties': {
                'mapObjectId': polygon.mapObject.id,
                'color': polygon.mapObject.customStyle && polygon.mapObject.customStyle.color !== undefined ? polygon.mapObject.customStyle.color : Constants.MAP_OBJECT_POLYGON_COLOR,
                'polygonOpacity': polygon.mapObject.customStyle && polygon.mapObject.customStyle.polygonOpacity !== undefined ? parseFloat(polygon.mapObject.customStyle.polygonOpacity) : Constants.MAP_OBJECT_POLYGON_OPACITY
              }
            };
            features.push(feature);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        var data = {
          'type': 'FeatureCollection',
          'features': features
        };

        _this.setSourceData(Constants.POINTS_BUFFER_LAYER_ID, data);
      } else {
        _this.clearSourceData(Constants.POINTS_BUFFER_LAYER_ID);
      }
    });

    _defineProperty$1(this, "drawGeofenceLinesBuffer", function (polygons) {
      if (polygons && polygons.length) {
        var features = [];

        var _iterator5 = _createForOfIteratorHelper(polygons),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var polygon = _step5.value;
            var feature = {
              'type': 'Feature',
              'geometry': {
                'type': 'Polygon',
                'coordinates': [polygon.coords]
              },
              'properties': {
                'mapObjectId': polygon.mapObject.id,
                'color': polygon.mapObject.customStyle && polygon.mapObject.customStyle.color !== undefined ? polygon.mapObject.customStyle.color : Constants.MAP_OBJECT_GEOFENCE_POLYGON_COLOR,
                'polygonOpacity': polygon.mapObject.customStyle && polygon.mapObject.customStyle.polygonOpacity !== undefined ? parseFloat(polygon.mapObject.customStyle.polygonOpacity) : Constants.MAP_OBJECT_POLYGON_OPACITY
              }
            };
            features.push(feature);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        var data = {
          'type': 'FeatureCollection',
          'features': features
        };

        _this.setSourceData(Constants.GEOFENCE_LINES_BUFFER_LAYER_ID, data);
      } else {
        _this.clearSourceData(Constants.GEOFENCE_LINES_BUFFER_LAYER_ID);
      }
    });

    _defineProperty$1(this, "drawGeofencePointsBuffer", function (polygons) {
      if (polygons && polygons.length) {
        var features = [];

        var _iterator6 = _createForOfIteratorHelper(polygons),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var polygon = _step6.value;
            var feature = {
              'type': 'Feature',
              'geometry': {
                'type': 'Polygon',
                'coordinates': [polygon.coords]
              },
              'properties': {
                'mapObjectId': polygon.mapObject.id,
                'color': polygon.mapObject.customStyle && polygon.mapObject.customStyle.color !== undefined ? polygon.mapObject.customStyle.color : Constants.MAP_OBJECT_GEOFENCE_POLYGON_COLOR,
                'polygonOpacity': polygon.mapObject.customStyle && polygon.mapObject.customStyle.polygonOpacity !== undefined ? parseFloat(polygon.mapObject.customStyle.polygonOpacity) : Constants.MAP_OBJECT_POLYGON_OPACITY
              }
            };
            features.push(feature);
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        var data = {
          'type': 'FeatureCollection',
          'features': features
        };

        _this.setSourceData(Constants.GEOFENCE_POINTS_BUFFER_LAYER_ID, data);
      } else {
        _this.clearSourceData(Constants.GEOFENCE_POINTS_BUFFER_LAYER_ID);
      }
    });

    _defineProperty$1(this, "drawBlockadeLinesBuffer", function (polygons) {
      if (polygons && polygons.length) {
        var features = [];

        var _iterator7 = _createForOfIteratorHelper(polygons),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var polygon = _step7.value;
            var feature = {
              'type': 'Feature',
              'geometry': {
                'type': 'Polygon',
                'coordinates': [polygon.coords]
              },
              'properties': {
                'mapObjectId': polygon.mapObject.id,
                'color': polygon.mapObject.customStyle && polygon.mapObject.customStyle.color !== undefined ? polygon.mapObject.customStyle.color : Constants.MAP_OBJECT_BLOCKADE_POLYGON_COLOR,
                'polygonOpacity': polygon.mapObject.customStyle && polygon.mapObject.customStyle.polygonOpacity !== undefined ? parseFloat(polygon.mapObject.customStyle.polygonOpacity) : Constants.MAP_OBJECT_BLOCKADE_POLYGON_OPACITY
              }
            };
            features.push(feature);
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }

        var data = {
          'type': 'FeatureCollection',
          'features': features
        };

        _this.setSourceData(Constants.BLOCKADE_LINES_BUFFER_LAYER_ID, data);
      } else {
        _this.clearSourceData(Constants.BLOCKADE_LINES_BUFFER_LAYER_ID);
      }
    });

    _defineProperty$1(this, "drawBlockadePointsBuffer", function (polygons) {
      if (polygons && polygons.length) {
        var features = [];

        var _iterator8 = _createForOfIteratorHelper(polygons),
            _step8;

        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var polygon = _step8.value;
            var feature = {
              'type': 'Feature',
              'geometry': {
                'type': 'Polygon',
                'coordinates': [polygon.coords]
              },
              'properties': {
                'mapObjectId': polygon.mapObject.id,
                'color': polygon.mapObject.customStyle && polygon.mapObject.customStyle.color !== undefined ? polygon.mapObject.customStyle.color : Constants.MAP_OBJECT_BLOCKADE_POLYGON_COLOR,
                'polygonOpacity': polygon.mapObject.customStyle && polygon.mapObject.customStyle.polygonOpacity !== undefined ? parseFloat(polygon.mapObject.customStyle.polygonOpacity) : Constants.MAP_OBJECT_BLOCKADE_POLYGON_OPACITY
              }
            };
            features.push(feature);
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }

        var data = {
          'type': 'FeatureCollection',
          'features': features
        };

        _this.setSourceData(Constants.BLOCKADE_POINTS_BUFFER_LAYER_ID, data);
      } else {
        _this.clearSourceData(Constants.BLOCKADE_POINTS_BUFFER_LAYER_ID);
      }
    });

    _defineProperty$1(this, "drawMyMapDrawingObjectTypeLines", function (coords) {
      var data = {
        'type': 'Feature',
        'properties': {},
        'geometry': {
          'type': 'LineString',
          'coordinates': coords
        }
      };

      _this.setSourceData(Constants.DRAWING_MAP_OBJECT_LINE_LAYER_ID, data);
    });

    _defineProperty$1(this, "clearMapObjectPopup", function (popup) {
      if (popup) {
        popup.remove();
      }

      return null;
    });

    _defineProperty$1(this, "initSource", function (sourceId) {
      var source = _this.map.getSource(sourceId);

      if (!source) {
        _this.clearSourceData(sourceId);
      }
    });

    _defineProperty$1(this, "clearAllSourceExcept", function (exceptSourceIds) {
      for (var sourceId in _this.sources) {
        if (!exceptSourceIds || !exceptSourceIds.includes(sourceId)) {
          _this.clearSourceData(sourceId);
        }
      }
    });

    _defineProperty$1(this, "clearSourceData", function (sourceId) {
      var emptyData = {
        'type': 'FeatureCollection',
        'features': []
      };

      _this.setSourceData(sourceId, emptyData);
    });

    _defineProperty$1(this, "setSourceData", function (sourceId, data) {
      var source = _this.map.getSource(sourceId);

      if (!source) {
        _this.map.addSource(sourceId, {
          'type': 'geojson',
          'data': data,
          'generateId': true
        });
      } else {
        source.setData(data);
      }

      _this.sources[sourceId] = data;
    });

    _defineProperty$1(this, "drawCircleSearchNearbyLayer", function (centerCoords, radius) {
      if (centerCoords && centerCoords.length && radius) {
        var data = _this.createGeoJSONCircle(centerCoords, radius);

        _this.setSourceData(Constants.CIRCLE_SEARCH_NEAR_BY_LAYER_ID, data);
      } else {
        _this.clearSourceData(Constants.CIRCLE_SEARCH_NEAR_BY_LAYER_ID);
      }
    });

    _defineProperty$1(this, "createGeoJSONCircle", function (center, radiusInMeters, points) {
      if (!points) {
        points = 64;
      }

      var coords = {
        latitude: center[1],
        longitude: center[0]
      };
      var km = radiusInMeters / 1000;
      var ret = [];
      var distanceX = km / (111.320 * Math.cos(coords.latitude * Math.PI / 180));
      var distanceY = km / 110.574;
      var theta, x, y;

      for (var i = 0; i < points; i++) {
        theta = i / points * (2 * Math.PI);
        x = distanceX * Math.cos(theta);
        y = distanceY * Math.sin(theta);
        ret.push([coords.longitude + x, coords.latitude + y]);
      }

      ret.push(ret[0]);
      return {
        'type': 'Feature',
        'geometry': {
          'type': 'Polygon',
          'coordinates': [ret]
        }
      };
    });

    _defineProperty$1(this, "getBoundsPadding", function (padding) {
      var bounds = _this.map.getBounds();

      if (padding) {
        var tr = _this.map.project(bounds._ne);

        var bl = _this.map.project(bounds._sw);

        if (_typeof(padding) === 'object') {
          tr.x -= padding.right;
          tr.y += padding.top;
          bl.x += padding.left;
          bl.y -= padding.bottom;
        } else {
          tr.x -= padding;
          tr.y += padding;
          bl.x += padding;
          bl.y -= padding;
        }

        bounds._ne = _this.map.unproject(tr);
        bounds._sw = _this.map.unproject(bl);
      }

      return bounds;
    });

    _defineProperty$1(this, "isPointInBounds", function (point, padding) {
      var bounds = _this.getBoundsPadding(padding);

      var lng = (point.lng - bounds._ne.lng) * (point.lng - bounds._sw.lng) < 0;
      var lat = (point.lat - bounds._ne.lat) * (point.lat - bounds._sw.lat) < 0;
      return lng && lat;
    });

    _defineProperty$1(this, "addLayerBelowLabel", function (data) {
      var layers = _this.map.getStyle().layers; // Find the index of the first symbol layer in the map style


      var symbolLayer = layers.find(function (l) {
        return l.type === 'symbol';
      });

      if (symbolLayer) {
        // Insert the layer beneath the first symbol layer.
        _this.map.addLayer(data, symbolLayer.id);
      } else {
        _this.map.addLayer(data);
      }
    });

    _defineProperty$1(this, "getTotalDistanceWithCoordinates", function (coords) {
      var distance = 0;

      if (coords && coords.length) {
        for (var i = 0; i < coords.length - 1; i++) {
          if (coords[i] && coords[i + 1]) {
            distance += _this.getDistance({
              X: coords[i].longitude,
              Y: coords[i].latitude
            }, {
              X: coords[i + 1].longitude,
              Y: coords[i + 1].latitude
            });
          }
        }
      }

      return distance;
    });

    _defineProperty$1(this, "fitBound", function (data) {
      if (_this.map && data && data.length) {
        var bounds = new mapboxgl__default['default'].LngLatBounds();

        var _iterator9 = _createForOfIteratorHelper(data),
            _step9;

        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var d = _step9.value;
            bounds.extend([d.y, d.x]);
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }

        _this.map.fitBounds(bounds, {
          maxZoom: 16
        });
      }
    });

    this.map = map;
  }

  _createClass(MapUtil, [{
    key: "pointsToCoords",
    value: function pointsToCoords(points) {
      return points.map(function (o) {
        return [o.longitude, o.latitude];
      });
    }
  }, {
    key: "getBufferCoords",
    value: function getBufferCoords(obj, radius) {
      if (!radius) {
        radius = 100;
      }

      var reader = new GeoJSONReader();
      var writer = new GeoJSONWriter();
      var r = reader.read(obj);
      var bf = BufferOp.bufferOp(r, radius / 111128.0); // 1 degree of latitude = 111,128 meters -> convert radius from degree to meters

      var w = writer.write(bf);

      if (obj.type === Constants.MAP_OBJECT.MARKER) {
        return w.coordinates;
      }

      return w.coordinates[0];
    }
  }, {
    key: "getMapObjectType",
    value: function getMapObjectType(geometry) {
      switch (geometry.type) {
        case 'Point':
          return Constants.MAP_OBJECT.MARKER;

        case 'Polygon':
          return Constants.MAP_OBJECT.POLYGON;

        case 'LineString':
          return Constants.MAP_OBJECT.LINES;

        default:
          return Constants.MAP_OBJECT.POINTER;
      }
    }
  }, {
    key: "getDistance",
    value: function getDistance(_ref, _ref2) {
      var lon1 = _ref.X,
          lat1 = _ref.Y;
      var lon2 = _ref2.X,
          lat2 = _ref2.Y;
      var R = 6371; // radius of earth, km (change this constant to get miles)

      var dLat = (lat2 - lat1) * Math.PI / 180;
      var dLon = (lon2 - lon1) * Math.PI / 180;
      var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.cos(lat1 * Math.PI / 180), 2) * Math.pow(Math.sin(dLon / 2), 2);
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      var d = R * c;
      return d * 1000; // meters
    }
  }]);

  return MapUtil;
}();

var MapEditor = function MapEditor(props) {
  var mapCenter = props.center || {
    lng: 72.86427969590417,
    lat: 18.95459856681687
  };
  var height = props.height,
      onMapStyleLoad = props.onMapStyleLoad;

  var _useContext = React.useContext(MapContext$1),
      mapState = _useContext.mapState,
      dispatch = _useContext.dispatch;

  var onDrawCreate = function onDrawCreate(obj) {
    dispatch({
      type: 'createDraw',
      data: obj.features[0]
    });
  };

  var onDrawUpdate = function onDrawUpdate(obj) {
    dispatch({
      type: 'setDrawObj',
      data: obj.features[0]
    });
  };

  var onDrawDelete = function onDrawDelete() {
    dispatch({
      type: 'setDrawObj',
      data: null
    });
  };

  var onStyleLoad = function onStyleLoad(map) {
    map.addControl(mapState.draw, 'top-left');
    map.on('draw.create', onDrawCreate);
    map.on('draw.update', onDrawUpdate);
    map.on('draw.delete', onDrawDelete);
    mapState.map = map;
    mapState.mapUtil = new MapUtil(map);

    if (typeof onMapStyleLoad === 'function') {
      onMapStyleLoad(map);
    }
  };

  return /*#__PURE__*/jsxRuntime.jsx(Map$2, {
    center: mapCenter,
    zoomLevel: [12.5],
    height: height,
    width: '100%',
    fontURL: '' // saveViewport
    ,
    onStyleLoad: onStyleLoad
  });
};

MapEditor.defaultProps = {
  value: '',
  height: '40rem',
  onMapStyleLoad: function onMapStyleLoad(map) {
    map.resize();
  }
};

var MapInput = function MapInput(props) {
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(Input, {
      ref: props.ref,
      className: "input-text  ".concat(props.className + (props.type === 'range' ? ' slider' : '')),
      placeholder: props.placeholder,
      readOnly: props.readOnly,
      value: props.value,
      onChange: props.onChange,
      onFocus: props.onFocus
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "map-icon",
      children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
        icon: 'map-marker-alt',
        size: '1rem',
        onClick: props.onFocus
      })
    })]
  });
};

MapInput.defaultProps = {
  value: '',
  type: '',
  className: '',
  placeholder: '',
  onFocus: function onFocus() {},
  onChange: function onChange() {}
};

var _excluded$b = ["value", "onChange", "readOnly", "required", "placeholder"];
var MapControlContainer = function MapControlContainer(_ref) {
  var _ref$value = _ref.value,
      value = _ref$value === void 0 ? '' : _ref$value,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      _ref$readOnly = _ref.readOnly,
      readOnly = _ref$readOnly === void 0 ? false : _ref$readOnly;
      _ref.required;
      var _ref$placeholder = _ref.placeholder,
      placeholder = _ref$placeholder === void 0 ? '' : _ref$placeholder;
      _objectWithoutProperties(_ref, _excluded$b);

  var _useContext = React.useContext(MapContext$1),
      mapState = _useContext.mapState,
      dispatch = _useContext.dispatch;

  var mapControlRef = React.useRef();

  var closeMap = function closeMap() {
    dispatch({
      type: 'closeMap'
    });
  };

  var onFocus = function onFocus() {
    dispatch({
      type: 'openMap'
    });
  };

  var drawGeoJson = function drawGeoJson(val) {
    if (val) {
      try {
        var geometry = JSON.parse(val);
        var id = mapState.draw.add(geometry)[0];
        dispatch({
          type: 'createDraw',
          data: {
            id: id,
            geometry: geometry
          }
        });
        mapState.mapUtil.fitBound([{
          y: geometry.coordinates[0],
          x: geometry.coordinates[1]
        }]);
      } catch (err) {
        console.error(err.message);
      }
    }
  };

  var onMapStyleLoad = function onMapStyleLoad() {
    drawGeoJson(value);
  }; // const onSearchSuggestClick = (item: any) =>
  // {
  //     drawGeoJson(JSON.stringify({
  //         'type': 'Point',
  //         'coordinates': [
  //             item.longitude,
  //             item.latitude,
  //         ],
  //     }));
  // };


  var onSave = function onSave() {
    if (mapState.drawObj) {
      dispatch({
        type: 'setValue',
        data: JSON.stringify(mapState.drawObj.geometry)
      });
      onChange(JSON.stringify(mapState.drawObj.geometry));
      dispatch({
        type: 'closeMap'
      });
    }
  };

  return /*#__PURE__*/jsxRuntime.jsx(Container, {
    style: {
      width: '100%'
    },
    className: "form-map-container",
    children: /*#__PURE__*/jsxRuntime.jsxs("div", {
      ref: mapControlRef,
      className: "form-map-control-container",
      children: [/*#__PURE__*/jsxRuntime.jsx(MapInput, {
        value: value,
        readOnly: readOnly,
        placeholder: placeholder,
        onFocus: onFocus
      }), mapState.open && !readOnly && /*#__PURE__*/jsxRuntime.jsx(PopOver, {
        width: 600,
        height: 360,
        className: 'minimap-popover',
        anchorEl: mapControlRef,
        onBackgroundClick: closeMap,
        children: /*#__PURE__*/jsxRuntime.jsxs(Col2, {
          sx: {
            spaceBetweenX: 0,
            spaceBetweenY: 0
          },
          children: [/*#__PURE__*/jsxRuntime.jsx(MapEditor, {
            onMapStyleLoad: onMapStyleLoad
          }), /*#__PURE__*/jsxRuntime.jsx(Row2, {
            justify: "end",
            children: /*#__PURE__*/jsxRuntime.jsx(Button, {
              disabled: !mapState.drawObj,
              icon: 'save',
              text: 'Lưu',
              onClick: onSave
            })
          })]
        })
      })]
    })
  });
};
var MapControl = function MapControl(props) {
  return /*#__PURE__*/jsxRuntime.jsx(MapStateProvider, {
    children: /*#__PURE__*/jsxRuntime.jsx(MapControlContainer, _objectSpread2({}, props))
  });
};

var DynamicField = function DynamicField(props) {
  var className = props.className,
      schema = props.schema,
      options = props.options,
      autoFocus = props.autoFocus,
      onChange = props.onChange,
      onChangeFiles = props.onChangeFiles,
      onChangeDone = props.onChangeDone,
      onClose = props.onClose,
      changeImmediately = props.changeImmediately;

  var _useState = React.useState(props.value),
      _useState2 = _slicedToArray(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1];

  if (!schema) {
    return null;
  }

  var handleChange = function handleChange(value) {
    setValue(value);
    onChange && onChange(value);
  };

  var inputJsx = function () {
    switch (schema) {
      case exports.DataTypes.Boolean:
        return /*#__PURE__*/jsxRuntime.jsx(CheckBox, {
          checked: value,
          onChange: handleChange
        });

      case exports.DataTypes.Currency:
      case exports.DataTypes.Numeric:
        return /*#__PURE__*/jsxRuntime.jsx(Input, {
          type: "number",
          step: 1,
          defaultValue: value,
          autoFocus: autoFocus,
          onChange: handleChange
        });

      case exports.DataTypes.Real:
        return /*#__PURE__*/jsxRuntime.jsx(Input, {
          type: "number",
          step: 0.01,
          defaultValue: value,
          autoFocus: autoFocus,
          onChange: handleChange
        });

      case exports.DataTypes.Date:
        return /*#__PURE__*/jsxRuntime.jsx(DateTimePicker, {
          value: value,
          isVisible: autoFocus,
          showTimeRange: true,
          onChange: handleChange
        });

      case exports.DataTypes.Datetime:
        return /*#__PURE__*/jsxRuntime.jsx(DateTimePicker, {
          value: value,
          isVisible: autoFocus,
          showTimeRange: true,
          onChange: handleChange
        });

      case exports.DataTypes.Text:
        return /*#__PURE__*/jsxRuntime.jsx(Input, {
          type: "text",
          defaultValue: value,
          autoFocus: autoFocus,
          onChange: handleChange,
          onBlur: function onBlur(event) {
            return onClose && onClose(event);
          }
        });

      case exports.DataTypes.File:
        return /*#__PURE__*/jsxRuntime.jsx(FileInput, {
          onChangeFiles: onChangeFiles
        });

      case exports.DataTypes.List:
        {
          var _config$content, _config$content2;

          var config = JSON.parse(options || '{}');
          var selectOptions = (Array.isArray(config === null || config === void 0 ? void 0 : (_config$content = config.content) === null || _config$content === void 0 ? void 0 : _config$content.source) ? config === null || config === void 0 ? void 0 : (_config$content2 = config.content) === null || _config$content2 === void 0 ? void 0 : _config$content2.source : []).map(function (op) {
            return {
              id: op.Value,
              label: op.Display
            };
          });
          return /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
            options: selectOptions,
            value: value,
            isVisible: autoFocus,
            onChange: handleChange
          });
        }

      case exports.DataTypes.Select:
        {
          // const defaultColor = 'var(--default-color)';
          var _selectOptions = options.map(function (option) {
            var _option$size;

            return {
              label: option.color ? /*#__PURE__*/jsxRuntime.jsx(Tag, {
                textCase: 'sentence',
                text: option.label,
                color: option.color,
                size: (_option$size = option.size) !== null && _option$size !== void 0 ? _option$size : 'medium',
                textStyle: {
                  color: option.textColor
                },
                isRound: true
              }) : option.color,
              id: option.id
            };
          });

          return /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
            options: _selectOptions,
            value: value,
            isVisible: autoFocus,
            searchable: false,
            onChange: handleChange
          });
        }

      case exports.DataTypes.Map:
      case exports.DataTypes.MapVN2000:
        {
          var geoJsonValue = value;

          if (value && typeof value !== 'string') {
            geoJsonValue = JSON.stringify(value);
          }

          return /*#__PURE__*/jsxRuntime.jsx(MapStateProvider, {
            initState: {
              open: true
            },
            children: /*#__PURE__*/jsxRuntime.jsx(MapControlContainer, {
              placeholder: 'Nhấp để đặt vị trí',
              value: geoJsonValue || '',
              onChange: handleChange
            })
          });
        }

      default:
        return /*#__PURE__*/jsxRuntime.jsx(MultilineInput, {
          maxTextareaHeight: "5rem",
          value: value,
          autoFocus: true,
          onChange: handleChange
        });
    }
  }();

  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: changeImmediately ? _objectSpread2(_objectSpread2({}, inputJsx), {}, {
      props: _objectSpread2(_objectSpread2({}, inputJsx.props), {}, {
        className: className
      })
    }) : /*#__PURE__*/jsxRuntime.jsxs(InputGroup, {
      className: className,
      children: [_objectSpread2(_objectSpread2({}, inputJsx), {}, {
        props: _objectSpread2({}, inputJsx.props)
      }), /*#__PURE__*/jsxRuntime.jsx(InputAppend, {
        children: /*#__PURE__*/jsxRuntime.jsxs(Row2, {
          items: "center",
          children: [/*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
            icon: "check",
            iconSize: "xxl",
            onlyIcon: true,
            onClick: function onClick(e) {
              e.stopPropagation();
              onChangeDone && onChangeDone(value);
            }
          }), /*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
            icon: "times",
            iconSize: "xxl",
            onlyIcon: true,
            onClick: function onClick(e) {
              e.stopPropagation();
              onChangeDone && onChangeDone(undefined);
            }
          })]
        })
      })]
    })
  });
};

var ProgressBar = /*#__PURE__*/function (_Component) {
  _inherits(ProgressBar, _Component);

  var _super = _createSuper(ProgressBar);

  function ProgressBar() {
    var _this;

    _classCallCheck(this, ProgressBar);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "formatter", function (val) {
      if (val >= 1000000) {
        return (val / 1000000).toFixed(2) + ' triệu';
      } else if (val >= 1000) {
        return (val / 1000).toFixed(2) + ' nghìn';
      } else {
        return val.toFixed(2);
      }
    });

    return _this;
  }

  _createClass(ProgressBar, [{
    key: "render",
    value: function render() {
      var percent = this.props.value / this.props.total * 100;
      var initStyle = '';

      if (this.props.value === 0) {
        percent = 5;
        initStyle = 'init';
      }

      if (this.props.percent) {
        return /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "progress-bar ".concat(this.props.className),
          style: {
            width: '100%',
            height: '20px'
          },
          children: this.props.value > this.props.total / 2 ? /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
            children: /*#__PURE__*/jsxRuntime.jsx("div", {
              className: "progress-bar-percent ".concat(initStyle, " "),
              style: {
                width: "".concat(this.props.value / this.props.total * 100, "%"),
                height: '100%',
                backgroundColor: this.props.color || 'var(--primary)'
              },
              children: /*#__PURE__*/jsxRuntime.jsx("div", {
                className: 'inner',
                children: this.formatter(this.props.value)
              })
            })
          }) : /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
            children: [/*#__PURE__*/jsxRuntime.jsx("div", {
              className: "progress-bar-percent ".concat(initStyle, " "),
              style: {
                width: "".concat(this.props.value / this.props.total * 100, "%"),
                height: '100%',
                backgroundColor: this.props.color || 'var(--primary)'
              }
            }), /*#__PURE__*/jsxRuntime.jsx("div", {
              className: 'outer',
              children: this.formatter(this.props.value)
            })]
          })
        });
      }

      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "progress-bar ".concat(this.props.className),
        style: {
          width: '100%'
        },
        children: [/*#__PURE__*/jsxRuntime.jsxs("span", {
          children: [this.props.value, " / ", this.props.total]
        }), /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "progress-bar-value ".concat(initStyle, " "),
          style: {
            width: "".concat(percent, "%")
          }
        })]
      });
    }
  }]);

  return ProgressBar;
}(React.Component);
ProgressBar.propTypes = {
  className: PropTypes__default['default'].string,
  value: PropTypes__default['default'].number,
  total: PropTypes__default['default'].number,
  percent: PropTypes__default['default'].bool,
  color: PropTypes__default['default'].string
};
ProgressBar.defaultProps = {
  className: ''
};

var formatCurrency$1 = function formatCurrency(number, locale) {
  switch (locale) {
    case 'vi':
      {
        var parts = number.toString().split('.');
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, '.');
        return parts.join('.') + 'đ';
      }

    default:
      {
        var _parts = number.toString().split('.');

        _parts[0] = _parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        return '$' + _parts.join('.');
      }
  }
}; // format: \# or #.## or #,##


var formatNumeric$1 = function formatNumeric(number, format) {
  switch (format) {
    case '#,##':
      return Number(number).toFixed(2).toString().replaceAll('.', ',');

    case '#.##':
      return Number(number).toFixed(2);

    default:
      return number;
  }
};

var typeA = ['select', 'date', 'datetime'];

var DataGridCell = function DataGridCell(props) {
  var definition = props.definition,
      content = props.content,
      style = props.style,
      editable = props.editable,
      onDataChanged = props.onDataChanged,
      getNumOfEditableFieldsPerRow = props.getNumOfEditableFieldsPerRow;
      props.onSelect;
  var _definition$locale = definition.locale,
      locale = _definition$locale === void 0 ? 'vi' : _definition$locale,
      format = definition.format,
      options = definition.options;
  var schema = definition.schema;

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      hasInput = _useState2[0],
      setHasInput = _useState2[1];

  var _useState3 = React.useState(content),
      _useState4 = _slicedToArray(_useState3, 2),
      value = _useState4[0],
      setValue = _useState4[1];

  var _useState5 = React.useState(!typeA.includes(schema)),
      _useState6 = _slicedToArray(_useState5, 2),
      focus = _useState6[0],
      setFocus = _useState6[1];

  var contentRef = React.useRef(null);
  var editingRef = React.useRef(false);
  React.useEffect(function () {
    return setValue(content);
  }, [content]);
  React.useEffect(function () {
    editingRef.current = hasInput && focus;
  }, [hasInput, focus]);
  React.useEffect(function () {
    if (!hasInput && value !== content && !typeA.includes(schema) && schema !== 'boolean') {
      onDataChanged && onDataChanged(definition.uniqueId, value);
    }
  }, [hasInput]);
  React.useEffect(function () {
    if (contentRef.current) {
      var element = contentRef.current.parentNode;
      element.addEventListener('focus', handleFocus);
    }

    return function () {
      if (contentRef.current) {
        var _element = contentRef.current.parentNode;

        _element.removeEventListener('focus', handleFocus);
      }
    };
  }, [contentRef]); // HANDLE AFTER FOCUSING AN ELEMENT

  var handleFocus = function handleFocus(event) {
    var prevSelectedElements = Array.from(document.querySelectorAll('.dg-cell.editable.selected-field'));
    prevSelectedElements.map(function (element) {
      return element.classList.remove('selected-field');
    });

    if (!editable) {
      return;
    }

    var curClassList = event.target.classList;

    if (curClassList.value.includes('dg-cell editable')) {
      curClassList.add('selected-field');
      setKeyDown(true, event.target);
    }

    if (typeA.includes(schema)) {
      event.target.addEventListener('mouseup', function () {
        return hasInput && setFocus(true);
      });
    }

    handleShowInput(event);
  }; // ADD/REMOVE EVENT KEYDOWN


  var setKeyDown = function setKeyDown() {
    var _contentRef$current;

    var turnOn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 ? void 0 : _contentRef$current.parentNode;

    if (!element) {
      return;
    }

    if (turnOn) {
      element.addEventListener('keydown', handleKeyDown);
      return;
    }

    element.removeEventListener('keydown', handleKeyDown);
  };

  var handleKeyDown = function handleKeyDown(event) {
    var key = event.which || event.code || event.keyCode;
    var enterKey = key === 13 || key === 'Enter';

    if (editingRef.current) {
      var active = key === 'Tab' || key === 9 || key === 'Escape' || key === 27 || enterKey || schema === 'boolean';
      active && handleFocusByKey(key, function () {
        return event.preventDefault();
      }, true);
      return;
    } // If schema is 'select' or 'date', 'Enter' key is used to open option list.


    if (typeA.includes(schema)) {
      if (enterKey) {
        event.stopImmediatePropagation();
        setFocus(true, handleShowInput(event), handleDateSchema());
      }
    } else if (schema === 'boolean') {
      if (enterKey) {
        event.stopImmediatePropagation();
        setFocus(!value, handleShowInput(event));
      }
    } else if (event.key.length === 1 && !event.ctrlKey && !event.metaKey || enterKey) {
      !enterKey && setValue(event.key);
      setHasInput(true);
    } // Handle 'Arrow' key.


    !enterKey && handleFocusByKey(key, function () {
      return event.preventDefault();
    });
  };

  var handleFocusByKey = function handleFocusByKey(key, callBack) {
    var editing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var editableFields = Array.from(document.querySelectorAll('.dg-cell.editable'));
    var curFieldIndex = editableFields.findIndex(function (field) {
      return field.classList.value.includes('selected-field');
    });
    var numOfEditableField = getNumOfEditableFieldsPerRow();

    if (curFieldIndex < 0 || numOfEditableField === 0 || editableFields.length === 0) {
      return;
    }

    callBack && callBack(); // ESCAPE

    if (key === 'Escape' || key === 27) {
      handleDateSchema(false);
      setValue(content);
      editingRef.current = false;
      editableFields[curFieldIndex].focus();
    } // KEY ENTER WHEN EDITING


    if ((key === 13 || key === 'Enter') && editing) {
      if (typeA.includes(schema)) {
        setFocus(false);
        return;
      }

      if (schema === 'boolean') {
        setValue(!value);
        return;
      }
    } // KEY UP


    if (key === 'ArrowUp' || key === 38) {
      var switchedField = editableFields[curFieldIndex - numOfEditableField];
      switchedField && switchedField.focus();
    } // KEY DOWN & ENTER


    if (key === 'ArrowDown' || key === 40 || key === 13 || key === 'Enter') {
      var _switchedField = editableFields[curFieldIndex + numOfEditableField];

      if (_switchedField) {
        _switchedField.focus();

        return;
      }

      editableFields[curFieldIndex].focus();
    }

    if (numOfEditableField === 1) {
      return;
    } // KEY LEFT


    if ((key === 'ArrowLeft' || key === 37) && curFieldIndex % numOfEditableField !== 0) {
      var _switchedField2 = editableFields[curFieldIndex - 1];
      _switchedField2 && _switchedField2.focus();
    } // KEY RIGHT & TAB


    if ((key === 'Tab' || key === 9 || key === 'ArrowRight' || key === 39) && (curFieldIndex + 1) % numOfEditableField !== 0) {
      var _switchedField3 = editableFields[curFieldIndex + 1];
      _switchedField3 && _switchedField3.focus();
    }
  };

  var handleShowInput = function handleShowInput(event) {
    if (typeA.includes(schema) || schema === 'boolean') {
      setHasInput(true);
    } else {
      event.target.addEventListener('dblclick', handleDbClick);
    }

    event.target.addEventListener('blur', handleBlur);
  };

  var handleDbClick = function handleDbClick(event) {
    event.preventDefault();
    setHasInput(true);
  };

  var handleBlur = function handleBlur(event) {
    var curTarget = event.relatedTarget;
    var dynamicField = curTarget && curTarget.classList.value.includes('input-editable');
    var isClose = !curTarget || curTarget && curTarget !== event.target && !dynamicField;
    var test = checkEditor(curTarget);

    if (typeA.includes(schema)) {
      if (schema === 'date' && test) {
        handleDateSchema();
      } // If current target is AdvanceSelect, add blur event.


      if (test) {
        curTarget.addEventListener('blur', function () {
          editingRef.current = false;
          contentRef.current.parentNode.focus();
          setFocus(false);
        });
      } // Closing editor if current target isn't AdvanceSelect or is null


      if (isClose && !test) {
        handleClose();
        setFocus(false);
        return;
      } // If AdvanceSelect or DatePicker Overlay are visible, not focus cell;


      var hasOverlay = schema === 'date' ? document.querySelectorAll('.m-input-moment').length > 0 : document.querySelectorAll('.as-dropdown-container').length > 0;

      if (!hasOverlay) {
        event.target.focus();
      }

      return;
    }

    if (schema === 'boolean') {
      var checkbox = curTarget && curTarget.tagName === 'INPUT' && curTarget.type === 'checkbox';
      isClose && !checkbox && handleClose();
    } // If current target isn't editor, close editor.


    !dynamicField && handleClose();
  };

  var handleClose = function handleClose() {
    var selectedCells = Array.from(document.querySelectorAll('.selected-field'));
    selectedCells.forEach(function (field) {
      return field.classList.remove('selected-field');
    });
    setHasInput(false);
  };

  var handleChangeDone = function handleChangeDone(val) {
    if (val !== undefined && val !== value) {
      if (typeA.includes(schema) || schema === 'boolean') {
        onDataChanged && onDataChanged(definition.uniqueId, val);
      }

      setValue(val);

      if (typeA.includes(schema)) {
        setFocus(false);
        contentRef.current.parentNode.focus();
      }
    }
  };

  var checkEditor = function checkEditor(element) {
    var _element$classList;

    if (!element) {
      return false;
    }

    var list = ['as-dropdown-container', 'as-container', 'dtp-container', 'input-editable', 'm-input-moment'];
    var classValue = (_element$classList = element.classList) === null || _element$classList === void 0 ? void 0 : _element$classList.value;
    var result = list.some(function (cls) {
      return classValue === null || classValue === void 0 ? void 0 : classValue.includes(cls);
    });

    if (!result && element.parentNode) {
      return checkEditor(element.parentNode);
    }

    return result;
  };

  var handleDateSchema = function handleDateSchema() {
    var focusMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    if (schema !== 'date') {
      return;
    }

    if (!focusMode) {
      var overlay = document.getElementById('modalRoot');
      overlay && overlay.parentNode.removeChild(overlay);
      return;
    }

    var datePicker;
    var intervelTime = setInterval(function () {
      datePicker = document.querySelectorAll('.m-input-moment')[0];

      if (datePicker) {
        clearInterval(intervelTime);
        datePicker.tabIndex = 1;
        datePicker.focus();
        datePicker.addEventListener('keydown', function (event) {
          event.preventDefault();
          var key = event.which || event.code || event.keyCode;
          (key === 'Escape' || key === 27) && handleFocusByKey(key);
        });
      }
    }, 5);
  };

  if (!hasInput || !editable || schema === 'boolean') {
    switch (schema) {
      case 'boolean':
        return /*#__PURE__*/jsxRuntime.jsxs("div", {
          ref: contentRef,
          className: 'boolean',
          children: [value ? /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
            className: 'checkbox-icon',
            icon: 'check',
            size: '.75rem',
            color: 'var(--primary-color)'
          }) : /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {}), /*#__PURE__*/jsxRuntime.jsx(CheckBox, {
            className: "checkbox-field",
            checked: value,
            disabled: !editable,
            onChange: handleChangeDone
          })]
        });

      case 'currency':
        return /*#__PURE__*/jsxRuntime.jsx("div", {
          ref: contentRef,
          className: 'number',
          style: style,
          children: formatCurrency$1(content, locale)
        });

      case 'datetime':
      case 'date':
        return /*#__PURE__*/jsxRuntime.jsx("div", {
          ref: contentRef,
          className: "datetime",
          children: /*#__PURE__*/jsxRuntime.jsx("span", {
            className: "date",
            children: moment__default['default'](value).isValid() ? moment__default['default'](value).format(format || (schema === 'date' ? 'L' : 'L LT')) : ''
          })
        });

      case 'numeric':
        return /*#__PURE__*/jsxRuntime.jsx("div", {
          ref: contentRef,
          className: 'number',
          style: style,
          children: formatNumeric$1(content, format)
        });

      case 'json':
        return content ? JSON.stringify(content) : null;

      case 'link':
        return /*#__PURE__*/jsxRuntime.jsx("span", {
          ref: contentRef,
          children: /*#__PURE__*/jsxRuntime.jsx(Link, {
            href: value !== null && value !== void 0 ? value : '#',
            children: value
          })
        });

      case 'select':
        {
          var _option$size;

          var option = options === null || options === void 0 ? void 0 : options.find(function (option) {
            return option.id === value;
          });
          return option ? /*#__PURE__*/jsxRuntime.jsx("span", {
            ref: contentRef,
            children: option.color ? /*#__PURE__*/jsxRuntime.jsx(Tag, {
              textCase: 'sentence',
              text: option.label,
              color: option.color,
              size: (_option$size = option.size) !== null && _option$size !== void 0 ? _option$size : 'medium',
              textStyle: _objectSpread2(_objectSpread2({}, style), {}, {
                color: option.textColor
              }),
              isRound: true
            }) : /*#__PURE__*/jsxRuntime.jsx("div", {
              children: option.label
            })
          }) : /*#__PURE__*/jsxRuntime.jsx("span", {
            ref: contentRef,
            children: value
          });
        }

      case 'multi-select':
        return options === null || options === void 0 ? void 0 : options.filter(function (option) {
          return content === null || content === void 0 ? void 0 : content.includes(option.id);
        }).map(function (option) {
          return /*#__PURE__*/jsxRuntime.jsx(Tag, {
            textCase: 'sentence',
            text: option === null || option === void 0 ? void 0 : option.label,
            color: option === null || option === void 0 ? void 0 : option.color,
            textStyle: _objectSpread2(_objectSpread2({}, style), {}, {
              color: option === null || option === void 0 ? void 0 : option.textColor
            }),
            isRound: true
          }, option === null || option === void 0 ? void 0 : option.id);
        });

      case 'image':
        return /*#__PURE__*/jsxRuntime.jsx("div", {
          children: /*#__PURE__*/jsxRuntime.jsx(Image$1, {
            width: definition.imageWidth,
            height: definition.imageHeight || '70px',
            src: content,
            fitMode: "contain",
            canEnlarge: true
          })
        });

      case 'react-node':
        return /*#__PURE__*/jsxRuntime.jsx(Container, {
          children: content || null
        });

      case 'chart':
        return /*#__PURE__*/jsxRuntime.jsx(DataGridChartCell, {
          content: content,
          options: definition
        });

      case 'progress':
        return /*#__PURE__*/jsxRuntime.jsx("div", {
          children: /*#__PURE__*/jsxRuntime.jsx(ProgressBar, {
            total: content.max,
            value: content.value,
            color: content.bgColor,
            percent: true
          })
        });

      default:
        return /*#__PURE__*/jsxRuntime.jsx("div", {
          ref: contentRef,
          style: style,
          className: 'text',
          children: value
        });
    }
  }

  return /*#__PURE__*/jsxRuntime.jsx("div", _objectSpread2(_objectSpread2({
    ref: contentRef,
    className: "dynamic-container"
  }, schema === 'boolean' ? {
    onMouseLeave: function onMouseLeave() {
      return setHasInput(false);
    }
  } : {}), {}, {
    children: /*#__PURE__*/jsxRuntime.jsx(DynamicField, _objectSpread2(_objectSpread2({}, typeA.includes(schema) ? {
      key: "".concat(definition.uniqueId, "--").concat(focus)
    } : {}), {}, {
      schema: exports.DataTypes[schema[0].toUpperCase() + schema.slice(1)],
      value: value,
      className: 'input-editable',
      options: options,
      autoFocus: focus,
      changeImmediately: true,
      onChange: handleChangeDone,
      onClose: handleBlur
    }))
  }));
};

// Used in DataToolbar
var DATA_TYPE = {
  "boolean": 1,
  integer: 2,
  string: 3,
  "float": 4,
  datetime: 5,
  text: 6,
  location: 7,
  document: 8,
  array: 10
}; // Used in DataGrid

var SCHEMAS$1 = ['boolean', 'currency', 'datetime', 'date', 'numeric', 'select', 'multi-select', 'image', 'link', 'json', 'react-node', 'chart'];
/**
 * Functions
 */

var getOperators$1 = function getOperators(dataTypeId) {
  var operators = [];

  switch (dataTypeId) {
    case DATA_TYPE.integer:
    case DATA_TYPE["float"]:
    case DATA_TYPE.datetime:
      operators = [{
        id: '=',
        label: '='
      }, {
        id: '>',
        label: '>'
      }, {
        id: '<',
        label: '<'
      }, {
        id: '>=',
        label: '>='
      }, {
        id: '<=',
        label: '<='
      }, {
        id: 'between',
        label: 'Giữa'
      }];
      break;

    case DATA_TYPE.string:
    case DATA_TYPE.text:
    case DATA_TYPE.document:
      operators = [{
        id: '=',
        label: 'Bằng'
      }, {
        id: 'like',
        label: 'Giống'
      }, {
        id: 'is null',
        label: 'Rỗng'
      }, {
        id: 'is not null',
        label: 'Không rỗng'
      }];
      break;

    case DATA_TYPE["boolean"]:
    case DATA_TYPE.array:
      operators = [{
        id: '=',
        label: 'Bằng'
      }, {
        id: 'like',
        label: 'Giống'
      }];
      break;
  }

  return operators;
};
var getDataType = function getDataType(schema) {
  switch (schema) {
    case 'currency':
    case 'numeric':
      return DATA_TYPE.integer;

    case 'datetime':
    case 'date':
      return DATA_TYPE.datetime;

    case 'boolean':
      return DATA_TYPE["boolean"];

    case 'select':
    case 'multi-select':
      return DATA_TYPE.array;

    case 'react-node':
    case 'chart':
      return '';

    case 'image':
    case 'link':
    case 'json':
    default:
      return DATA_TYPE.string;
  }
};
var isFilterActive = function isFilterActive(filter) {
  if (!filter) {
    return false;
  }

  var keys = Object.keys(filter);

  if (!keys.includes('columnName') || !keys.includes('dataType') || !keys.includes('operator') || !keys.includes('value')) {
    return false;
  }

  switch (filter.dataType) {
    case DATA_TYPE.integer:
    case DATA_TYPE["float"]:
    case DATA_TYPE.datetime:
      if (filter.operator === 'between') {
        if (isEmpty(filter.value)) {
          return false;
        }

        var valueArr = filter.value.split('AND', 2);

        if (valueArr.length < 2) {
          return false;
        }

        return !isEmpty(valueArr[0]) && !isEmpty(valueArr[1]);
      }

      return !isEmpty(filter.operator) && !isEmpty(filter.value);

    case DATA_TYPE.string:
    case DATA_TYPE.text:
    case DATA_TYPE.document:
    case DATA_TYPE["boolean"]:
    case DATA_TYPE.array:
      if (filter.operator === 'is null' || filter.operator === 'is not null') {
        return true;
      }

      return !isEmpty(filter.value);

    default:
      return false;
  }
};

var isEmpty = function isEmpty(value) {
  if (value === undefined || value === null || value === '') {
    return true;
  }

  if (typeof value === 'boolean') {
    return false;
  }

  if (_typeof(value) === 'object') {
    return Object.keys(value).length === 0;
  }
};

var FilterValue = function FilterValue(props) {
  var renderBooleanValueFilter = function renderBooleanValueFilter(filter) {
    return /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
      options: [{
        id: true,
        label: 'Có'
      }, {
        id: false,
        label: 'Không'
      }],
      placeholder: 'Chọn giá trị',
      value: filter.value,
      onChange: props.onChange
    });
  };

  var renderNumberValueFilter = function renderNumberValueFilter(filter) {
    var typeInput = filter.dataType === DATA_TYPE.datetime ? 'date' : 'number';

    if (filter.operator !== 'between') {
      return renderInput(filter, typeInput);
    } else {
      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: 'field-value-between-date',
        children: [renderInput(filter, typeInput, 'from'), /*#__PURE__*/jsxRuntime.jsx(TB1, {
          children: "V\xE0"
        }), renderInput(filter, typeInput, 'to')]
      });
    }
  };

  var renderInput = function renderInput(filter) {
    var typeInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';
    var betweenType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

    var _ref = betweenType ? filter.value.split('AND') : [null, null],
        _ref2 = _slicedToArray(_ref, 2),
        fromData = _ref2[0],
        toData = _ref2[1];

    var value;

    if (betweenType && betweenType === 'from') {
      value = fromData;
    }

    if (betweenType && betweenType === 'to') {
      value = toData;
    }

    return /*#__PURE__*/jsxRuntime.jsx(Input, {
      className: 'form-control data-filter-value',
      height: '100%',
      type: typeInput,
      placeholder: 'Nhập giá trị',
      value: betweenType ? value.split(' ').join('') : filter.value,
      onChange: function onChange(value) {
        return props.onChange(value, betweenType);
      }
    });
  };

  var renderSpecialValueFilter = function renderSpecialValueFilter(filter, config) {
    if (filter.columnName.includes('ID')) {
      return renderInput(filter);
    } else {
      var valueOptions = (config || []).map(function (f) {
        return {
          id: f === null || f === void 0 ? void 0 : f.Value,
          label: f === null || f === void 0 ? void 0 : f.Display
        };
      });
      return /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
        options: valueOptions,
        placeholder: 'Chọn giá trị',
        value: filter.value,
        onChange: props.onChange
      });
    }
  };

  var renderValueFilter = function renderValueFilter(filter, config) {
    if (filter.operator === 'is null' || filter.operator === 'is not null') {
      return null;
    }

    switch (filter.dataType) {
      case DATA_TYPE["boolean"]:
        return renderBooleanValueFilter(filter);

      case DATA_TYPE.integer:
      case DATA_TYPE["float"]:
      case DATA_TYPE.datetime:
        return renderNumberValueFilter(filter);

      case DATA_TYPE.string:
      case DATA_TYPE.text:
      case DATA_TYPE.document:
        return renderInput(filter);

      case DATA_TYPE.array:
        return renderSpecialValueFilter(filter, config);

      default:
        return null;
    }
  };

  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: props.visible && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'data-filter-value',
      children: renderValueFilter(props.filter, props.config)
    })
  });
};
FilterValue.propTypes = {
  visible: PropTypes__default['default'].bool,
  filter: PropTypes__default['default'].object,
  config: PropTypes__default['default'].array,
  onChange: PropTypes__default['default'].func
};

var FilterInput = function FilterInput(props) {
  var _useState = React.useState(props.filter || {}),
      _useState2 = _slicedToArray(_useState, 2),
      filter = _useState2[0],
      setFilter = _useState2[1];

  var filterDebounce = AwesomeDebouncePromise__default['default'](function (value) {
    return props.onFilterChange(value);
  }, 300); // Functions support standalone usage

  var handleChangeOperator = function handleChangeOperator(value) {
    if (!props.isStandalone) {
      props.onChangeOperator && props.onChangeOperator(value, props.index);
    } else {
      var newFilter = _objectSpread2({}, filter);

      newFilter.operator = value;

      if (value === 'between') {
        newFilter.value = 'AND';
      }

      setFilter(newFilter);

      if ((value === 'like' || value === '=' || newFilter.dataType === DATA_TYPE.datetime) && (!newFilter.value || newFilter.value === 'AND')) {
        return;
      }

      props.onFilterChange && filterDebounce(newFilter);
    }
  };

  var handleChangeFilterValue = function handleChangeFilterValue(value, betweenType) {
    if (!props.isStandalone) {
      props.onChangeFilterValue && props.onChangeFilterValue(value, betweenType);
    } else {
      var _newFilter$value;

      var newFilter = _objectSpread2({}, filter);

      if (filter.operator !== 'between') {
        newFilter.value = value;
      } else {
        var _filter$value;

        var _filter$value$split = (_filter$value = filter.value) === null || _filter$value === void 0 ? void 0 : _filter$value.split('AND', 2),
            _filter$value$split2 = _slicedToArray(_filter$value$split, 2),
            fromData = _filter$value$split2[0],
            toData = _filter$value$split2[1];

        if (betweenType === 'from') {
          fromData = value;
        }

        if (betweenType === 'to') {
          toData = value;
        }

        newFilter.value = "".concat(fromData, "AND").concat(toData);
      }

      setFilter(newFilter);

      if (newFilter.operator === 'non-select' || newFilter.operator === 'between' && ((_newFilter$value = newFilter.value) === null || _newFilter$value === void 0 ? void 0 : _newFilter$value.split('AND').filter(function (item) {
        return item;
      }).length) < 2) {
        return;
      }

      props.onFilterChange && filterDebounce(newFilter);
    }
  }; // FilterInput hold Filter object when standalone


  var usingFilter = props.isStandalone ? filter : props.filter || {};
  var combination = usingFilter.combination,
      columnName = usingFilter.columnName,
      operator = usingFilter.operator,
      dataType = usingFilter.dataType;
  var operators = props.operators || getOperators$1(dataType);
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: "data-filter-input ".concat(props.showVertical ? 'vertical' : 'horizontal'),
    children: [!props.isStandalone && /*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
      icon: 'times',
      iconSize: "md",
      iconColor: 'var(--contrast-color)',
      onlyIcon: true,
      onClick: function onClick() {
        return props.onRemove(props.index);
      }
    }), !props.isStandalone && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'data-filter-combine',
      children: /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
        disabled: props.index === 0,
        options: props.combinations || [],
        value: combination,
        onChange: function onChange(value) {
          return props.onChangeCombination && props.onChangeCombination(value, props.index);
        }
      })
    }), !props.isStandalone && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'data-filter-columnName',
      children: /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
        width: '11rem',
        options: props.columnNames || [],
        value: columnName,
        placeholder: 'Chọn thuộc tính',
        onChange: function onChange(value) {
          return props.onChangeColumnName && props.onChangeColumnName(value, props.index);
        }
      })
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'data-filter-condition',
      children: /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
        width: '11rem',
        clearable: props.clearable,
        disabled: operators && operators.length === 1,
        options: operators,
        value: operator,
        placeholder: 'Chọn toán tử',
        onChange: handleChangeOperator
      })
    }), /*#__PURE__*/jsxRuntime.jsx(FilterValue, {
      visible: Boolean(operator),
      filter: usingFilter,
      config: props.config,
      onChange: handleChangeFilterValue
    })]
  });
};
FilterInput.propTypes = {
  // For using as standalone Input
  isStandalone: PropTypes__default['default'].bool,
  onFilterChange: PropTypes__default['default'].func,
  showVertical: PropTypes__default['default'].bool,
  clearable: PropTypes__default['default'].bool,
  // For using as Filter rows
  index: PropTypes__default['default'].number,
  combinations: PropTypes__default['default'].array,
  columnNames: PropTypes__default['default'].array,
  operators: PropTypes__default['default'].array,
  onRemove: PropTypes__default['default'].func,
  onChangeCombination: PropTypes__default['default'].func,
  onChangeColumnName: PropTypes__default['default'].func,
  onChangeOperator: PropTypes__default['default'].func,
  onChangeFilterValue: PropTypes__default['default'].func,
  // For both
  config: PropTypes__default['default'].arrayOf(PropTypes__default['default'].shape({
    Value: PropTypes__default['default'].string,
    Display: PropTypes__default['default'].string
  })),
  filter: PropTypes__default['default'].shape({
    combination: PropTypes__default['default'].string,
    dataType: PropTypes__default['default'].oneOf(Object.values(DATA_TYPE)),
    columnName: PropTypes__default['default'].string,
    operator: PropTypes__default['default'].string,
    value: PropTypes__default['default'].any
  })
};

var ResizeableHeader = function ResizeableHeader(props) {
  var id = props.id,
      width = props.width,
      displayAsText = props.displayAsText,
      schema = props.schema,
      style = props.style,
      isResizable = props.isResizable,
      onResize = props.onResize,
      isDraggable = props.isDraggable,
      display = props.display,
      defaultSortDirection = props.defaultSortDirection,
      isSortable = props.isSortable,
      sortDirection = props.sortDirection,
      _onClick = props.onClick,
      filter = props.filter,
      onFilterChange = props.onFilterChange,
      freeze = props.freeze,
      freezeEnd = props.freezeEnd,
      options = props.options;
  var filterButtonRef = React.useRef();

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isOpeningFilterPopover = _useState2[0],
      setOpeningFilterPopover = _useState2[1];

  var _useState3 = React.useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      resizing = _useState4[0],
      setResizing = _useState4[1]; // ADD


  React.useEffect(function () {
    defaultSortDirection && _onClick({
      id: id,
      direction: defaultSortDirection
    });
  }, []);
  var cond = filter && filter.conditions.find(function (f) {
    return f.columnName === id;
  });
  var mappedOptions = schema && getDataType(schema) === 10 ? options === null || options === void 0 ? void 0 : options.map(function (option) {
    return {
      Display: option.color ? /*#__PURE__*/jsxRuntime.jsx(Tag, {
        text: option.label,
        color: option.color,
        textStyle: {
          color: option.textColor
        },
        isRound: true
      }) : option.label,
      Value: option.id
    };
  }) : null;

  var mappedFilter = _objectSpread2(_objectSpread2({}, cond), {}, {
    columnName: id || '',
    dataType: getDataType(schema === 'select' && (!mappedOptions || mappedOptions && !mappedOptions.length) ? 'text' : schema)
  });

  var MAPPED_SORT_ICONS = {
    asc: 'arrow-up',
    desc: 'arrow-down'
  };

  var plainHeader = /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: "dg-header-item ".concat(freeze ? 'dg-freeze' : '', " ").concat(freezeEnd ? 'dg-freeze-end' : '', " ").concat(isSortable ? 'dg-header-sort' : '', " ").concat(sortDirection ? 'dg-header-sorting' : ''),
    style: _objectSpread2({}, style),
    children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
      className: 'dg-cell',
      onClick: function onClick() {
        return isSortable && _onClick({
          id: id,
          direction: changeSortDirection(sortDirection)
        });
      },
      children: [/*#__PURE__*/jsxRuntime.jsxs(Box, {
        children: [/*#__PURE__*/jsxRuntime.jsx(T, {
          children: display || displayAsText
        }), MAPPED_SORT_ICONS[sortDirection] && (isSortable || defaultSortDirection) && /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          icon: MAPPED_SORT_ICONS[sortDirection],
          type: 'solid',
          size: '1rem',
          className: 'dg-header-sort-icon'
        })]
      }), /*#__PURE__*/jsxRuntime.jsx(Flex, {
        shrink: 0,
        item: true,
        children: filter && /*#__PURE__*/jsxRuntime.jsx("div", {
          ref: filterButtonRef,
          className: "cell-filter-icon ".concat(isFilterActive(cond) ? 'active' : 'inactive'),
          children: /*#__PURE__*/jsxRuntime.jsx(IconButton, {
            icon: "filter",
            iconType: "solid",
            size: "xs",
            iconSize: "sm",
            color: "".concat(isFilterActive(cond) ? 'primary' : 'default'),
            variant: "empty",
            isRound: true,
            onClick: function onClick(e) {
              e.stopPropagation();
              setOpeningFilterPopover(true);
            }
          })
        })
      })]
    }), isOpeningFilterPopover && /*#__PURE__*/jsxRuntime.jsx(PopOver, {
      anchorEl: filterButtonRef,
      onBackgroundClick: function onBackgroundClick() {
        return setOpeningFilterPopover(false);
      },
      children: /*#__PURE__*/jsxRuntime.jsx(FilterInput, {
        filter: mappedFilter,
        config: mappedOptions,
        isStandalone: true,
        showVertical: true,
        clearable: true,
        isChangedOnConfirm: true,
        onFilterChange: onFilterChange
      })
    })]
  });

  function changeSortDirection(direction) {
    switch (direction) {
      case 'asc':
        return 'desc';

      case 'desc':
        return undefined;

      default:
        return 'asc';
    }
  }

  if (!isResizable) {
    return plainHeader;
  }

  return /*#__PURE__*/jsxRuntime.jsx(reactResizable.Resizable, {
    width: width,
    height: 0,
    draggable: isDraggable && !resizing,
    onResizeStart: function onResizeStart() {
      return setResizing(true);
    },
    onResizeStop: function onResizeStop() {
      return setResizing(false);
    },
    onResize: onResize,
    children: plainHeader
  });
};

ResizeableHeader.propTypes = {
  id: PropTypes__default['default'].string,
  style: PropTypes__default['default'].object,
  displayAsText: PropTypes__default['default'].string,
  isResizable: PropTypes__default['default'].bool,
  isDraggable: PropTypes__default['default'].bool,
  width: PropTypes__default['default'].number,
  format: PropTypes__default['default'].string,
  // use ### for numbers, ISO format for date time
  schema: PropTypes__default['default'].oneOf(SCHEMAS$1),
  // A Schema to use for the column. Can be expanded by defining your own
  locale: PropTypes__default['default'].oneOf(['vi']),
  display: PropTypes__default['default'].node,
  // A ReactNode used when rendering the column header. When providing complicated content, please make sure to utilize CSS to respect truncation as space allows.
  onClick: PropTypes__default['default'].func,
  onResize: PropTypes__default['default'].func,
  // Sorting
  isSortable: PropTypes__default['default'].bool,
  defaultSortDirection: PropTypes__default['default'].oneOf(['asc', 'desc']),
  sortDirection: PropTypes__default['default'].oneOf(['asc', 'desc']),
  // Filters
  filter: PropTypes__default['default'].shape({
    conditions: PropTypes__default['default'].arrayOf(PropTypes__default['default'].shape({
      operator: PropTypes__default['default'].string,
      value: PropTypes__default['default'].any,
      options: PropTypes__default['default'].array // select: [{id, label, color}]

    })),
    onChange: PropTypes__default['default'].func
  }),
  onFilterChange: PropTypes__default['default'].func,
  // not implement yet but nice to have
  isExpandable: PropTypes__default['default'].bool // Defaults to true. Defines whether or not the column's cells can be expanded with a popup onClick / keydown.

};
ResizeableHeader.defaultProps = {
  isResizable: true,
  isDraggable: true,
  width: 50
};

var DataGridSummaryCell = function DataGridSummaryCell(props) {
  var col = props.col,
      style = props.style,
      items = props.items,
      className = props.className;

  var _ref = col.summary || {},
      label = _ref.label,
      formula = _ref.formula;

  var _useState = React.useState(''),
      _useState2 = _slicedToArray(_useState, 2),
      result = _useState2[0],
      setResult = _useState2[1];

  var colItems = items.map(function (row) {
    return row[col.id];
  });

  var sum = function sum() {
    return colItems.reduce(function (pre, cur) {
      return pre += cur;
    }, 0);
  };

  var calcSummary = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(typeof formula === 'function')) {
                _context.next = 6;
                break;
              }

              _context.t0 = setResult;
              _context.next = 4;
              return formula(colItems);

            case 4:
              _context.t1 = _context.sent;
              return _context.abrupt("return", (0, _context.t0)(_context.t1));

            case 6:
              if (!(typeof formula === 'string')) {
                _context.next = 12;
                break;
              }

              _context.t2 = formula;
              _context.next = _context.t2 === 'average' ? 10 : 11;
              break;

            case 10:
              return _context.abrupt("return", setResult(sum() / colItems.length));

            case 11:
              return _context.abrupt("return", setResult(sum()));

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function calcSummary() {
      return _ref2.apply(this, arguments);
    };
  }();

  React.useEffect(function () {
    calcSummary();
  }, [formula]);
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: clsx__default['default']('dg-footer-item', className),
    style: style,
    children: /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "dg-cell",
      children: formula && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [label ? label + ': ' : '', /*#__PURE__*/jsxRuntime.jsx(DataGridCell, {
          definition: col,
          content: "".concat(result)
        })]
      })
    })
  });
};
DataGridSummaryCell.propTypes = {
  col: PropTypes__default['default'].object,
  style: PropTypes__default['default'].object,
  items: PropTypes__default['default'].array,
  className: PropTypes__default['default'].string
};

var DataGrid = function DataGrid(props) {
  var columns = props.columns,
      sorting = props.sorting,
      leadingControlColumns = props.leadingControlColumns,
      trailingControlColumns = props.trailingControlColumns,
      rowNumber = props.rowNumber,
      pagination = props.pagination,
      loading = props.loading,
      summary = props.summary,
      selectRows = props.selectRows,
      onRowClick = props.onRowClick,
      onCellClick = props.onCellClick,
      onCellDoubleClick = props.onCellDoubleClick,
      onDataChanged = props.onDataChanged,
      onColumnsVisibilityChanged = props.onColumnsVisibilityChanged,
      selectedRow = props.selectedRow,
      border = props.border,
      stripes = props.stripes;

  var _useState = React.useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      cols = _useState2[0],
      setCols = _useState2[1];

  var _useState3 = React.useState(true),
      _useState4 = _slicedToArray(_useState3, 2);
      _useState4[0];
      var setHideCols = _useState4[1];

  var _useState5 = React.useState(''),
      _useState6 = _slicedToArray(_useState5, 2);
      _useState6[0];
      var setDragOver = _useState6[1];

  var _useState7 = React.useState(false),
      _useState8 = _slicedToArray(_useState7, 2),
      isLoading = _useState8[0],
      setIsLoading = _useState8[1];

  var _useState9 = React.useState(''),
      _useState10 = _slicedToArray(_useState9, 2),
      bodyWidth = _useState10[0],
      setBodyWidth = _useState10[1];

  var scrollRef = React.useRef();
  var numOfEditableFieldPerRowRef = React.useRef(0);

  var _containerRef = React.useRef();

  var headerRef = React.useRef();
  var items = React.useMemo(function () {
    return Array.isArray(props.items) && props.items.map(function (item) {
      var uniqueId = createUniqueId();
      var selected = true;

      if (selectedRow && Object.keys(selectedRow).length && item) {
        for (var key in selectedRow) {
          if (item[key] !== selectedRow[key]) {
            selected = false;
            break;
          }
        }
      } else {
        selected = false;
      }

      return _objectSpread2(_objectSpread2({}, item), {}, {
        uniqueId: uniqueId,
        selected: selected
      });
    }) || [];
  }, [props.items, selectedRow]);
  var borderStyle = 'row--';

  switch (border) {
    case 'vertical':
      borderStyle += 'vertical-border';
      break;

    case 'horizontal':
      borderStyle += 'horizontal-border';
      break;

    case 'all':
      borderStyle += 'border';
      break;

    default:
      borderStyle = '';
  }

  React.useEffect(function () {
    if (!columns || !columns.length) {
      return;
    }

    setCols(columns);
    countEditableFieldsPerRow(columns);
    var checkColumn = columns.find(function (col) {
      return !col.hidden;
    });
    setHideCols(checkColumn);
    onColumnsVisibilityChanged && onColumnsVisibilityChanged(columns);
  }, [columns]);
  React.useEffect(function () {
    if (headerRef.current && _containerRef.current) {
      _containerRef.current.scrollLeft = headerRef.current.scrollLeft;
    }
  }, [items]);
  React.useEffect(function () {
    var columns = [].concat(_toConsumableArray(cols), _toConsumableArray(leadingControlColumns || []), _toConsumableArray(trailingControlColumns || []), _toConsumableArray(autoNumberRows || []), _toConsumableArray(checkboxHeaderControl || []));
    var tableWidth = columns.reduce(function (pre, cur) {
      var _cur$width;

      return !cur.hidden ? pre + ((_cur$width = cur.width) !== null && _cur$width !== void 0 ? _cur$width : 0) : pre;
    }, 0);

    if (_containerRef.current) {
      var containerWidth = _containerRef.current.clientWidth;

      if (containerWidth - tableWidth > 0) {
        var unsetWidthCols = props.columns.filter(function (col) {
          return !col.width && !col.hidden;
        });

        if (unsetWidthCols.length > 0) {
          var width = Math.max((containerWidth - tableWidth) / unsetWidthCols.length, 200);
          unsetWidthCols.forEach(function (col) {
            return col.width = width;
          });
          tableWidth += width * unsetWidthCols.length;
        } else {
          props.columns[props.columns.length - 1].width = (props.columns[props.columns.length - 1].width || 0) + (containerWidth - tableWidth);
        }
      }
    }

    setBodyWidth(tableWidth); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [cols]);

  var countEditableFieldsPerRow = function countEditableFieldsPerRow(cols) {
    var filteredColumns = cols.filter(function (col) {
      return col.editable && !col.hidden;
    });

    if (filteredColumns.length !== numOfEditableFieldPerRowRef.current) {
      numOfEditableFieldPerRowRef.current = filteredColumns.length;
    }
  };

  var handleResize = function handleResize(index) {
    return function (e, _ref) {
      var size = _ref.size;

      var nextCols = _toConsumableArray(cols); // clone


      nextCols[index] = _objectSpread2(_objectSpread2({}, nextCols[index]), {}, {
        width: size.width
      });
      setCols(nextCols);
    };
  };

  var handleDragStart = function handleDragStart(e) {
    var id = e.target.id;
    var idx = cols.findIndex(function (i) {
      return i.id === id;
    });
    e.dataTransfer.setData('colIdx', idx);
  };

  var handleDragOver = function handleDragOver(e) {
    return e.preventDefault();
  };

  var handleDragEnter = function handleDragEnter(e) {
    var id = e.target.id;
    setDragOver(id);
  };

  var handleOnDrop = function handleOnDrop(e) {
    var id = e.target.id;

    if (!id) {
      id = e.target.parentNode.id; // fix element was dropped on resizable icon
    }

    var tempCols = _toConsumableArray(cols);

    var draggedColIdx = parseInt(e.dataTransfer.getData('colIdx'));
    var cutOut = tempCols.splice(draggedColIdx, 1)[0]; // cut the element at index 'draggedColIdx'

    var droppedColIdx = parseInt(tempCols.findIndex(function (i) {
      return i.id === id;
    })); // calculate new position of dragged element

    var rect = e.target.getBoundingClientRect();
    var isFirstHalf = e.clientX < rect.left + rect.width / 2;

    if (!isFirstHalf) {
      droppedColIdx += 1;
    }

    tempCols.splice(droppedColIdx, 0, cutOut); // insert it at index 'droppedColIdx'

    setCols(tempCols);
    setDragOver('');
  };

  function hideAllColumns() {
    setHideCols(false);
    setCols(cols === null || cols === void 0 ? void 0 : cols.map(function (col) {
      return _objectSpread2(_objectSpread2({}, col), {}, {
        hidden: true
      });
    }));
  }

  function showAllColumns() {
    setHideCols(true);
    setCols(cols === null || cols === void 0 ? void 0 : cols.map(function (col) {
      return _objectSpread2(_objectSpread2({}, col), {}, {
        hidden: false
      });
    }));
  }

  function defaultColumns() {
    setHideCols(true);
    setCols(columns === null || columns === void 0 ? void 0 : columns.map(function (col) {
      return _objectSpread2({}, col);
    }));
  }

  function toggleColumnVisibility(id) {
    var newCols = cols === null || cols === void 0 ? void 0 : cols.map(function (col) {
      if (col.id === id) {
        return _objectSpread2(_objectSpread2({}, col), {}, {
          hidden: !col.hidden
        });
      }

      return col;
    });
    setCols(newCols);
    countEditableFieldsPerRow(newCols);
    onColumnsVisibilityChanged && onColumnsVisibilityChanged(newCols);
  }

  var getPosition = function getPosition(col) {
    var freezeArr = cols.filter(function (col) {
      return col.freeze;
    });

    if (selectRows) {
      freezeArr.unshift({
        width: 50,
        id: 'auto_number_id'
      });
    }

    if (rowNumber) {
      freezeArr.unshift({
        width: 50,
        id: 'auto_checkbox_id'
      });
    }

    var index = freezeArr.findIndex(function (freeze) {
      return freeze.id === col.id;
    });
    var arrCopy = [];

    for (var i = 0; i < index; i++) {
      arrCopy.push(freezeArr[i]);
    }

    var sum = 0;
    var left = arrCopy.reduce(function (pre, cur) {
      return pre + cur.width;
    }, sum);
    return left;
  };

  var getCellStyle = function getCellStyle(col) {
    var style = {};

    if (col.width) {
      if (col.freeze) {
        style = {
          flex: "0 0 ".concat(col.width, "px"),
          maxWidth: col.width,
          left: getPosition(col)
        };
      } else {
        style = {
          flex: "0 0 ".concat(col.width, "px"),
          maxWidth: col.width
        };
      }
    } else {
      style = {
        flex: 1,
        minWidth: '200px'
      };
    }

    if (col.minWidth) {
      style.minWidth = col.minWidth;
    }

    return style;
  };

  var HeaderItem = function HeaderItem(col, index) {
    return /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "dg-header-item ".concat(col.freeze ? 'dg-freeze' : '', " ").concat(col.freezeEnd ? 'dg-freeze-end' : '', " ").concat(borderStyle || ''),
      style: getCellStyle(col),
      children: /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'dg-cell',
        children: /*#__PURE__*/jsxRuntime.jsx(T, {
          children: col.headerCellRender
        })
      })
    }, col.id || index);
  };

  var CellItem = function CellItem(_ref2) {
    var row = _ref2.row,
        col = _ref2.col,
        index = _ref2.index;
    return /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "dg-row-item ".concat(col.freeze ? 'dg-freeze' : '', " ").concat(col.freezeEnd ? 'dg-freeze-end' : '', " ").concat(borderStyle),
      style: getCellStyle(col),
      children: /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'dg-cell',
        children: col.rowCellRender(row, index)
      })
    }, col.id || index);
  };

  var cellContentStyle = function cellContentStyle(col) {
    switch (col.textWrapping) {
      case 'nowrap':
        return {
          textOverflow: 'ellipsis',
          maxWidth: '100%',
          whiteSpace: 'nowrap',
          overflow: 'hidden'
        };

      default:
        return {};
    }
  };

  var RenderNumberRows = function RenderNumberRows(_ref3) {
    var col = _ref3.col,
        index = _ref3.index,
        _ref3$pageSize = _ref3.pageSize,
        pageSize = _ref3$pageSize === void 0 ? 0 : _ref3$pageSize,
        _ref3$pageIndex = _ref3.pageIndex,
        pageIndex = _ref3$pageIndex === void 0 ? 0 : _ref3$pageIndex;
    var startIndex = index + pageSize * pageIndex - pageSize;
    return /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "dg-row-item ".concat(col.freeze ? 'dg-freeze' : '', " ").concat(borderStyle),
      style: getCellStyle(col),
      children: /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'dg-cell',
        children: /*#__PURE__*/jsxRuntime.jsx("span", {
          className: 'auto-number',
          children: startIndex + 1
        })
      })
    }, col.id || index);
  };

  var handleSort = function handleSort(_ref4) {
    var sortingId = _ref4.id,
        sortingDirection = _ref4.direction;

    if (sorting) {
      var _sorting$columns;

      if (sorting.isSingleSort) {
        sorting.onSort([{
          id: sortingId,
          direction: sortingDirection
        }]);
        return;
      }

      var found = false;

      var _columns = ((_sorting$columns = sorting.columns) === null || _sorting$columns === void 0 ? void 0 : _sorting$columns.map(function (_ref5) {
        var id = _ref5.id,
            direction = _ref5.direction;

        if (id === sortingId) {
          found = true;
          return {
            id: id,
            direction: sortingDirection
          };
        }

        return {
          id: id,
          direction: direction
        };
      })) || [];

      if (!found) {
        _columns.push({
          id: sortingId,
          direction: sortingDirection
        });
      }

      sorting.onSort(_columns);
    }
  };

  var handleFilterChange = function handleFilterChange(filter) {
    if (props.filter) {
      var newFilters = (props.filter.conditions || []).filter(function (f) {
        return f.columnName !== filter.columnName;
      });
      newFilters.push(filter);
      props.filter.onChange && props.filter.onChange(newFilters);
    }
  };

  var handleScrollDown = function handleScrollDown() {
    var _props$pagination;

    if (!isLoading && (_props$pagination = props.pagination) !== null && _props$pagination !== void 0 && _props$pagination.useInfiniteScroll && _containerRef.current.scrollHeight - _containerRef.current.scrollTop < 3 * _containerRef.current.clientHeight) {
      var _props$pagination2;

      // Load more when 2 view height left
      setIsLoading(true);
      var prm = ((_props$pagination2 = props.pagination) === null || _props$pagination2 === void 0 ? void 0 : _props$pagination2.onChangePage) && props.pagination.onChangePage(pagination === null || pagination === void 0 ? void 0 : pagination.pageIndex, true, function () {
        return setIsLoading(false);
      });

      if (prm && prm.then) {
        prm.then(function () {
          setIsLoading(false);
        });
      }
    }
  };

  var handleScrollX = function handleScrollX(event) {// if (!headerRef.current)
    // {
    //     return;
    // }
    // // headerRef.current.scrollLeft = event.scrollLeft;
    // const width = headerRef.current.clientWidth + event.scrollLeft;
    // setBodyWidth(width);
  };

  var handleDataChange = function handleDataChange(id, value) {
    var _id$split = id.split('--'),
        _id$split2 = _slicedToArray(_id$split, 2),
        colId = _id$split2[0],
        uniqueId = _id$split2[1];

    var updatedItem = _objectSpread2({}, items.find(function (item) {
      return item.uniqueId === uniqueId;
    }));

    if (updatedItem && updatedItem[colId] !== value) {
      updatedItem[colId] = value;
      onDataChanged && onDataChanged(updatedItem);
    }
  };

  var autoNumberRows = [];

  if (rowNumber) {
    autoNumberRows.push({
      headerCellRender: 'STT',
      width: 50,
      id: 'auto_number_id',
      freeze: true
    });
  }

  var checkboxHeaderControl = [];

  if (selectRows) {
    checkboxHeaderControl.push({
      width: 50,
      id: 'auto_checkbox_id',
      freeze: true
    });
  }

  var CheckBoxHeaderItem = function CheckBoxHeaderItem(col, index) {
    var selected = items === null || items === void 0 ? void 0 : items.filter(function (row) {
      return row.isSelected;
    });
    return /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "dg-header-item ".concat(col.freeze ? 'dg-freeze' : ''),
      style: getCellStyle(col),
      children: /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'dg-cell check-cell',
        children: /*#__PURE__*/jsxRuntime.jsx("span", {
          children: /*#__PURE__*/jsxRuntime.jsx(CheckBox, {
            indeterminate: !!(selected !== null && selected !== void 0 && selected.length) && (selected === null || selected === void 0 ? void 0 : selected.length) < (items === null || items === void 0 ? void 0 : items.length),
            checked: !!(selected !== null && selected !== void 0 && selected.length) && (selected === null || selected === void 0 ? void 0 : selected.length) <= (items === null || items === void 0 ? void 0 : items.length),
            onChange: function onChange(event) {
              var _selectRows$onChangeA;

              return (_selectRows$onChangeA = selectRows.onChangeAll) === null || _selectRows$onChangeA === void 0 ? void 0 : _selectRows$onChangeA.call(selectRows, event, items);
            }
          })
        })
      })
    }, col.id || index);
  };

  var CheckBoxItem = function CheckBoxItem(_ref6) {
    var row = _ref6.row,
        col = _ref6.col,
        index = _ref6.index;
    return /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "dg-row-item ".concat(col.freeze ? 'dg-freeze' : '', " ").concat(borderStyle),
      style: getCellStyle(col),
      children: /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'dg-cell check-cell',
        children: /*#__PURE__*/jsxRuntime.jsx(CheckBox, {
          checked: row.isSelected,
          onChange: function onChange(event) {
            var _selectRows$onChange;

            return (_selectRows$onChange = selectRows.onChange) === null || _selectRows$onChange === void 0 ? void 0 : _selectRows$onChange.call(selectRows, event, row);
          }
        })
      })
    }, col.id || index);
  };

  var handleSelect = function handleSelect(target) {
    var selectedRows = Array.from(document.querySelectorAll('.dg-row.selected-row'));
    selectedRows.map(function (element) {
      return element.classList.remove('selected-row');
    });
    target.classList.add('selected-row');
  };

  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: 'data-grid-wrapper',
    children: /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: 'data-grid-content',
      children: [props.toolbarVisibility && /*#__PURE__*/jsxRuntime.jsx(DataGridToolbar, _objectSpread2(_objectSpread2({}, props), {}, {
        loading: loading,
        cols: cols,
        setCols: setCols,
        hideAllColumns: hideAllColumns,
        showAllColumns: showAllColumns,
        defaultColumns: defaultColumns,
        toggleColumnVisibility: toggleColumnVisibility
      })), props.header && /*#__PURE__*/jsxRuntime.jsx("h1", {
        children: props.header
      }), /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'data-grid-container',
        onClick: props.onClick,
        children: (cols === null || cols === void 0 ? void 0 : cols.length) > 0 && /*#__PURE__*/jsxRuntime.jsxs("div", {
          className: "data-grid ".concat(props.className || ''),
          children: [/*#__PURE__*/jsxRuntime.jsx(ScrollView, {
            ref: scrollRef,
            containerRef: function containerRef(ref) {
              _containerRef.current = ref;
            },
            onScrollDown: function onScrollDown() {
              return handleScrollDown();
            },
            onScrollX: handleScrollX,
            children: /*#__PURE__*/jsxRuntime.jsxs("div", {
              style: {
                width: bodyWidth,
                position: 'relative'
              },
              children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
                className: 'dg-header',
                children: [checkboxHeaderControl === null || checkboxHeaderControl === void 0 ? void 0 : checkboxHeaderControl.map(CheckBoxHeaderItem), autoNumberRows === null || autoNumberRows === void 0 ? void 0 : autoNumberRows.map(HeaderItem), leadingControlColumns === null || leadingControlColumns === void 0 ? void 0 : leadingControlColumns.map(HeaderItem), cols === null || cols === void 0 ? void 0 : cols.map(function (col, index) {
                  var _sorting$columns2, _sorting$columns2$fil;

                  return !col.hidden && /*#__PURE__*/jsxRuntime.jsx(ResizeableHeader, _objectSpread2({
                    width: col.width,
                    style: getCellStyle(col),
                    sortDirection: sorting === null || sorting === void 0 ? void 0 : (_sorting$columns2 = sorting.columns) === null || _sorting$columns2 === void 0 ? void 0 : (_sorting$columns2$fil = _sorting$columns2.filter(function (_ref7) {
                      var id = _ref7.id;
                          _ref7.direction;
                      return id === col.id;
                    })[0]) === null || _sorting$columns2$fil === void 0 ? void 0 : _sorting$columns2$fil.direction,
                    isDraggable: false,
                    filter: props.filter,
                    isResizable: index !== cols.length - 1,
                    onDragStart: handleDragStart,
                    onDragOver: handleDragOver,
                    onResize: handleResize(index),
                    onDrop: handleOnDrop,
                    onDragEnter: handleDragEnter,
                    onClick: handleSort,
                    onFilterChange: handleFilterChange
                  }, col), col.id);
                } // isDraggable too buggy, disabled
                ), trailingControlColumns === null || trailingControlColumns === void 0 ? void 0 : trailingControlColumns.map(HeaderItem)]
              }), loading && /*#__PURE__*/jsxRuntime.jsx(Row2, {
                justify: "center",
                children: /*#__PURE__*/jsxRuntime.jsx(Loading, {})
              }), !loading && (items === null || items === void 0 ? void 0 : items.length) > 0 && /*#__PURE__*/jsxRuntime.jsx("div", {
                className: "dg-body ".concat(stripes ? 'dg-body--stripes' : ''),
                children: items.map(function (row, rowIndex) {
                  return /*#__PURE__*/jsxRuntime.jsxs("div", {
                    className: ['dg-row', props.rowClassName && props.rowClassName(row, rowIndex), row.selected ? 'selected-row' : '', onRowClick || onCellClick || onCellDoubleClick ? 'selectable-row' : ''].join(' '),
                    onClick: function onClick(e) {
                      handleSelect(e.currentTarget);
                      typeof onRowClick === 'function' && onRowClick(event, row);
                    },
                    children: [checkboxHeaderControl === null || checkboxHeaderControl === void 0 ? void 0 : checkboxHeaderControl.map(function (col, index) {
                      return /*#__PURE__*/jsxRuntime.jsx(CheckBoxItem, {
                        row: row,
                        col: col,
                        index: index
                      }, "".concat(row[props.rowKey], "_").concat(col.id));
                    }), autoNumberRows === null || autoNumberRows === void 0 ? void 0 : autoNumberRows.map(function (col) {
                      return /*#__PURE__*/jsxRuntime.jsx(RenderNumberRows, {
                        col: col,
                        index: rowIndex,
                        pageSize: pagination === null || pagination === void 0 ? void 0 : pagination.pageSize,
                        pageIndex: pagination === null || pagination === void 0 ? void 0 : pagination.pageIndex
                      }, "".concat(row[props.rowKey], "_").concat(col.id));
                    }), leadingControlColumns === null || leadingControlColumns === void 0 ? void 0 : leadingControlColumns.map(function (col, index) {
                      return /*#__PURE__*/jsxRuntime.jsx(CellItem, {
                        row: row,
                        col: col,
                        index: index
                      }, "".concat(row[props.rowKey], "_").concat(col.id));
                    }), cols === null || cols === void 0 ? void 0 : cols.map(function (col, colIndex) {
                      var _sorting$columns3, _sorting$columns3$fin, _props$filter, _props$filter$conditi;

                      var isSorting = sorting === null || sorting === void 0 ? void 0 : (_sorting$columns3 = sorting.columns) === null || _sorting$columns3 === void 0 ? void 0 : (_sorting$columns3$fin = _sorting$columns3.find(function (c) {
                        return c.id === col.id;
                      })) === null || _sorting$columns3$fin === void 0 ? void 0 : _sorting$columns3$fin.direction;
                      var isFiltering = props === null || props === void 0 ? void 0 : (_props$filter = props.filter) === null || _props$filter === void 0 ? void 0 : (_props$filter$conditi = _props$filter.conditions) === null || _props$filter$conditi === void 0 ? void 0 : _props$filter$conditi.find(function (_ref8) {
                        var columnName = _ref8.columnName;
                        return columnName === col.id;
                      });

                      if (!col.hidden) {
                        return /*#__PURE__*/jsxRuntime.jsx("div", {
                          className: clsx__default['default']('dg-row-item', col.freeze && 'dg-freeze', col.freezeEnd && 'dg-freeze-end', isSorting && 'dg-row-sorting', isFiltering && 'dg-row-filtering', borderStyle),
                          style: getCellStyle(col),
                          onClick: function onClick(e) {
                            if (onCellClick) {
                              e.stopPropagation();
                              onCellClick && onCellClick(e, row, col);
                            }

                            handleSelect(e.currentTarget.parentNode);
                          },
                          onDoubleClick: function onDoubleClick(e) {
                            return onCellDoubleClick && onCellDoubleClick(e, row, col);
                          },
                          children: /*#__PURE__*/jsxRuntime.jsx("div", {
                            className: "dg-cell ".concat(col.editable ? 'editable' : ''),
                            tabIndex: col.editable ? 1 : 0,
                            children: row[col.id] !== undefined && (props.cellRender ? props.cellRender(col, row, rowIndex) : /*#__PURE__*/jsxRuntime.jsx(DataGridCell, {
                              id: col.id,
                              definition: _objectSpread2(_objectSpread2({}, col), {}, {
                                uniqueId: "".concat(col.id, "--").concat(row.uniqueId)
                              }),
                              content: row[col.id],
                              index: rowIndex,
                              row: row,
                              style: cellContentStyle(col),
                              editable: col.editable,
                              getNumOfEditableFieldsPerRow: function getNumOfEditableFieldsPerRow() {
                                return numOfEditableFieldPerRowRef.current;
                              },
                              onDataChanged: handleDataChange
                            }))
                          })
                        }, "".concat(props.rowKey && row[props.rowKey] || rowIndex, "_").concat(col.id));
                      } else {
                        return null;
                      }
                    }), trailingControlColumns === null || trailingControlColumns === void 0 ? void 0 : trailingControlColumns.map(function (col, index) {
                      return /*#__PURE__*/jsxRuntime.jsx(CellItem, {
                        row: row,
                        col: col,
                        index: index
                      }, index);
                    })]
                  }, props.rowKey && row[props.rowKey] || rowIndex);
                })
              }), summary && (items === null || items === void 0 ? void 0 : items.length) > 0 && /*#__PURE__*/jsxRuntime.jsx("div", {
                className: 'dg-footer summary',
                style: summary.stick ? {
                  position: 'sticky',
                  top: 'unset',
                  bottom: 0
                } : {
                  position: 'relative'
                },
                children: [].concat(_toConsumableArray(checkboxHeaderControl || []), _toConsumableArray(autoNumberRows || []), _toConsumableArray(leadingControlColumns || []), _toConsumableArray(cols), _toConsumableArray(trailingControlColumns || [])).map(function (col, index) {
                  return !col.hidden && /*#__PURE__*/jsxRuntime.jsx(DataGridSummaryCell, {
                    col: col,
                    items: items,
                    style: getCellStyle(col),
                    className: clsx__default['default']({
                      'dg-freeze': col.freeze,
                      'dg-freeze-end': col.freezeEnd
                    })
                  }, col.id);
                })
              })]
            })
          }), !loading && !(items !== null && items !== void 0 && items.length) && /*#__PURE__*/jsxRuntime.jsx(Row2, {
            className: "dg-empty",
            children: /*#__PURE__*/jsxRuntime.jsx(EmptyData, {})
          })]
        })
      }), !props.hideBottomBar && /*#__PURE__*/jsxRuntime.jsx(DataGridBottomBar, _objectSpread2(_objectSpread2({}, props), {}, {
        isLoading: isLoading
      }))]
    })
  });
};
DataGrid.propTypes = {
  // Display
  className: PropTypes__default['default'].string,
  header: PropTypes__default['default'].string,
  columns: PropTypes__default['default'].arrayOf(PropTypes__default['default'].shape({
    // Display
    width: PropTypes__default['default'].number,
    hidden: PropTypes__default['default'].bool,
    // Data
    id: PropTypes__default['default'].string,
    displayAsText: PropTypes__default['default'].string,
    display: PropTypes__default['default'].node,
    schema: PropTypes__default['default'].string,
    locale: PropTypes__default['default'].string,
    format: PropTypes__default['default'].string,
    // Feature
    isSortable: PropTypes__default['default'].bool,
    defaultSortDirection: PropTypes__default['default'].oneOf(['desc', 'asc']),
    isMiniStyle: PropTypes__default['default'].bool,
    options: PropTypes__default['default'].array
  })),
  // Data
  items: PropTypes__default['default'].arrayOf(PropTypes__default['default'].object),
  pagination: PropTypes__default['default'].shape({
    // Infinite Scroll
    useInfiniteScroll: PropTypes__default['default'].bool,
    pageIndex: PropTypes__default['default'].number,
    pageSize: PropTypes__default['default'].number,
    pageSizeOptions: PropTypes__default['default'].arrayOf(PropTypes__default['default'].number),
    // [50, 100, 200] An array of page sizes the user can select from. Leave this prop undefined or use an empty array to hide "Rows per page" select button
    onChangePage: PropTypes__default['default'].func,
    // (itemsPerPage: number) => void
    onChangeItemsPerPage: PropTypes__default['default'].func // (pageIndex: number) => void

  }),
  externalPaginationRow: PropTypes__default['default'].bool,
  // Sorting feature
  total: PropTypes__default['default'].number,
  sorting: PropTypes__default['default'].shape({
    isSingleSort: PropTypes__default['default'].bool,
    columns: PropTypes__default['default'].arrayOf(PropTypes__default['default'].shape({
      id: PropTypes__default['default'].string,
      direction: PropTypes__default['default'].string
    })),
    // [{ id: 'C', direction: 'asc' }]
    onSort: PropTypes__default['default'].func // (columns: { id: string; direction: "asc" | "desc"; }[]) => void

  }),
  // Filter feature
  filter: PropTypes__default['default'].shape({
    conditions: PropTypes__default['default'].arrayOf(PropTypes__default['default'].shape({
      operator: PropTypes__default['default'].string,
      value: PropTypes__default['default'].any,
      options: PropTypes__default['default'].array // select: [{id, label, color}]

    })),
    onChange: PropTypes__default['default'].func
  }),
  // Search feature
  searching: PropTypes__default['default'].shape({
    searchKey: PropTypes__default['default'].string,
    onSearch: PropTypes__default['default'].func
  }),
  rowKey: PropTypes__default['default'].string,
  leadingControlColumns: PropTypes__default['default'].array,
  trailingControlColumns: PropTypes__default['default'].array,
  // plugin to show number column at first column, apply with paging as well
  rowNumber: PropTypes__default['default'].bool,
  // plugin to have check column at first column
  selectRows: PropTypes__default['default'].shape({
    onChange: PropTypes__default['default'].func,
    onChangeAll: PropTypes__default['default'].func
  }),
  loading: PropTypes__default['default'].bool,
  onReload: PropTypes__default['default'].func,
  // Top bar
  toolbarVisibility: PropTypes__default['default'].oneOfType([PropTypes__default['default'].bool, PropTypes__default['default'].shape({
    showColumnSelector: PropTypes__default['default'].bool,
    showStyleSelector: PropTypes__default['default'].bool,
    showSortSelector: PropTypes__default['default'].bool,
    showFullScreenSelector: PropTypes__default['default'].bool,
    showReloadButton: PropTypes__default['default'].bool
  })]),
  // Summary feature
  summary: PropTypes__default['default'].shape({
    stick: PropTypes__default['default'].bool
  }),
  toolbarActions: PropTypes__default['default'].node,
  onDataChanged: PropTypes__default['default'].func,
  // Top bar Events
  onColumnsVisibilityChanged: PropTypes__default['default'].func,
  selectedRow: PropTypes__default['default'].object,
  border: PropTypes__default['default'].oneOf(['none', 'horizontal', 'vertical', 'all']),
  stripes: PropTypes__default['default'].bool,
  // Remove onSelect because it's duplicated with onCellClick
  onRowClick: PropTypes__default['default'].func,
  onCellClick: PropTypes__default['default'].func,
  onCellDoubleClick: PropTypes__default['default'].func,
  hideBottomBar: PropTypes__default['default'].bool
};
DataGrid.defaultProps = {
  currentPage: 1,
  pageSize: 10,
  toolbarVisibility: true,
  rowNumber: false,
  loading: false,
  border: 'horizontal',
  stripes: false
};

var SCHEMAS = ['boolean', 'currency', 'datetime', 'date', 'numeric', 'select', 'multi-select', 'image', 'link', 'json', 'react-node'];

var getOperators = function getOperators(dataType) {
  if (dataType) {
    var operators = [];

    switch (dataType) {
      case 2:
      case 4:
      case 5:
        operators = [{
          id: '=',
          label: '='
        }, {
          id: '>',
          label: '>'
        }, {
          id: '<',
          label: '<'
        }, {
          id: '>=',
          label: '>='
        }, {
          id: '<=',
          label: '<='
        }, {
          id: 'between',
          label: 'Giữa'
        }];
        break;

      case 3:
      case 6:
      case 8:
        operators = [{
          id: '=',
          label: 'Bằng'
        }, {
          id: 'like',
          label: 'Giống'
        }, {
          id: 'is null',
          label: 'Rỗng'
        }, {
          id: 'is not null',
          label: 'Không rỗng'
        }];
        break;

      case 1:
      case 10:
        operators = [{
          id: '=',
          label: 'Bằng'
        }, {
          id: 'like',
          label: 'Giống'
        }];
        break;
    }

    return operators;
  }

  return [];
};

var mapColumnSchemaToDataType = function mapColumnSchemaToDataType(schema) {
  switch (schema) {
    case 'image':
    case 'link':
    case 'json':
      return 'string';

    case 'currency':
    case 'numeric':
      return 'integer';

    case 'datetime':
    case 'date':
      return 'datetime';

    case 'boolean':
      return 'boolean';

    case 'select':
    case 'multi-select':
      return 'array';

    default:
      return;
  }
};

var COMBINE_OPTIONS = [{
  id: 'AND',
  label: 'Và'
}, {
  id: 'OR',
  label: 'Hoặc'
}, {
  id: 'NOT',
  label: 'Không'
}];
var ADVANCE_FILTER_FEATURE = [{
  id: 'search-feature',
  icon: 'search',
  tooltip: 'Tìm kiếm'
}, {
  id: 'data-sort',
  icon: 'sort',
  tooltip: 'Sắp xếp'
}, {
  id: 'data-filter',
  icon: 'filter',
  tooltip: 'Bộ lọc'
}, {
  id: 'column-toggle',
  icon: 'list-ol',
  tooltip: 'Dữ liệu hiển thị'
}];

var DataToolBarContext = /*#__PURE__*/React.createContext();

var DataToolBarProvider = function DataToolBarProvider(props) {
  var containerRef = React.useRef();

  var _useState = React.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      visibleActive = _useState2[0],
      setVisibleActive = _useState2[1];

  var _useState3 = React.useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      feature = _useState4[0],
      setFeature = _useState4[1];

  var _useState5 = React.useState({}),
      _useState6 = _slicedToArray(_useState5, 2),
      dirty = _useState6[0],
      setDirty = _useState6[1];

  var _useState7 = React.useState(),
      _useState8 = _slicedToArray(_useState7, 2),
      valueSearch = _useState8[0],
      setValueSearch = _useState8[1];

  var _useState9 = React.useState([]),
      _useState10 = _slicedToArray(_useState9, 2),
      sortFields = _useState10[0],
      setSortFields = _useState10[1];

  var _useState11 = React.useState(false),
      _useState12 = _slicedToArray(_useState11, 2),
      isAutoSort = _useState12[0],
      setAutoSort = _useState12[1];

  var _useState13 = React.useState([]),
      _useState14 = _slicedToArray(_useState13, 2),
      filterFields = _useState14[0],
      setFilterFields = _useState14[1];

  var _useState15 = React.useState(false),
      _useState16 = _slicedToArray(_useState15, 2),
      isAutoFilter = _useState16[0],
      setAutoFilter = _useState16[1];

  var _useState17 = React.useState([]),
      _useState18 = _slicedToArray(_useState17, 2),
      fieldsShow = _useState18[0],
      setFieldsShow = _useState18[1];

  var _useState19 = React.useState([]),
      _useState20 = _slicedToArray(_useState19, 2),
      fields = _useState20[0],
      setFields = _useState20[1];

  var _useState21 = React.useState((props === null || props === void 0 ? void 0 : props.primaryFields) || []),
      _useState22 = _slicedToArray(_useState21, 2),
      primaryFields = _useState22[0],
      setPrimaryFields = _useState22[1];

  var _useState23 = React.useState((props === null || props === void 0 ? void 0 : props.defaultFields) || []),
      _useState24 = _slicedToArray(_useState23, 2),
      defaultFields = _useState24[0],
      setDefaultFields = _useState24[1];

  React.useEffect(function () {
    setFields(props === null || props === void 0 ? void 0 : props.fields);
  }, [props === null || props === void 0 ? void 0 : props.fields]);
  React.useEffect(function () {
    setFieldsShow(props === null || props === void 0 ? void 0 : props.fieldsShow);
  }, [props === null || props === void 0 ? void 0 : props.fieldsShow]);
  React.useEffect(function () {
    setDirty({
      'search-feature': valueSearch,
      'data-sort': sortFields === null || sortFields === void 0 ? void 0 : sortFields.length,
      'data-filter': filterFields === null || filterFields === void 0 ? void 0 : filterFields.length,
      'column-toggle': fieldsShow.slice().sort().join(',') !== defaultFields.sort().join(',')
    });
  }, [valueSearch, sortFields, filterFields, fieldsShow]);
  return /*#__PURE__*/jsxRuntime.jsx(DataToolBarContext.Provider, {
    value: {
      ADVANCE_FILTER_FEATURE: ADVANCE_FILTER_FEATURE,
      COMBINE_OPTIONS: COMBINE_OPTIONS,
      feature: feature,
      setFeature: setFeature,
      dirty: dirty,
      containerRef: containerRef,
      visibleActive: visibleActive,
      setVisibleActive: setVisibleActive,
      valueSearch: valueSearch,
      setValueSearch: setValueSearch,
      isAutoSort: isAutoSort,
      setAutoSort: setAutoSort,
      sortFields: sortFields,
      setSortFields: setSortFields,
      isAutoFilter: isAutoFilter,
      setAutoFilter: setAutoFilter,
      filterFields: filterFields,
      setFilterFields: setFilterFields,
      fields: fields,
      setFields: setFields,
      defaultFields: defaultFields,
      setDefaultFields: setDefaultFields,
      primaryFields: primaryFields,
      setPrimaryFields: setPrimaryFields,
      fieldsShow: fieldsShow,
      setFieldsShow: setFieldsShow
    },
    children: props === null || props === void 0 ? void 0 : props.children
  });
};

var DataToolBarControl = function DataToolBarControl(props) {
  var _useContext = React.useContext(DataToolBarContext),
      ADVANCE_FILTER_FEATURE = _useContext.ADVANCE_FILTER_FEATURE,
      feature = _useContext.feature,
      setFeature = _useContext.setFeature,
      dirty = _useContext.dirty;

  var handleFeatureClick = function handleFeatureClick(item) {
    setFeature(item);
    props.onFeatureClick && props.onFeatureClick(item.id);
    props.onSetVisiblePopup(true);
  };

  return /*#__PURE__*/jsxRuntime.jsx(Container, {
    className: 'afc-feature-container',
    children: ADVANCE_FILTER_FEATURE.map(function (item) {
      return /*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
        icon: item.icon,
        tooltip: item.tooltip,
        color: dirty[item.id] ? 'primary' : 'default',
        iconSize: "sm",
        backgroundColor: item.id === (feature === null || feature === void 0 ? void 0 : feature.id) ? 'var(--contrast-highlight)' : '',
        onlyIcon: true,
        onClick: function onClick() {
          return handleFeatureClick(item);
        }
      }, item.id);
    })
  });
};

DataToolBarControl.propTypes = {
  onFeatureClick: PropTypes__default['default'].func,
  onSetVisiblePopup: PropTypes__default['default'].func
};
DataToolBarControl.defaultProps = {};

var DataSortPanel = function DataSortPanel(props) {
  var _useContext = React.useContext(DataToolBarContext),
      fields = _useContext.fields,
      fieldsShow = _useContext.fieldsShow,
      sortFields = _useContext.sortFields,
      setSortFields = _useContext.setSortFields,
      isAutoSort = _useContext.isAutoSort,
      setAutoSort = _useContext.setAutoSort,
      setVisibleActive = _useContext.setVisibleActive;

  var fieldOptions = fields.filter(function (f) {
    return fieldsShow.includes(f.ColumnName);
  }).map(function (field) {
    return {
      id: field.ColumnName,
      label: field.DisplayName,
      direction: 'Ascending'
    };
  });
  var fieldsObj = {};
  fieldOptions.forEach(function (field) {
    fieldsObj[field.id] = field;
  });

  var handleChooseField = function handleChooseField(fieldId) {
    var newSortFields = [].concat(_toConsumableArray(sortFields), [fieldsObj[fieldId]]);
    setSortFields(newSortFields);

    if (isAutoSort) {
      props.onSort(newSortFields);
    }
  };

  var handleRemoveFieldSort = function handleRemoveFieldSort(fieldId) {
    var fieldsUpdate = sortFields.filter(function (sortField) {
      return sortField.id !== fieldId;
    });

    if (fieldsUpdate.length === 0) {
      props.onSort(fieldsUpdate);
    }

    setSortFields(fieldsUpdate);
  };

  var handleAddFieldSort = function handleAddFieldSort(curFieldObj, newFieldId, index) {
    if (curFieldObj.id !== newFieldId) {
      var sortFieldsUpdate = sortFields.map(function (field, fIndex) {
        if (index === fIndex) {
          field = fieldsObj[newFieldId];
        }

        return field;
      });
      setSortFields(sortFieldsUpdate);

      if (isAutoSort) {
        props.onSort(sortFieldsUpdate);
      }
    }
  };

  var handleSortDirectionClick = function handleSortDirectionClick(typeSort, index) {
    var newSortFields = _toConsumableArray(sortFields);

    if (newSortFields[index].direction !== typeSort) {
      newSortFields[index].direction = typeSort;
      setSortFields(newSortFields);
    }

    if (isAutoSort) {
      props.onSort(sortFields);
    }
  };

  var handleCancel = function handleCancel() {
    setVisibleActive(false);
  };

  var handleApply = function handleApply() {
    props.onSort(sortFields);
    setVisibleActive(false);
  };

  var handleCheckAuto = function handleCheckAuto(value) {
    setAutoSort(value);

    if (value) {
      props.onSort(sortFields);
    }
  };

  var renderSortField = function renderSortField(fieldSort, index) {
    // build options that excluded selected sort
    var addSortOptions = fieldOptions.filter(function (field) {
      return !sortFields.find(function (sf) {
        return sf.id === field.id;
      }) || field.id === fieldSort.id;
    });
    return /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: 'data-sort-condition-item',
      children: [/*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
        icon: 'times',
        iconSize: "md",
        iconColor: 'var(--contrast-color)',
        onlyIcon: true,
        onClick: function onClick() {
          return handleRemoveFieldSort(fieldSort.id);
        }
      }), /*#__PURE__*/jsxRuntime.jsx(TB1, {
        style: {
          minWidth: '50px'
        },
        children: index === 0 ? 'Sắp xếp' : 'sau đó'
      }), /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
        options: addSortOptions,
        value: fieldSort === null || fieldSort === void 0 ? void 0 : fieldSort.id,
        onChange: function onChange(id) {
          return handleAddFieldSort(fieldSort, id, index);
        }
      }), /*#__PURE__*/jsxRuntime.jsx(TB1, {
        children: "theo"
      }), /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: 'data-sort-action-group',
        children: [/*#__PURE__*/jsxRuntime.jsx(Button, {
          text: 'Tăng dần',
          className: (fieldSort === null || fieldSort === void 0 ? void 0 : fieldSort.direction) === 'Ascending' ? 'active' : '',
          onClick: function onClick() {
            return handleSortDirectionClick('Ascending', index);
          }
        }), /*#__PURE__*/jsxRuntime.jsx(Button, {
          className: (fieldSort === null || fieldSort === void 0 ? void 0 : fieldSort.direction) === 'Descending' ? 'active' : '',
          text: 'Giảm dần',
          onClick: function onClick() {
            return handleSortDirectionClick('Descending', index);
          }
        })]
      })]
    }, fieldSort.id);
  };

  var addSortOptions = fieldOptions.filter(function (field) {
    return !sortFields.find(function (sf) {
      return sf.id === field.id;
    });
  });
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: 'data-sort-container',
    children: [/*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'data-sort-condition-content',
      children: (sortFields === null || sortFields === void 0 ? void 0 : sortFields.length) === 0 ? /*#__PURE__*/jsxRuntime.jsx(TB1, {
        style: {
          color: 'gray'
        },
        children: "Ch\u01B0a c\xF3 s\u1EAFp x\u1EBFp n\xE0o \u0111\u01B0\u1EE3c \xE1p d\u1EE5ng"
      }) : /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'data-sort-condition-item-container',
        children: sortFields.map(renderSortField)
      })
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: 'data-sort-add-condition',
      children: [/*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
        options: addSortOptions,
        disabled: addSortOptions.length === 0,
        placeholder: 'Chọn thuộc tính để sắp xếp',
        onChange: handleChooseField
      }), (sortFields === null || sortFields === void 0 ? void 0 : sortFields.length) > 0 && !isAutoSort && /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: 'data-sort-action-button',
        children: [/*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
          text: 'Hủy bỏ',
          onClick: handleCancel
        }), /*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
          color: 'primary',
          text: 'Áp dụng',
          onClick: handleApply
        })]
      })]
    }), (sortFields === null || sortFields === void 0 ? void 0 : sortFields.length) > 0 && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'data-sort-footer',
      children: /*#__PURE__*/jsxRuntime.jsx(CheckBox, {
        label: "T\u1EF1 \u0111\u1ED9ng",
        checked: isAutoSort,
        onChange: handleCheckAuto
      })
    })]
  });
};
DataSortPanel.propTypes = {
  fields: PropTypes__default['default'].array,
  onSort: PropTypes__default['default'].func
};
DataSortPanel.defaultProps = {
  fields: []
};

var WAIT_INTERVAL$1 = 1000;
var ENTER_KEY = 13;
var DataSearchPanel = function DataSearchPanel(_ref) {
  var onSearch = _ref.onSearch;

  var _useContext = React.useContext(DataToolBarContext),
      valueSearch = _useContext.valueSearch,
      setValueSearch = _useContext.setValueSearch;

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isFocus = _useState2[0],
      setFocus = _useState2[1];

  React.useEffect(function () {
    if (isFocus) {
      var timeout = setTimeout(function () {
        if (valueSearch) {
          onSearch(valueSearch);
        }
      }, WAIT_INTERVAL$1); // if this effect run again, because `value` changed, we remove the previous timeout

      return function () {
        return clearTimeout(timeout);
      };
    }
  }, [valueSearch]);

  var handleChange = function handleChange(value) {
    setValueSearch(value);

    if (value === '') {
      onSearch(value);
    }
  };

  var handleKeyDown = function handleKeyDown(e) {
    if (e.keyCode === ENTER_KEY) {
      if (valueSearch) {
        onSearch(valueSearch);
      }
    }
  };

  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: 'search-feature-action',
    children: /*#__PURE__*/jsxRuntime.jsx(SearchBox, {
      placeholder: 'Nhập từ khóa để tìm kiếm',
      onChange: handleChange,
      value: valueSearch,
      onKeyDown: handleKeyDown,
      onFocus: function onFocus() {
        return setFocus(true);
      }
    })
  });
};
DataSearchPanel.propTypes = {
  onSearch: PropTypes__default['default'].func,
  fields: PropTypes__default['default'].array,
  onSort: PropTypes__default['default'].func
};

var WAIT_INTERVAL = 300;
var DataFilterPanel = function DataFilterPanel(props) {
  var _useContext = React.useContext(DataToolBarContext),
      fields = _useContext.fields,
      fieldsShow = _useContext.fieldsShow,
      filterFields = _useContext.filterFields,
      setFilterFields = _useContext.setFilterFields,
      isAutoFilter = _useContext.isAutoFilter,
      setAutoFilter = _useContext.setAutoFilter,
      setVisibleActive = _useContext.setVisibleActive;

  var fieldsShowInfo = fields.filter(function (f) {
    return fieldsShow.includes(f.ColumnName);
  });

  var handleAddFilter = function handleAddFilter() {
    var _fieldsShowInfo$, _fieldsShowInfo$2, _fieldsShowInfo$3;

    var operators = getOperators$1((_fieldsShowInfo$ = fieldsShowInfo[0]) === null || _fieldsShowInfo$ === void 0 ? void 0 : _fieldsShowInfo$.DataType);
    var newFilter = {
      Combine: 'AND',
      ColumnName: (_fieldsShowInfo$2 = fieldsShowInfo[0]) === null || _fieldsShowInfo$2 === void 0 ? void 0 : _fieldsShowInfo$2.ColumnName,
      DataType: (_fieldsShowInfo$3 = fieldsShowInfo[0]) === null || _fieldsShowInfo$3 === void 0 ? void 0 : _fieldsShowInfo$3.DataType,
      Condition: operators && operators.length > 0 ? operators[0].id : '',
      // Currently, all data types have operators. Use first by default
      ValueFilter: '',
      id: CommonHelper.uuid()
    };
    setFilterFields([].concat(_toConsumableArray(filterFields), [_objectSpread2({}, newFilter)]));
  };

  var handleCancel = function handleCancel() {
    setVisibleActive(false);
  };

  var handleApply = function handleApply() {
    props.onFilter && props.onFilter(filterFields);
    setVisibleActive(false);
  };

  var handleCheckAuto = function handleCheckAuto(checked) {
    setAutoFilter(checked);

    if (checked) {
      props.onFilter && props.onFilter(filterFields);
    }
  };

  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: 'data-filter-container',
    children: [/*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'data-filter-condition-content',
      children: (filterFields === null || filterFields === void 0 ? void 0 : filterFields.length) === 0 ? /*#__PURE__*/jsxRuntime.jsx(TB1, {
        style: {
          color: 'gray'
        },
        children: "Ch\u01B0a c\xF3 b\u1ED9 l\u1ECDc n\xE0o \u0111\u01B0\u1EE3c \xE1p d\u1EE5ng"
      }) : /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'data-filter-condition-item-container',
        children: filterFields.map(function (filterField, index) {
          return /*#__PURE__*/jsxRuntime.jsx(FilterField, {
            fields: fieldsShowInfo,
            data: filterField,
            index: index,
            onFilter: props.onFilter
          }, filterField.id);
        })
      })
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: 'data-filter-add-condition',
      children: [/*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
        icon: 'plus',
        text: 'Thêm bộ lọc',
        onClick: handleAddFilter
      }), (filterFields === null || filterFields === void 0 ? void 0 : filterFields.length) > 0 && !isAutoFilter && /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: 'data-filter-action-button',
        children: [/*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
          text: 'Hủy bỏ',
          onClick: handleCancel
        }), /*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
          color: 'primary',
          text: 'Áp dụng',
          onClick: handleApply
        })]
      })]
    }), (filterFields === null || filterFields === void 0 ? void 0 : filterFields.length) > 0 && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'data-filter-footer',
      children: /*#__PURE__*/jsxRuntime.jsx(CheckBox, {
        label: "T\u1EF1 \u0111\u1ED9ng",
        checked: isAutoFilter,
        onChange: handleCheckAuto
      })
    })]
  });
};
DataFilterPanel.propTypes = {
  fields: PropTypes__default['default'].array,
  onFilter: PropTypes__default['default'].func
};
DataFilterPanel.defaultProps = {
  fields: []
};
var timeout$1 = null;

var FilterField = function FilterField(_ref) {
  var _fields$find2, _config$content;

  var data = _ref.data,
      fields = _ref.fields,
      index = _ref.index,
      onFilter = _ref.onFilter;

  var _useContext2 = React.useContext(DataToolBarContext),
      fieldsShow = _useContext2.fieldsShow,
      filterFields = _useContext2.filterFields,
      setFilterFields = _useContext2.setFilterFields,
      isAutoFilter = _useContext2.isAutoFilter,
      COMBINE_OPTIONS = _useContext2.COMBINE_OPTIONS;

  var _useState = React.useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      operators = _useState2[0],
      setOperators = _useState2[1];

  var fieldOptions = fields.filter(function (f) {
    return fieldsShow.includes(f.ColumnName);
  }).map(function (field) {
    return {
      id: field.ColumnName,
      label: field.DisplayName
    };
  });
  React.useEffect(function () {
    setOperators(getOperators$1(data === null || data === void 0 ? void 0 : data.DataType));
  }, []);

  var handleRemove = function handleRemove(index) {
    var fieldsUpdate = filterFields.filter(function (field, i) {
      return i !== index;
    });

    if (fieldsUpdate.length === 0) {
      onFilter(fieldsUpdate);
    }

    setFilterFields(fieldsUpdate);
  };

  var isFieldValid = function isFieldValid(field) {
    var isValid = true;
    Object.keys(field).forEach(function (key) {
      if (!field[key]) {
        isValid = false;
      }
    });
    return isValid;
  };

  var handleChangeType = function handleChangeType(type, value) {
    var filterFieldsUpdate = _toConsumableArray(filterFields);

    filterFieldsUpdate[index][type] = value;

    if (type === 'ColumnName') {
      var _fields$find, _filterFieldsUpdate$i;

      filterFieldsUpdate[index].DataType = (_fields$find = fields.find(function (f) {
        return f.ColumnName === value;
      })) === null || _fields$find === void 0 ? void 0 : _fields$find.DataType;

      var _operators = getOperators$1((_filterFieldsUpdate$i = filterFieldsUpdate[index]) === null || _filterFieldsUpdate$i === void 0 ? void 0 : _filterFieldsUpdate$i.DataType);

      filterFieldsUpdate[index].Condition = _operators && _operators.length > 0 ? _operators[0].id : ''; // Currently, all data types have operators. Use first by default

      setOperators(_operators);
      filterFieldsUpdate[index].ValueFilter = '';
    } else if (type === 'Condition') {
      if (value === 'is null' || value === 'is not null') {
        filterFieldsUpdate[index].ValueFilter = '';
      } else if (value === 'between') {
        filterFieldsUpdate[index].ValueFilter = ' AND   ';
      }
    }

    if (isAutoFilter && isFieldValid(data)) {
      // debounce change
      // if this effect run again, because `value` changed, we remove the previous timeout
      clearTimeout(timeout$1);
      timeout$1 = setTimeout(function () {
        onFilter(filterFieldsUpdate);
      }, WAIT_INTERVAL);
    }

    setFilterFields(filterFieldsUpdate);
  };

  var handleChangeValueFilter = function handleChangeValueFilter(value, betweenType) {
    if (data.Condition !== 'between') {
      handleChangeType('ValueFilter', value);
    } else {
      var _filterFields$index$V3;

      var _filterFields$index$V = (_filterFields$index$V3 = filterFields[index].ValueFilter) === null || _filterFields$index$V3 === void 0 ? void 0 : _filterFields$index$V3.split('AND', 2),
          _filterFields$index$V2 = _slicedToArray(_filterFields$index$V, 2),
          formData = _filterFields$index$V2[0],
          toData = _filterFields$index$V2[1];

      if (betweenType === 'from') {
        formData = value;
      }

      if (betweenType === 'to') {
        toData = value;
      }

      value = "".concat(formData, " AND ").concat(toData);
      handleChangeType('ValueFilter', value);
    }
  };

  var configStr = (_fields$find2 = fields.find(function (f) {
    return f.ColumnName === (data === null || data === void 0 ? void 0 : data.ColumnName);
  })) === null || _fields$find2 === void 0 ? void 0 : _fields$find2.Config;
  var config = configStr ? JSON.parse(configStr) : {};
  var filter = {
    dataType: data === null || data === void 0 ? void 0 : data.DataType,
    combination: data === null || data === void 0 ? void 0 : data.Combine,
    columnName: data === null || data === void 0 ? void 0 : data.ColumnName,
    operator: data === null || data === void 0 ? void 0 : data.Condition,
    value: data === null || data === void 0 ? void 0 : data.ValueFilter
  };
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: 'data-filter-condition-item',
    children: /*#__PURE__*/jsxRuntime.jsx(FilterInput, {
      index: index,
      filter: filter,
      config: config === null || config === void 0 ? void 0 : (_config$content = config.content) === null || _config$content === void 0 ? void 0 : _config$content.source,
      combinations: COMBINE_OPTIONS,
      columnNames: fieldOptions,
      operators: operators,
      onRemove: function onRemove(index) {
        return handleRemove(index);
      },
      onChangeCombination: function onChangeCombination(value, index) {
        return handleChangeType('Combine', value);
      },
      onChangeColumnName: function onChangeColumnName(value, index) {
        return handleChangeType('ColumnName', value);
      },
      onChangeOperator: function onChangeOperator(value, index) {
        return handleChangeType('Condition', value);
      },
      onChangeFilterValue: handleChangeValueFilter
    })
  });
};

FilterField.propTypes = {
  data: PropTypes__default['default'].object,
  field: PropTypes__default['default'].object,
  index: PropTypes__default['default'].number,
  onFilter: PropTypes__default['default'].func
};
FilterField.defaultProps = {
  data: {},
  field: {},
  index: null
};

var ColumnTogglePanel = function ColumnTogglePanel(props) {
  var _useContext = React.useContext(DataToolBarContext),
      fields = _useContext.fields,
      defaultFields = _useContext.defaultFields,
      primaryFields = _useContext.primaryFields,
      fieldsShow = _useContext.fieldsShow,
      setFieldsShow = _useContext.setFieldsShow,
      setVisibleActive = _useContext.setVisibleActive;

  var _useState = React.useState(''),
      _useState2 = _slicedToArray(_useState, 2),
      keyFilter = _useState2[0],
      setKeyFilter = _useState2[1];

  var _useState3 = React.useState(props.listFiledProp),
      _useState4 = _slicedToArray(_useState3, 2),
      listFiledProp = _useState4[0],
      setListFiledProp = _useState4[1];

  React.useEffect(function () {
    if (!keyFilter) {
      setListFiledProp(fields);
    } else {
      var listFieldFilter = fields.filter(function (f) {
        return f.ColumnName.toUpperCase().includes(keyFilter.toUpperCase());
      });
      setListFiledProp(listFieldFilter);
    }
  }, [keyFilter]);

  var handleFieldCheck = function handleFieldCheck(checked, field) {
    var fieldsShowUpdate = _toConsumableArray(fieldsShow);

    if (checked) {
      fieldsShowUpdate.push(field.ColumnName);
    } else {
      fieldsShowUpdate = fieldsShowUpdate.filter(function (f) {
        return f !== field.ColumnName;
      });
    }

    setFieldsShow(fieldsShowUpdate);
  };

  var handleDefault = function handleDefault() {
    setFieldsShow(defaultFields);
  };

  var handleApply = function handleApply() {
    props.onColumnToggle && props.onColumnToggle(fieldsShow);
    setVisibleActive(false);
  };

  var renderFieldItem = function renderFieldItem(field, isPrimary) {
    return /*#__PURE__*/jsxRuntime.jsx(CheckBox, {
      className: 'column-toggle-item',
      label: field.ColumnName,
      checked: fieldsShow.indexOf(field.ColumnName) !== -1,
      disabled: isPrimary,
      onChange: function onChange(isCheck) {
        return handleFieldCheck(isCheck, field);
      }
    }, field.ColumnName);
  };

  var primField = fields.filter(function (field) {
    return primaryFields.indexOf(field.ColumnName) !== -1;
  });
  var normalField = listFiledProp.filter(function (field) {
    return primaryFields.indexOf(field.ColumnName) === -1;
  });
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: 'column-toggle-container',
    children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
      className: 'column-toggle-body',
      children: [/*#__PURE__*/jsxRuntime.jsx(Input, {
        className: 'column-toggle-filter',
        placeholder: 'Tìm kiếm thuộc tính',
        value: keyFilter,
        onChange: setKeyFilter
      }), /*#__PURE__*/jsxRuntime.jsx("div", {
        style: {
          height: '400px'
        },
        children: /*#__PURE__*/jsxRuntime.jsxs(ScrollView, {
          children: [primField.map(function (field) {
            return renderFieldItem(field, true);
          }), normalField.map(function (field) {
            return renderFieldItem(field, false);
          })]
        })
      })]
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: 'column-toggle-footer',
      children: [/*#__PURE__*/jsxRuntime.jsx(Button, {
        text: 'Mặc định',
        onClick: handleDefault
      }), /*#__PURE__*/jsxRuntime.jsx(Button, {
        color: 'primary',
        text: 'Áp dụng',
        onClick: handleApply
      })]
    })]
  });
};
ColumnTogglePanel.propTypes = {
  onColumnToggle: PropTypes__default['default'].func,
  listFiledProp: PropTypes__default['default'].array
};
ColumnTogglePanel.defaultProps = {
  listFiledProp: []
};

var DataToolBarActive = function DataToolBarActive(props) {
  var _useContext = React.useContext(DataToolBarContext),
      feature = _useContext.feature;

  if (!feature) {
    return null;
  }

  var panel;

  switch (feature.id) {
    case 'search-feature':
      panel = /*#__PURE__*/jsxRuntime.jsx(DataSearchPanel, {
        onSearch: props.onSearch
      });
      break;

    case 'data-sort':
      panel = /*#__PURE__*/jsxRuntime.jsx(DataSortPanel, {
        onSort: props.onSort
      });
      break;

    case 'data-filter':
      panel = /*#__PURE__*/jsxRuntime.jsx(DataFilterPanel, {
        onFilter: props.onFilter
      });
      break;

    case 'column-toggle':
      panel = /*#__PURE__*/jsxRuntime.jsx(ColumnTogglePanel, {
        onColumnToggle: props.onColumnToggle
      });
      break;

    default:
      panel = null;
  }

  return panel;
};
DataToolBarActive.propTypes = {
  onSearch: PropTypes__default['default'].func,
  onSort: PropTypes__default['default'].func,
  onFilter: PropTypes__default['default'].func,
  onColumnToggle: PropTypes__default['default'].func
};

var _excluded$a = ["onFeatureClick"];

var DataToolBarContainer = function DataToolBarContainer(_ref) {
  var onFeatureClick = _ref.onFeatureClick,
      props = _objectWithoutProperties(_ref, _excluded$a);

  var _useContext = React.useContext(DataToolBarContext),
      setFeature = _useContext.setFeature,
      containerRef = _useContext.containerRef,
      visibleActive = _useContext.visibleActive,
      setVisibleActive = _useContext.setVisibleActive;

  var onBlur = function onBlur() {
    setVisibleActive(false);
    setFeature(null);
  };

  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    ref: containerRef,
    children: [/*#__PURE__*/jsxRuntime.jsx(DataToolBarControl, {
      onSetVisiblePopup: setVisibleActive,
      onFeatureClick: onFeatureClick
    }), visibleActive && /*#__PURE__*/jsxRuntime.jsx(PopOver, {
      anchorEl: containerRef,
      onBackgroundClick: onBlur,
      children: /*#__PURE__*/jsxRuntime.jsx(DataToolBarActive, _objectSpread2({}, props))
    })]
  });
};

DataToolBarContainer.propTypes = {
  onFeatureClick: PropTypes__default['default'].func
};
var DataToolBar = function DataToolBar(props) {
  return /*#__PURE__*/jsxRuntime.jsx(DataToolBarProvider, _objectSpread2(_objectSpread2({}, props), {}, {
    children: /*#__PURE__*/jsxRuntime.jsx(DataToolBarContainer, _objectSpread2({}, props))
  }));
};
DataToolBar.propTypes = {
  fields: PropTypes__default['default'].arrayOf(PropTypes__default['default'].shape({
    ColumnName: PropTypes__default['default'].string,
    DisplayName: PropTypes__default['default'].string,
    DataType: PropTypes__default['default'].oneOf(Object.values(DATA_TYPE))
  })),
  defaultFields: PropTypes__default['default'].arrayOf(PropTypes__default['default'].string),
  // Fields that are shown by default
  primaryFields: PropTypes__default['default'].arrayOf(PropTypes__default['default'].string),
  // Fields that can't be hidden
  fieldsShow: PropTypes__default['default'].arrayOf(PropTypes__default['default'].string),
  // Fields that are currently showing
  onFeatureClick: PropTypes__default['default'].func,
  onSearch: PropTypes__default['default'].func,
  onSort: PropTypes__default['default'].func,
  onFilter: PropTypes__default['default'].func,
  onColumnToggle: PropTypes__default['default'].func
};

var MAX_DATE_SECOND = 86400;
var TIME_SPACE = {
  Seconds: 1,
  Minutes: 60,
  Hours: 3600
};
// Slider Time 24h on date with type Hours, Minutes, Seconds
var RangeTime = function RangeTime(props) {
  var inDate = props.inDate,
      onChange = props.onChange,
      onAfterChange = props.onAfterChange,
      disabled = props.disabled;
  var _props$type = props.type,
      type = _props$type === void 0 ? 'Minutes' : _props$type,
      _props$timeStart = props.timeStart,
      timeStart = _props$timeStart === void 0 ? moment__default['default']().startOf('date') : _props$timeStart,
      _props$timeEnd = props.timeEnd,
      timeEnd = _props$timeEnd === void 0 ? moment__default['default']().endOf('date') : _props$timeEnd,
      _props$timeFormat = props.timeFormat,
      timeFormat = _props$timeFormat === void 0 ? 'hh:mm A' : _props$timeFormat,
      _props$stepWithType = props.stepWithType,
      stepWithType = _props$stepWithType === void 0 ? 1 : _props$stepWithType;
  var displayMap = React.useRef({});
  var sliderRef = React.useRef(null);

  var _useState = React.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1];

  var timeSpace = TIME_SPACE[type];
  var MAX = Math.round(MAX_DATE_SECOND / timeSpace);

  var formatRangeTime = function formatRangeTime(time) {
    return moment__default['default'](time, 'HH:mm:ss').format('HH:mm:ss');
  };

  React.useEffect(function () {
    var start = convertTimeToNumber(formatRangeTime(timeStart), type);
    var end = convertTimeToNumber(formatRangeTime(timeEnd), type);

    if (start === MAX - 1) {
      start = MAX;
    }

    if (end === MAX - 1) {
      end = MAX;
    }

    if (sliderRef.current) {
      var _sliderRef$current$se, _sliderRef$current;

      (_sliderRef$current$se = (_sliderRef$current = sliderRef.current).setValueSlider) === null || _sliderRef$current$se === void 0 ? void 0 : _sliderRef$current$se.call(_sliderRef$current, [start, end]);
    }

    setValue([start, end]);
  }, [timeStart, timeEnd, MAX, type]);
  React.useEffect(function () {
    displayMap.current = getDisplayMap();
  }, [type]);

  var convertTimeToNumber = function convertTimeToNumber(time, type) {
    // type : Hours , Minutes, Seconds
    var typeConvert = "as".concat(type); // moment.duration(time).asHours() .asMinutes() .asSeconds()

    return Math.round(moment__default['default'].duration(time)[typeConvert]());
  };

  var convertNumberToTime = function convertNumberToTime(timeNumb) {
    var timeSpace = TIME_SPACE[type]; // moment toDay with 0:00:00

    var toDayNumb = moment__default['default'](moment__default['default'](inDate).format('LL')).format('X');
    return moment__default['default'].unix(parseInt(toDayNumb) + timeNumb * timeSpace);
  };

  var displayTime = function displayTime(timeNumber, typeFormat) {
    timeNumber = timeNumber === MAX ? timeNumber - 1 : timeNumber;
    var timeSpace = TIME_SPACE[type]; // should return time

    return moment__default['default'].utc(timeNumber * 1000 * timeSpace).format(typeFormat || 'LTS');
  };

  var getDisplayMap = function getDisplayMap() {
    var map = {};

    for (var i = 0; i <= 23; i++) {
      map[Math.round(i * 4.2)] = moment__default['default'].utc(i * 3600 * 1000).format('hhA');
    }

    return map;
  };

  var handleChangeValue = function handleChangeValue(value) {
    var _value = _slicedToArray(value, 2),
        start = _value[0],
        end = _value[1];

    var valueShow = CommonHelper.clone(value);

    if (start === MAX) {
      valueShow[0]--;
    }

    if (end === MAX) {
      valueShow[1]--;
    }

    setValue(value);
    onChange && onChange(valueShow);
  };

  var handleAfterChange = function handleAfterChange(value) {
    var _ref = CommonHelper.clone(value),
        _ref2 = _slicedToArray(_ref, 2),
        start = _ref2[0],
        end = _ref2[1];

    if (start === MAX) {
      start--;
    }

    if (end === MAX) {
      end--;
    }

    var timeStart = convertNumberToTime(start);
    var timeEnd = convertNumberToTime(end);
    onAfterChange && onAfterChange(start < end ? [timeStart, timeEnd] : [timeEnd, timeStart]);
  };

  return function () {
    if (!value) {
      return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {});
    }

    var _value2 = _slicedToArray(value, 2),
        start = _value2[0],
        end = _value2[1];

    var styleMark = {
      color: disabled ? 'var(--text-dark)' : 'var(--text-light)',
      fontSize: '0.75rem'
    };
    return /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: 'range-time-container',
      children: [/*#__PURE__*/jsxRuntime.jsx(Slider, {
        ref: sliderRef,
        disabled: disabled,
        min: 0,
        max: MAX,
        step: stepWithType,
        thumbSize: '12px',
        rangeSize: '3px',
        railStyle: {
          backgroundColor: 'var(--contrast-highlight)',
          opacity: 'unset',
          borderRadius: '4px'
        },
        value: value,
        displayMap: displayMap.current,
        marks: {
          0: {
            label: displayTime(0, timeFormat),
            style: styleMark
          },
          100: {
            label: displayTime(MAX - 1, timeFormat),
            style: styleMark
          }
        },
        range: true,
        showIndicator: true,
        onChange: handleChangeValue,
        onAfterChange: handleAfterChange
      }), /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'range-time-display',
        style: _objectSpread2({}, disabled && {
          color: 'var(--text-dark)'
        }),
        children: start <= end ? "".concat(displayTime(start, timeFormat), " - ").concat(displayTime(end, timeFormat)) : "".concat(displayTime(end, timeFormat), " - ").concat(displayTime(start, timeFormat))
      })]
    });
  }();
};

var CallTimer = /*#__PURE__*/function (_Component) {
  _inherits(CallTimer, _Component);

  var _super = _createSuper(CallTimer);

  function CallTimer(props) {
    var _this;

    _classCallCheck(this, CallTimer);

    _this = _super.call(this, props);

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      timer: 0,
      dot: 0
    });

    _defineProperty$1(_assertThisInitialized(_this), "timeCounter", function () {
      var me = _assertThisInitialized(_this);

      setTimeout(function () {
        var _me$state = me.state,
            dot = _me$state.dot,
            timer = _me$state.timer;

        if (me.props.active) {
          timer++;
        } else {
          timer = 0;

          if (me.props.starting) {
            if (dot > 3) {
              dot = 0;
            }

            dot++;
          }
        }

        me.setState({
          timer: timer,
          dot: dot
        });
        me.timeCounter();
      }, 1000);
    });

    _defineProperty$1(_assertThisInitialized(_this), "getCallStatus", function () {
      if (_this.props.active) {
        var minutes = Math.floor(_this.state.timer / 60.0);
        var seconds = _this.state.timer % 60;

        if (minutes < 10) {
          minutes = '0' + minutes;
        }

        if (seconds < 10) {
          seconds = '0' + seconds;
        }

        return minutes + ':' + seconds;
      } else if (_this.props.starting) {
        return 'Calling' + Array(_this.state.dot).join('.');
      }
    });

    _this.timeCounter();

    return _this;
  }

  _createClass(CallTimer, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsx("span", {
        children: /*#__PURE__*/jsxRuntime.jsx(T, {
          children: this.getCallStatus()
        })
      });
    }
  }]);

  return CallTimer;
}(React.Component);

var DialPad = /*#__PURE__*/function (_Component) {
  _inherits(DialPad, _Component);

  var _super = _createSuper(DialPad);

  function DialPad() {
    var _this;

    _classCallCheck(this, DialPad);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      phoneNumber: ''
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleAddDigit", function (digit) {
      _this.setState({
        phoneNumber: _this.state.phoneNumber + digit
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleRemoveDigit", function () {
      _this.setState({
        phoneNumber: _this.state.phoneNumber.substring(0, _this.state.phoneNumber.length - 1)
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleChange", function (event) {
      _this.setState({
        phoneNumber: event.target.value
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleCallClick", function () {
      if (_this.props.active || _this.props.starting) {
        _this.props.onStopClick();
      } else {
        _this.props.onCallClick(_this.state.phoneNumber);
      }
    });

    return _this;
  }

  _createClass(DialPad, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "pad",
        children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
          className: "dial-pad",
          children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
            className: "contact",
            children: [/*#__PURE__*/jsxRuntime.jsx("div", {
              className: "avatar"
            }), /*#__PURE__*/jsxRuntime.jsxs("div", {
              className: "contact-info",
              children: [/*#__PURE__*/jsxRuntime.jsx("div", {
                className: "contact-name",
                children: "Matt Sich"
              }), /*#__PURE__*/jsxRuntime.jsx("div", {
                className: "contact-position",
                children: "CodePenner"
              }), /*#__PURE__*/jsxRuntime.jsx("div", {
                className: "contact-number",
                children: "(123) 456 - 7890"
              })]
            }), /*#__PURE__*/jsxRuntime.jsxs("div", {
              className: "contact-buttons",
              children: [/*#__PURE__*/jsxRuntime.jsx("button", {
                className: "icon-message"
              }), /*#__PURE__*/jsxRuntime.jsx("button", {
                className: "icon-video"
              })]
            })]
          }), /*#__PURE__*/jsxRuntime.jsx("div", {
            className: "phoneString",
            children: /*#__PURE__*/jsxRuntime.jsx("input", {
              ref: function ref(input) {
                return input && input.focus();
              },
              type: "text",
              value: this.state.phoneNumber,
              onChange: this.handleChange
            })
          }), /*#__PURE__*/jsxRuntime.jsxs("div", {
            className: "digits",
            children: [/*#__PURE__*/jsxRuntime.jsx("div", {
              className: "dig pound",
              onClick: this.handleAddDigit.bind(this, 1),
              children: "1"
            }), /*#__PURE__*/jsxRuntime.jsxs("div", {
              className: "dig",
              onClick: this.handleAddDigit.bind(this, 2),
              children: ["2", /*#__PURE__*/jsxRuntime.jsx("div", {
                className: "sub-dig",
                children: "ABC"
              })]
            }), /*#__PURE__*/jsxRuntime.jsxs("div", {
              className: "dig",
              onClick: this.handleAddDigit.bind(this, 3),
              children: ["3", /*#__PURE__*/jsxRuntime.jsx("div", {
                className: "sub-dig",
                children: "DEF"
              })]
            }), /*#__PURE__*/jsxRuntime.jsxs("div", {
              className: "dig",
              onClick: this.handleAddDigit.bind(this, 4),
              children: ["4", /*#__PURE__*/jsxRuntime.jsx("div", {
                className: "sub-dig",
                children: "GHI"
              })]
            }), /*#__PURE__*/jsxRuntime.jsxs("div", {
              className: "dig",
              onClick: this.handleAddDigit.bind(this, 5),
              children: ["5", /*#__PURE__*/jsxRuntime.jsx("div", {
                className: "sub-dig",
                children: "JKL"
              })]
            }), /*#__PURE__*/jsxRuntime.jsxs("div", {
              className: "dig",
              onClick: this.handleAddDigit.bind(this, 6),
              children: ["6", /*#__PURE__*/jsxRuntime.jsx("div", {
                className: "sub-dig",
                children: "MNO"
              })]
            }), /*#__PURE__*/jsxRuntime.jsxs("div", {
              className: "dig",
              onClick: this.handleAddDigit.bind(this, 7),
              children: ["7", /*#__PURE__*/jsxRuntime.jsx("div", {
                className: "sub-dig",
                children: "PQRS"
              })]
            }), /*#__PURE__*/jsxRuntime.jsxs("div", {
              className: "dig",
              onClick: this.handleAddDigit.bind(this, 8),
              children: ["8", /*#__PURE__*/jsxRuntime.jsx("div", {
                className: "sub-dig",
                children: "TUV"
              })]
            }), /*#__PURE__*/jsxRuntime.jsxs("div", {
              className: "dig",
              onClick: this.handleAddDigit.bind(this, 9),
              children: ["9", /*#__PURE__*/jsxRuntime.jsx("div", {
                className: "sub-dig",
                children: "WXYZ"
              })]
            }), /*#__PURE__*/jsxRuntime.jsx("div", {
              className: "dig astrisk",
              onClick: this.handleAddDigit.bind(this, '*'),
              children: "*"
            }), /*#__PURE__*/jsxRuntime.jsx("div", {
              className: "dig pound",
              onClick: this.handleAddDigit.bind(this, 0),
              children: "0"
            }), /*#__PURE__*/jsxRuntime.jsx("div", {
              className: "dig pound",
              onClick: this.handleAddDigit.bind(this, '#'),
              children: "#"
            })]
          }), /*#__PURE__*/jsxRuntime.jsxs("div", {
            className: "digits",
            children: [/*#__PURE__*/jsxRuntime.jsx("div", {
              className: "dig addPerson",
              children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                icon: 'user-plus',
                size: '24px',
                type: 'regular',
                color: 'white'
              })
            }), /*#__PURE__*/jsxRuntime.jsx("div", {
              className: "dig-spacer"
            }), /*#__PURE__*/jsxRuntime.jsx("div", {
              className: "dig goBack",
              onClick: this.handleRemoveDigit,
              children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                icon: 'backspace',
                size: '24px',
                type: 'regular',
                color: 'white'
              })
            })]
          })]
        }), /*#__PURE__*/jsxRuntime.jsxs("div", {
          className: "call-pad ".concat(this.props.active || this.props.starting ? 'in-call' : ''),
          children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
            className: "pulsate",
            children: [/*#__PURE__*/jsxRuntime.jsx("div", {}), /*#__PURE__*/jsxRuntime.jsx("div", {}), /*#__PURE__*/jsxRuntime.jsx("div", {})]
          }), /*#__PURE__*/jsxRuntime.jsx("div", {
            className: "ca-avatar",
            children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
              icon: 'user-circle',
              size: '100px',
              color: 'white'
            })
          }), /*#__PURE__*/jsxRuntime.jsx("div", {
            className: "ca-number",
            children: this.props.counterpart
          }), /*#__PURE__*/jsxRuntime.jsx("div", {
            className: "ca-status",
            children: /*#__PURE__*/jsxRuntime.jsx(CallTimer, _objectSpread2({}, this.props))
          }), /*#__PURE__*/jsxRuntime.jsxs("div", {
            className: 'ca-buttons',
            children: [/*#__PURE__*/jsxRuntime.jsx("div", {
              className: "ca-b-single",
              "data-label": "Add Contact",
              children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                icon: 'user-plus',
                size: '24px',
                color: 'white'
              })
            }), /*#__PURE__*/jsxRuntime.jsx("div", {
              className: "ca-b-single",
              "data-label": "Mute",
              children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                icon: 'microphone-slash',
                size: '24px',
                color: 'white'
              })
            }), /*#__PURE__*/jsxRuntime.jsx("div", {
              className: "ca-b-single",
              "data-label": "Speaker",
              children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                icon: 'volume',
                size: '24px',
                color: 'white'
              })
            }), /*#__PURE__*/jsxRuntime.jsx("div", {
              className: "ca-b-single",
              "data-label": "Face to Face",
              children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                icon: 'video',
                size: '24px',
                color: 'white'
              })
            }), /*#__PURE__*/jsxRuntime.jsx("div", {
              className: "ca-b-single",
              "data-label": "Chat",
              children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                icon: 'comment-lines',
                size: '24px',
                color: 'white'
              })
            }), /*#__PURE__*/jsxRuntime.jsx("div", {
              className: "ca-b-single",
              "data-label": "Keypad",
              children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                icon: 'keyboard',
                size: '24px',
                color: 'white'
              })
            })]
          })]
        }), !this.props.incoming && /*#__PURE__*/jsxRuntime.jsxs("div", {
          className: "call action-dig ".concat(this.props.active || this.props.starting ? 'in-call' : ''),
          onClick: this.handleCallClick,
          children: [/*#__PURE__*/jsxRuntime.jsx("div", {
            className: "call-change",
            children: /*#__PURE__*/jsxRuntime.jsx("span", {})
          }), /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
            className: 'call-icon',
            icon: 'phone',
            size: '24px',
            type: 'regular',
            color: 'white'
          })]
        }), this.props.incoming && /*#__PURE__*/jsxRuntime.jsxs("div", {
          children: [/*#__PURE__*/jsxRuntime.jsx("div", {
            className: 'reject action-dig',
            onClick: this.props.onStopClick,
            children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
              icon: 'phone',
              size: '24px',
              type: 'regular',
              color: 'white'
            })
          }), /*#__PURE__*/jsxRuntime.jsx("div", {
            className: 'answer action-dig',
            onClick: this.props.onAnswerClick,
            children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
              icon: 'phone',
              size: '24px',
              type: 'regular',
              color: 'white'
            })
          })]
        })]
      });
    }
  }]);

  return DialPad;
}(React.Component);
DialPad.propTypes = {
  className: PropTypes__default['default'].string,
  onStopClick: PropTypes__default['default'].func,
  onCallClick: PropTypes__default['default'].func,
  onAnswerClick: PropTypes__default['default'].func,
  active: PropTypes__default['default'].bool,
  starting: PropTypes__default['default'].bool,
  incoming: PropTypes__default['default'].bool,
  counterpart: PropTypes__default['default'].string
};
DialPad.defaultProps = {
  className: ''
};

var Expanded = function Expanded(props) {
  var _props$flex = props.flex,
      flex = _props$flex === void 0 ? true : _props$flex,
      _props$padding = props.padding,
      padding = _props$padding === void 0 ? '0 0 0 0' : _props$padding,
      _props$margin = props.margin,
      margin = _props$margin === void 0 ? '0 0 0 0' : _props$margin,
      className = props.className,
      children = props.children;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: className,
    style: {
      flex: 1,
      width: '100%',
      height: '100%',
      display: flex ? 'flex' : 'block',
      padding: padding,
      margin: margin
    },
    children: children
  });
};

var FSDataContainer = function FSDataContainer(_ref) {
  var className = _ref.className,
      children = _ref.children;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: "fs-data-container ".concat(className),
    children: children
  });
};
FSDataContainer.propTypes = {
  className: PropTypes__default['default'].string
};
FSDataContainer.defaultProps = {
  className: ''
};
var FSDataBody = function FSDataBody(_ref2) {
  var className = _ref2.className,
      children = _ref2.children,
      layout = _ref2.layout;
      _ref2.verticalLine;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: "fs-data-body ".concat(layout, " ").concat(className),
    children: children
  });
};
FSDataBody.propTypes = {
  className: PropTypes__default['default'].string,
  verticalLine: PropTypes__default['default'].bool,
  layout: PropTypes__default['default'].string
};
FSDataBody.defaultProps = {
  className: '',
  verticalLine: false,
  layout: ''
};
var FSDataContent = function FSDataContent(_ref3) {
  var className = _ref3.className,
      children = _ref3.children;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: "fs-data-content ".concat(className),
    children: children
  });
};
FSDataContent.propTypes = {
  className: PropTypes__default['default'].string
};
FSDataContent.defaultProps = {
  className: ''
};
var VerticalLine = function VerticalLine() {
  return /*#__PURE__*/jsxRuntime.jsx("i", {
    className: 'vertical-line '
  });
};

var FeatureBar = /*#__PURE__*/function (_Component) {
  _inherits(FeatureBar, _Component);

  var _super = _createSuper(FeatureBar);

  function FeatureBar() {
    _classCallCheck(this, FeatureBar);

    return _super.apply(this, arguments);
  }

  _createClass(FeatureBar, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "feature-bar ".concat(this.props.className || ''),
        children: /*#__PURE__*/jsxRuntime.jsx(FlexPanel2, {
          children: this.props.children
        })
      });
    }
  }]);

  return FeatureBar;
}(React.Component);
FeatureBar.propTypes = {// className: PropTypes.string,
  // scroll: PropTypes.bool,
};
FeatureBar.defaultProps = {// className: '',
};
var FeatureBarTop = /*#__PURE__*/function (_Component2) {
  _inherits(FeatureBarTop, _Component2);

  var _super2 = _createSuper(FeatureBarTop);

  function FeatureBarTop() {
    _classCallCheck(this, FeatureBarTop);

    return _super2.apply(this, arguments);
  }

  _createClass(FeatureBarTop, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'feature-bar-top',
        children: this.props.children
      });
    }
  }]);

  return FeatureBarTop;
}(React.Component);
var FeatureBarBottom = /*#__PURE__*/function (_Component3) {
  _inherits(FeatureBarBottom, _Component3);

  var _super3 = _createSuper(FeatureBarBottom);

  function FeatureBarBottom() {
    _classCallCheck(this, FeatureBarBottom);

    return _super3.apply(this, arguments);
  }

  _createClass(FeatureBarBottom, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'feature-bar-bottom',
        children: this.props.children
      });
    }
  }]);

  return FeatureBarBottom;
}(React.Component);

var withI18n = function withI18n(Component) {
  return function (props) {
    var i18n = useI18n();
    return /*#__PURE__*/jsxRuntime.jsx(Component, _objectSpread2(_objectSpread2({}, i18n), props));
  };
};

exports.FeatureImage = /*#__PURE__*/function (_Component) {
  _inherits(FeatureImage, _Component);

  var _super = _createSuper(FeatureImage);

  function FeatureImage() {
    var _this;

    _classCallCheck(this, FeatureImage);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "handleClick", function (event) {
      _this.props.onClick(_this.props, event);
    });

    return _this;
  }

  _createClass(FeatureImage, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsx("button", {
        className: "feature-item feature-image ".concat(this.props.active ? 'active' : '', " ").concat(this.props.className),
        title: this.props.t(this.props.tooltip),
        onClick: this.handleClick,
        children: /*#__PURE__*/jsxRuntime.jsx(Image$1, {
          src: this.props.src,
          width: '1.5rem',
          height: '1.5rem',
          altSrc: 'icon.png'
        })
      });
    }
  }]);

  return FeatureImage;
}(React.Component);

exports.FeatureImage.propTypes = {
  id: PropTypes__default['default'].string,
  className: PropTypes__default['default'].string,
  src: PropTypes__default['default'].string.isRequired,
  active: PropTypes__default['default'].bool,
  tooltip: PropTypes__default['default'].string,
  onClick: PropTypes__default['default'].func
};
exports.FeatureImage.defaultProps = {
  id: '',
  className: '',
  badgeCount: null,
  active: false,
  icon: '',
  onClick: function onClick() {}
};
exports.FeatureImage = withI18n(exports.FeatureImage);

var FeatureLink = function FeatureLink(props) {
  var badgeCount = props.badgeCount,
      className = props.className,
      icon = props.icon,
      to = props.to,
      tooltip = props.tooltip,
      exact = props.exact;

  var _useI18n = useI18n(),
      t = _useI18n.t;

  var badge = badgeCount === 0 ? null : badgeCount;
  return /*#__PURE__*/jsxRuntime.jsx(reactRouterDom.NavLink, {
    className: "feature-item ".concat(className),
    "badge-count": badge,
    to: to,
    exact: exact,
    title: t(tooltip),
    children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
      icon: icon,
      type: 'light',
      size: '1.25rem'
    })
  });
};
FeatureLink.propTypes = {
  id: PropTypes__default['default'].string,
  className: PropTypes__default['default'].string,
  icon: PropTypes__default['default'].string.isRequired,
  badgeCount: PropTypes__default['default'].number,
  tooltip: PropTypes__default['default'].string
};
FeatureLink.defaultProps = {
  className: '',
  badgeCount: null,
  icon: ''
};

var FeatureText = function FeatureText(props) {
  var _useI18n = useI18n(),
      t = _useI18n.t;

  var handleClick = function handleClick(event) {
    props.onClick && props.onClick(props, event);
  };

  var badge = props.badgeCount === 0 ? null : props.badgeCount;
  var content = props.content;

  if (content && content.length > 2) {
    content = content.substr(0, 2);
  }

  return /*#__PURE__*/jsxRuntime.jsx("button", {
    className: "feature-item feature-text ".concat(props.active ? 'active' : '', " ").concat(props.className),
    onClick: handleClick,
    "badge-count": badge,
    title: t(props.title),
    children: /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "text-container",
      children: content
    })
  });
};

FeatureText.propTypes = {
  id: PropTypes__default['default'].string,
  className: PropTypes__default['default'].string,
  content: PropTypes__default['default'].string.isRequired,
  active: PropTypes__default['default'].bool,
  badgeCount: PropTypes__default['default'].number,
  title: PropTypes__default['default'].string,
  onClick: PropTypes__default['default'].func
};
FeatureText.defaultProps = {
  id: '',
  className: '',
  badgeCount: null,
  active: false,
  icon: '',
  onClick: function onClick() {}
};

var SearchField = /*#__PURE__*/function (_Component) {
  _inherits(SearchField, _Component);

  var _super = _createSuper(SearchField);

  function SearchField() {
    var _this;

    _classCallCheck(this, SearchField);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      value: _this.props.value || ''
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleChange", function (value) {
      _this.setState({
        value: value
      }, _this.props.onChange(value));
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleClearText", function () {
      _this.setState({
        value: ''
      }, _this.props.onChange(''));
    });

    return _this;
  }

  _createClass(SearchField, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          type = _this$props.type,
          className = _this$props.className,
          placeholder = _this$props.placeholder,
          width = _this$props.width,
          fullwidth = _this$props.fullwidth;
      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: 'search-box',
        children: [/*#__PURE__*/jsxRuntime.jsx(Input, {
          type: type,
          className: "search-field ".concat(className),
          style: {
            width: fullwidth ? '100%' : width
          },
          value: this.state.value,
          placeholder: placeholder,
          onChange: this.handleChange
        }), this.state.value && /*#__PURE__*/jsxRuntime.jsx("button", {
          className: 'search-btn clear-text',
          onClick: this.handleClearText,
          children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
            icon: 'times',
            size: '1.125rem'
          })
        }), !this.state.value && /*#__PURE__*/jsxRuntime.jsx("button", {
          className: 'search-btn',
          children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
            icon: 'search',
            size: '1.125rem'
          })
        })]
      });
    }
  }]);

  return SearchField;
}(React.Component);
SearchField.propTypes = {
  disabled: PropTypes__default['default'].bool,
  placeholder: PropTypes__default['default'].string,
  type: PropTypes__default['default'].string,
  value: PropTypes__default['default'].any,
  className: PropTypes__default['default'].string,
  width: PropTypes__default['default'].string,
  fullwidth: PropTypes__default['default'].bool,
  onChange: PropTypes__default['default'].func
};
SearchField.defaultProps = {
  disabled: false,
  placeholder: '',
  type: 'text',
  value: '',
  className: '',
  width: '20rem',
  fullWidth: false,
  onChange: function onChange() {}
};

var FormField = /*#__PURE__*/function (_Component) {
  _inherits(FormField, _Component);

  var _super = _createSuper(FormField);

  function FormField() {
    _classCallCheck(this, FormField);

    return _super.apply(this, arguments);
  }

  _createClass(FormField, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsxs(Container, {
        className: "form-field-item form-field-".concat(this.props.type, " ").concat(this.props.className),
        children: [/*#__PURE__*/jsxRuntime.jsx(Container, {
          className: "form-field-left",
          children: /*#__PURE__*/jsxRuntime.jsx(T, {
            children: this.props.label
          })
        }), /*#__PURE__*/jsxRuntime.jsx(Container, {
          className: "form-field-right",
          children: this.props.children
        })]
      });
    }
  }]);

  return FormField;
}(React.Component);
FormField.propTypes = {
  className: PropTypes__default['default'].string,
  label: PropTypes__default['default'].any,
  type: PropTypes__default['default'].oneOf(['vertical', 'horizontal'])
};
FormField.defaultProps = {
  className: '',
  label: '',
  type: 'horizontal'
};

var Iframe = function Iframe(props) {
  var className = props.className,
      width = props.width,
      height = props.height,
      background = props.background,
      src = props.src,
      _props$frameBorder = props.frameBorder,
      frameBorder = _props$frameBorder === void 0 ? 0 : _props$frameBorder;
  return /*#__PURE__*/jsxRuntime.jsx("iframe", {
    className: className,
    frameBorder: frameBorder,
    style: {
      width: width,
      height: height,
      background: background
    },
    src: src
  });
};

var BoxImage = /*#__PURE__*/function (_React$Component) {
  _inherits(BoxImage, _React$Component);

  var _super = _createSuper(BoxImage);

  function BoxImage() {
    var _this;

    _classCallCheck(this, BoxImage);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "borderWidth", 2);

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      src: '',
      loaded: false,
      boxes: []
    });

    _defineProperty$1(_assertThisInitialized(_this), "canvasRef", /*#__PURE__*/React__default['default'].createRef());

    _defineProperty$1(_assertThisInitialized(_this), "currentTarget", null);

    _defineProperty$1(_assertThisInitialized(_this), "handleImageLoad", function (event) {
      _this.currentTarget = event.currentTarget;
      var canvas = _this.canvasRef.current;
      var _event$currentTarget = event.currentTarget,
          naturalWidth = _event$currentTarget.naturalWidth,
          naturalHeight = _event$currentTarget.naturalHeight;
      var ctx = canvas.getContext('2d');
      canvas.width = naturalWidth;
      canvas.height = naturalHeight;
      ctx.drawImage(event.currentTarget, 0, 0);
      _this.props.onImageLoaded && _this.props.onImageLoaded(canvas.toDataURL('image/jpeg', 0.7));

      _this.setState({
        loaded: true
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleOnClick", function (box) {
      _this.props.onClick && _this.props.onClick(box);
    });

    _defineProperty$1(_assertThisInitialized(_this), "getMarkupImage", function () {
      var boxes = _this.props.boxes;
      var _this$currentTarget = _this.currentTarget,
          naturalWidth = _this$currentTarget.naturalWidth,
          naturalHeight = _this$currentTarget.naturalHeight;
      var canvas = _this.canvasRef.current;
      var ctx = canvas.getContext('2d');
      canvas.width = naturalWidth;
      canvas.height = naturalHeight;
      ctx.drawImage(_this.currentTarget, 0, 0);

      var _iterator = _createForOfIteratorHelper(boxes),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var box = _step.value;
          ctx.beginPath();
          ctx.lineWidth = 4;
          ctx.strokeStyle = _this.props.choosingId === box.id ? _this.props.choosingColor || 'yellow' : box.color;
          ctx.rect(box.left * naturalWidth, box.top * naturalHeight, box.width * naturalWidth, box.height * naturalHeight);
          ctx.stroke();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var _iterator2 = _createForOfIteratorHelper(boxes),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _box = _step2.value;
          ctx.font = '35px Verdana';
          ctx.lineWidth = 4;
          ctx.strokeStyle = 'white';
          ctx.strokeText(_box.label, _box.left * naturalWidth, _box.top * naturalHeight - 10);
          ctx.fillStyle = _this.props.choosingId === _box.id ? _this.props.choosingColor || 'yellow' : _box.color;
          ctx.fillText(_box.label, _box.left * naturalWidth, _box.top * naturalHeight - 10);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return canvas.toDataURL('image/jpeg', 0.7);
    });

    _defineProperty$1(_assertThisInitialized(_this), "getBoxStyle", function (b) {
      return {
        position: 'absolute',
        left: "calc(".concat(b.left * 100, "% - ").concat(_this.borderWidth / 2, "px)"),
        top: "calc(".concat(b.top * 100, "% - ").concat(_this.borderWidth / 2, "px)"),
        width: "calc(".concat(b.width * 100, "% - ").concat(_this.borderWidth / 2, "px)"),
        height: "calc(".concat(b.height * 100, "% - ").concat(_this.borderWidth / 2, "px)"),
        // border: `${b.border} solid ${this.props.choosingId === b.id ? this.props.choosingColor || 'yellow' : b.color}`,
        opacity: 0.8
      };
    });

    return _this;
  }

  _createClass(BoxImage, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      return /*#__PURE__*/jsxRuntime.jsx(reactZoomPanPinch.TransformWrapper, {
        wheel: {
          step: 4
        },
        enablePadding: false,
        enablePanPadding: false,
        children: /*#__PURE__*/jsxRuntime.jsx(reactZoomPanPinch.TransformComponent, {
          children: /*#__PURE__*/jsxRuntime.jsxs("div", {
            style: {
              position: 'relative'
            },
            children: [/*#__PURE__*/jsxRuntime.jsx("canvas", {
              ref: this.canvasRef,
              style: {
                display: 'none'
              }
            }), this.state.loaded ? /*#__PURE__*/jsxRuntime.jsx(Image$1, {
              src: this.getMarkupImage()
            }) : /*#__PURE__*/jsxRuntime.jsx(Image$1, {
              ref: this.imageRef,
              src: this.props.imageData,
              onLoad: this.handleImageLoad
            }), this.props.boxes.filter(function (b) {
              return b.width < 0.7 && b.height < 0.7;
            }).sort(function (a, b) {
              return b.width * b.height - a.width * a.height;
            }).map(function (b, i) {
              return /*#__PURE__*/jsxRuntime.jsx("div", {
                onClick: function onClick() {
                  return _this2.handleOnClick(b);
                },
                style: _this2.getBoxStyle(b)
              }, i);
            })]
          })
        })
      });
    }
  }]);

  return BoxImage;
}(React__default['default'].Component);

_defineProperty$1(BoxImage, "getDerivedStateFromProps", function (nextProps, prevState) {
  if (prevState.src !== nextProps.imageData) {
    return {
      src: nextProps.imageData,
      loaded: false
    };
  } else {
    return null;
  }
});
BoxImage.propTypes = {
  className: PropTypes__default['default'].string,
  imageData: PropTypes__default['default'].string,
  boxes: PropTypes__default['default'].array,
  width: PropTypes__default['default'].string,
  height: PropTypes__default['default'].string,
  onClick: PropTypes__default['default'].func,
  choosingColor: PropTypes__default['default'].string,
  choosingId: PropTypes__default['default'].string,
  onImageLoaded: PropTypes__default['default'].func
};
BoxImage.defaultProps = {
  className: ''
};

var CropImage = /*#__PURE__*/function (_React$Component) {
  _inherits(CropImage, _React$Component);

  var _super = _createSuper(CropImage);

  function CropImage() {
    var _this;

    _classCallCheck(this, CropImage);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      cropImage: ''
    });

    _defineProperty$1(_assertThisInitialized(_this), "canvasRef", /*#__PURE__*/React__default['default'].createRef());

    _defineProperty$1(_assertThisInitialized(_this), "imgRef", /*#__PURE__*/React__default['default'].createRef());

    return _this;
  }

  _createClass(CropImage, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      var box = this.props.box;
      var canvas = this.canvasRef.current;
      var img = this.imgRef.current;
      canvas.width = box.width;
      canvas.height = box.height;
      var ctx = canvas.getContext('2d');

      img.onload = function () {
        var x = box.x;
        var y = box.y;
        var width = box.width;
        var height = box.height;

        if (_this2.props.unit === '%') {
          x = Math.floor(x * img.width);
          y = Math.floor(y * img.height);
          width = Math.ceil(width * img.width);
          height = Math.ceil(height * img.height);
          canvas.width = width;
          canvas.height = height;
        }

        ctx.drawImage(img, x, y, width, height, 0, 0, width, height);

        _this2.setState({
          cropImage: canvas.toDataURL()
        });
      };
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        style: {
          border: "1px solid ".concat(this.props.borderColor || 'transparent'),
          width: 'fit-content',
          margin: 'auto'
        },
        children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
          style: {
            display: 'none'
          },
          children: [/*#__PURE__*/jsxRuntime.jsx("canvas", {
            ref: this.canvasRef
          }), /*#__PURE__*/jsxRuntime.jsx("img", {
            crossOrigin: "anonymous",
            ref: this.imgRef,
            alt: 'hidden',
            src: this.props.imageData
          })]
        }), /*#__PURE__*/jsxRuntime.jsx(Image$1, _objectSpread2({
          src: this.state.cropImage,
          alt: this.props.alt
        }, this.props))]
      });
    }
  }]);

  return CropImage;
}(React__default['default'].Component);
CropImage.propTypes = {
  className: PropTypes__default['default'].string,
  imageData: PropTypes__default['default'].string,
  box: PropTypes__default['default'].object,
  unit: PropTypes__default['default'].string,
  borderColor: PropTypes__default['default'].string
};
CropImage.defaultProps = {
  className: ''
};

var DetectImage = /*#__PURE__*/function (_React$Component) {
  _inherits(DetectImage, _React$Component);

  var _super = _createSuper(DetectImage);

  function DetectImage() {
    var _this;

    _classCallCheck(this, DetectImage);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      image: _this.props.imageData
    });

    _defineProperty$1(_assertThisInitialized(_this), "canvasRef", /*#__PURE__*/React__default['default'].createRef());

    _defineProperty$1(_assertThisInitialized(_this), "handleImageLoad", function (event) {
      var boxes = _this.props.boxes;
      var canvas = _this.canvasRef.current;
      var _event$currentTarget = event.currentTarget,
          width = _event$currentTarget.width,
          height = _event$currentTarget.height;
      var ctx = canvas.getContext('2d');
      canvas.width = width;
      canvas.height = height;
      ctx.drawImage(event.currentTarget, 0, 0);

      var _iterator = _createForOfIteratorHelper(boxes),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var box = _step.value;
          ctx.beginPath();
          ctx.lineWidth = 6;
          ctx.strokeStyle = box.color;
          ctx.rect(box.left * width, box.top * height, box.width * width, box.height * height);
          ctx.stroke();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var _iterator2 = _createForOfIteratorHelper(boxes),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _box = _step2.value;
          ctx.font = '35px Verdana';
          ctx.lineWidth = 4;
          ctx.strokeStyle = 'white';
          ctx.strokeText(_box.label, _box.left * width, _box.top * height - 10);
          ctx.fillStyle = _box.color;
          ctx.fillText(_box.label, _box.left * width, _box.top * height - 10);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      _this.setState({
        image: canvas.toDataURL('image/jpeg', 0.7)
      });
    });

    return _this;
  }

  _createClass(DetectImage, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
          style: {
            display: 'none'
          },
          children: [/*#__PURE__*/jsxRuntime.jsx("canvas", {
            ref: this.canvasRef
          }), /*#__PURE__*/jsxRuntime.jsx("img", {
            alt: 'hidden',
            crossOrigin: 'anonymous',
            src: this.props.imageData,
            onLoad: this.handleImageLoad
          })]
        }), /*#__PURE__*/jsxRuntime.jsx(Image$1, _objectSpread2({
          src: this.state.image
        }, this.props))]
      });
    }
  }]);

  return DetectImage;
}(React__default['default'].Component);
DetectImage.propTypes = {
  className: PropTypes__default['default'].string,
  imageData: PropTypes__default['default'].string,
  boxes: PropTypes__default['default'].array
};
DetectImage.defaultProps = {
  className: ''
};

var unknownFace = "data:image/png;base64,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";

var _excluded$9 = ["fitMode", "score", "accuracy", "title", "active", "onClick", "backgroundImage", "widthImage", "heightImage", "src"];
var FSImage = function FSImage(_ref) {
  var fitMode = _ref.fitMode,
      score = _ref.score,
      accuracy = _ref.accuracy,
      title = _ref.title,
      active = _ref.active,
      onClick = _ref.onClick,
      backgroundImage = _ref.backgroundImage,
      widthImage = _ref.widthImage,
      heightImage = _ref.heightImage,
      src = _ref.src,
      props = _objectWithoutProperties(_ref, _excluded$9);

  var bestClass = accuracy > 0.6 ? 'fsi-best-match' : '';
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: "fsi ".concat(bestClass),
    children: /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'fsi-container ',
      style: {
        width: widthImage
      },
      onClick: onClick,
      children: /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "fsi-content ".concat(active ? 'active' : ''),
        children: [title && /*#__PURE__*/jsxRuntime.jsx("p", {
          className: 'fsi-label top',
          children: /*#__PURE__*/jsxRuntime.jsx(T, {
            children: title
          })
        }), typeof src === 'string' ? /*#__PURE__*/jsxRuntime.jsx(Image$1, _objectSpread2(_objectSpread2({
          width: widthImage,
          height: heightImage,
          fitMode: fitMode,
          background: backgroundImage
        }, props), {}, {
          src: src,
          altSrc: unknownFace
        })) : /*#__PURE__*/jsxRuntime.jsx(CropImage, _objectSpread2({
          imageData: src.imageData,
          box: src.box,
          width: widthImage,
          height: heightImage,
          fitMode: fitMode,
          background: backgroundImage,
          altSrc: unknownFace
        }, props)), score && /*#__PURE__*/jsxRuntime.jsxs("p", {
          className: 'fsi-label bottom',
          children: [/*#__PURE__*/jsxRuntime.jsx(T, {
            children: "Score"
          }), " ", Math.floor(score * 100)]
        }), accuracy && /*#__PURE__*/jsxRuntime.jsx("p", {
          className: 'fsi-label bottom',
          children: (accuracy * 100).toFixed(0) + '%'
        })]
      })
    })
  });
};
FSImage.propTypes = {
  fitMode: PropTypes__default['default'].string,
  src: PropTypes__default['default'].any,
  canEnlarge: PropTypes__default['default'].bool,
  score: PropTypes__default['default'].number,
  accuracy: PropTypes__default['default'].number,
  widthImage: PropTypes__default['default'].string,
  heightImage: PropTypes__default['default'].string,
  title: PropTypes__default['default'].string,
  active: PropTypes__default['default'].bool,
  onClick: PropTypes__default['default'].func,
  backgroundImage: PropTypes__default['default'].string
};
FSImage.defaultProps = {
  fitMode: 'contain',
  canEnlarge: false,
  score: null,
  accuracy: null,
  title: '',
  widthImage: '',
  heightImage: '',
  active: false,
  backgroundImage: '',
  onClick: function onClick() {}
};

var UploadImage = function UploadImage(props) {
  var width = props.width,
      height = props.height,
      canEnlarge = props.canEnlarge,
      canDelete = props.canDelete,
      src = props.src,
      className = props.className,
      fitMode = props.fitMode,
      isLoading = props.isLoading,
      onChange = props.onChange,
      onDelete = props.onDelete,
      multi = props.multi,
      limit = props.limit;
  var inputRef = React.useRef();
  var containerRef = React.useRef();
  var imageReader = new ImageReader();

  var _useModal = useModal(),
      menu = _useModal.menu,
      toast = _useModal.toast;

  var handleImageChange = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(event) {
      var files, list;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(onChange && event.target.files && event.target.files.length > 0)) {
                _context2.next = 8;
                break;
              }

              files = Array.from(event.target.files);

              if (multi && limit && files && files.length > limit) {
                files.length = limit;
                toast({
                  type: 'error',
                  message: "T\u1EA3i l\xEAn t\u1ED1i \u0111a ".concat(limit, " \u1EA3nh")
                });
              }

              _context2.next = 5;
              return Promise.all(files.map( /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(file) {
                  var fileName, _yield$imageReader$re, data, orientation;

                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          fileName = file.name;
                          _context.next = 3;
                          return imageReader.read(file);

                        case 3:
                          _yield$imageReader$re = _context.sent;
                          data = _yield$imageReader$re.image;
                          orientation = _yield$imageReader$re.orientation;
                          return _context.abrupt("return", {
                            fileName: fileName,
                            data: data,
                            rawData: file,
                            orientation: orientation
                          });

                        case 7:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }));

                return function (_x2) {
                  return _ref2.apply(this, arguments);
                };
              }()));

            case 5:
              list = _context2.sent;
              event.target.value = '';
              onChange(multi ? list : list[0]);

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function handleImageChange(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  var handleChangeClick = function handleChangeClick(event) {
    event && event.stopPropagation();
    inputRef.current.click();
  };

  var handleDeleteClick = function handleDeleteClick(event) {
    event && event.stopPropagation();

    if (onDelete) {
      onDelete();
    }
  };

  var handleClick = function handleClick(event) {
    var position = event.target.getBoundingClientRect();
    var buttons = [{
      label: 'Tải ảnh lên',
      icon: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
        className: 'upload-icon',
        icon: 'cloud-upload-alt',
        type: 'solid',
        color: 'var(--success-color)',
        size: "1rem"
      }),
      onClick: handleChangeClick
    }];
    canDelete && buttons.push({
      label: 'Xoá',
      icon: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
        className: 'remove-icon',
        icon: 'trash-alt',
        type: 'solid',
        color: 'var(--danger-color)',
        size: "1rem"
      }),
      onClick: handleDeleteClick
    }); // click action doesn't close context menu

    menu({
      id: 'click-image',
      position: {
        x: position.left,
        y: position.bottom + 3
      },
      isTopLeft: true,
      actions: buttons,
      isCloseOnAction: true
    });
  };

  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx("div", _objectSpread2(_objectSpread2({
      ref: containerRef,
      className: "upload-image-container ".concat(className)
    }, !isLoading ? {
      onClick: !src ? handleChangeClick : handleClick
    } : {}), {}, {
      style: {
        width: width,
        height: height
      },
      children: isLoading ? /*#__PURE__*/jsxRuntime.jsx(Loading, {
        spinnerSize: 'lg'
      }) : /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [src && /*#__PURE__*/jsxRuntime.jsx(Image$1, {
          canEnlarge: canEnlarge,
          width: "calc(".concat(width, " - 4px)"),
          height: "calc(".concat(height, " - 4px)"),
          fitMode: fitMode,
          src: src
        }), /*#__PURE__*/jsxRuntime.jsx("div", {
          className: 'upload-image-actions',
          children: !src && /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
            className: 'add-new-icon',
            icon: 'plus',
            type: 'solid'
          })
        })]
      })
    })), /*#__PURE__*/jsxRuntime.jsx("input", {
      ref: inputRef,
      type: "file",
      accept: 'image/png, image/jpeg',
      multiple: multi,
      hidden: true,
      onChange: handleImageChange
    })]
  });
};

UploadImage.propTypes = {
  className: PropTypes__default['default'].string,
  width: PropTypes__default['default'].string,
  height: PropTypes__default['default'].string,
  fitMode: PropTypes__default['default'].oneOf(['cover', 'contain', '']),
  src: PropTypes__default['default'].string,
  loading: PropTypes__default['default'].bool,
  canEnlarge: PropTypes__default['default'].bool,
  canDelete: PropTypes__default['default'].bool,
  onChange: PropTypes__default['default'].func,
  onDelete: PropTypes__default['default'].func,
  isLoading: PropTypes__default['default'].bool,
  multi: PropTypes__default['default'].bool,
  limit: PropTypes__default['default'].number
};
UploadImage.defaultProps = {
  className: ''
};

var ImageGrid = function ImageGrid(props) {
  var gridRef = React.useRef();
  var blockRef = React.useRef();
  var cellRef = React.useRef();

  var _useState = React.useState('0px'),
      _useState2 = _slicedToArray(_useState, 2),
      cellMargin = _useState2[0],
      setCellMargin = _useState2[1];

  React.useEffect(function () {
    adjustMargin();
    window.addEventListener('resize', adjustMargin);
    return function () {
      window.removeEventListener('resize', adjustMargin);
    };
  }, []);

  var adjustMargin = function adjustMargin() {
    if (!gridRef.current || !blockRef.current || !cellRef.current) {
      return;
    } // Reset padding, let browser do all the calculation again


    setCellMargin('0px'); // Recalculate manually

    var cellWidth = cellRef.current.clientWidth + 2; // 2px of the border

    var gridWidth = gridRef.current.clientWidth;
    var imgCount = parseInt(gridWidth / cellWidth);
    var remain = gridWidth - imgCount * cellWidth;
    setCellMargin("".concat(remain / (imgCount + 1), "px"));
  };

  return /*#__PURE__*/jsxRuntime.jsxs(ScrollView, {
    scrollX: false,
    children: [!props.isLoading && (!props.data || !Array.isArray(props.data) || Array.isArray(props.data) && props.data.length === 0) && /*#__PURE__*/jsxRuntime.jsx("div", {
      style: {
        width: '100%',
        top: '40%',
        textAlign: 'center',
        position: 'absolute'
      },
      children: /*#__PURE__*/jsxRuntime.jsx("div", {
        style: {
          opacity: '0.7'
        },
        children: "Kh\xF4ng c\xF3 d\u1EEF li\u1EC7u"
      })
    }), !props.isLoading && Array.isArray(props.data) && props.data.length > 0 && /*#__PURE__*/jsxRuntime.jsx("div", {
      ref: gridRef,
      className: "img-grid",
      style: {
        marginBottom: cellMargin
      },
      children: /*#__PURE__*/jsxRuntime.jsx("div", {
        ref: blockRef,
        className: "img-grid-block",
        children: props.data.map(function (img, i) {
          return /*#__PURE__*/jsxRuntime.jsxs("div", {
            ref: i === 0 ? cellRef : null,
            className: "img-grid-cell ".concat(img.isSelected ? 'selected' : ''),
            style: {
              marginLeft: cellMargin,
              marginTop: cellMargin
            },
            children: [img.onSelect && /*#__PURE__*/jsxRuntime.jsx("div", {
              className: 'img-grid-cell-select',
              children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                size: '20px',
                color: img.isSelected ? 'var(--primary-color)' : 'var(--text-color)',
                icon: img.isSelected ? 'check-circle' : 'circle',
                onClick: function onClick() {
                  return img.onSelect(img);
                }
              })
            }), /*#__PURE__*/jsxRuntime.jsx(Image$1, {
              width: '10rem',
              height: '10rem',
              src: img.src,
              onClick: function onClick(e) {
                return img.onClick && img.onClick(e, img);
              }
            })]
          }, props.imageKey && img[props.imageKey] ? img[props.imageKey] : i);
        })
      })
    }), props.isLoading && /*#__PURE__*/jsxRuntime.jsx(Col2, {
      justify: 'center',
      items: 'center',
      children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
        icon: 'spinner-third',
        type: 'duotone',
        size: '3rem',
        spin: true
      })
    })]
  });
};

ImageGrid.propTypes = {
  isLoading: PropTypes__default['default'].bool,
  data: PropTypes__default['default'].arrayOf(PropTypes__default['default'].shape({
    isSelected: PropTypes__default['default'].bool,
    onClick: PropTypes__default['default'].func,
    src: PropTypes__default['default'].any
  })),
  onSelect: PropTypes__default['default'].func,
  imageKey: PropTypes__default['default'].string // support live update

};

var ICON_POSITION_ENUM = {
  top: 'flex-start',
  middle: 'center',
  bottom: 'flex-end'
};
var ListItem = function ListItem(props) {
  var _clsx;

  var disableSelection = props.disableSelection,
      active = props.active,
      className = props.className,
      _props$direction = props.direction,
      direction = _props$direction === void 0 ? 'row' : _props$direction,
      splitter = props.splitter;
  var icon = props.icon,
      iconUrl = props.iconUrl,
      iconClass = props.iconClass,
      iconColor = props.iconColor,
      _props$iconType = props.iconType,
      iconType = _props$iconType === void 0 ? 'light' : _props$iconType,
      _props$iconPosition = props.iconPosition,
      iconPosition = _props$iconPosition === void 0 ? 'middle' : _props$iconPosition,
      iconTypeSvg = props.iconTypeSvg;
  var label = props.label,
      isImportant = props.isImportant,
      sub = props.sub,
      trailing = props.trailing,
      onClick = props.onClick;
  var listItemWrapperClasses = clsx__default['default']("list-item--direction-".concat(direction), (_clsx = {}, _defineProperty$1(_clsx, 'list-item-reader', disableSelection), _defineProperty$1(_clsx, 'list-item-container', !disableSelection), _defineProperty$1(_clsx, 'active', active), _defineProperty$1(_clsx, 'splitter', splitter), _clsx), className);
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: listItemWrapperClasses,
    onClick: onClick,
    children: [(iconUrl || iconClass || icon) && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "list-item-icon",
      style: {
        alignSelf: ICON_POSITION_ENUM[iconPosition]
      },
      children: /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "list-icon list-item-icon-inner",
        children: [iconUrl && /*#__PURE__*/jsxRuntime.jsx("img", {
          alt: 'icon-url',
          src: iconUrl
        }), iconClass && !iconTypeSvg && /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          icon: iconClass,
          color: iconColor,
          type: iconType,
          size: '1.125rem'
        }), iconClass && iconTypeSvg && /*#__PURE__*/jsxRuntime.jsx(vicon.SVG, {
          name: iconClass,
          width: '18px',
          height: '18px',
          fill: 'rgba(var(--contrast), 0.5)'
        }), icon && icon]
      })
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: "list-item-content",
      children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "list-item-title ml-ellipsis",
        children: [/*#__PURE__*/jsxRuntime.jsx(T, {
          children: label
        }), isImportant && /*#__PURE__*/jsxRuntime.jsx("span", {
          style: {
            color: 'red'
          },
          children: "\xA0(*)"
        })]
      }), sub && /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "list-item-subtitle-line ml-ellipsis",
        children: /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "list-item-subtitle",
          children: /*#__PURE__*/jsxRuntime.jsx(T, {
            children: sub
          })
        })
      })]
    }), trailing && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "list-item-secondary",
      children: trailing
    })]
  });
};

var LazyLoadList = /*#__PURE__*/function (_Component) {
  _inherits(LazyLoadList, _Component);

  var _super = _createSuper(LazyLoadList);

  function LazyLoadList() {
    var _this;

    _classCallCheck(this, LazyLoadList);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      activeIndex: -1
    });

    return _this;
  }

  _createClass(LazyLoadList, [{
    key: "handleClickItem",
    value: function handleClickItem(obj, index) {
      this.setState({
        activeIndex: index
      });

      if (typeof this.props.onItemClicked === 'function') {
        this.props.onItemClicked(obj, index);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var items = this.props.items;
      return /*#__PURE__*/jsxRuntime.jsxs(Container, {
        className: "lazy-load-list-container",
        children: [/*#__PURE__*/jsxRuntime.jsx(ScrollView, {
          onYReachEnd: this.props.onYReachEnd,
          children: items.map(function (item, i) {
            return /*#__PURE__*/jsxRuntime.jsx(ListItem, {
              label: item[_this2.props.titleField],
              sub: item[_this2.props.subTitleField],
              iconUrl: item[_this2.props.iconUrlField],
              active: _this2.state.activeIndex === i,
              trailing: _this2.props.onMenuClick && /*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
                size: "sm",
                icon: "ellipsis-v",
                onlyIcon: true,
                onClick: _this2.props.onMenuClick
              }),
              onClick: function onClick() {
                return _this2.handleClickItem(item, i);
              }
            }, i);
          })
        }), this.props.isSearching && /*#__PURE__*/jsxRuntime.jsx(Container, {
          className: "loading-container",
          children: /*#__PURE__*/jsxRuntime.jsxs(Container, {
            className: "lds-ripple",
            children: [/*#__PURE__*/jsxRuntime.jsx(Container, {}), /*#__PURE__*/jsxRuntime.jsx(Container, {})]
          })
        })]
      });
    }
  }]);

  return LazyLoadList;
}(React.Component);
LazyLoadList.propTypes = {
  items: PropTypes__default['default'].any,
  isSearching: PropTypes__default['default'].bool,
  titleField: PropTypes__default['default'].string,
  subTitleField: PropTypes__default['default'].string,
  iconUrlField: PropTypes__default['default'].string,
  onItemClicked: PropTypes__default['default'].func,
  onMenuClick: PropTypes__default['default'].func,
  onYReachEnd: PropTypes__default['default'].func
};

var Line = /*#__PURE__*/function (_Component) {
  _inherits(Line, _Component);

  var _super = _createSuper(Line);

  function Line() {
    _classCallCheck(this, Line);

    return _super.apply(this, arguments);
  }

  _createClass(Line, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        className: this.props.className,
        style: {
          backgroundColor: this.props.color,
          width: this.props.width,
          height: this.props.height
        }
      });
    }
  }]);

  return Line;
}(React.Component);
Line.propTypes = {
  className: PropTypes__default['default'].string,
  height: PropTypes__default['default'].string,
  width: PropTypes__default['default'].string,
  color: PropTypes__default['default'].string
};
Line.defaultProps = {
  className: '',
  height: '1px',
  width: '',
  color: 'white'
};

var _excluded$8 = ["children"];
var Ul = function Ul(_ref) {
  var children = _ref.children,
      restProps = _objectWithoutProperties(_ref, _excluded$8);

  return /*#__PURE__*/jsxRuntime.jsx("ul", _objectSpread2(_objectSpread2({}, restProps), {}, {
    children: children
  }));
};

var _excluded$7 = ["children"];
var Li = function Li(_ref) {
  var children = _ref.children,
      restProps = _objectWithoutProperties(_ref, _excluded$7);

  return /*#__PURE__*/jsxRuntime.jsx("li", _objectSpread2(_objectSpread2({}, restProps), {}, {
    children: children
  }));
};

var BoxSelectHandler = /*#__PURE__*/function () {
  function BoxSelectHandler(map) {
    var _this = this;

    _classCallCheck(this, BoxSelectHandler);

    _defineProperty$1(this, "map", null);

    _defineProperty$1(this, "canvas", null);

    _defineProperty$1(this, "start", null);

    _defineProperty$1(this, "current", null);

    _defineProperty$1(this, "box", null);

    _defineProperty$1(this, "minLatLng", null);

    _defineProperty$1(this, "maxLatLng", null);

    _defineProperty$1(this, "mousePos", function (e) {
      var rect = _this.canvas.getBoundingClientRect();

      return new mapboxgl__default['default'].Point(e.clientX - rect.left - _this.canvas.clientLeft, e.clientY - rect.top - _this.canvas.clientTop);
    });

    _defineProperty$1(this, "onKeyDown", function (e) {
      // If the ESC key is pressed
      if (e.keyCode === 27) {
        _this.finish();
      }
    });

    _defineProperty$1(this, "onMouseMove", function (e) {
      // Capture the ongoing xy coordinates
      _this.current = _this.mousePos(e); // Append the box element if it doesnt exist

      if (!_this.box) {
        _this.box = document.createElement('div');

        _this.box.classList.add('boxdraw');

        _this.canvas.appendChild(_this.box);
      }

      var minX = Math.min(_this.start.x, _this.current.x);
      var maxX = Math.max(_this.start.x, _this.current.x);
      var minY = Math.min(_this.start.y, _this.current.y);
      var maxY = Math.max(_this.start.y, _this.current.y);
      _this.minLatLng = new mapboxgl__default['default'].Point(maxX, minY);
      _this.maxLatLng = new mapboxgl__default['default'].Point(minX, maxY); // Adjust width and xy position of the box element ongoing

      var pos = 'translate(' + minX + 'px,' + minY + 'px)';
      _this.box.style.transform = 'translate(' + minX + 'px,' + minY + 'px)';
      _this.box.style.WebkitTransform = pos;
      _this.box.style.width = "".concat(maxX - minX, "px");
      _this.box.style.height = "".concat(maxY - minY, "px");
    });

    _defineProperty$1(this, "finish", function (bbox) {
      // Remove these events now that finish has been called.
      document.removeEventListener('mousemove', _this.onMouseMove);
      document.removeEventListener('keydown', _this.onKeyDown);
      document.removeEventListener('mouseup', _this.onMouseUp);

      if (_this.box) {
        _this.box.parentNode.removeChild(_this.box);

        _this.box = null;
      } // If bbox exists. use this value as the argument for `queryRenderedFeatures`


      if (bbox) {
        _this.map.onBoxSelectHandler(bbox, _this.map);
      }

      _this.map.dragPan.enable();
    });

    _defineProperty$1(this, "onMouseUp", function () {
      // Capture xy coordinates
      _this.finish([_this.maxLatLng, _this.minLatLng]);
    });

    _defineProperty$1(this, "mouseDown", function (e) {
      // Continue the rest of the function if the shiftkey is pressed.
      if (!(e.shiftKey && e.button === 0)) {
        return;
      } // Disable default drag zooming when the shift key is held down.


      _this.map.dragPan.disable();

      _this.map.boxZoom.disable(); // Call functions for the following events


      document.addEventListener('mousemove', _this.onMouseMove);
      document.addEventListener('mouseup', _this.onMouseUp);
      document.addEventListener('keydown', _this.onKeyDown); // // Capture the first xy coordinates

      _this.start = _this.mousePos(e);
    });

    this.map = map;
    this.canvas = map.getCanvasContainer();
  } // Return the xy coordinates of the mouse position


  _createClass(BoxSelectHandler, [{
    key: "initBoxSelectEvent",
    value: function initBoxSelectEvent() {
      this.canvas.addEventListener('mousedown', this.mouseDown, true);
    }
  }]);

  return BoxSelectHandler;
}();

var Compass = function Compass(props) {
  return /*#__PURE__*/jsxRuntime.jsx("svg", _objectSpread2(_objectSpread2({
    xmlns: "http://www.w3.org/2000/svg",
    xmlSpace: "preserve",
    width: "60px",
    height: "60px",
    version: "1.1",
    shapeRendering: "geometricPrecision",
    textRendering: "geometricPrecision",
    imageRendering: "optimizeQuality",
    fillRule: "evenodd",
    clipRule: "evenodd",
    viewBox: "0 0 60 60",
    xmlnsXlink: "http://www.w3.org/1999/xlink"
  }, props), {}, {
    children: /*#__PURE__*/jsxRuntime.jsxs("g", {
      id: "Layer_x0020_1",
      children: [/*#__PURE__*/jsxRuntime.jsx("metadata", {
        id: "CorelCorpID_0Corel-Layer"
      }), /*#__PURE__*/jsxRuntime.jsx("rect", {
        fill: "none",
        width: "60",
        height: "60"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        fill: "white",
        d: "M30 1c16.016,0 29,12.984 29,29 0,16.016 -12.984,29 -29,29 -16.016,0 -29,-12.984 -29,-29 0,-16.016 12.984,-29 29,-29zm-27 28.252l8 0 0 1.5 -8 0 0 -1.5zm3.243 13.6l3.464 -2 0.75 1.299 -3.464 2 -0.75 -1.299zm9.609 10.157l2 -3.464 1.299 0.75 -2 3.464 -1.299 -0.75zm27 0.748l-2 -3.464 1.299 -0.75 2 3.464 -1.299 0.75zm10.157 -9.609l-3.464 -2 0.75 -1.299 3.464 2 -0.75 1.299zm0.748 -27l-3.464 2 -0.75 -1.299 3.464 -2 0.75 1.299zm-9.609 -10.157l-2 3.464 -1.299 -0.75 2 -3.464 1.299 0.75zm-27 -0.748l2 3.464 -1.299 0.75 -2 -3.464 1.299 -0.75zm-10.157 9.609l3.464 2 -0.75 1.299 -3.464 -2 0.75 -1.299zm-2.363 19.913c0.534,-0.142 1.082,0.174 1.225,0.708 0.143,0.533 -0.174,1.081 -0.708,1.225 -0.533,0.142 -1.081,-0.174 -1.224,-0.708 -0.143,-0.533 0.173,-1.081 0.707,-1.225zm6.282 11.914c0.39,-0.39 1.023,-0.39 1.414,0 0.391,0.391 0.391,1.024 0,1.415 -0.391,0.39 -1.024,0.39 -1.414,0 -0.391,-0.391 -0.391,-1.024 0,-1.415zm11.397 7.177c0.143,-0.534 0.691,-0.85 1.225,-0.707 0.533,0.143 0.85,0.691 0.707,1.225 -0.143,0.533 -0.691,0.85 -1.225,0.707 -0.533,-0.143 -0.85,-0.691 -0.707,-1.225zm13.458 0.517c-0.142,-0.534 0.174,-1.082 0.708,-1.225 0.533,-0.143 1.081,0.173 1.225,0.707 0.142,0.534 -0.174,1.082 -0.708,1.225 -0.533,0.143 -1.081,-0.174 -1.225,-0.707zm11.914 -6.282c-0.39,-0.391 -0.39,-1.024 0,-1.414 0.391,-0.391 1.024,-0.391 1.415,0 0.39,0.39 0.39,1.023 0,1.414 -0.391,0.39 -1.024,0.39 -1.415,0zm7.177 -11.397c-0.534,-0.143 -0.85,-0.692 -0.707,-1.225 0.143,-0.534 0.691,-0.85 1.225,-0.707 0.533,0.143 0.85,0.691 0.707,1.225 -0.143,0.533 -0.691,0.85 -1.225,0.707zm0.517 -13.459c-0.534,0.143 -1.082,-0.173 -1.225,-0.707 -0.143,-0.534 0.173,-1.082 0.707,-1.225 0.534,-0.143 1.082,0.174 1.225,0.707 0.143,0.534 -0.174,1.082 -0.707,1.225zm-6.282 -11.914c-0.391,0.391 -1.024,0.391 -1.414,0 -0.391,-0.39 -0.391,-1.023 0,-1.414 0.39,-0.391 1.023,-0.391 1.414,0 0.39,0.391 0.39,1.024 0,1.414zm-11.397 -7.176c-0.143,0.533 -0.692,0.85 -1.225,0.707 -0.534,-0.143 -0.85,-0.692 -0.707,-1.225 0.143,-0.534 0.691,-0.85 1.225,-0.707 0.533,0.143 0.85,0.691 0.707,1.225zm-13.459 -0.517c0.143,0.534 -0.173,1.082 -0.707,1.225 -0.534,0.143 -1.082,-0.174 -1.225,-0.708 -0.143,-0.533 0.174,-1.081 0.707,-1.224 0.534,-0.143 1.082,0.173 1.225,0.707zm-11.914 6.282c0.391,0.39 0.391,1.023 0,1.414 -0.39,0.391 -1.023,0.391 -1.414,0 -0.391,-0.391 -0.391,-1.024 0,-1.414 0.391,-0.391 1.024,-0.391 1.414,0zm-7.176 11.397c0.533,0.143 0.85,0.691 0.707,1.225 -0.143,0.533 -0.692,0.85 -1.225,0.707 -0.534,-0.143 -0.85,-0.692 -0.707,-1.225 0.143,-0.534 0.691,-0.85 1.225,-0.707zm43.855 6.945l8 0 0 1.5 -8 0 0 -1.5z"
      }), /*#__PURE__*/jsxRuntime.jsx("polygon", {
        fill: "#FF3732",
        points: "30,3 36,15 24,15 "
      }), /*#__PURE__*/jsxRuntime.jsx("polygon", {
        fill: "#363636",
        points: "30,57.001 36,45.002 24,45.002 "
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        fill: "#363636",
        d: "M24.001 23.001c1.067,0 2.134,0 3.2,0l5.801 8.924 0 -8.924 3 0 0 14c-1.067,0 -2.134,0 -3.2,0l-5.801 -8.923 0 8.923 -3 0 0 -14z"
      })]
    })
  }));
};

var GeoMap = /*#__PURE__*/function (_Component) {
  _inherits(GeoMap, _Component);

  var _super = _createSuper(GeoMap);

  function GeoMap(props) {
    var _this;

    _classCallCheck(this, GeoMap);

    _this = _super.call(this, props);
    _this.map = /*#__PURE__*/React__default['default'].createRef();
    return _this;
  }

  _createClass(GeoMap, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      return this.props.id !== nextProps.id;
    }
  }, {
    key: "render",
    value: function render() {
      var MapBox = new ReactMapboxGl__default['default']({
        ref: this.map,
        accessToken: '',
        scrollZoom: this.props.scrollZoom,
        dragPan: this.props.dragPan,
        interactive: this.props.interactive
      });
      var mapStyle = {
        'version': 8,
        'sources': {},
        'layers': []
      };
      var _this$props = this.props,
          center = _this$props.center,
          zoomLevel = _this$props.zoomLevel;
      return /*#__PURE__*/jsxRuntime.jsxs(MapBox, {
        style: mapStyle,
        containerStyle: {
          height: this.props.height,
          width: this.props.width
        },
        center: center,
        zoom: zoomLevel,
        trackResize: true,
        onClick: this.props.onClick,
        children: [/*#__PURE__*/jsxRuntime.jsx(ReactMapboxGl.ZoomControl, {
          className: 'map-zoom-control'
        }), this.props.children]
      });
    }
  }]);

  return GeoMap;
}(React.Component);
GeoMap.propTypes = {
  id: PropTypes__default['default'].string,
  width: PropTypes__default['default'].string,
  height: PropTypes__default['default'].string,
  center: PropTypes__default['default'].object,
  zoomLevel: PropTypes__default['default'].array
};
GeoMap.defaultProps = {
  width: '100%',
  height: '100%'
};
GeoMap.contextType = ThemeContext;

var CircleMarker = /*#__PURE__*/function (_Component) {
  _inherits(CircleMarker, _Component);

  var _super = _createSuper(CircleMarker);

  function CircleMarker() {
    var _this;

    _classCallCheck(this, CircleMarker);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "animationDuration", 300);

    _defineProperty$1(_assertThisInitialized(_this), "notifyInterval", undefined);

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      notifyZoom: 1,
      notifyDirection: 1,
      isVisible: true
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleClick", function (e) {
      var _this$props = _this.props,
          onClick = _this$props.onClick,
          onActiveMarker = _this$props.onActiveMarker;

      if ((e.ctrlKey || e.metaKey) && e.button === 0) {
        if (onActiveMarker) {
          onActiveMarker();
        }
      } else {
        onClick(_this.props);
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "notifyIconHandler", function () {
      var zoom = _this.state.notifyZoom;
      var direction = 0;

      if (zoom < 0.6 && _this.state.notifyDirection === 0) {
        direction = 1;
      } else if (zoom > 1 && _this.state.notifyDirection === 1) {
        direction = 0;
      }

      _this.setState({
        notifyZoom: zoom + (direction === 1 ? 0.05 : -0.05)
      });
    });

    return _this;
  }

  _createClass(CircleMarker, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.isNotify) {
        this.notifyInterval = setInterval(this.notifyIconHandler, 100);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.notifyInterval) {
        clearInterval(this.notifyInterval);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          className = _this$props2.className,
          color = _this$props2.color,
          backgroundColor = _this$props2.backgroundColor,
          size = _this$props2.size,
          icon = _this$props2.icon,
          active = _this$props2.active,
          isNotify = _this$props2.isNotify,
          notifyIcon = _this$props2.notifyIcon;
      var isVisible = this.state.isVisible;
      return /*#__PURE__*/jsxRuntime.jsx(reactAnimatedCss.Animated, {
        animationIn: "zoomIn",
        animationOut: "zoomOut",
        animationInDuration: this.animationDuration,
        isVisible: isVisible,
        children: /*#__PURE__*/jsxRuntime.jsxs("div", {
          className: "map-marker ".concat(className),
          style: {
            width: size + 'px',
            height: size + 'px',
            border: "2px solid ".concat(!active ? color : '#1769ff'),
            backgroundColor: backgroundColor,
            fontSize: "".concat(size / 2, "px")
          },
          onClick: this.handleClick,
          children: [isNotify && /*#__PURE__*/jsxRuntime.jsx("div", {
            className: 'mmk-notify' // style={{ transform: `scale(${this.state.notifyZoom})` }}
            ,
            children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
              icon: notifyIcon,
              size: '70%',
              color: "white"
            })
          }), /*#__PURE__*/jsxRuntime.jsx("div", {
            className: 'map-marker-content',
            children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
              icon: icon,
              size: "".concat(size / 2, "px"),
              color: !active ? color : '#1769ff',
              type: this.props.typeMarker
            })
          })]
        })
      });
    }
  }]);

  return CircleMarker;
}(React.Component);
CircleMarker.propTypes = {
  className: PropTypes__default['default'].string,
  icon: PropTypes__default['default'].string.isRequired,
  notifyIcon: PropTypes__default['default'].string.isRequired,
  isNotify: PropTypes__default['default'].bool,
  size: PropTypes__default['default'].number.isRequired,
  color: PropTypes__default['default'].string,
  backgroundColor: PropTypes__default['default'].string,
  directional: PropTypes__default['default'].number,
  typeMarker: PropTypes__default['default'].string,
  onClick: PropTypes__default['default'].func
};
CircleMarker.defaultProps = {
  className: '',
  icon: '',
  notifyIcon: 'exclamation',
  notifyIconSize: '12px',
  isNotify: false,
  size: 48,
  directional: 0,
  color: 'white',
  backgroundColor: '#303030',
  typeMarker: 'light',
  onClick: function onClick() {}
};

var CircleMarkerWithDistance = /*#__PURE__*/function (_CircleMarker) {
  _inherits(CircleMarkerWithDistance, _CircleMarker);

  var _super = _createSuper(CircleMarkerWithDistance);

  function CircleMarkerWithDistance() {
    _classCallCheck(this, CircleMarkerWithDistance);

    return _super.apply(this, arguments);
  }

  _createClass(CircleMarkerWithDistance, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          className = _this$props.className,
          color = _this$props.color,
          backgroundColor = _this$props.backgroundColor,
          size = _this$props.size,
          icon = _this$props.icon,
          isActive = _this$props.isActive,
          isNotify = _this$props.isNotify,
          notifyIcon = _this$props.notifyIcon;
      var isVisible = this.state.isVisible;
      return /*#__PURE__*/jsxRuntime.jsxs(reactAnimatedCss.Animated, {
        animationIn: "zoomIn",
        animationOut: "zoomOut",
        animationInDuration: this.animationDuration,
        isVisible: isVisible,
        children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
          className: "map-marker ".concat(className),
          style: {
            width: size + 'px',
            height: size + 'px',
            border: "2px solid ".concat(!isActive ? color : '#1769ff'),
            backgroundColor: backgroundColor,
            fontSize: "".concat(size / 2, "px")
          },
          onClick: this.handleClick,
          children: [isNotify && /*#__PURE__*/jsxRuntime.jsx("div", {
            className: 'mmk-notify',
            style: {
              transform: "scale(".concat(this.state.notifyZoom, ")")
            },
            children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
              icon: notifyIcon,
              size: '70%',
              color: "white"
            })
          }), /*#__PURE__*/jsxRuntime.jsx("div", {
            className: 'map-marker-content',
            children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
              icon: icon,
              size: "".concat(size / 2, "px"),
              color: !isActive ? color : '#1769ff'
            })
          })]
        }), /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "map-marker-distance ".concat(className),
          onClick: this.handleClick,
          children: this.props.distance
        })]
      });
    }
  }]);

  return CircleMarkerWithDistance;
}(CircleMarker);
CircleMarkerWithDistance.propTypes = {
  className: PropTypes__default['default'].string,
  icon: PropTypes__default['default'].string.isRequired,
  notifyIcon: PropTypes__default['default'].string.isRequired,
  isNotify: PropTypes__default['default'].bool,
  size: PropTypes__default['default'].number.isRequired,
  color: PropTypes__default['default'].string,
  backgroundColor: PropTypes__default['default'].string,
  directional: PropTypes__default['default'].number,
  distance: PropTypes__default['default'].string,
  onClick: PropTypes__default['default'].func
};
CircleMarkerWithDistance.defaultProps = {
  className: '',
  icon: '',
  notifyIcon: 'exclamation',
  notifyIconSize: '12px',
  isNotify: false,
  size: 48,
  directional: 0,
  color: 'white',
  backgroundColor: '#303030',
  distance: '? km',
  onClick: function onClick() {}
};

var MarkerPopup = /*#__PURE__*/function (_Component) {
  _inherits(MarkerPopup, _Component);

  var _super = _createSuper(MarkerPopup);

  function MarkerPopup() {
    var _this;

    _classCallCheck(this, MarkerPopup);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "animationDuration", 300);

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      isVisible: true
    });

    _defineProperty$1(_assertThisInitialized(_this), "onFocus", function (event) {
      _this.props.onFocus({
        event: event,
        id: _this.props.id
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "onClose", function (event) {
      _this.setState({
        isVisible: false
      });

      setTimeout(function () {
        _this.props.onClose({
          event: event,
          id: _this.props.id
        });
      }, _this.animationDuration);
      event.stopPropagation();
    });

    return _this;
  }

  _createClass(MarkerPopup, [{
    key: "render",
    value: function render() {
      var arrowSize = 15;
      var spacing = this.props.spacing || 2;
      var anchor = '';
      var arrowOffset = [];
      var offsetMarker = this.props.markerSize / 2 + arrowSize + spacing;
      var markerOffset = this.props.markerOffset || offsetMarker;

      switch (this.props.location) {
        case 'left':
          arrowOffset = [-markerOffset, 0];
          anchor = 'right';
          break;

        case 'right':
          arrowOffset = [markerOffset, 0];
          anchor = 'left';
          break;

        default:
        case 'top':
          arrowOffset = [0, -markerOffset];
          anchor = 'bottom';
          break;

        case 'bottom':
          arrowOffset = [0, markerOffset];
          anchor = 'top';
          break;
      }

      return /*#__PURE__*/jsxRuntime.jsx(ReactMapboxGl.Marker, {
        className: "marker-popup ".concat(this.props.className),
        coordinates: [this.props.lng, this.props.lat],
        offset: arrowOffset,
        anchor: anchor,
        children: /*#__PURE__*/jsxRuntime.jsxs(reactAnimatedCss.Animated, {
          animationIn: "zoomIn",
          animationOut: "zoomOut",
          animationInDuration: this.animationDuration,
          isVisible: this.state.isVisible,
          children: [/*#__PURE__*/jsxRuntime.jsx("div", {
            className: "mp-arrow-container ".concat(this.props.location),
            children: /*#__PURE__*/jsxRuntime.jsx("div", {
              className: "mp-arrow ".concat(this.props.location)
            })
          }), /*#__PURE__*/jsxRuntime.jsxs("div", {
            className: 'mp-container',
            onClick: this.onFocus,
            children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
              className: "mp-header",
              style: {
                width: this.props.width
              },
              children: [/*#__PURE__*/jsxRuntime.jsxs("h3", {
                children: [/*#__PURE__*/jsxRuntime.jsx(T, {
                  children: this.props.title
                }), /*#__PURE__*/jsxRuntime.jsx("small", {
                  children: /*#__PURE__*/jsxRuntime.jsx(T, {
                    children: this.props.sub
                  })
                })]
              }), /*#__PURE__*/jsxRuntime.jsxs("div", {
                className: 'mp-header-actions',
                children: [this.props.headerActions.map(function (action) {
                  return /*#__PURE__*/jsxRuntime.jsx("button", {
                    onClick: action.onClick,
                    children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                      icon: action.icon,
                      color: action.iconColor,
                      size: '1.5rem',
                      type: 'light'
                    })
                  }, action.icon);
                }), /*#__PURE__*/jsxRuntime.jsx("button", {
                  onClick: this.onClose,
                  children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                    icon: 'times',
                    size: '1.5rem',
                    type: 'light'
                  })
                }, 'close')]
              })]
            }), /*#__PURE__*/jsxRuntime.jsx("div", {
              className: "mp-body",
              style: {
                width: this.props.width,
                height: this.props.height,
                maxWidth: this.props.width,
                maxHeight: this.props.height
              },
              children: /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
                scrollX: false,
                children: this.props.children
              })
            }), /*#__PURE__*/jsxRuntime.jsx("div", {
              className: 'mp-footer',
              children: /*#__PURE__*/jsxRuntime.jsx("div", {
                className: 'mp-footer-actions',
                children: this.props.actions.map(function (action) {
                  return /*#__PURE__*/jsxRuntime.jsx("button", {
                    onClick: action.onClick,
                    children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                      icon: action.icon,
                      size: '1.5rem',
                      type: 'light'
                    })
                  }, action.icon);
                })
              })
            })]
          })]
        })
      });
    }
  }]);

  return MarkerPopup;
}(React.Component);
MarkerPopup.propTypes = {
  /** Key of Window Popup */
  id: PropTypes__default['default'].any,

  /** Class of Window Popup */
  className: PropTypes__default['default'].string,

  /** Title of Window Popup */
  title: PropTypes__default['default'].string,
  sub: PropTypes__default['default'].string,

  /** longitude of this popup in map */
  lng: PropTypes__default['default'].number,

  /** Latitude of this popup in map */
  lat: PropTypes__default['default'].number,

  /** Offset in map */
  offset: PropTypes__default['default'].array,

  /** isActivate: true, false */
  isActivate: PropTypes__default['default'].bool,

  /** location: true, false */
  location: PropTypes__default['default'].oneOf(['none', 'left', 'right', 'top', 'bottom']),

  /** Number of width: px */
  width: PropTypes__default['default'].number.isRequired,

  /** Number of height: px */
  height: PropTypes__default['default'].number.isRequired,

  /** isNotFixed: true, false */
  isNotFixed: PropTypes__default['default'].bool,

  /** Marker size: number */
  markerSize: PropTypes__default['default'].number,
  headerActions: PropTypes__default['default'].array,
  actions: PropTypes__default['default'].array,

  /** onFocus: Function with key */
  onFocus: PropTypes__default['default'].func,

  /** onClose: Function with key */
  onClose: PropTypes__default['default'].func,
  markerOffset: PropTypes__default['default'].number,
  spacing: PropTypes__default['default'].number
};
MarkerPopup.defaultProps = {
  id: '',
  className: '',
  title: '',
  sub: '',
  lng: 0,
  lat: 0,
  isActivate: false,
  location: 'top',
  isNotFixed: false,
  markerSize: 45,
  headerActions: [],
  actions: [],
  onFocus: function onFocus() {},
  onClose: function onClose() {},
  spacing: 2
};

var PointMarker = /*#__PURE__*/function (_Component) {
  _inherits(PointMarker, _Component);

  var _super = _createSuper(PointMarker);

  function PointMarker() {
    var _this;

    _classCallCheck(this, PointMarker);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "animationDuration", 300);

    _defineProperty$1(_assertThisInitialized(_this), "notifyInterval", undefined);

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      notifyZoom: 1,
      notifyDirection: 1,
      isVisible: true
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleClick", function (e) {
      var _this$props = _this.props,
          onClick = _this$props.onClick,
          onActiveMarker = _this$props.onActiveMarker;

      if ((e.ctrlKey || e.metaKey) && e.button === 0) {
        if (onActiveMarker) {
          onActiveMarker();
        }
      } else {
        onClick(_this.props);
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "notifyIconHandler", function () {
      var zoom = _this.state.notifyZoom;
      var direction = 0;

      if (zoom < 0.6 && _this.state.notifyDirection === 0) {
        direction = 1;
      } else if (zoom > 1 && _this.state.notifyDirection === 1) {
        direction = 0;
      }

      _this.setState({
        notifyZoom: zoom + (direction === 1 ? 0.05 : -0.05)
      });
    });

    return _this;
  }

  _createClass(PointMarker, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.isNotify) {
        this.notifyInterval = setInterval(this.notifyIconHandler, 100);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.notifyInterval) {
        clearInterval(this.notifyInterval);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          className = _this$props2.className,
          color = _this$props2.color,
          size = _this$props2.size,
          icon = _this$props2.icon,
          active = _this$props2.active;
      var isVisible = this.state.isVisible;
      return /*#__PURE__*/jsxRuntime.jsx(reactAnimatedCss.Animated, {
        animationIn: "zoomIn",
        animationOut: "zoomOut",
        animationInDuration: this.animationDuration,
        isVisible: isVisible,
        children: /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "point-marker ".concat(className),
          style: {
            width: size + 'px',
            height: size + 'px'
          },
          onClick: this.handleClick,
          children: /*#__PURE__*/jsxRuntime.jsx("div", {
            className: 'point-marker-content',
            children: /*#__PURE__*/jsxRuntime.jsx(vicon.SVG, {
              name: icon,
              width: "".concat(size, "px"),
              height: "".concat(size, "px"),
              fill: !active ? color : '#ec3f30',
              type: this.props.typeMarker,
              stroke: !active ? 'black' : 'white',
              strokeWidth: !active ? 0.5 : 1,
              strokeOpacity: !active ? 0.25 : 1
            })
          })
        })
      });
    }
  }]);

  return PointMarker;
}(React.Component);
PointMarker.propTypes = {
  className: PropTypes__default['default'].string,
  icon: PropTypes__default['default'].string.isRequired,
  notifyIcon: PropTypes__default['default'].string.isRequired,
  isNotify: PropTypes__default['default'].bool,
  size: PropTypes__default['default'].number.isRequired,
  color: PropTypes__default['default'].string,
  directional: PropTypes__default['default'].number,
  typeMarker: PropTypes__default['default'].string,
  onClick: PropTypes__default['default'].func
};
PointMarker.defaultProps = {
  className: '',
  icon: '',
  notifyIcon: 'exclamation',
  notifyIconSize: '12px',
  isNotify: false,
  size: 32,
  directional: 0,
  color: 'white',
  typeMarker: 'solid',
  onClick: function onClick() {}
};

var TrackingMarker = /*#__PURE__*/function (_Component) {
  _inherits(TrackingMarker, _Component);

  var _super = _createSuper(TrackingMarker);

  function TrackingMarker() {
    _classCallCheck(this, TrackingMarker);

    return _super.apply(this, arguments);
  }

  _createClass(TrackingMarker, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: 'tracking-marker',
        style: {
          width: this.props.size + 'px',
          height: this.props.size + 'px',
          fontSize: "".concat(this.props.size / 2, "px")
        },
        children: [this.props.heading !== null && /*#__PURE__*/jsxRuntime.jsx("i", {
          className: "fas fa-caret-up tm-heading",
          style: {
            transform: 'rotate(' + this.props.heading + 'deg)',
            fontSize: "".concat(this.props.size / 2, "px"),
            color: this.props.color
          }
        }), this.props.title && this.props.isShowLabel && /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "tracking-marker-label",
          style: {
            color: this.props.color
          },
          children: /*#__PURE__*/jsxRuntime.jsx(T, {
            children: this.props.title
          })
        }), /*#__PURE__*/jsxRuntime.jsx(CircleMarker, _objectSpread2({}, this.props))]
      });
    }
  }]);

  return TrackingMarker;
}(React.Component);
TrackingMarker.propTypes = {
  size: PropTypes__default['default'].number,
  color: PropTypes__default['default'].string,
  isShowLabel: PropTypes__default['default'].bool,
  title: PropTypes__default['default'].any,
  heading: PropTypes__default['default'].number
};
TrackingMarker.defaultProps = {
  heading: 0
};

var PageTitle = function PageTitle(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: 'page-title',
    children: /*#__PURE__*/jsxRuntime.jsx(T, {
      children: children
    })
  });
};

var NavigationMenu = /*#__PURE__*/function (_Component) {
  _inherits(NavigationMenu, _Component);

  var _super = _createSuper(NavigationMenu);

  function NavigationMenu() {
    var _this;

    _classCallCheck(this, NavigationMenu);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "handleChange", function (menuId, event) {
      if (typeof _this.props.onChange === 'function') {
        _this.props.onChange(menuId, event);
      }
    });

    return _this;
  }

  _createClass(NavigationMenu, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          header = _this$props.header,
          menus = _this$props.menus;
      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: 'nav-container',
        children: [header && /*#__PURE__*/jsxRuntime.jsx(PageTitle, {
          children: header
        }), /*#__PURE__*/jsxRuntime.jsx("ul", {
          className: "nav-menu ".concat(this.props.type === 'vertical' ? '' : 'horizontal'),
          children: menus.map(function (m) {
            return /*#__PURE__*/jsxRuntime.jsx(MenuItem, {
              id: m.id,
              active: _this2.props.activeMenu === m.id,
              onClick: _this2.handleChange,
              children: m.name
            }, m.id);
          })
        })]
      });
    }
  }]);

  return NavigationMenu;
}(React.Component);
NavigationMenu.propTypes = {
  className: PropTypes__default['default'].string,
  header: PropTypes__default['default'].string,
  menus: PropTypes__default['default'].array,
  activeMenu: PropTypes__default['default'].string,
  onChange: PropTypes__default['default'].func,
  type: PropTypes__default['default'].string
};
NavigationMenu.defaultProps = {
  menus: [],
  type: 'vertical'
};
var MenuItem = function MenuItem(_ref) {
  var children = _ref.children,
      id = _ref.id,
      onClick = _ref.onClick,
      active = _ref.active;

  var onMenuItemClick = function onMenuItemClick(event) {
    onClick(id, event);
  };

  return /*#__PURE__*/jsxRuntime.jsx("li", {
    className: "menu-item ".concat(active ? 'active' : ''),
    onClick: onMenuItemClick,
    children: /*#__PURE__*/jsxRuntime.jsx(T, {
      children: children
    })
  });
};
MenuItem.propTypes = {
  id: PropTypes__default['default'].string,
  active: PropTypes__default['default'].bool,
  onClick: PropTypes__default['default'].func
};
MenuItem.defaultProps = {
  active: false
};

var LargeDataPaging = function LargeDataPaging(props) {
  var changePage = function changePage(page) {
    page !== currentPage && props.onChange && props.onChange(page);
  };

  var currentPage = props.currentPage,
      className = props.className,
      isLast = props.isLast;
  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: /*#__PURE__*/jsxRuntime.jsxs("ul", {
      className: "pagination ".concat(className),
      children: [/*#__PURE__*/jsxRuntime.jsx("li", {
        className: currentPage === 1 ? 'disabled' : '',
        children: /*#__PURE__*/jsxRuntime.jsx("a", {
          onClick: function onClick() {
            return changePage(1);
          },
          children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
            icon: 'angle-double-left',
            size: '1.25rem'
          })
        })
      }), /*#__PURE__*/jsxRuntime.jsx("li", {
        className: currentPage === 1 ? 'disabled' : '',
        children: /*#__PURE__*/jsxRuntime.jsx("a", {
          onClick: function onClick() {
            return changePage(currentPage - 1);
          },
          children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
            icon: 'angle-left',
            size: '1.25rem'
          })
        })
      }), /*#__PURE__*/jsxRuntime.jsx("li", {
        className: 'active',
        children: /*#__PURE__*/jsxRuntime.jsx("span", {
          children: currentPage
        })
      }), /*#__PURE__*/jsxRuntime.jsx("li", {
        className: isLast ? 'disabled' : '',
        children: /*#__PURE__*/jsxRuntime.jsx("a", {
          onClick: function onClick() {
            return changePage(currentPage + 1);
          },
          children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
            icon: 'angle-right',
            size: '1.25rem'
          })
        })
      })]
    })
  });
};

LargeDataPaging.propTypes = {
  className: PropTypes__default['default'].string,
  currentPage: PropTypes__default['default'].number,
  isLast: PropTypes__default['default'].bool,
  onChange: PropTypes__default['default'].func
};
LargeDataPaging.defaultProps = {
  className: '',
  currentPage: 1,
  isLast: false
};

var _excluded$6 = ["disabled", "text", "isDirty"];
var PanelFooter = function PanelFooter(props) {
  var children = props.children,
      _props$docked = props.docked,
      docked = _props$docked === void 0 ? true : _props$docked,
      actions = props.actions;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: clsx__default['default']('panel-footer', docked !== null && docked !== void 0 ? docked : 'panel-footer-docked'),
    children: actions ? /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'panel-footer-actions',
      children: actions.map(function (_ref) {
        var disabled = _ref.disabled,
            text = _ref.text,
            isDirty = _ref.isDirty,
            restButtonProps = _objectWithoutProperties(_ref, _excluded$6);

        return /*#__PURE__*/React.createElement(Button, _objectSpread2(_objectSpread2({}, restButtonProps), {}, {
          key: text,
          disabled: props.disabled || disabled,
          text: /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
            children: [/*#__PURE__*/jsxRuntime.jsx(T, {
              children: text
            }), isDirty && /*#__PURE__*/jsxRuntime.jsx("span", {
              style: {
                color: 'red'
              },
              children: "\xA0(*)"
            })]
          }),
          size: "sm"
        }));
      })
    }) : children
  });
};

var PanelHeaderWithSwitcher = function PanelHeaderWithSwitcher(props) {
  var _props$value = props.value,
      value = _props$value === void 0 ? 0 : _props$value,
      onChanged = props.onChanged,
      settingRef = props.settingRef,
      onSettingClick = props.onSettingClick,
      children = props.children,
      disabled = props.disabled;

  var handleSwitchStateChange = function handleSwitchStateChange() {
    return onChanged(!value);
  };

  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: 'panel-header-switch',
    children: [/*#__PURE__*/jsxRuntime.jsx("h3", {
      children: /*#__PURE__*/jsxRuntime.jsx(T, {
        children: children
      })
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: 'panel-header-switch-actions',
      children: [onSettingClick && /*#__PURE__*/jsxRuntime.jsx("button", _objectSpread2({
        className: "setting-btn",
        onClick: onSettingClick
      }, settingRef && {
        ref: settingRef
      })), /*#__PURE__*/jsxRuntime.jsx(Switch__default['default'], {
        checked: value === 1,
        uncheckedIcon: false,
        checkedIcon: false,
        width: 38,
        height: 22,
        activeBoxShadow: "none",
        disabled: disabled,
        className: 'switch-toggle ' + (value === 1 ? 'active' : 'disable'),
        onChange: handleSwitchStateChange
      })]
    })]
  });
};

var Panorama = /*#__PURE__*/function (_Component) {
  _inherits(Panorama, _Component);

  var _super = _createSuper(Panorama);

  function Panorama() {
    _classCallCheck(this, Panorama);

    return _super.apply(this, arguments);
  }

  _createClass(Panorama, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          width = _this$props.width,
          height = _this$props.height;
      return /*#__PURE__*/jsxRuntime.jsx(pannellumReact.Pannellum, {
        width: width,
        height: height,
        image: this.props.img,
        pitch: 10,
        yaw: 180,
        hfov: 110,
        autoLoad: true,
        showZoomCtrl: false
      });
    }
  }]);

  return Panorama;
}(React.Component);
Panorama.propTypes = {
  img: PropTypes__default['default'].string,
  width: PropTypes__default['default'].string,
  height: PropTypes__default['default'].string
};
Panorama.defaultProps = {
  img: '',
  width: '100%',
  height: '100%'
};

var ContainField = function ContainField(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: 'popup-contain',
    children: children
  });
};
var Field = function Field(_ref2) {
  var children = _ref2.children,
      className = _ref2.className,
      _ref2$layout = _ref2.layout,
      layout = _ref2$layout === void 0 ? 'vertical' : _ref2$layout;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: clsx__default['default']('popup-field', layout === 'horizontal' && 'pf-horizontal', className),
    children: children
  });
};
var Label = function Label(_ref3) {
  var children = _ref3.children,
      _ref3$width = _ref3.width,
      width = _ref3$width === void 0 ? '120px' : _ref3$width;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: 'popup-label',
    title: children,
    style: _objectSpread2({}, width && {
      flex: "0 0 ".concat(width)
    }),
    children: /*#__PURE__*/jsxRuntime.jsx(T, {
      children: children
    })
  });
};
var Info = function Info(_ref4) {
  var color = _ref4.color,
      className = _ref4.className,
      children = _ref4.children;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    style: {
      color: color
    },
    className: clsx__default['default']('popup-info', className),
    children: /*#__PURE__*/jsxRuntime.jsx(T, {
      children: children
    })
  });
};

var Positioned = /*#__PURE__*/function (_Component) {
  _inherits(Positioned, _Component);

  var _super = _createSuper(Positioned);

  function Positioned() {
    _classCallCheck(this, Positioned);

    return _super.apply(this, arguments);
  }

  _createClass(Positioned, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "".concat(this.props.className),
        style: {
          position: 'absolute',
          top: this.props.top,
          right: this.props.right,
          bottom: this.props.bottom,
          left: this.props.left
        },
        children: this.props.children
      });
    }
  }]);

  return Positioned;
}(React.Component);
Positioned.propTypes = {
  className: PropTypes__default['default'].string,
  top: PropTypes__default['default'].string,
  right: PropTypes__default['default'].string,
  bottom: PropTypes__default['default'].string,
  left: PropTypes__default['default'].string
};
Positioned.defaultProps = {
  className: '',
  top: 'unset',
  right: 'unset',
  bottom: 'unset',
  left: 'unset'
};

var ProgressInProgressBar = /*#__PURE__*/function (_Component) {
  _inherits(ProgressInProgressBar, _Component);

  var _super = _createSuper(ProgressInProgressBar);

  function ProgressInProgressBar() {
    _classCallCheck(this, ProgressInProgressBar);

    return _super.apply(this, arguments);
  }

  _createClass(ProgressInProgressBar, [{
    key: "render",
    value: function render() {
      var startPoint = this.props.middleStart / 24 * 100;
      var endPoint = this.props.middleEnd / 24 * 100;
      var startTime = this.props.startTime / 24 * 100; // realtime start point

      var endTime = this.props.endTime / 24 * 100; // realtime end point

      var estimated_range = endPoint - startPoint;
      var realtime_range = endTime - startTime;

      if (startPoint === 0) {
        startPoint += 1;
      }

      if (endPoint === 0) {
        endPoint += 1;
      }

      if (startTime === 0) {
        startTime += 1;
      }

      if (endTime === 0) {
        endTime += 1;
      }

      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "progress-in-progress-bar ".concat(this.props.className),
        style: {
          width: '100%',
          position: 'relative'
        },
        children: [!isNaN(startPoint) && !isNaN(endPoint) ? /*#__PURE__*/jsxRuntime.jsx("div", {
          className: 'progress-bar-value-estimated-range',
          style: {
            left: "".concat(startPoint, "%"),
            width: "".concat(estimated_range, "%")
          }
        }) : !isNaN(endPoint) ? /*#__PURE__*/jsxRuntime.jsx("div", {
          className: 'progress-bar-value-estimated',
          style: {
            right: "".concat(endPoint, "%")
          }
        }) : !isNaN(startPoint) ? /*#__PURE__*/jsxRuntime.jsx("div", {
          className: 'progress-bar-value-estimated',
          style: {
            left: "".concat(startPoint, "%")
          }
        }) : null, !isNaN(startTime) && !isNaN(endTime) ? /*#__PURE__*/jsxRuntime.jsx("div", {
          className: 'progress-bar-value-realtime-range',
          style: {
            left: "".concat(startTime, "%"),
            width: "".concat(realtime_range, "%")
          }
        }) : !isNaN(endTime) ? /*#__PURE__*/jsxRuntime.jsx("div", {
          className: 'progress-bar-value-realtime',
          style: {
            right: "".concat(endTime, "%")
          }
        }) : !isNaN(startTime) ? /*#__PURE__*/jsxRuntime.jsx("div", {
          className: 'progress-bar-value-realtime',
          style: {
            left: "".concat(startTime, "%")
          }
        }) : null]
      });
    }
  }]);

  return ProgressInProgressBar;
}(React.Component);
ProgressInProgressBar.propTypes = {
  className: PropTypes__default['default'].string
};
ProgressInProgressBar.defaultProps = {
  className: ''
};

var ProgressLinear = /*#__PURE__*/function (_Component) {
  _inherits(ProgressLinear, _Component);

  var _super = _createSuper(ProgressLinear);

  function ProgressLinear() {
    _classCallCheck(this, ProgressLinear);

    return _super.apply(this, arguments);
  }

  _createClass(ProgressLinear, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          width = _this$props.width,
          loading = _this$props.loading,
          trackColor = _this$props.trackColor,
          loadingColor = _this$props.loadingColor,
          backgroundColor = _this$props.backgroundColor;
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "progress-linear-wrap",
        style: {
          borderColor: backgroundColor,
          width: width
        },
        children: /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "progress-linear",
          style: {
            backgroundColor: loading ? 'transparent' : "".concat(trackColor)
          },
          children: loading && /*#__PURE__*/jsxRuntime.jsxs("div", {
            className: "loading-progress",
            role: "progressbar",
            style: {
              backgroundColor: backgroundColor,
              width: width
            },
            children: [/*#__PURE__*/jsxRuntime.jsx("div", {
              className: "loading-progress-bar loading-track1",
              style: {
                backgroundColor: loadingColor
              }
            }), /*#__PURE__*/jsxRuntime.jsx("div", {
              className: "loading-progress-bar loading-track2",
              style: {
                backgroundColor: loadingColor
              }
            })]
          })
        })
      });
    }
  }]);

  return ProgressLinear;
}(React.Component);
ProgressLinear.propTypes = {
  className: PropTypes__default['default'].string,
  width: PropTypes__default['default'].string,
  height: PropTypes__default['default'].string,
  loading: PropTypes__default['default'].bool,
  trackColor: PropTypes__default['default'].string,
  loadingColor: PropTypes__default['default'].string,
  backgroundColor: PropTypes__default['default'].string
};
ProgressLinear.defaultProps = {
  className: '',
  width: '100%',
  height: '10px',
  loading: true,
  trackColor: 'blue',
  loadingColor: 'red',
  backgroundColor: 'lightgray'
};

var ResponsiveGrid = /*#__PURE__*/function (_Component) {
  _inherits(ResponsiveGrid, _Component);

  var _super = _createSuper(ResponsiveGrid);

  function ResponsiveGrid() {
    _classCallCheck(this, ResponsiveGrid);

    return _super.apply(this, arguments);
  }

  _createClass(ResponsiveGrid, [{
    key: "render",
    value: function render() {
      var items = Array.isArray(this.props.children) ? this.props.children.filter(function (child) {
        return child.type === ResponsiveGridItem;
      }) : [];
      var col = items.length === 1 || items.length === 2 ? items.length : Math.ceil(Math.sqrt(items.length));
      var percent = 100 / col;
      var height = 100 / Math.ceil(items.length / col);
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'responsive-grid',
        children: items.map(function (item) {
          return /*#__PURE__*/React__default['default'].cloneElement(item, {
            style: {
              maxWidth: "".concat(percent, "%"),
              flex: "1 0 ".concat(percent, "%"),
              height: "".concat(height, "%"),
              maxHeight: "".concat(height, "%")
            }
          });
        })
      });
    }
  }]);

  return ResponsiveGrid;
}(React.Component);
ResponsiveGrid.propTypes = {};
ResponsiveGrid.defaultProps = {};
var ResponsiveGridItem = /*#__PURE__*/function (_Component2) {
  _inherits(ResponsiveGridItem, _Component2);

  var _super2 = _createSuper(ResponsiveGridItem);

  function ResponsiveGridItem() {
    _classCallCheck(this, ResponsiveGridItem);

    return _super2.apply(this, arguments);
  }

  _createClass(ResponsiveGridItem, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'responsive-grid-item',
        style: this.props.style,
        children: this.props.children
      });
    }
  }]);

  return ResponsiveGridItem;
}(React.Component);

var SuggestItem = /*#__PURE__*/function (_Component) {
  _inherits(SuggestItem, _Component);

  var _super = _createSuper(SuggestItem);

  function SuggestItem() {
    var _this;

    _classCallCheck(this, SuggestItem);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "handleClick", function () {
      _this.props.onClick(_this.props.data);
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleClickSetting", function (e) {
      e.stopPropagation();

      _this.props.onClickSetting(_this.props.data);
    });

    _defineProperty$1(_assertThisInitialized(_this), "renderContent", function () {
      var setting = _this.props.onClickSetting ? /*#__PURE__*/jsxRuntime.jsx("button", {
        onClick: function onClick(e) {
          return _this.handleClickSetting(e);
        },
        children: /*#__PURE__*/jsxRuntime.jsx(T, {
          children: "Thi\u1EBFt l\u1EADp"
        })
      }) : null;

      if (_this.props.data.hint) {
        // two line
        return /*#__PURE__*/jsxRuntime.jsxs("div", {
          className: 'suggest-text two-line',
          children: [setting, /*#__PURE__*/jsxRuntime.jsx("div", {
            className: 'suggest-query',
            children: /*#__PURE__*/jsxRuntime.jsx(T, {
              children: _this.props.data.query
            })
          }), /*#__PURE__*/jsxRuntime.jsx("div", {
            className: 'suggest-hint',
            children: /*#__PURE__*/jsxRuntime.jsx(T, {
              children: _this.props.data.hint
            })
          }), _this.props.data.provider && /*#__PURE__*/jsxRuntime.jsx("div", {
            className: 'suggest-type',
            children: /*#__PURE__*/jsxRuntime.jsx(T, {
              children: _this.props.data.provider
            })
          })]
        });
      } else {
        // one line
        return /*#__PURE__*/jsxRuntime.jsxs("div", {
          className: 'suggest-text',
          children: [/*#__PURE__*/jsxRuntime.jsx(T, {
            children: _this.props.data.query
          }), _this.props.data.provider && /*#__PURE__*/jsxRuntime.jsx("div", {
            className: 'suggest-type',
            children: /*#__PURE__*/jsxRuntime.jsx(T, {
              children: _this.props.data.provider
            })
          }), setting]
        });
      }
    });

    return _this;
  }

  _createClass(SuggestItem, [{
    key: "render",
    value: function render() {
      var highlightClass = this.props.highlight ? 'sbox-highlight' : '';
      var iconClass = this.props.data.iconClass;
      iconClass = iconClass || (this.props.data.history ? 'ml-icon-history' : 'ml-icon-place');
      return /*#__PURE__*/jsxRuntime.jsx("li", {
        className: highlightClass,
        onClick: this.handleClick,
        children: /*#__PURE__*/jsxRuntime.jsx("div", {
          className: !this.props.data.provider ? 'suggest' : 'suggest suggest-provider',
          children: /*#__PURE__*/jsxRuntime.jsxs("div", {
            className: "suggest-text-area ml-borderbox",
            children: [/*#__PURE__*/jsxRuntime.jsx("div", {
              className: "suggest-icon-container",
              children: /*#__PURE__*/jsxRuntime.jsx("svg", {
                className: 'ml-icon ' + iconClass
              })
            }), this.renderContent()]
          })
        })
      });
    }
  }]);

  return SuggestItem;
}(React.Component);
SuggestItem.propTypes = {
  data: PropTypes__default['default'].any,
  onClickSetting: PropTypes__default['default'].func,
  highlight: PropTypes__default['default'].bool
};

var SuggestList = /*#__PURE__*/function (_Component) {
  _inherits(SuggestList, _Component);

  var _super = _createSuper(SuggestList);

  function SuggestList() {
    var _this;

    _classCallCheck(this, SuggestList);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "handleClick", function (data, index) {
      if (_this.props.onSelect) {
        _this.props.onSelect(data);
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleClickSetting", function (data) {
      if (_this.props.onClickSetting) {
        _this.props.onClickSetting(data);
      }
    });

    return _this;
  }

  _createClass(SuggestList, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      if (this.props.data && this.props.data.length) {
        var suggestItem = [];

        var _loop = function _loop(i) {
          var s = _this2.props.data[i];
          var highlight = _this2.props.highlightId ? _this2.props.highlightId === s.id : _this2.props.highlightIndex === i;

          if (s.favLocation) {
            var setting = !s.isMyLocation ? function () {
              _this2.handleClickSetting(s);
            } : null;
            suggestItem.push( /*#__PURE__*/jsxRuntime.jsx(SuggestItem, {
              data: s,
              highlight: highlight,
              isProvider: _this2.props.isProvider,
              onClick: function onClick() {
                return _this2.handleClick(s);
              },
              onClickSetting: setting
            }, i));
          } else {
            if (i > 0 && _this2.props.data[i - 1].favLocation) {
              suggestItem.push( /*#__PURE__*/jsxRuntime.jsx("li", {
                className: 'suggestion-divider'
              }, 'divider'));
            }

            suggestItem.push( /*#__PURE__*/jsxRuntime.jsx(SuggestItem, {
              data: s,
              highlight: _this2.props.highlightIndex === i,
              onClick: function onClick() {
                return _this2.handleClick(s);
              }
            }, i));
          }
        };

        for (var i = 0; i < this.props.data.length; i++) {
          _loop(i);
        }

        return /*#__PURE__*/jsxRuntime.jsx("ul", {
          className: "suggestions sbsb_b",
          children: suggestItem
        });
      } else {
        return null;
      }
    }
  }]);

  return SuggestList;
}(React.Component);

SuggestList.propTypes = {
  data: PropTypes__default['default'].array,
  onClickSetting: PropTypes__default['default'].func,
  onSelect: PropTypes__default['default'].func,
  highlightIndex: PropTypes__default['default'].number,
  highlightId: PropTypes__default['default'].any
};

var SearchSuggestContainer = /*#__PURE__*/function (_Component) {
  _inherits(SearchSuggestContainer, _Component);

  var _super = _createSuper(SearchSuggestContainer);

  function SearchSuggestContainer() {
    var _this;

    _classCallCheck(this, SearchSuggestContainer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "handleSelect", function (data) {
      if (_this.props.onSelect) {
        _this.props.onSelect(data);
      }
    });

    return _this;
  }

  _createClass(SearchSuggestContainer, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          searchResults = _this$props.searchResults,
          handleClickSetting = _this$props.handleClickSetting;
      return /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
        className: "ml-directions-suggestion-container ml-directions-suggestions-shown",
        style: {
          'maxHeight': this.props.maxHeight ? this.props.maxHeight : 700
        },
        children: /*#__PURE__*/jsxRuntime.jsx(SuggestList, {
          data: searchResults,
          onSelect: this.handleSelect,
          onClickSetting: handleClickSetting ? handleClickSetting : null
        })
      });
    }
  }]);

  return SearchSuggestContainer;
}(React.Component);

_defineProperty$1(SearchSuggestContainer, "propTypes", {
  searchResults: PropTypes__default['default'].array.isRequired
});

var CollapsibleSection = function CollapsibleSection(props) {
  var _props$className = props.className,
      className = _props$className === void 0 ? '' : _props$className,
      children = props.children,
      header = props.header,
      _props$actions = props.actions,
      actions = _props$actions === void 0 ? [] : _props$actions,
      _props$defaultExpande = props.defaultExpanded,
      defaultExpanded = _props$defaultExpande === void 0 ? true : _props$defaultExpande;
  var sectionRef = React.useRef(null);
  var contentRef = React.useRef(null);
  var timeout = React.useRef(null);

  var _useState = React.useState(defaultExpanded),
      _useState2 = _slicedToArray(_useState, 2),
      isExpanded = _useState2[0],
      setIsExpanded = _useState2[1];

  React.useLayoutEffect(function () {
    if (!sectionRef.current) {
      return;
    }

    sectionRef.current.classList.add('animated');
  }, [sectionRef]);
  React.useLayoutEffect(function () {
    if (!sectionRef.current || !contentRef.current) {
      return;
    }

    var sectionChildren = Array.from(sectionRef.current.children);
    var content = sectionChildren.find(function (el) {
      var _el$classList$value;

      return (_el$classList$value = el.classList.value) === null || _el$classList$value === void 0 ? void 0 : _el$classList$value.includes('section-panel-body');
    });
    var header = sectionChildren.find(function (el) {
      var _el$classList$value2;

      return (_el$classList$value2 = el.classList.value) === null || _el$classList$value2 === void 0 ? void 0 : _el$classList$value2.includes('section-header');
    });

    if (!content || !header) {
      return;
    }

    isExpanded ? sectionRef.current.classList.add('expanded') : sectionRef.current.classList.remove('expanded');

    if (!isExpanded) {
      timeout.current && clearTimeout(timeout.current);
      timeout.current = setTimeout(function () {
        if (!content || !sectionRef.current) {
          return;
        }

        content.style.height = '0px';
        sectionRef.current.style.maxHeight = "".concat(header.offsetHeight, "px");
      }, 100);
      return;
    }

    var height = contentRef.current.clientHeight;
    content.style.height = "".concat(Math.max(height, content.clientHeight), "px");
    sectionRef.current.style.maxHeight = '999999px';
    var resize = new ResizeObserver(function (entries) {
      if (!content) {
        return;
      }

      var rect = entries[0].contentRect;
      content.style.height = "".concat(rect.height, "px");
    });
    resize.observe(contentRef.current);
    return function () {
      return resize.disconnect();
    };
  }, [isExpanded]);

  var toggleExpand = function toggleExpand() {
    return setIsExpanded(function (prev) {
      return !prev;
    });
  };

  return /*#__PURE__*/jsxRuntime.jsx(Section, {
    className: "section-collapse-panel ".concat(className),
    innerRef: sectionRef,
    header: header,
    actions: [].concat(_toConsumableArray(actions), [{
      icon: 'chevron-up',
      className: isExpanded ? 'show' : '',
      onClick: toggleExpand
    }]),
    onHeaderClick: toggleExpand,
    children: /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
      children: /*#__PURE__*/jsxRuntime.jsx(Container, {
        ref: contentRef,
        children: children
      })
    })
  });
};

var Select = /*#__PURE__*/function (_Component) {
  _inherits(Select, _Component);

  var _super = _createSuper(Select);

  function Select(props) {
    var _this;

    _classCallCheck(this, Select);

    _this = _super.call(this, props);

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      value: _this.props.value
    });

    _this.handleChange = _this.handleChange.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(Select, [{
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      if (nextProps.value !== this.state.value) {
        this.setState({
          value: nextProps.value
        });
      }
    }
  }, {
    key: "handleChange",
    value: function handleChange(event) {
      this.setState({
        value: event.target.value
      });
      this.fireOnSelect(event);
    }
  }, {
    key: "render",
    value: function render() {
      var padding = this.props.padding;
      return /*#__PURE__*/jsxRuntime.jsx("select", {
        className: this.props.className,
        value: this.state.value,
        disabled: this.props.disabled,
        style: {
          width: this.props.width,
          padding: padding
        },
        onChange: this.handleChange,
        children: this.props.children
      });
    }
  }, {
    key: "fireOnSelect",
    value: function fireOnSelect(event) {
      if (typeof this.props.onChange === 'function') {
        this.props.onChange(event.target.value);
      }
    }
  }]);

  return Select;
}(React.Component);
Select.propTypes = {
  /** Class of Select */
  className: PropTypes__default['default'].string,

  /** Value of Select */
  value: PropTypes__default['default'].any,
  width: PropTypes__default['default'].string,

  /** Disabled: true, false */
  disabled: PropTypes__default['default'].bool,

  /** Callback function when changed value */
  onChange: PropTypes__default['default'].func,

  /** padding select control */
  padding: PropTypes__default['default'].string
};
Select.defaultProps = {
  className: '',
  width: '100%',
  disabled: false,
  padding: null,
  onChange: function onChange() {// console.log('Select value changed');
  }
};

exports.SelectOption = /*#__PURE__*/function (_Component2) {
  _inherits(SelectOption, _Component2);

  var _super2 = _createSuper(SelectOption);

  function SelectOption() {
    _classCallCheck(this, SelectOption);

    return _super2.apply(this, arguments);
  }

  _createClass(SelectOption, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          value = _this$props.value,
          text = _this$props.text,
          t = _this$props.t;
      return (
        /*#__PURE__*/
        // Don't use: <option value={value}><T>{text}</T></option>
        jsxRuntime.jsx("option", {
          value: value,
          children: t(text)
        })
      );
    }
  }]);

  return SelectOption;
}(React.Component);

exports.SelectOption = withI18n(exports.SelectOption);
exports.SelectOption.propTypes = {
  /** Value of Select Option */
  value: PropTypes__default['default'].any,

  /** Text of Select Option */
  text: PropTypes__default['default'].string.isRequired
};
exports.SelectOption.defaultProps = {
  text: ''
};

var SideBar = function SideBar(props) {
  var _props$width = props.width,
      width = _props$width === void 0 ? '200px' : _props$width,
      _props$flex = props.flex,
      flex = _props$flex === void 0 ? 0 : _props$flex,
      className = props.className,
      children = props.children;
  return /*#__PURE__*/jsxRuntime.jsx(BorderPanel, {
    className: clsx__default['default']('side-bar', className),
    width: width,
    flex: flex,
    children: children
  });
};

var Status = function Status(props) {
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: 'status-control',
    children: [/*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
      icon: 'circle',
      type: 'solid',
      size: '12px',
      color: props.color
    }), /*#__PURE__*/jsxRuntime.jsx("h4", {
      children: /*#__PURE__*/jsxRuntime.jsx(T, {
        children: props.text
      })
    })]
  });
};
Status.propTypes = {
  color: PropTypes__default['default'].string,
  text: PropTypes__default['default'].string
};
Status.defaultProps = {
  color: 'green',
  text: 'status'
};

var Table = function Table(props) {
  var headers = props.headers,
      isFixedHeader = props.isFixedHeader,
      className = props.className,
      isLoading = props.isLoading,
      children = props.children;
  return /*#__PURE__*/jsxRuntime.jsxs(ScrollView, {
    className: className,
    children: [/*#__PURE__*/jsxRuntime.jsxs("table", {
      className: "table-panel ".concat(isFixedHeader ? 'fixed-header' : ''),
      children: [/*#__PURE__*/jsxRuntime.jsx("thead", {
        children: /*#__PURE__*/jsxRuntime.jsx("tr", {
          children: Array.isArray(headers) && headers.map(function (h, index) {
            var _h$subCols;

            return h.isUseChild ? /*#__PURE__*/jsxRuntime.jsx("th", {
              style: {
                width: h.width
              },
              colSpan: h.col,
              align: h.align ? h.align : 'center',
              children: h.child
            }, index) : /*#__PURE__*/jsxRuntime.jsxs("th", {
              style: {
                width: h.width
              },
              colSpan: h.col || ((_h$subCols = h.subCols) === null || _h$subCols === void 0 ? void 0 : _h$subCols.length),
              align: h.align ? h.align : 'center',
              children: [/*#__PURE__*/jsxRuntime.jsx(Container, {
                children: /*#__PURE__*/jsxRuntime.jsx(T, {
                  children: h.label
                })
              }), h.subCols && /*#__PURE__*/jsxRuntime.jsx(Row2, {
                justify: 'around',
                gap: 2,
                sx: {
                  p: 2
                },
                children: h.subCols.map(function (sub, index) {
                  return /*#__PURE__*/jsxRuntime.jsx(Container, {
                    children: sub.label
                  }, index);
                })
              })]
            }, index);
          })
        })
      }), !isLoading && children && /*#__PURE__*/jsxRuntime.jsx("tbody", {
        children: children
      })]
    }), !isLoading && (!children || Array.isArray(children) && children.length === 0 || typeof children === 'boolean') && /*#__PURE__*/jsxRuntime.jsx("div", {
      style: {
        width: '100%',
        top: '50%',
        textAlign: 'center',
        paddingTop: '2rem',
        position: 'absolute'
      },
      children: /*#__PURE__*/jsxRuntime.jsx("div", {
        style: {
          opacity: '0.7'
        },
        children: "Kh\xF4ng c\xF3 d\u1EEF li\u1EC7u"
      })
    }), isLoading && /*#__PURE__*/jsxRuntime.jsx(Col2, {
      justify: "center",
      items: "center",
      children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
        icon: 'spinner-third',
        type: 'duotone',
        size: '3rem',
        spin: true
      })
    })]
  });
};

var _excluded$5 = ["children", "align"];
var TableRowCell = function TableRowCell(props) {
  var children = props.children,
      _props$align = props.align,
      align = _props$align === void 0 ? 'center' : _props$align,
      restProps = _objectWithoutProperties(props, _excluded$5);

  return /*#__PURE__*/jsxRuntime.jsx("td", _objectSpread2(_objectSpread2({
    align: align
  }, restProps), {}, {
    children: children
  }));
};

var _excluded$4 = ["children"];
var TableRow = function TableRow(props) {
  var children = props.children,
      restProps = _objectWithoutProperties(props, _excluded$4);

  return /*#__PURE__*/jsxRuntime.jsx("tr", _objectSpread2(_objectSpread2({}, restProps), {}, {
    children: children
  }));
};

var Tab = function Tab(props) {
  var flex = props.flex,
      active = props.active,
      id = props.id,
      title = props.title,
      _onClick = props.onClick,
      route = props.route;

  if (route) {
    return /*#__PURE__*/jsxRuntime.jsx(RouteTab, _objectSpread2({}, props));
  }

  return /*#__PURE__*/jsxRuntime.jsx("div", _objectSpread2(_objectSpread2(_objectSpread2({
    className: clsx__default['default']('tab-item-header', active && 'active')
  }, !flex && {
    style: {
      flex: 'none'
    }
  }), _onClick && {
    onClick: function onClick() {
      return _onClick(id || '');
    }
  }), {}, {
    children: /*#__PURE__*/jsxRuntime.jsx("span", {
      children: typeof title === 'string' ? /*#__PURE__*/jsxRuntime.jsx(T, {
        children: title
      }) : title
    })
  }));
};

var RouteTab = function RouteTab(props) {
  var history = reactRouterDom.useHistory();
  var flex = props.flex,
      active = props.active,
      title = props.title,
      _onClick2 = props.onClick,
      route = props.route;
  return /*#__PURE__*/jsxRuntime.jsx("div", _objectSpread2(_objectSpread2(_objectSpread2({
    className: clsx__default['default']('tab-item-header', active && 'active')
  }, !flex && {
    style: {
      flex: 'none'
    }
  }), _onClick2 && {
    onClick: function onClick() {
      _onClick2(route || '');

      route && history.push('/' + route);
    }
  }), {}, {
    children: /*#__PURE__*/jsxRuntime.jsx("span", {
      children: /*#__PURE__*/jsxRuntime.jsx(T, {
        children: title
      })
    })
  }));
};

var TabContent = function TabContent(props) {
  var _props$active = props.active,
      active = _props$active === void 0 ? true : _props$active,
      renderOnActive = props.renderOnActive,
      children = props.children;

  if (active && renderOnActive || !renderOnActive) {
    return /*#__PURE__*/jsxRuntime.jsx("div", {
      className: clsx__default['default']('tab-item-content', active && 'active'),
      children: children
    });
  } else {
    return null;
  }
};

var Tabs = function Tabs(props) {
  var children = props.children,
      onSelect = props.onSelect,
      selected = props.selected,
      _props$className = props.className,
      className = _props$className === void 0 ? '' : _props$className,
      _props$flexHeader = props.flexHeader,
      flexHeader = _props$flexHeader === void 0 ? true : _props$flexHeader,
      _props$renderOnActive = props.renderOnActive,
      renderOnActive = _props$renderOnActive === void 0 ? false : _props$renderOnActive;
  var tabs = [];
  var hasRoute = Array.isArray(children) ? children.some(function (child) {
    return child.props.route;
  }) : children === null || children === void 0 ? void 0 : children.props.route;
  Array.isArray(children) ? children.forEach(function (child) {
    return (child === null || child === void 0 ? void 0 : child.type) && tabs.push(child);
  }) : (children === null || children === void 0 ? void 0 : children.type) && tabs.push(children);

  if (hasRoute) {
    return /*#__PURE__*/jsxRuntime.jsx(RouterTabs, _objectSpread2({}, props));
  }

  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: ['tab-control', className].join(' '),
    children: [/*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'tab-header-wrap',
      children: /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
        children: /*#__PURE__*/jsxRuntime.jsx("div", {
          className: clsx__default['default']('tab-header', flexHeader && 'flex-header'),
          children: tabs.map(function (child, index) {
            return /*#__PURE__*/jsxRuntime.jsx(Tab, _objectSpread2(_objectSpread2({}, child.props), {}, {
              flex: flexHeader,
              active: (child.props.route || child.props.id) === selected,
              onClick: function onClick(id) {
                return onSelect && onSelect(id);
              }
            }), child.props.route || child.props.id || index);
          })
        })
      })
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'tab-content',
      children: tabs.map(function (child) {
        return child.props.id && /*#__PURE__*/jsxRuntime.jsx(TabContent, _objectSpread2(_objectSpread2({
          renderOnActive: renderOnActive
        }, child.props), {}, {
          active: child.props.id === selected,
          children: child.props.children
        }), child.props.id);
      })
    })]
  });
};

var RouterTabs = function RouterTabs(props) {
  var _tabs$find;

  var children = props.children,
      onSelect = props.onSelect,
      selected = props.selected,
      _props$className2 = props.className,
      className = _props$className2 === void 0 ? '' : _props$className2,
      _props$flexHeader2 = props.flexHeader,
      flexHeader = _props$flexHeader2 === void 0 ? true : _props$flexHeader2,
      _props$renderOnActive2 = props.renderOnActive,
      renderOnActive = _props$renderOnActive2 === void 0 ? false : _props$renderOnActive2;
  var location = reactRouterDom.useLocation();

  var _useRouteMatch = reactRouterDom.useRouteMatch(),
      url = _useRouteMatch.url;

  var tabs = [];
  Array.isArray(children) ? children.forEach(function (child) {
    return (child === null || child === void 0 ? void 0 : child.type) && tabs.push(child);
  }) : (children === null || children === void 0 ? void 0 : children.type) && tabs.push(children);
  React.useLayoutEffect(function () {
    var selectedTab = tabs.find(function (tab) {
      return tab.props.route === location.pathname.split(url + '/')[1];
    }) || tabs.find(function (tab) {
      return tab.props.route === selected;
    });
    selectedTab && onSelect && onSelect(selectedTab.props.route || selectedTab.props.id);
  }, []);
  var redirect = (_tabs$find = tabs.find(function (tab) {
    return tab.props.route === selected;
  })) === null || _tabs$find === void 0 ? void 0 : _tabs$find.props.route;
  return /*#__PURE__*/jsxRuntime.jsx(reactRouterDom.BrowserRouter, {
    basename: url,
    children: /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: ['tab-control', className].join(' '),
      children: [/*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'tab-header-wrap',
        children: /*#__PURE__*/jsxRuntime.jsx("div", {
          className: 'tab-header',
          children: tabs.map(function (child, index) {
            return /*#__PURE__*/jsxRuntime.jsx(Tab, _objectSpread2(_objectSpread2({}, child.props), {}, {
              flex: flexHeader,
              active: (child.props.route || child.props.id) === selected,
              onClick: function onClick(id) {
                return onSelect && onSelect(id);
              }
            }), child.props.route || child.props.id || index);
          })
        })
      }), /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'tab-content',
        children: /*#__PURE__*/jsxRuntime.jsxs(reactRouterDom.Switch, {
          children: [tabs.map(function (child) {
            return child.props.route && /*#__PURE__*/jsxRuntime.jsx(reactRouterDom.Route, {
              path: '/' + child.props.route,
              children: /*#__PURE__*/jsxRuntime.jsx(TabContent, _objectSpread2(_objectSpread2({
                renderOnActive: renderOnActive
              }, child.props), {}, {
                active: child.props.route === selected,
                children: child.props.children
              }))
            }, child.props.route);
          }), redirect && /*#__PURE__*/jsxRuntime.jsx(reactRouterDom.Redirect, {
            to: '/' + redirect
          })]
        })
      })]
    })
  });
};

var Tree = function Tree(props) {
  var _useState = React.useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      expandedKeys = _useState2[0],
      setExpandedKeys = _useState2[1];

  var _useState3 = React.useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      selectedKey = _useState4[0],
      setSelectedKey = _useState4[1];

  React.useEffect(function () {
    setExpandedKeys(props.defaultExpandedKeys || []);
  }, [props.defaultExpandedKeys]);

  var handleExpand = function handleExpand(item) {
    var _item$key;

    if (expandedKeys.includes((_item$key = item.key) !== null && _item$key !== void 0 ? _item$key : item.value)) {
      var newExpandedKeys = expandedKeys.filter(function (key) {
        var _ref;

        return (_ref = key !== item.key) !== null && _ref !== void 0 ? _ref : item.value;
      });
      props.onCollapse && props.onCollapse(_objectSpread2(_objectSpread2({}, item), {}, {
        defaultExpandedKeys: newExpandedKeys
      }));
      setExpandedKeys(newExpandedKeys);
    } else {
      var _item$key2;

      props.onExpand && props.onExpand(item);
      setExpandedKeys([].concat(_toConsumableArray(expandedKeys), [(_item$key2 = item.key) !== null && _item$key2 !== void 0 ? _item$key2 : item.value]));
    }
  };

  var handleSelect = function handleSelect(item) {
    var _item$key3;

    setSelectedKey((_item$key3 = item.key) !== null && _item$key3 !== void 0 ? _item$key3 : item.value);
    props.onSelect && props.onSelect(item);
  };

  return TreeView(_objectSpread2(_objectSpread2({}, props), {}, {
    defaultExpandedKeys: expandedKeys,
    onExpand: handleExpand,
    onSelect: handleSelect,
    selectedKey: selectedKey
  }));
};
var TreeView = function TreeView(props) {
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: "tree",
    children: props.data && props.data.map(function (item) {
      return TreeItem$1(_objectSpread2(_objectSpread2(_objectSpread2({}, props), item), {}, {
        data: item.data || []
      }));
    })
  });
};
var TreeItem$1 = function TreeItem(props) {
  var _props$data, _props$defaultExpande, _props$key, _props$key2, _props$key3, _props$treeItemDispla;

  var onClick = function onClick(e) {
    e.preventDefault();
    props.onSelect && props.onSelect(props);
  };

  var hasChildren = ((_props$data = props.data) === null || _props$data === void 0 ? void 0 : _props$data.length) || false;
  var isExpanded = (_props$defaultExpande = props.defaultExpandedKeys) === null || _props$defaultExpande === void 0 ? void 0 : _props$defaultExpande.includes((_props$key = props.key) !== null && _props$key !== void 0 ? _props$key : props.value);
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    children: [/*#__PURE__*/jsxRuntime.jsx("div", {
      className: "tree-item".concat(props.selectedKey === ((_props$key3 = props.key) !== null && _props$key3 !== void 0 ? _props$key3 : props.value) ? ' selected' : ''),
      onClick: onClick,
      children: /*#__PURE__*/jsxRuntime.jsxs(Row2, {
        items: "center",
        children: [/*#__PURE__*/jsxRuntime.jsx(Col2, {
          panel: false,
          children: !props.isLeaf && /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
            type: "duotone",
            className: "icon",
            icon: isExpanded ? 'angle-down' : 'angle-right',
            size: "1.2rem",
            onClick: function onClick(e) {
              e.preventDefault();
              e.stopPropagation();
              props.onExpand && props.onExpand(props);
            }
          })
        }), /*#__PURE__*/jsxRuntime.jsx(Col2, {
          children: /*#__PURE__*/jsxRuntime.jsx("div", {
            children: ((_props$treeItemDispla = props.treeItemDisplay) === null || _props$treeItemDispla === void 0 ? void 0 : _props$treeItemDispla.call(props, props)) || props.label || props.value
          })
        })]
      })
    }), isExpanded && hasChildren && TreeView(props)]
  }, (_props$key2 = props.key) !== null && _props$key2 !== void 0 ? _props$key2 : props.value);
};

var TagSelected = function TagSelected(_ref) {
  var data = _ref.data,
      onRemoveTag = _ref.onRemoveTag;

  var _useState = React.useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      tagData = _useState2[0],
      setTagData = _useState2[1];

  React.useEffect(function () {
    setTagData(data);
  }, [data]);

  var handleRemoveTag = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(tag) {
      var newTagData;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              newTagData = tagData.filter(function (tagItem) {
                return tagItem.id !== tag.id;
              });
              setTagData(newTagData);
              onRemoveTag(tag);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function handleRemoveTag(_x) {
      return _ref2.apply(this, arguments);
    };
  }();

  return tagData && tagData.length > 0 && /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
    className: 'tsp-tag-data-container',
    children: tagData.map(function (tag) {
      return /*#__PURE__*/jsxRuntime.jsx(Tag, {
        text: tag.label,
        onCloseClick: function onCloseClick() {
          return handleRemoveTag(tag);
        }
      }, tag.id);
    })
  });
};
TagSelected.propTypes = {
  data: PropTypes__default['default'].array,
  onRemoveTag: PropTypes__default['default'].func
};
TagSelected.defaultProps = {
  data: [],
  onRemoveTag: function onRemoveTag() {}
};

var TreeItem = function TreeItem(_ref) {
  var children = _ref.children,
      node = _ref.node,
      onChecked = _ref.onChecked,
      onExpand = _ref.onExpand;
  var textColor = 'var(--text-color)';
  var type = node.child && node.child.length ? 'folder' : 'file';
  var isExpand = children && children.length;
  var checkingType = node.checkingType || 0;

  var handleChecked = function handleChecked() {
    onChecked(node, checkingType === 0 || checkingType === 2 ? 1 : 0);
  };

  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: 'tree-item-container',
    children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
      className: 'tree-item-node',
      children: [type === 'folder' && /*#__PURE__*/jsxRuntime.jsx("div", {
        className: 'tree-item-node-expand',
        children: isExpand ? /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          icon: "angle-down",
          size: "1.5rem",
          color: 'var(--contrast-color)',
          onClick: function onClick() {
            return onExpand(node, !isExpand);
          }
        }) : /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          icon: "angle-right",
          size: "1.5rem",
          color: textColor,
          onClick: function onClick() {
            return onExpand(node, !isExpand);
          }
        })
      }), /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "tree-item-node-content ".concat(type === 'file' ? 'file' : 'folder'),
        children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
          className: "tree-item-node-check",
          children: [checkingType === 0 && /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
            color: textColor,
            size: "1.25rem",
            icon: "square",
            onClick: handleChecked
          }), checkingType === 1 && /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
            color: "var(--primary-color)",
            size: "1.25rem",
            icon: "check-square",
            onClick: handleChecked
          }), checkingType === 2 && /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
            size: "1.25rem",
            icon: "check-square",
            color: textColor,
            backgroundColor: "var(--contrast-highlight)",
            onClick: handleChecked
          })]
        }), /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "tree-item-node-label",
          onClick: handleChecked,
          children: /*#__PURE__*/jsxRuntime.jsx(T, {
            children: node.label
          })
        })]
      })]
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      className: 'tree-item-child',
      children: children
    })]
  });
};

TreeItem.propTypes = {};

var defaultProps = {
  data: [],
  defaultExpandIds: [],
  defaultCheckedIds: [],
  onlySelectLeaves: false,
  multiple: true,
  canCheck: true,
  recursiveChildren: true,
  onAfterInit: function onAfterInit() {}
};

var useTree = function useTree(props) {
  var _useState = React.useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      data = _useState2[0],
      setData = _useState2[1];

  var _useState3 = React.useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      nodeSelected = _useState4[0],
      setNodeSelected = _useState4[1];

  props = _objectSpread2(_objectSpread2({}, defaultProps), props);
  React.useEffect(function () {
    var newData = JSON.parse(JSON.stringify(props.data)); // deep clone
    // assign parent for easy go up

    treeIterate(newData, function (node, parent) {
      var _props$defaultExpandI, _node$child;

      node.parent = parent;

      if (((_props$defaultExpandI = props.defaultExpandIds) === null || _props$defaultExpandI === void 0 ? void 0 : _props$defaultExpandI.length) > 0 && props.defaultExpandIds.indexOf(node.id) !== -1 && ((_node$child = node.child) === null || _node$child === void 0 ? void 0 : _node$child.length) > 0) {
        node.expand = true;
      }
    });
    setData(newData);
  }, []);
  React.useEffect(function () {
    if ((data === null || data === void 0 ? void 0 : data.length) > 0) {
      props.onAfterInit && props.onAfterInit(data); // wait for state already set

      if (props.nodeSelected) {
        var _props$nodeSelected;

        checkIds((_props$nodeSelected = props.nodeSelected) === null || _props$nodeSelected === void 0 ? void 0 : _props$nodeSelected.map(function (node) {
          return node.id;
        }), 1, true);
      }
    }
  }, [data.length > 0]);

  var loadTree = function loadTree(data) {
    var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    setData(data);
    cb && cb(data);
  };

  var expandAll = function expandAll(nodes, expand) {
    var saveOrigin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    treeIterate(nodes, function (node) {
      if (saveOrigin && node.originExpand === null) {
        node.originExpand = node.expand;
      }

      node.expand = expand;
    });
    setData(_toConsumableArray(nodes));
  }; // function to traverse tree and callback on every node, to simplify tree manipulation -> use it like forEach on array


  var treeIterate = function treeIterate(trees, cb, done) {
    var iterate = function iterate(parent, cb) {
      if (parent.child) {
        var _iterator = _createForOfIteratorHelper(parent.child),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var node = _step.value;
            cb(node, parent);
            iterate(node, cb);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    };

    var _iterator2 = _createForOfIteratorHelper(trees),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var node = _step2.value;
        cb(node, null);
        iterate(node, cb);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    done && done();
  };

  var treeUp = function treeUp(node, cb) {
    if (node.parent) {
      cb(node.parent);
      treeUp(node.parent, cb);
    }
  };

  var recursiveChecked = function recursiveChecked(node, checkingType) {
    treeIterate([node], function (child) {
      child.checkingType = checkingType;
    });
  };

  var recursiveParentChecked = function recursiveParentChecked(node) {
    treeUp(node, function (parent) {
      var childPartialChecked = parent.child.filter(function (child) {
        return child.checkingType === 2;
      }).length;

      if (childPartialChecked === 0) {
        var childChecked = parent.child.filter(function (child) {
          return child.checkingType === 1;
        }).length;
        parent.checkingType = childChecked === 0 ? 0 : parent.child.length === childChecked ? 1 : 2;
      } else {
        parent.checkingType = 2;
      }
    });
  };

  var restoreExpand = function restoreExpand(nodes) {
    treeIterate(nodes, function (node) {
      if (node.originExpand !== null) {
        node.expand = node.originExpand;
        delete node.originExpand;
      }
    });
  };

  var checkAll = function checkAll(data, checkingType, done) {
    if (checkingType === 2) {
      return;
    } else if ((data === null || data === void 0 ? void 0 : data.length) > 0) {
      treeIterate(data, function (node) {
        return node.checkingType = checkingType;
      }, function () {
        done && done(data);
      });
    }
  };

  var check = function check(node, checkingType, cb) {
    if (!props.canCheck) {
      return;
    }

    if (!props.multiple) {
      checkAll(data, 0);
    }

    node.checkingType = checkingType; // child

    props.recursiveChildren && recursiveChecked(node, checkingType); // parent

    recursiveParentChecked(node); // event

    var nodeSelected = [];
    treeIterate(data, function (node) {
      if (node.checkingType === 1) {
        if (props.onlySelectLeaves) {
          if (!node.child || node.child.length === 0) {
            nodeSelected.push(node);
          }
        } else {
          nodeSelected.push(node); // to return node selected when select

          cb && cb(nodeSelected);
        }
      }
    }, function () {
      setData(data);
      setNodeSelected(nodeSelected);
    });
  };

  var checkIds = function checkIds(ids, checkingType, clearOld, cb) {
    var nodeSelected = [];

    if (!props.canCheck) {
      return;
    }

    if (clearOld) {
      checkAll(data, 0);
    }

    treeIterate(data, function (node) {
      if (ids.indexOf(node.id) !== -1 && node.checkingType !== checkingType) {
        node.checkingType = checkingType; // child

        props.recursiveChildren && recursiveChecked(node, checkingType); // parent

        recursiveParentChecked(node);
      }
    }); // event

    treeIterate(data, function (node) {
      if (node.checkingType === 1) {
        if (props.onlySelectLeaves) {
          if (!node.child || node.child.length === 0) {
            nodeSelected.push(node);
          }
        } else {
          nodeSelected.push(node); // to return node selected when select

          cb && cb(nodeSelected);
        }
      }
    }, function () {
      setData(data);
      setNodeSelected(nodeSelected);
    });
  };

  var expand = function expand(node, isExpand) {
    node.expand = isExpand; // can make remote expand here by call out expand event and wait to receive child than use it to set data state again

    setData(_toConsumableArray(data));
  };

  var updateNode = function updateNode(node, config) {
    for (var fieldName in config) {
      if (node.hasOwnProperty(fieldName)) {
        node[fieldName] = config[fieldName];
      }
    }

    setData(_toConsumableArray(data));
  };

  var expandIds = function expandIds(ids, isExpand) {
    var data = JSON.parse(JSON.stringify(props.data)); // deep clone
    // assign parent for easy go up

    treeIterate(data, function (node, parent) {
      var _node$child2;

      if ((ids === null || ids === void 0 ? void 0 : ids.length) > 0 && ids.indexOf(node.id) !== -1 && ((_node$child2 = node.child) === null || _node$child2 === void 0 ? void 0 : _node$child2.length) > 0) {
        node.expand = isExpand;
      }
    }, function () {
      setData(_toConsumableArray(data));
    });
  };

  var filter = function filter(keyFilter) {
    if (keyFilter !== '') {
      treeIterate(data, function (node) {
        node.visible = node.label.toLowerCase().includes(keyFilter.toLowerCase());

        if (node.visible) {
          treeUp(node, function (parent) {
            parent.visible = true;
          });
        }
      });
      expandAll(data, true, true);
    } else {
      treeIterate(data, function (node) {
        node.visible = true;
      });
      restoreExpand(data);
    }

    setData(_toConsumableArray(data));
  };

  var getNodeById = function getNodeById(id) {
    var nodeGet;
    treeIterate(data, function (node, parent) {
      if (node.id === id) {
        node.parent = parent;
        nodeGet = node;
      }
    });
    return nodeGet;
  };

  return [{
    data: data,
    nodeSelected: nodeSelected
  }, {
    expand: expand,
    expandIds: expandIds,
    expandAll: expandAll,
    filter: filter,
    check: check,
    checkAll: checkAll,
    checkIds: checkIds,
    getNodeById: getNodeById,
    updateNode: updateNode,
    loadTree: loadTree
  }];
};

useTree.propTypes = {
  data: PropTypes__default['default'].array,
  nodeSelected: PropTypes__default['default'].array,
  // multiple select
  multiple: PropTypes__default['default'].bool,
  // only return node leave when select
  onlySelectLeaves: PropTypes__default['default'].bool,
  // recursive children when check
  recursiveChildren: PropTypes__default['default'].bool,
  //  has the ability to check
  canCheck: PropTypes__default['default'].bool,
  // fuction will call after init data
  onAfterInit: PropTypes__default['default'].func,
  // default expand ids
  defaultExpandIds: PropTypes__default['default'].array,
  // default checked ids
  defaultCheckedIds: PropTypes__default['default'].array
};

var _excluded$3 = ["showTag", "height", "hasSearch"];
var TreeSelect = function TreeSelect(_ref) {
  var showTag = _ref.showTag,
      height = _ref.height,
      hasSearch = _ref.hasSearch,
      treeProps = _objectWithoutProperties(_ref, _excluded$3);

  var _useState = React.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      keySearch = _useState2[0],
      setKeySearch = _useState2[1];

  var callAfterIntiTree = function callAfterIntiTree(treeData) {
    expandAll(treeData, treeProps.expandAll);
  }; // call useTree to build tree (get state, and function off Tree) from tree data


  var _useTree = useTree(_objectSpread2(_objectSpread2({}, treeProps), {}, {
    onAfterInit: callAfterIntiTree
  })),
      _useTree2 = _slicedToArray(_useTree, 2),
      _useTree2$ = _useTree2[0],
      data = _useTree2$.data,
      nodeSelected = _useTree2$.nodeSelected,
      _useTree2$2 = _useTree2[1],
      expand = _useTree2$2.expand,
      filter = _useTree2$2.filter,
      check = _useTree2$2.check,
      expandAll = _useTree2$2.expandAll;

  var handleRemoveTag = function handleRemoveTag(node) {
    check(node, false);
  };

  var handleSearch = function handleSearch(key) {
    filter(key);
    setKeySearch(key);
  };

  var renderTreeItem = function renderTreeItem(node) {
    return node.visible !== false && /*#__PURE__*/jsxRuntime.jsx(TreeItem, {
      node: node,
      onChecked: check,
      onExpand: expand,
      children: node.expand && node.child && node.child.map(function (child) {
        return renderTreeItem(child);
      })
    }, node.id);
  };

  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    children: [hasSearch && /*#__PURE__*/jsxRuntime.jsx(FormControlLabel, {
      control: /*#__PURE__*/jsxRuntime.jsx(Input, {
        placeholder: 'Tìm kiếm',
        value: keySearch,
        onChange: handleSearch
      })
    }), showTag && (nodeSelected === null || nodeSelected === void 0 ? void 0 : nodeSelected.length) > 0 && /*#__PURE__*/jsxRuntime.jsx(TagSelected, {
      data: nodeSelected,
      size: 'small',
      onRemoveTag: handleRemoveTag
    }), /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
      style: {
        height: height
      },
      children: data && (data === null || data === void 0 ? void 0 : data.length) > 0 && data.map(function (node) {
        return renderTreeItem(node);
      })
    })]
  });
};
TreeSelect.propTypes = {
  data: PropTypes__default['default'].array,
  nodeSelected: PropTypes__default['default'].array,
  onlySelectLeaves: PropTypes__default['default'].bool,
  showTag: PropTypes__default['default'].bool,
  height: PropTypes__default['default'].string,
  expandAll: PropTypes__default['default'].bool,
  onChecked: PropTypes__default['default'].func,
  hasSearch: PropTypes__default['default'].bool
};
TreeSelect.defaultProps = {
  data: [],
  hasSearch: true,
  onlySelectLeaves: true,
  height: 'auto',
  showTag: true,
  expandAll: false
};

var _excluded$2 = ["data", "nodeSelected", "expandAll", "onClose"];
var TreeSelectPopup = /*#__PURE__*/function (_Component) {
  _inherits(TreeSelectPopup, _Component);

  var _super = _createSuper(TreeSelectPopup);

  function TreeSelectPopup() {
    var _this;

    _classCallCheck(this, TreeSelectPopup);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "handleTreeChecked", function (nodeSelected) {
      _this.nodeSelected = nodeSelected;
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleSave", function () {
      var _this$props = _this.props,
          onSave = _this$props.onSave,
          onClose = _this$props.onClose;
      onSave && onSave(_this.nodeSelected);
      onClose && onClose();
    });

    return _this;
  }

  _createClass(TreeSelectPopup, [{
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          data = _this$props2.data,
          nodeSelected = _this$props2.nodeSelected,
          expandAll = _this$props2.expandAll,
          onClose = _this$props2.onClose,
          rest = _objectWithoutProperties(_this$props2, _excluded$2);

      if (!data || data.length === 0) {
        return null;
      }

      return /*#__PURE__*/jsxRuntime.jsxs(Popup, _objectSpread2(_objectSpread2({
        width: '500px',
        onClose: onClose
      }, rest), {}, {
        children: [/*#__PURE__*/jsxRuntime.jsx(TreeSelect, {
          height: '500px',
          data: data,
          expandAll: expandAll,
          nodeSelected: nodeSelected,
          onChecked: this.handleTreeChecked
        }), /*#__PURE__*/jsxRuntime.jsx(PopupFooter, {
          children: /*#__PURE__*/jsxRuntime.jsx(Button, {
            className: "tsp-btn-save",
            color: "primary",
            text: "L\u01B0u",
            onClick: this.handleSave
          })
        })]
      }));
    }
  }]);

  return TreeSelectPopup;
}(React.Component);
TreeSelectPopup.propTypes = {
  data: PropTypes__default['default'].array,
  expandAll: PropTypes__default['default'].bool,
  onSave: PropTypes__default['default'].func,
  onClose: PropTypes__default['default'].func,
  nodeSelected: PropTypes__default['default'].array
};
TreeSelectPopup.defaultProps = {
  data: [],
  expandAll: false
};

var WebSocketService = /*#__PURE__*/function () {
  function WebSocketService() {
    _classCallCheck(this, WebSocketService);
  }

  _createClass(WebSocketService, null, [{
    key: "subscribeChanel",
    value: function subscribeChanel(channel, listener) {
      this.chanelSubscribers = this.chanelSubscribers || [];
      this.chanelSubscribers[channel] = this.chanelSubscribers[channel] || [];

      if (!this.chanelSubscribers[channel].includes(listener)) {
        this.chanelSubscribers[channel].push(listener);
      }
    }
  }, {
    key: "leaveChanel",
    value: function leaveChanel(channel, listener) {
      if (this.chanelSubscribers && this.chanelSubscribers[channel] && this.chanelSubscribers[channel].includes(listener)) {
        this.chanelSubscribers[channel] = this.chanelSubscribers[channel].filter(function (l) {
          return l !== listener;
        });
      }
    }
  }, {
    key: "hasChannel",
    value: function hasChannel(channel) {
      if (this.chanelSubscribers) {
        return !!this.chanelSubscribers[channel];
      }
    }
  }, {
    key: "sendMessage",
    value: function sendMessage(channel, data) {
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        var message = JSON.stringify({
          type: 'message',
          channel: channel,
          data: data
        });
        this.ws.send(message);
      }
    }
  }, {
    key: "requestAPI",
    value: function requestAPI(channel, body) {
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        var message = JSON.stringify(_objectSpread2({
          type: 'api',
          channel: channel
        }, body));
        this.ws.send(message);
      }
    }
  }]);

  return WebSocketService;
}();

_defineProperty$1(WebSocketService, "init", function (options) {
  WebSocketService.options = options;
  WebSocketService.url = WebSocketService.options.url;
  WebSocketService.connect();
});

_defineProperty$1(WebSocketService, "close", function () {
  WebSocketService.ws.close();
});

_defineProperty$1(WebSocketService, "connect", function () {
  if (WebSocketService.ws) {
    WebSocketService.ws.close(1000, 'Stop current websocket');
  }

  WebSocketService.ws = new WebSocket(WebSocketService.url);

  WebSocketService.ws.onopen = function () {
    WebSocketService.logging('Websocket onopen', WebSocketService.url);

    if (typeof WebSocketService.options.onOpen === 'function') {
      WebSocketService.options.onOpen();
    }
  };

  WebSocketService.ws.onclose = function (evt) {
    WebSocketService.logging('Websocket closing. Reason', evt.reason, 'Code', evt.code);

    if (typeof WebSocketService.options.onClose === 'function') {
      WebSocketService.options.onClose(evt.code, evt.reason);
    }

    if (WebSocketService.options.reconnect && (!WebSocketService.ws || WebSocketService.ws.readyState === WebSocket.CLOSED)) {
      WebSocketService.logging('Websocket reconnect after closes');
      WebSocketService.connect();
    }
  };

  WebSocketService.ws.onerror = function (err) {
    WebSocketService.logging('Error and Close Websocket', err);

    if (typeof WebSocketService.options.onError === 'function') {
      WebSocketService.options.onError(err);
    }

    WebSocketService.ws.close(1000, err);
  };

  WebSocketService.ws.onmessage = function (evt) {
    WebSocketService.logging('Websocket onmessage', evt.data);

    try {
      var message = JSON.parse(evt.data);

      if (message.channel) {
        if (WebSocketService.chanelSubscribers && WebSocketService.chanelSubscribers[message.channel]) {
          WebSocketService.chanelSubscribers[message.channel].forEach(function (onMessage) {
            onMessage(message.data);
          });
        }
      } else {
        console.error('Websocket invalid message: missing channel', message);
      }
    } catch (e) {
      console.error('Websocket malformed message', e);
    }
  };
});

_defineProperty$1(WebSocketService, "logging", function () {
  if (WebSocketService.options.debug) {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    console.log(args);
  }
});

var WindowFixedItem = /*#__PURE__*/function (_Component) {
  _inherits(WindowFixedItem, _Component);

  var _super = _createSuper(WindowFixedItem);

  function WindowFixedItem() {
    var _this;

    _classCallCheck(this, WindowFixedItem);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      notifyTop: -15
    });

    _defineProperty$1(_assertThisInitialized(_this), "notifyDirection", 1);

    return _this;
  }

  _createClass(WindowFixedItem, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      this.notifyInternal = setInterval(function () {
        var top = _this2.state.notifyTop;

        if (top < -18 && _this2.notifyDirection === 0) {
          _this2.notifyDirection = 1;
        } else if (top > -15 && _this2.notifyDirection === 1) {
          _this2.notifyDirection = 0;
        }

        _this2.setState({
          notifyTop: top + (_this2.notifyDirection === 1 ? 2 : -2)
        });
      }, 100);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      clearInterval(this.notifyInternal);
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        style: {
          position: 'relative',
          display: 'inline',
          cursor: 'pointer'
        },
        children: [this.props.isNotify && /*#__PURE__*/jsxRuntime.jsx("div", {
          style: {
            position: 'absolute',
            top: this.state.notifyTop + 'px',
            right: '5px',
            padding: '0px 5px',
            backgroundColor: 'red',
            zIndex: 2
          },
          children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
            icon: this.props.notifyIcon,
            size: "10pt",
            color: "white"
          })
        }), /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          className: this.props.className,
          icon: this.props.icon,
          size: "20pt",
          color: "white",
          onClick: this.props.onClick
        })]
      });
    }
  }]);

  return WindowFixedItem;
}(React.Component);
WindowFixedItem.propTypes = {
  /** Class of Icon */
  className: PropTypes__default['default'].string,

  /** Icon name */
  icon: PropTypes__default['default'].string.isRequired,

  /** Notify Icon */
  notifyIcon: PropTypes__default['default'].string.isRequired,

  /** Enable/Disable notify of this marker */
  isNotify: PropTypes__default['default'].bool,

  /** Callback function when click icon */
  onClick: PropTypes__default['default'].func
};
WindowFixedItem.defaultProps = {
  className: '',
  icon: '',
  notifyIcon: 'exclamation',
  isNotify: false,
  onClick: function onClick() {}
};

var WindowPopup = /*#__PURE__*/function (_Component) {
  _inherits(WindowPopup, _Component);

  var _super = _createSuper(WindowPopup);

  function WindowPopup() {
    var _this;

    _classCallCheck(this, WindowPopup);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "myRef", /*#__PURE__*/React__default['default'].createRef());

    _defineProperty$1(_assertThisInitialized(_this), "isMoving", false);

    _defineProperty$1(_assertThisInitialized(_this), "isResizing", false);

    _defineProperty$1(_assertThisInitialized(_this), "currentX", null);

    _defineProperty$1(_assertThisInitialized(_this), "currentY", null);

    _defineProperty$1(_assertThisInitialized(_this), "borderWidth", 20);

    _defineProperty$1(_assertThisInitialized(_this), "borderHeight", 51);

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      width: _this.props.width,
      height: _this.props.height,
      top: _this.props.top,
      left: _this.props.left
    });

    _defineProperty$1(_assertThisInitialized(_this), "onWindowFocus", function () {
      _this.props.onFocus(_this.props);
    });

    _defineProperty$1(_assertThisInitialized(_this), "onWindowClose", function () {
      _this.props.onClose(_this.props);
    });

    _defineProperty$1(_assertThisInitialized(_this), "moving", function (event) {
      _this.isMoving = true;
      _this.currentX = event.screenX;
      _this.currentY = event.screenY;
    });

    _defineProperty$1(_assertThisInitialized(_this), "resizing", function (event) {
      _this.isResizing = true;
      _this.currentX = event.screenX;
      _this.currentY = event.screenY;
    });

    _defineProperty$1(_assertThisInitialized(_this), "onMouseUp", function () {
      _this.isMoving = false;
      _this.isResizing = false;
      _this.currentX = null;
      _this.currentY = null;
    });

    _defineProperty$1(_assertThisInitialized(_this), "onMouseMove", function (event) {
      if (_this.isResizing) {
        var newWidth = _this.state.width + (event.screenX - _this.currentX);
        var newHeight = _this.state.height + (event.screenY - _this.currentY);
        _this.currentX = event.screenX;
        _this.currentY = event.screenY;

        var _this$calculateSize = _this.calculateSize(newWidth, newHeight),
            width = _this$calculateSize.width,
            height = _this$calculateSize.height;

        _this.setState({
          width: width <= 200 ? _this.state.width : width,
          height: height <= 150 ? _this.state.height : height
        });
      } else if (_this.isMoving) {
        var newTop = _this.state.top + (event.screenY - _this.currentY);
        var newLeft = _this.state.left + (event.screenX - _this.currentX);
        _this.currentX = event.screenX;
        _this.currentY = event.screenY;

        var _this$validateParentB = _this.validateParentBound(newTop, newLeft),
            top = _this$validateParentB.top,
            left = _this$validateParentB.left;

        _this.setState({
          top: top,
          left: left
        });
      }
    });

    return _this;
  }

  _createClass(WindowPopup, [{
    key: "calculateSize",
    value: function calculateSize(newWidth, newHeight) {
      var parentWidth = this.myRef.current.parentElement.clientWidth;
      var parentHeight = this.myRef.current.parentElement.clientHeight;

      if (newWidth + this.state.left + this.borderWidth >= parentWidth) {
        newWidth = this.state.width;
      }

      if (newHeight + this.state.top + this.borderHeight >= parentHeight) {
        newHeight = this.state.height;
      }

      return {
        width: newWidth,
        height: newHeight
      };
    }
  }, {
    key: "validateParentBound",
    value: function validateParentBound(newTop, newLeft) {
      var parentWidth = this.myRef.current.parentElement.clientWidth;
      var parentHeight = this.myRef.current.parentElement.clientHeight;

      if (newTop <= 0 || newTop + this.state.height + this.borderHeight >= parentHeight) {
        // out bound reset top
        newTop = this.state.top;
      }

      if (newLeft <= 0 || newLeft + this.state.width + this.borderWidth >= parentWidth) {
        // out bound, reset left
        newLeft = this.state.left;
      }

      return {
        top: newTop,
        left: newLeft
      };
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      // global window event
      window.addEventListener('mouseup', this.onMouseUp);
      window.addEventListener('mousemove', this.onMouseMove);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      // global window event
      window.removeEventListener('mouseup', this.onMouseUp);
      window.removeEventListener('mousemove', this.onMouseMove);
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        ref: this.myRef,
        className: "window-popup ".concat(this.props.isActivate ? 'active' : '', " ").concat(this.props.visible ? 'show' : 'hide'),
        style: {
          top: "".concat(this.state.top, "px"),
          left: "".concat(this.state.left, "px")
        },
        onClick: this.onWindowFocus,
        children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
          className: "wp-header",
          onMouseDown: this.moving,
          children: [/*#__PURE__*/jsxRuntime.jsx("h3", {
            children: /*#__PURE__*/jsxRuntime.jsx(T, {
              children: this.props.title
            })
          }), /*#__PURE__*/jsxRuntime.jsx("div", {
            className: "wp-header-actions",
            children: /*#__PURE__*/jsxRuntime.jsx("button", {
              children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
                icon: "times",
                size: "24px",
                color: "white",
                onClick: this.onWindowClose
              })
            })
          })]
        }), /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "wp-body",
          style: {
            width: "".concat(this.state.width, "px"),
            height: "".concat(this.state.height, "px")
          },
          children: this.props.children
        }), /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "wp-footer",
          children: this.props.resizable && /*#__PURE__*/jsxRuntime.jsx("div", {
            className: "wp-tool-resize",
            onMouseDown: this.resizing
          })
        })]
      });
    }
  }]);

  return WindowPopup;
}(React.Component);
WindowPopup.propTypes = {
  id: PropTypes__default['default'].string,
  className: PropTypes__default['default'].string,
  visible: PropTypes__default['default'].bool,
  title: PropTypes__default['default'].any,
  isMinimize: PropTypes__default['default'].bool,
  width: PropTypes__default['default'].number,
  height: PropTypes__default['default'].number,
  left: PropTypes__default['default'].number,
  top: PropTypes__default['default'].number,
  resizable: PropTypes__default['default'].bool,
  isActivate: PropTypes__default['default'].bool,
  onFocus: PropTypes__default['default'].func,
  onClose: PropTypes__default['default'].func
};
WindowPopup.defaultProps = {
  id: '',
  className: '',
  visible: true,
  title: '',
  isMinimize: false,
  width: 400,
  height: 300,
  top: Math.random() * 200,
  left: Math.random() * 400,
  resizable: true,
  isActivate: false,
  onFocus: function onFocus() {},
  onClose: function onClose() {}
};

var Moment = function Moment(props) {
  var _useI18n = useI18n(),
      language = _useI18n.language;

  return /*#__PURE__*/jsxRuntime.jsx(ReactMoment__default['default'], _objectSpread2({
    locale: language
  }, props));
};

var WindowScreen = /*#__PURE__*/function (_Component) {
  _inherits(WindowScreen, _Component);

  var _super = _createSuper(WindowScreen);

  function WindowScreen() {
    var _this;

    _classCallCheck(this, WindowScreen);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      curTime: new Date()
    });

    return _this;
  }

  _createClass(WindowScreen, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      this.countTime = setInterval(function () {
        _this2.setState({
          curTime: new Date()
        });
      }, 1000);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      clearInterval(this.countTime);
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "window",
        style: {
          width: this.props.width,
          height: this.props.height
        },
        children: [/*#__PURE__*/jsxRuntime.jsx("div", {
          className: "window-body",
          children: this.props.children
        }), /*#__PURE__*/jsxRuntime.jsxs("div", {
          className: "window-footer",
          children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
            className: "window-tool",
            children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
              className: "window-fixed-items",
              children: [/*#__PURE__*/jsxRuntime.jsx(WindowFixedItem, {
                className: "window-item",
                icon: "edit",
                isNotify: true
              }), /*#__PURE__*/jsxRuntime.jsx(WindowFixedItem, {
                className: "window-item",
                icon: "trash"
              })]
            }), /*#__PURE__*/jsxRuntime.jsxs("div", {
              className: "window-tool-datetime",
              children: [/*#__PURE__*/jsxRuntime.jsx("div", {
                style: {
                  textAlign: 'center'
                },
                children: /*#__PURE__*/jsxRuntime.jsx(Moment, {
                  format: 'L',
                  children: this.state.curTime
                })
              }), /*#__PURE__*/jsxRuntime.jsx("div", {
                style: {
                  textAlign: 'center',
                  width: '60px',
                  height: '20px',
                  paddingLeft: '18px'
                },
                children: /*#__PURE__*/jsxRuntime.jsx(Moment, {
                  format: 'LTS',
                  style: {
                    "float": 'left'
                  },
                  children: this.state.curTime
                })
              })]
            }), /*#__PURE__*/jsxRuntime.jsx("div", {
              className: "clearfix"
            })]
          }), /*#__PURE__*/jsxRuntime.jsx("div", {
            className: "clearfix"
          })]
        })]
      });
    }
  }]);

  return WindowScreen;
}(React.Component);
WindowScreen.propTypes = {
  className: PropTypes__default['default'].string,
  width: PropTypes__default['default'].string,
  height: PropTypes__default['default'].string
};
WindowScreen.defaultProps = {
  className: '',
  width: '100vw',
  height: '100vh'
};

var VideoPlayer = function VideoPlayer(props) {
  var source = props.source;
  var innerRef = React.useRef(null);
  React.useEffect(function () {
    var _innerRef$current;

    if (!innerRef.current) {
      return;
    }

    if (!((_innerRef$current = innerRef.current) !== null && _innerRef$current !== void 0 && _innerRef$current.plyr)) {
      innerRef.current.plyr = new Plyr__default['default']('.js-plyr', _objectSpread2(_objectSpread2({}, defaultVideoPlayerOptions), props.options));
    }

    if (innerRef.current && source) {
      innerRef.current.plyr.source = source;
    }
  }, [innerRef, props.options, props.source]);
  return /*#__PURE__*/jsxRuntime.jsx("video", {
    ref: innerRef,
    className: "js-plyr plyr"
  });
};
var defaultVideoPlayerOptions = {
  controls: ['rewind', 'play', 'play-large', 'fast-forward', 'progress', 'current-time', 'duration', 'mute', 'volume', 'captions', 'settings', 'fullscreen', 'pip', 'airplay', 'fullscreen'],
  seekTime: 5,
  i18n: {
    restart: 'Restart',
    rewind: 'Rewind {seektime}s',
    play: 'Play',
    pause: 'Pause',
    fastForward: 'Forward {seektime}s',
    seek: 'Seek',
    seekLabel: '{currentTime} of {duration}',
    played: 'Played',
    buffered: 'Buffered',
    currentTime: 'Current time',
    duration: 'Duration',
    volume: 'Volume',
    mute: 'Mute',
    unmute: 'Unmute',
    enableCaptions: 'Enable captions',
    disableCaptions: 'Disable captions',
    download: 'Download',
    enterFullscreen: 'Enter fullscreen',
    exitFullscreen: 'Exit fullscreen',
    frameTitle: 'Player for {title}',
    captions: 'Captions',
    settings: 'Settings',
    menuBack: 'Go back to previous menu',
    speed: 'Speed',
    normal: 'Normal',
    quality: 'Quality',
    loop: 'Loop'
  }
};

var TreeGrid = function TreeGrid(props) {
  // Utils
  var flattenNode = function flattenNode(treeNode, level) {
    var _props$expandedItems;

    var result = [];

    var newNode = _objectSpread2(_objectSpread2({}, treeNode), {}, {
      _level: level
    });

    newNode._isExpanded = level === 0 || ((_props$expandedItems = props.expandedItems) === null || _props$expandedItems === void 0 ? void 0 : _props$expandedItems.some(function (id) {
      return id === newNode[props.rowKey];
    }));

    if (props.showRoot || level > 0) {
      result.push(newNode);
    }

    if (newNode._isExpanded) {
      for (var i = 0; newNode.children && i < newNode.children.length; i++) {
        result.push.apply(result, _toConsumableArray(flattenNode(newNode.children[i], level + 1)));
      }
    }

    return result;
  }; // Handlers


  var handleClickExpander = function handleClickExpander(e, node) {
    e.stopPropagation();

    if (node._isExpanded) {
      props.onCollapse && props.onCollapse(node);
    } else {
      props.onExpand && props.onExpand(node);
    }
  };

  var handleClickCell = function handleClickCell(e, node) {
    props.onRowClick && props.onRowClick(node);
  }; // Preprocess


  var columns = [{
    id: '_treeHandler',
    displayAsText: 'Tên',
    width: props.treeWidth || 200,
    schema: 'react-node'
  }].concat(_toConsumableArray(props.columns || []));
  var gridItems = flattenNode(props.root, 0);
  gridItems.forEach(function (item) {
    if (item._level === undefined) {
      return;
    }

    var hideIcon = typeof item.isExpandable === 'boolean' && !item.isExpandable;
    var iconJsx = props.renderIcon && props.renderIcon(item);
    item._treeHandler = /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: "tree_handler",
      style: {
        paddingLeft: (props.showRoot ? item._level : item._level - 1) + 'rem'
      },
      children: [/*#__PURE__*/jsxRuntime.jsx("div", {
        className: "tree_handler-icon",
        onClick: function onClick(e) {
          return handleClickExpander(e, item);
        },
        children: iconJsx ? iconJsx : !hideIcon && /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          type: "light",
          icon: item._isExpanded ? 'chevron-down' : 'chevron-right',
          size: '16px'
        })
      }), /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "tree_handler-label",
        children: item.label ? item.label : String(item.id)
      })]
    });
  });
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: "tree_grid",
    style: {
      width: '100%',
      height: '100%'
    },
    children: /*#__PURE__*/jsxRuntime.jsx(DataGrid, {
      rowKey: props.rowKey,
      columns: columns,
      items: gridItems,
      toolbarVisibility: false,
      onCellClick: handleClickCell
    })
  });
};

var Separator = function Separator(props) {
  var _display;

  var _props$className = props.className,
      className = _props$className === void 0 ? '' : _props$className,
      displayAs = props.displayAs,
      _props$weight = props.weight,
      weight = _props$weight === void 0 ? 'normal' : _props$weight;
  var display = undefined;

  if (displayAs === 'forward-slash') {
    display = '/';
  }

  if (displayAs === 'backslash') {
    display = '\\';
  }

  if (displayAs === 'arrow') {
    display = '›';
  }

  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: "".concat(className, " separator-container"),
    children: /*#__PURE__*/jsxRuntime.jsx("span", {
      className: "separator-".concat(weight),
      children: (_display = display) !== null && _display !== void 0 ? _display : props.children
    })
  });
};

var ChartType;

(function (ChartType) {
  ChartType[ChartType["Line"] = 0] = "Line";
  ChartType[ChartType["Doughnut"] = 1] = "Doughnut";
  ChartType[ChartType["Bar"] = 2] = "Bar";
})(ChartType || (ChartType = {}));

var DisplayChart = function DisplayChart(props) {
  var options = props.options,
      value = props.value;
  var chartType = options.chartType,
      height = options.height,
      isMiniStyle = options.isMiniStyle;
  var DEFAULT_OPTIONS = {
    plugins: {
      legend: {
        display: false
      },
      title: {
        display: false
      }
    },
    scales: {
      x: {
        grid: {
          display: !isMiniStyle
        },
        ticks: {
          display: !isMiniStyle
        }
      },
      y: {
        grid: {
          display: !isMiniStyle
        },
        ticks: {
          display: !isMiniStyle
        }
      }
    },
    layout: {
      padding: {
        left: 4,
        right: 4,
        top: 12,
        bottom: 12
      }
    }
  };
  var PRIMARY_COLOR = getComputedStyle(document.body).getPropertyValue('--primary-color');
  var DEFAULT_DATASETS_OPTIONS = {
    borderColor: PRIMARY_COLOR,
    borderWidth: chartType === ChartType.Line ? 1 : 0,
    lineTension: 0,
    backgroundColor: chartType === ChartType.Doughnut ? ['red', 'blue', 'yellow', 'green'] : chartType === ChartType.Bar ? PRIMARY_COLOR : 'rgba(0,0,0,0)',
    pointRadius: 1
  };

  var data = _objectSpread2(_objectSpread2({}, value), {}, {
    datasets: value.datasets.map(function (e) {
      return _objectSpread2(_objectSpread2({}, DEFAULT_DATASETS_OPTIONS), e);
    })
  });

  switch (chartType) {
    case ChartType.Doughnut:
      return /*#__PURE__*/jsxRuntime.jsx(reactChartjs2.Doughnut, {
        height: height,
        data: data,
        options: _objectSpread2(_objectSpread2({}, DEFAULT_OPTIONS), options)
      });

    case ChartType.Line:
      return /*#__PURE__*/jsxRuntime.jsx(reactChartjs2.Line, {
        data: data,
        height: height,
        options: _objectSpread2(_objectSpread2({}, DEFAULT_OPTIONS), options)
      });

    case ChartType.Bar:
      return /*#__PURE__*/jsxRuntime.jsx(reactChartjs2.Bar, {
        data: data,
        height: height,
        options: _objectSpread2(_objectSpread2({}, DEFAULT_OPTIONS), options)
      });

    default:
      return null;
  }
};

var _excluded$1 = ["schema", "value", "format", "locale", "options"];
var DynamicDisplay = function DynamicDisplay(props) {
  var schema = props.schema,
      value = props.value,
      format = props.format,
      locale = props.locale,
      options = props.options,
      rest = _objectWithoutProperties(props, _excluded$1);

  if (value === undefined) {
    return null;
  }

  var displayComponent = function displayComponent() {
    switch (schema) {
      case exports.DataTypes.Boolean:
        return /*#__PURE__*/jsxRuntime.jsx(CheckBox, {
          checked: !!value
        });

      case exports.DataTypes.Currency:
        return /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "number",
          children: formatCurrency(value, locale)
        });

      case exports.DataTypes.Datetime:
        return /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "datetime",
          children: /*#__PURE__*/jsxRuntime.jsx("span", {
            className: "time",
            children: moment__default['default'](value).format(format || 'LT')
          })
        });

      case exports.DataTypes.Date:
        return /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "datetime",
          children: /*#__PURE__*/jsxRuntime.jsx("span", {
            className: "date",
            children: moment__default['default'](value).format(format || 'L')
          })
        });

      case exports.DataTypes.Numeric:
        return /*#__PURE__*/jsxRuntime.jsx("div", {
          className: 'number',
          children: formatNumeric(value, format)
        });

      case exports.DataTypes.JSON:
        return /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "text",
          children: JSON.stringify(value)
        });

      case exports.DataTypes.Link:
        return /*#__PURE__*/jsxRuntime.jsx(Link, {
          href: value !== null && value !== void 0 ? value : '#',
          children: value
        });

      case exports.DataTypes.Select:
        {
          var option = options === null || options === void 0 ? void 0 : options.find(function (option) {
            return option.id === value;
          });
          var defaultColor = 'var(--default-color)';
          return option ? /*#__PURE__*/jsxRuntime.jsx(Tag, {
            text: option.label,
            color: option.color || defaultColor
          }) : /*#__PURE__*/jsxRuntime.jsx(Tag, {
            text: value,
            color: defaultColor
          });
        }

      case exports.DataTypes.MultiSelect:
        return options === null || options === void 0 ? void 0 : options.filter(function (option) {
          return value === null || value === void 0 ? void 0 : value.includes(option.id);
        }).map(function (option) {
          return /*#__PURE__*/jsxRuntime.jsx(Tag, {
            text: option === null || option === void 0 ? void 0 : option.label,
            color: option === null || option === void 0 ? void 0 : option.color
          }, option === null || option === void 0 ? void 0 : option.id);
        });

      case exports.DataTypes.Image:
        return /*#__PURE__*/jsxRuntime.jsx(Image$1, {
          src: value
        });

      case exports.DataTypes.Chart:
        return /*#__PURE__*/jsxRuntime.jsx(DisplayChart, {
          value: value,
          options: _objectSpread2(_objectSpread2({}, options), rest)
        });

      case exports.DataTypes.Map:
      case exports.DataTypes.MapVN2000:
        {
          var geoJsonValue = value;

          if (value && typeof value !== 'string') {
            geoJsonValue = JSON.stringify(value);
          }

          return /*#__PURE__*/jsxRuntime.jsx(MapControl, {
            placeholder: 'Nhấp để đặt vị trí',
            value: geoJsonValue || '',
            readOnly: true
          });
        }

      default:
        return /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "undefined",
          children: value
        });
    }
  };

  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: "dynamic-display",
    children: displayComponent()
  });
};

var formatCurrency = function formatCurrency(number, locale) {
  switch (locale) {
    case 'vi':
      {
        var parts = number.toString().split('.');
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, '.');
        return parts.join('.') + 'đ';
      }

    default:
      {
        var _parts = number.toString().split('.');

        _parts[0] = _parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        return '$' + _parts.join('.');
      }
  }
}; // format: \# or #.## or #,##


var formatNumeric = function formatNumeric(number, format) {
  switch (format) {
    case '#,##':
      return Number(number).toFixed(2).toString().replaceAll('.', ',');

    case '#.##':
      return Number(number).toFixed(2);

    default:
      return number;
  }
};

var DynamicForm = function DynamicForm(props) {
  var className = props.className,
      schema = props.schema,
      options = props.options,
      autoFocus = props.autoFocus,
      onChange = props.onChange,
      onChangeFiles = props.onChangeFiles,
      onChangeDone = props.onChangeDone,
      changeImmediately = props.changeImmediately;

  var _useState = React.useState(props.value),
      _useState2 = _slicedToArray(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1];

  if (!schema) {
    return null;
  }

  var handleChange = function handleChange(value) {
    setValue(value);
    onChange && onChange(value);
  };

  var inputJsx = function () {
    switch (schema) {
      case exports.DataTypes.Boolean:
        return /*#__PURE__*/jsxRuntime.jsx(CheckBox, {
          checked: value,
          onChange: handleChange
        });

      case exports.DataTypes.Currency:
      case exports.DataTypes.Numeric:
        return /*#__PURE__*/jsxRuntime.jsx(Input, {
          type: "number",
          step: 1,
          defaultValue: value,
          autoFocus: autoFocus,
          onChange: handleChange
        });

      case exports.DataTypes.Real:
        return /*#__PURE__*/jsxRuntime.jsx(Input, {
          type: "number",
          step: 0.01,
          defaultValue: value,
          autoFocus: autoFocus,
          onChange: handleChange
        });

      case exports.DataTypes.Date:
        return /*#__PURE__*/jsxRuntime.jsx(DateTimePicker, {
          value: value,
          isVisible: autoFocus,
          showTimeRange: true,
          onChange: handleChange
        });

      case exports.DataTypes.Datetime:
        return /*#__PURE__*/jsxRuntime.jsx(DateTimePicker, {
          value: value,
          isVisible: autoFocus,
          showTimeRange: true,
          onChange: handleChange
        });

      case exports.DataTypes.Text:
        return /*#__PURE__*/jsxRuntime.jsx(Input, {
          type: "text",
          defaultValue: value,
          autoFocus: autoFocus,
          onChange: handleChange
        });

      case exports.DataTypes.File:
        return /*#__PURE__*/jsxRuntime.jsx(FileInput, {
          onChangeFiles: onChangeFiles
        });

      case exports.DataTypes.List:
        {
          var _config$content, _config$content2;

          var config = JSON.parse(options || '{}');
          var selectOptions = (Array.isArray(config === null || config === void 0 ? void 0 : (_config$content = config.content) === null || _config$content === void 0 ? void 0 : _config$content.source) ? config === null || config === void 0 ? void 0 : (_config$content2 = config.content) === null || _config$content2 === void 0 ? void 0 : _config$content2.source : []).map(function (op) {
            return {
              id: op.Value,
              label: op.Display
            };
          });
          return /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
            options: selectOptions,
            value: value,
            isVisible: autoFocus,
            onChange: handleChange
          });
        }

      case exports.DataTypes.Map:
      case exports.DataTypes.MapVN2000:
        {
          var geoJsonValue = value;

          if (value && typeof value !== 'string') {
            geoJsonValue = JSON.stringify(value);
          }

          return /*#__PURE__*/jsxRuntime.jsx(MapStateProvider, {
            initState: {
              open: true
            },
            children: /*#__PURE__*/jsxRuntime.jsx(MapControlContainer, {
              placeholder: 'Nhấp để đặt vị trí',
              value: geoJsonValue || '',
              onChange: handleChange
            })
          });
        }

      default:
        return /*#__PURE__*/jsxRuntime.jsx(MultilineInput, {
          maxTextareaHeight: "5rem",
          value: value,
          autoFocus: true,
          onChange: handleChange
        });
    }
  }();

  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: changeImmediately ? _objectSpread2(_objectSpread2({}, inputJsx), {}, {
      props: _objectSpread2(_objectSpread2({}, inputJsx.props), {}, {
        className: className
      })
    }) : /*#__PURE__*/jsxRuntime.jsxs(InputGroup, {
      className: className,
      children: [_objectSpread2(_objectSpread2({}, inputJsx), {}, {
        props: _objectSpread2({}, inputJsx.props)
      }), /*#__PURE__*/jsxRuntime.jsx(InputAppend, {
        children: /*#__PURE__*/jsxRuntime.jsxs(Row2, {
          items: "center",
          children: [/*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
            icon: "check",
            onlyIcon: true,
            onClick: function onClick(e) {
              e.stopPropagation();
              onChangeDone && onChangeDone(value);
            }
          }), /*#__PURE__*/jsxRuntime.jsx(EmptyButton, {
            icon: "times",
            onlyIcon: true,
            onClick: function onClick(e) {
              e.stopPropagation();
              onChangeDone && onChangeDone(undefined);
            }
          })]
        })
      })]
    })
  });
};

var DynamicDisplayForm = function DynamicDisplayForm(props) {
  return null;
};

var DescriptionItem = function DescriptionItem(props) {
  var className = props.className,
      icon = props.icon,
      iconClassName = props.iconClassName,
      iconType = props.iconType,
      iconSize = props.iconSize,
      iconColor = props.iconColor,
      direction = props.direction,
      label = props.label,
      labelWidth = props.labelWidth,
      labelLocation = props.labelLocation;
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: "des-item des-item-".concat(direction, " ").concat(className),
    children: [icon && /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
      icon: icon,
      className: iconClassName,
      type: iconType,
      size: iconSize,
      color: iconColor
    }), label && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "des-item-label des-item-label-align-".concat(labelLocation),
      style: {
        flex: direction === 'row' ? "0 0 ".concat(labelWidth) : ''
      },
      children: /*#__PURE__*/jsxRuntime.jsx(T, {
        children: label
      })
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      children: props.children
    })]
  });
};

DescriptionItem.propTypes = {
  className: PropTypes__default['default'].string,
  icon: PropTypes__default['default'].string,
  iconClassName: PropTypes__default['default'].string,
  iconType: PropTypes__default['default'].oneOf(['solid', 'regular', 'light']),
  iconSize: PropTypes__default['default'].string,
  iconColor: PropTypes__default['default'].string,
  label: PropTypes__default['default'].any,
  labelWidth: PropTypes__default['default'].string,
  labelLocation: PropTypes__default['default'].oneOf(['left', 'right']),
  direction: PropTypes__default['default'].oneOf(['row', 'column']),
  children: PropTypes__default['default'].node
};
DescriptionItem.defaultProps = {
  direction: 'row',
  iconType: 'solid',
  iconSize: '1rem',
  labelWidth: '70px',
  labelLocation: 'left',
  className: ''
};

var DescriptionGroup = function DescriptionGroup(_ref) {
  var _ref$direction = _ref.direction,
      direction = _ref$direction === void 0 ? 'column' : _ref$direction,
      children = _ref.children,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: "des-group des-group-".concat(direction, " ").concat(className),
    children: children
  });
};
DescriptionGroup.propTypes = {
  className: PropTypes__default['default'].string,
  direction: PropTypes__default['default'].oneOf(['row', 'column'])
};

var useTenant = function useTenant() {
  var tenant = React.useContext(TenantContext);
  var tenantConfig = (tenant === null || tenant === void 0 ? void 0 : tenant.config) || {};
  return tenantConfig;
};

var withTenant = function withTenant(Component) {
  // eslint-disable-next-line react/display-name
  return function (props) {
    var tenantConfig = useTenant();
    return /*#__PURE__*/jsxRuntime.jsx(Component, _objectSpread2({
      tenantConfig: tenantConfig
    }, props));
  };
};

var ThemeIcon = function ThemeIcon(props) {
  return /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
    className: "theme-icon ".concat(props.className),
    icon: 'circle',
    type: 'solid',
    size: '1.5rem',
    color: props.color,
    tooltip: props.tooltip || 'Chủ đề'
  });
};
ThemeIcon.propTypes = {
  color: PropTypes__default['default'].string,
  className: PropTypes__default['default'].string,
  tooltip: PropTypes__default['default'].string
};
ThemeIcon.defaultProps = {
  color: 'white',
  className: ''
};

var en = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  format: "{reason} at line {line}",
  symbols: {
    colon: "colon",
    // :
    comma: "comma",
    // ,  ،  、
    semicolon: "semicolon",
    // ;
    slash: "slash",
    // /  relevant for comment syntax support
    backslash: "backslash",
    // \  relevant for escaping character
    brackets: {
      round: "round brackets",
      // ( )
      square: "square brackets",
      // [ ]
      curly: "curly brackets",
      // { }
      angle: "angle brackets" // < >

    },
    period: "period",
    // . Also known as full point, full stop, or dot
    quotes: {
      single: "single quote",
      // '
      double: "double quote",
      // "
      grave: "grave accent" // ` used on Javascript ES6 Syntax for String Templates

    },
    space: "space",
    //       
    ampersand: "ampersand",
    //	&
    asterisk: "asterisk",
    //	*  relevant for some comment sytanx
    at: "at sign",
    //	@  multiple uses in other coding languages including certain data types
    equals: "equals sign",
    //	=
    hash: "hash",
    //	#
    percent: "percent",
    //	%
    plus: "plus",
    //	+
    minus: "minus",
    //	−
    dash: "dash",
    //	−
    hyphen: "hyphen",
    //	−
    tilde: "tilde",
    //	~
    underscore: "underscore",
    //	_
    bar: "vertical bar" //	|

  },
  types: {
    key: "key",
    value: "value",
    number: "number",
    string: "string",
    primitive: "primitive",
    boolean: "boolean",
    character: "character",
    integer: "integer",
    array: "array",
    float: "float" //... Reference: https://en.wikipedia.org/wiki/List_of_data_structures

  },
  invalidToken: {
    tokenSequence: {
      prohibited: "'{firstToken}' token cannot be followed by '{secondToken}' token(s)",
      permitted: "'{firstToken}' token can only be followed by '{secondToken}' token(s)"
    },
    termSequence: {
      prohibited: "A {firstTerm} cannot be followed by a {secondTerm}",
      permitted: "A {firstTerm} can only be followed by a {secondTerm}"
    },
    double: "'{token}' token cannot be followed by another '{token}' token",
    useInstead: "'{badToken}' token is not accepted. Use '{goodToken}' instead",
    unexpected: "Unexpected '{token}' token found"
  },
  brace: {
    curly: {
      missingOpen: "Missing '{' open curly brace",
      missingClose: "Open '{' curly brace is missing closing '}' curly brace",
      cannotWrap: "'{token}' token cannot be wrapped in '{}' curly braces"
    },
    square: {
      missingOpen: "Missing '[' open square brace",
      missingClose: "Open '[' square brace is missing closing ']' square brace",
      cannotWrap: "'{token}' token cannot be wrapped in '[]' square braces"
    }
  },
  string: {
    missingOpen: "Missing/invalid opening string '{quote}' token",
    missingClose: "Missing/invalid closing string '{quote}' token",
    mustBeWrappedByQuotes: "Strings must be wrapped by quotes",
    nonAlphanumeric: "Non-alphanumeric token '{token}' is not allowed outside string notation",
    unexpectedKey: "Unexpected key found at string position"
  },
  key: {
    numberAndLetterMissingQuotes: "Key beginning with number and containing letters must be wrapped by quotes",
    spaceMissingQuotes: "Key containing space must be wrapped by quotes",
    unexpectedString: "Unexpected string found at key position"
  },
  noTrailingOrLeadingComma: "Trailing or leading commas in arrays and objects are not permitted"
};
exports.default = _default;
});

var locale = /*@__PURE__*/getDefaultExportFromCjs(en);

var JSONInputEditor = function JSONInputEditor(props) {
  var themeContext = React.useContext(ThemeContext);
  var themeBase = themeList.find(function (theme) {
    return themeContext.theme === theme;
  }).base;
  return /*#__PURE__*/jsxRuntime.jsx(JSONInput__default['default'], _objectSpread2({
    locale: locale,
    theme: themeBase === 'light' ? 'light_mitsuketa_tribute' : 'dark_vscode_tribute'
  }, props));
};

var initState = {
  map: undefined,
  location: null,
  mapCenter: null,
  clickToPin: false
};
var AdministrativeMapContext = /*#__PURE__*/React.createContext({});

var AdministrativeMapProvider = function AdministrativeMapProvider(_ref) {
  var children = _ref.children;

  var _useMergeState = useMergeState(initState),
      _useMergeState2 = _slicedToArray(_useMergeState, 2),
      adminMapState = _useMergeState2[0],
      setAdminMapState = _useMergeState2[1];

  return /*#__PURE__*/jsxRuntime.jsx(AdministrativeMapContext.Provider, {
    value: _objectSpread2(_objectSpread2({}, adminMapState), {}, {
      setAdminMapState: setAdminMapState
    }),
    children: children
  });
};

var AdministrativeMarker = function AdministrativeMarker(props) {
  var _useContext = React.useContext(AdministrativeMapContext),
      map = _useContext.map,
      location = _useContext.location,
      clickToPin = _useContext.clickToPin,
      setAdminMapState = _useContext.setAdminMapState;

  var onLocationChange = props.onLocationChange;
  var onMapClick = React.useRef(function (event) {
    onLocationChange(event);
  }).current;

  var onMarkerDragEnd = function onMarkerDragEnd(event) {
    onLocationChange(event);
  };

  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(Positioned, {
      children: /*#__PURE__*/jsxRuntime.jsx(Button, {
        className: "map-control map-control-button ".concat(clickToPin && 'active'),
        icon: 'map-marker-plus',
        onlyIcon: true,
        onClick: function onClick() {
          if (clickToPin) {
            map.getCanvas().style.cursor = null;
            map.off('click', onMapClick);
          } else {
            map.getCanvas().style.cursor = 'crosshair';
            map.on('click', onMapClick);
          }

          setAdminMapState({
            clickToPin: !clickToPin
          });
        }
      })
    }), /*#__PURE__*/jsxRuntime.jsx(ReactMapboxGl.Layer, {
      type: "symbol",
      id: "map-location-marker",
      layout: {
        'text-field': CommonHelper.getFontAwesomeStringFromClassName('map-marker-alt', 'solid'),
        'text-font': ['Font Awesome Pro Solid'],
        'text-size': 24,
        'text-anchor': 'top',
        'text-offset': [0, -1],
        'text-ignore-placement': true,
        // important, reduce flickering when drag
        'text-allow-overlap': true // important, reduce flickering when drag

      },
      paint: {
        'text-color': '#037de8',
        'text-halo-color': '#fff',
        'text-halo-width': 0.8
      },
      children: /*#__PURE__*/jsxRuntime.jsx(ReactMapboxGl.Feature, {
        coordinates: [location.longitude, location.latitude],
        draggable: true,
        onDragEnd: onMarkerDragEnd
      })
    })]
  });
};

var AdministrativeMap = function AdministrativeMap(props) {
  var _props$height = props.height,
      height = _props$height === void 0 ? '300px' : _props$height,
      center = props.center,
      onLocationChange = props.onLocationChange,
      zoom = props.zoom,
      scrollZoom = props.scrollZoom,
      isNotControl = props.isNotControl;

  var _useContext = React.useContext(AdministrativeMapContext),
      map = _useContext.map,
      setAdminMapState = _useContext.setAdminMapState;

  React.useEffect(function () {
    if (map) {
      map.panTo(center);
    }
  }, [center]); // update location when move end

  var handleLocationChange = function handleLocationChange(event) {
    var location = {
      longitude: event.lngLat.lng,
      latitude: event.lngLat.lat
    };
    onLocationChange && onLocationChange(location);
  };

  var onStyleLoad = function onStyleLoad(map) {
    setAdminMapState({
      map: map
    });
  };

  return /*#__PURE__*/jsxRuntime.jsx(Map$2, {
    height: height,
    center: center,
    zoomLevel: [zoom],
    isNotControl: isNotControl,
    scrollZoom: scrollZoom,
    fontURL: "",
    onStyleLoad: onStyleLoad,
    children: /*#__PURE__*/jsxRuntime.jsx(AdministrativeMarker, {
      onLocationChange: handleLocationChange
    })
  });
};

var AdministrativeSearch = function AdministrativeSearch(props) {
  var administrativeSvc = props.administrativeSvc,
      onSelectionChange = props.onSelectionChange,
      _props$label = props.label,
      label = _props$label === void 0 ? '' : _props$label,
      _props$direction = props.direction,
      direction = _props$direction === void 0 ? 'column' : _props$direction;

  var _useContext = React.useContext(AdministrativeMapContext),
      map = _useContext.map,
      location = _useContext.location;

  var _useMergeState = useMergeState({
    locations: [],
    location: {},
    options: [],
    value: ''
  }),
      _useMergeState2 = _slicedToArray(_useMergeState, 2),
      state = _useMergeState2[0],
      setState = _useMergeState2[1];

  React.useEffect(function () {
    setLocation(location);
  }, [location]);

  var setLocation = function setLocation(location) {
    if (location) {
      if (!location.id) {
        location.id = location.latitude + ',' + location.longitude;
      }

      var initLabel = [location.name, location.address].filter(function (x) {
        return x;
      }).join(', ');
      var options = [{
        id: location.id,
        label: initLabel,
        provider: location.provider
      }];
      setState({
        location: location,
        options: options,
        value: location.id
      });
    } else {
      setState({
        location: {},
        options: [],
        value: ''
      });
    }
  };

  var getBounds = function getBounds() {
    if (map) {
      var bounds = map.getBounds();
      return {
        north: bounds.getNorth(),
        east: bounds.getEast(),
        south: bounds.getSouth(),
        west: bounds.getWest()
      };
    }

    return {};
  };

  var _useState = React.useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      textChangeDelay = _useState2[0],
      setTextChangeDelay = _useState2[1];

  var handleTextChange = function handleTextChange(searchKey) {
    if (textChangeDelay) {
      clearTimeout(textChangeDelay);
      setTextChangeDelay(null);
    }

    if (searchKey) {
      setTextChangeDelay(setTimeout(function () {
        if (searchKey) {
          administrativeSvc.search(searchKey, getBounds()).then(function (res) {
            if (res.docs && res.docs.length > 0) {
              var newOptions = res.docs.map(function (doc) {
                if (!doc.id) {
                  doc.id = doc.longitude + '-' + doc.latitude;
                }

                return {
                  id: doc.id,
                  provider: doc.provider,
                  label: [doc.name || '', doc.address].concat(doc.provider ? [" (".concat(doc.provider, ")")] : []).filter(function (item) {
                    return item;
                  }).join(', ')
                };
              });
              setState({
                locations: res.docs,
                options: newOptions
              });
            }
          });
        }
      }, 500));
    }
  };

  var handleSelectionChange = function handleSelectionChange(value) {
    var _loc, _loc2, _loc3, _loc4, _loc5, _loc6;

    if (!value || value === -1 || value === 'non-select') {
      return;
    }

    var locations = state.locations,
        options = state.options;
    var refreshOptions = options.filter(function (option) {
      return option.id === value;
    }); // check locations in init

    var loc = locations.length === 0 ? location : locations.find(function (loc) {
      return loc.id === value;
    });
    loc = {
      longitude: ((_loc = loc) === null || _loc === void 0 ? void 0 : _loc.longitude) || location.longitude || '',
      latitude: ((_loc2 = loc) === null || _loc2 === void 0 ? void 0 : _loc2.latitude) || location.latitude || '',
      name: ((_loc3 = loc) === null || _loc3 === void 0 ? void 0 : _loc3.name) || '',
      address: ((_loc4 = loc) === null || _loc4 === void 0 ? void 0 : _loc4.address) || '',
      city: ((_loc5 = loc) === null || _loc5 === void 0 ? void 0 : _loc5.province) || '',
      country: ((_loc6 = loc) === null || _loc6 === void 0 ? void 0 : _loc6.country) || ''
    };

    if (typeof onSelectionChange === 'function') {
      onSelectionChange(loc);
    }

    !refreshOptions.length && refreshOptions.push(loc);
    setState({
      options: refreshOptions,
      value: value
    });
  };

  return /*#__PURE__*/jsxRuntime.jsx(FormControlLabel, {
    label: label,
    direction: direction,
    control: /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
      options: state.options,
      value: state.value,
      searchMode: "remote",
      searchable: true,
      onRemoteFetch: handleTextChange,
      onChange: handleSelectionChange
    })
  });
};

var useConvertCoordinatesToOLC = function useConvertCoordinatesToOLC(params) {
  var latitude = params.latitude,
      longitude = params.longitude,
      Tang = params.Tang;

  var _useState = React.useState(''),
      _useState2 = _slicedToArray(_useState, 2),
      postalCode = _useState2[0],
      setPostalCode = _useState2[1];

  var CODE_PRECISION = 12;
  var MAX_DIGIT_COUNT = 15;
  var PAIR_CODE_LENGTH = 10;
  var CODE_ALPHABET = '23456789CFGHJMPQRVWX';
  var ENCODING_BASE = CODE_ALPHABET.length;
  var GRID_ROWS = 5;
  var GRID_COLUMNS = 4;
  var LATITUDE_MAX = 90;
  var LONGITUDE_MAX = 180;
  var PAIR_PRECISION = Math.pow(ENCODING_BASE, 3);
  var FINAL_LAT_PRECISION = PAIR_PRECISION * Math.pow(GRID_ROWS, MAX_DIGIT_COUNT - PAIR_CODE_LENGTH);
  var FINAL_LNG_PRECISION = PAIR_PRECISION * Math.pow(GRID_COLUMNS, MAX_DIGIT_COUNT - PAIR_CODE_LENGTH);
  var SEPARATOR = '+';
  var SEPARATOR_POSITION = 8;
  var GRID_CODE_LENGTH = MAX_DIGIT_COUNT - PAIR_CODE_LENGTH;
  React.useEffect(function () {
    var OLCode = encode(latitude, longitude);
    setPostalCode(OLCode);
  }, [latitude, longitude, Tang]);

  var encode = function encode(latitude, longitude) {
    var codeLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : CODE_PRECISION;
    var lat = parseFloat(latitude);
    var lng = parseFloat(longitude);

    if (codeLength < 2 || codeLength < PAIR_CODE_LENGTH && codeLength % 2 === 1) {
      throw new Error('IllegalArgumentException: Invalid Open Location Code length');
    } // Ensure that latitude and longitude are valid.


    lat = clipLatitude(lat);
    lng = normalizeLongitude(lng); // Latitude 90 needs to be adjusted to be just less, so the returned code
    // can also be decoded.

    if (lat === 90) {
      lat = lat - computeLatitudePrecision(codeLength);
    }

    var code = ''; // Compute the code.
    // This approach converts each value to an integer after multiplying it by
    // the final precision. This allows us to use only integer operations, so
    // avoiding any accumulation of floating point representation errors.
    // Multiply values by their precision and convert to positive.
    // Force to integers so the division operations will have integer results.
    // Note: JavaScript requires rounding before truncating to ensure precision!

    var latVal = Math.floor(Math.round((lat + LATITUDE_MAX) * FINAL_LAT_PRECISION * 1e6) / 1e6);
    var lngVal = Math.floor(Math.round((lng + LONGITUDE_MAX) * FINAL_LNG_PRECISION * 1e6) / 1e6); // Compute the grid part of the code if necessary.

    if (codeLength > PAIR_CODE_LENGTH) {
      for (var i = 0; i < MAX_DIGIT_COUNT - PAIR_CODE_LENGTH; i++) {
        var latDigit = latVal % GRID_ROWS;
        var lngDigit = lngVal % GRID_COLUMNS;
        var ndx = latDigit * GRID_COLUMNS + lngDigit;
        code = CODE_ALPHABET.charAt(ndx) + code; // Note! Integer division.

        latVal = Math.floor(latVal / GRID_ROWS);
        lngVal = Math.floor(lngVal / GRID_COLUMNS);
      }
    } else {
      latVal = Math.floor(latVal / Math.pow(GRID_ROWS, GRID_CODE_LENGTH));
      lngVal = Math.floor(lngVal / Math.pow(GRID_COLUMNS, GRID_CODE_LENGTH));
    } // Compute the pair section of the code.


    for (var _i = 0; _i < PAIR_CODE_LENGTH / 2; _i++) {
      code = CODE_ALPHABET.charAt(lngVal % ENCODING_BASE) + code;
      code = CODE_ALPHABET.charAt(latVal % ENCODING_BASE) + code;
      latVal = Math.floor(latVal / ENCODING_BASE);
      lngVal = Math.floor(lngVal / ENCODING_BASE);
    } // Pad and return the code.


    code = Tang && Tang !== '0' ? code.substring(0, SEPARATOR_POSITION) + SEPARATOR + code.substring(SEPARATOR_POSITION, CODE_PRECISION - Tang.toString().length - 1) + Tang : code.substring(0, SEPARATOR_POSITION) + SEPARATOR + code.substring(SEPARATOR_POSITION, CODE_PRECISION - 1);
    return code.substring(0, CODE_PRECISION);
  };

  var clipLatitude = function clipLatitude(lat) {
    return Math.min(90, Math.max(-90, lat));
  };

  var computeLatitudePrecision = function computeLatitudePrecision(codeLength) {
    if (codeLength <= 10) {
      return Math.pow(ENCODING_BASE, Math.floor(codeLength / -2 + 2));
    }

    return Math.pow(ENCODING_BASE, -3) / Math.pow(GRID_ROWS, codeLength - 10);
  };

  var normalizeLongitude = function normalizeLongitude(lng) {
    while (lng < -180) {
      lng = lng + 360;
    }

    while (lng >= 180) {
      lng = lng - 360;
    }

    return lng;
  };

  return {
    postalCode: postalCode
  };
};

exports.AdminFields = void 0;

(function (AdminFields) {
  AdminFields["location"] = "location";
  AdminFields["province"] = "province";
  AdminFields["district"] = "district";
  AdminFields["ward"] = "ward";
  AdminFields["street"] = "street";
  AdminFields["address"] = "address";
  AdminFields["shortAddress"] = "shortAddress";
  AdminFields["floor"] = "floor";
  AdminFields["postalCode"] = "postalCode";
})(exports.AdminFields || (exports.AdminFields = {}));

var adminType = [Constants.TYPE_PROVINCE, Constants.TYPE_DISTRICT, Constants.TYPE_WARD];

var AdministrativeComponent = function AdministrativeComponent(props) {
  var data = props.data,
      _props$fields = props.fields,
      fields = _props$fields === void 0 ? [exports.AdminFields.location, exports.AdminFields.province, exports.AdminFields.district, exports.AdminFields.ward, exports.AdminFields.address, exports.AdminFields.floor, exports.AdminFields.postalCode] : _props$fields,
      _props$lngLat = props.lngLat,
      lngLat = _props$lngLat === void 0 ? {
    lng: 106.66887141635867,
    lat: 10.782883235202302
  } : _props$lngLat,
      _props$isReadOnly = props.isReadOnly,
      isReadOnly = _props$isReadOnly === void 0 ? false : _props$isReadOnly,
      mapHeight = props.mapHeight,
      onChange = props.onChange,
      administrativeSvc = props.administrativeSvc,
      displayField = props.displayField,
      valueField = props.valueField,
      labelWidth = props.labelWidth;

  var _useMergeState = useMergeState({
    stateOptions: [],
    districtOptions: [],
    wardOptions: []
  }),
      _useMergeState2 = _slicedToArray(_useMergeState, 2),
      options = _useMergeState2[0],
      setOptions = _useMergeState2[1];

  var _useMergeState3 = useMergeState(data || {
    location: undefined,
    province: undefined,
    district: undefined,
    ward: undefined,
    street: undefined,
    address: undefined,
    floor: undefined,
    postalCode: undefined
  }),
      _useMergeState4 = _slicedToArray(_useMergeState3, 2),
      adminData = _useMergeState4[0],
      setAdminData = _useMergeState4[1];

  var _useContext = React.useContext(AdministrativeMapContext),
      mapCenter = _useContext.mapCenter,
      location = _useContext.location,
      setAdminMapState = _useContext.setAdminMapState;

  var _useConvertCoordinate = useConvertCoordinatesToOLC(_objectSpread2(_objectSpread2({}, location), {}, {
    Tang: adminData === null || adminData === void 0 ? void 0 : adminData.floor
  })),
      postalCode = _useConvertCoordinate.postalCode;

  var getChildByParentId = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(parentId, type) {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return administrativeSvc.getChildByParentId(parentId, type);

            case 2:
              return _context.abrupt("return", _context.sent);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function getChildByParentId(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();

  var bindAdminOptions = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(province, district) {
      var provinces, districts, wards;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (options.stateOptions.length) {
                _context2.next = 5;
                break;
              }

              _context2.next = 3;
              return getChildByParentId(0, Constants.TYPE_PROVINCE);

            case 3:
              provinces = _context2.sent;
              setAdminOptions(Constants.LEVEL_PROVINCE, provinces);

            case 5:
              if (!province) {
                _context2.next = 15;
                break;
              }

              _context2.next = 8;
              return getChildByParentId(province, Constants.TYPE_DISTRICT);

            case 8:
              districts = _context2.sent;
              setAdminOptions(Constants.LEVEL_DISTRICT, districts);

              if (!district) {
                _context2.next = 15;
                break;
              }

              _context2.next = 13;
              return getChildByParentId(district, Constants.TYPE_WARD);

            case 13:
              wards = _context2.sent;
              setAdminOptions(Constants.LEVEL_WARD, wards);

            case 15:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function bindAdminOptions(_x3, _x4) {
      return _ref2.apply(this, arguments);
    };
  }();

  var setAdminOptions = function setAdminOptions(level, admins) {
    var adminOptions = mapAdminOptions(admins || []);

    switch (level) {
      case Constants.LEVEL_PROVINCE:
        setOptions({
          stateOptions: adminOptions,
          districtOptions: [],
          wardOptions: []
        });
        break;

      case Constants.LEVEL_DISTRICT:
        setOptions({
          districtOptions: adminOptions,
          wardOptions: []
        });
        break;

      case Constants.LEVEL_WARD:
        setOptions({
          wardOptions: adminOptions
        });
        break;
    }
  };

  var mapAdminOptions = function mapAdminOptions() {
    var admins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return admins.map(function (admin) {
      return _objectSpread2({
        id: Number(admin[valueField]),
        label: admin[displayField]
      }, admin);
    });
  };

  React.useEffect(function () {
    var location = (data === null || data === void 0 ? void 0 : data.location) || {
      coordinates: [lngLat.lng, lngLat.lat]
    };

    if (location) {
      if (typeof location === 'string') {
        location = JSON.parse(location);
      }

      setAdminMapState({
        location: {
          longitude: location.coordinates[0],
          latitude: location.coordinates[1]
        },
        mapCenter: {
          lng: location.coordinates[0],
          lat: location.coordinates[1]
        }
      });
    }
  }, []);
  var didMountRef = React.useRef(false);
  React.useEffect(function () {
    if (Object.values(adminData).every(function (el) {
      return el === undefined || isNaN(el);
    })) {
      data && setAdminData(data);

      if (data !== null && data !== void 0 && data.location) {
        var _data$location;

        setAdminMapState({
          location: {
            longitude: data.location.coordinates[0],
            latitude: data === null || data === void 0 ? void 0 : (_data$location = data.location) === null || _data$location === void 0 ? void 0 : _data$location.coordinates[1]
          },
          mapCenter: {
            lng: data.location.coordinates[0],
            lat: data.location.coordinates[1]
          }
        });
      }
    }
  }, [data]);
  React.useEffect(function () {
    if (didMountRef.current) {
      onChange && onChange(_objectSpread2(_objectSpread2({}, adminData), {}, {
        postalCode: postalCode
      }));
    } else {
      bindAdminOptions(Number((adminData === null || adminData === void 0 ? void 0 : adminData.province) || ''), Number((adminData === null || adminData === void 0 ? void 0 : adminData.district) || '')).then(function () {
        didMountRef.current = true;
      });
    }
  }, [adminData]);
  React.useEffect(function () {
    if (typeof adminData.province === 'string') {
      var _options$stateOptions;

      var _province = (_options$stateOptions = options.stateOptions.find(function (option) {
        return option.label === adminData.province;
      })) === null || _options$stateOptions === void 0 ? void 0 : _options$stateOptions.label;

      bindAdminOptions(Number(_province));
      setAdminData({
        province: _province
      });
    }

    if (typeof adminData.district === 'string') {
      var _options$districtOpti;

      var _district = (_options$districtOpti = options.districtOptions.find(function (option) {
        return option.label === adminData.district;
      })) === null || _options$districtOpti === void 0 ? void 0 : _options$districtOpti.label;

      bindAdminOptions(Number((adminData === null || adminData === void 0 ? void 0 : adminData.province) || ''), Number(_district));
      setAdminData({
        district: _district
      });
    }

    if (typeof adminData.ward === 'string') {
      var _options$wardOptions$;

      var _ward = (_options$wardOptions$ = options.wardOptions.find(function (option) {
        return option.label === adminData.ward;
      })) === null || _options$wardOptions$ === void 0 ? void 0 : _options$wardOptions$.label;

      setAdminData({
        ward: _ward
      });
    }
  }, [options]);

  var bindRegionField = function bindRegionField(level, regions) {
    setAdminOptions(level, regions);
  };

  var handleSelectAdmin = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(level, adminId) {
      var childLevel, type, regions;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              // get child regions of this selected value
              childLevel = level + 1;
              type = adminType[childLevel];

              if (!type) {
                _context3.next = 7;
                break;
              }

              _context3.next = 5;
              return getChildByParentId(adminId, type);

            case 5:
              regions = _context3.sent;
              bindRegionField(childLevel, regions);

            case 7:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function handleSelectAdmin(_x5, _x6) {
      return _ref3.apply(this, arguments);
    };
  }();

  var handleLocationChange = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(location, changeMapCenter) {
      var longitude, latitude, locationInfo, rs;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              longitude = location.longitude, latitude = location.latitude;
              _context4.next = 3;
              return administrativeSvc.reverseGeocode(longitude, latitude);

            case 3:
              locationInfo = _context4.sent;
              setAdminMapState(_objectSpread2({
                location: location
              }, changeMapCenter && {
                mapCenter: {
                  lng: longitude,
                  lat: latitude
                }
              }));

              if (!locationInfo) {
                _context4.next = 12;
                break;
              }

              _context4.next = 8;
              return administrativeSvc.getAdminIdByName(locationInfo.province, locationInfo.district, locationInfo.ward);

            case 8:
              rs = _context4.sent;
              _context4.next = 11;
              return bindAdminOptions(rs.province, rs.district);

            case 11:
              setTimeout(function () {
                setAdminData({
                  location: JSON.stringify({
                    type: 'Point',
                    coordinates: [longitude, latitude]
                  }),
                  province: rs.province || locationInfo.province,
                  district: rs.district || (locationInfo === null || locationInfo === void 0 ? void 0 : locationInfo.district),
                  ward: rs.ward || locationInfo.ward,
                  street: locationInfo === null || locationInfo === void 0 ? void 0 : locationInfo.street,
                  address: locationInfo === null || locationInfo === void 0 ? void 0 : locationInfo.shortAddress,
                  postalCode: postalCode
                });
              }, 100);

            case 12:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function handleLocationChange(_x7, _x8) {
      return _ref4.apply(this, arguments);
    };
  }();

  var handleStateSelect = /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(value) {
      var record, loc;
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              record = options.stateOptions.find(function (d) {
                return d.id === value;
              });
              loc = null;

              if (record) {
                loc = [record.Longitude, record.Latitude];
                setAdminMapState({
                  location: {
                    longitude: record.Longitude,
                    latitude: record.Latitude
                  },
                  mapCenter: {
                    lng: record.Longitude,
                    lat: record.Latitude
                  }
                });
              }

              setAdminData({
                province: value,
                district: null,
                ward: null,
                location: JSON.stringify({
                  type: 'Point',
                  coordinates: loc
                }),
                street: null,
                address: null,
                shortAddress: null,
                postalCode: postalCode
              });
              _context5.next = 6;
              return handleSelectAdmin(0, value);

            case 6:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    return function handleStateSelect(_x9) {
      return _ref5.apply(this, arguments);
    };
  }();

  var handleDistrictSelect = /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(value) {
      var record, loc;
      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              record = options.districtOptions.find(function (d) {
                return d.id === value;
              });
              loc = null;

              if (record) {
                loc = [record.Longitude, record.Latitude];
                setAdminMapState({
                  location: {
                    longitude: record.Longitude,
                    latitude: record.Latitude
                  },
                  mapCenter: {
                    lng: record.Longitude,
                    lat: record.Latitude
                  }
                });
              }

              setAdminData({
                district: value,
                ward: null,
                location: JSON.stringify({
                  type: 'Point',
                  coordinates: loc
                }),
                postalCode: postalCode
              });
              _context6.next = 6;
              return handleSelectAdmin(1, value);

            case 6:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    return function handleDistrictSelect(_x10) {
      return _ref6.apply(this, arguments);
    };
  }();

  var handleWardSelect = function handleWardSelect(value) {
    var record = options.wardOptions.find(function (d) {
      return d.id === value;
    });
    var loc = null;

    if (record) {
      loc = [record.Longitude, record.Latitude];
      setAdminMapState({
        location: {
          longitude: record.Longitude,
          latitude: record.Latitude
        },
        mapCenter: {
          lng: record.Longitude,
          lat: record.Latitude
        }
      });
    }

    setAdminData({
      ward: value,
      location: JSON.stringify({
        type: 'Point',
        coordinates: loc
      }),
      postalCode: postalCode
    });
  };

  var handleAddressChange = function handleAddressChange(value) {
    setAdminData({
      address: value,
      shortAddress: value
    });
  };

  var handleFloorChange = function handleFloorChange(value) {
    setAdminData({
      floor: value,
      postalCode: postalCode
    });
  };

  var defaultRules = [{}];
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [fields.indexOf(exports.AdminFields.location) !== -1 && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
      children: [/*#__PURE__*/jsxRuntime.jsx(AdministrativeSearch, {
        administrativeSvc: administrativeSvc,
        label: 'Tìm kiếm',
        direction: 'row',
        onSelectionChange: /*#__PURE__*/function () {
          var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(location) {
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return handleLocationChange(location, true);

                  case 2:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7);
          }));

          return function (_x11) {
            return _ref7.apply(this, arguments);
          };
        }()
      }), /*#__PURE__*/jsxRuntime.jsx(AdministrativeMap, {
        height: mapHeight,
        center: mapCenter || lngLat,
        zoom: 12,
        scrollZoom: false,
        isNotControl: false,
        onLocationChange: handleLocationChange
      })]
    }), /*#__PURE__*/jsxRuntime.jsxs(Col2, {
      gap: 1,
      sx: {
        p: 1
      },
      children: [fields.indexOf(exports.AdminFields.province) !== -1 && /*#__PURE__*/jsxRuntime.jsx(FormControlLabel, {
        rules: defaultRules,
        label: 'Tỉnh/ thành',
        labelWidth: labelWidth,
        control: /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
          placeholder: 'Nhập tỉnh/ thành',
          name: exports.AdminFields.province,
          value: adminData.province,
          options: options.stateOptions,
          disabled: isReadOnly,
          onChange: handleStateSelect
        }),
        required: true
      }, exports.AdminFields.province), fields.indexOf(exports.AdminFields.district) !== -1 && /*#__PURE__*/jsxRuntime.jsx(FormControlLabel, {
        rules: defaultRules,
        label: 'Quận/ huyện',
        labelWidth: labelWidth,
        control: /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
          placeholder: 'Nhập quận/ huyện',
          name: exports.AdminFields.district,
          value: adminData.district,
          options: options.districtOptions,
          disabled: isReadOnly,
          onChange: handleDistrictSelect
        }),
        required: true
      }, exports.AdminFields.district), fields.indexOf(exports.AdminFields.ward) !== -1 && /*#__PURE__*/jsxRuntime.jsx(FormControlLabel, {
        rules: defaultRules,
        label: 'Xã/ phường',
        labelWidth: labelWidth,
        control: /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
          placeholder: 'Nhập xã/ phường',
          name: exports.AdminFields.ward,
          value: adminData.ward,
          options: options.wardOptions,
          disabled: isReadOnly,
          onChange: handleWardSelect
        }),
        required: true
      }, exports.AdminFields.ward), fields.indexOf(exports.AdminFields.address) !== -1 && /*#__PURE__*/jsxRuntime.jsx(FormControlLabel, {
        rules: defaultRules,
        label: 'Địa chỉ',
        labelWidth: labelWidth,
        control: /*#__PURE__*/jsxRuntime.jsx(Input, {
          placeholder: 'Nhập địa chỉ',
          name: exports.AdminFields.address,
          value: (adminData === null || adminData === void 0 ? void 0 : adminData.address) || '',
          disabled: isReadOnly,
          onChange: handleAddressChange
        })
      }, exports.AdminFields.address), fields.indexOf(exports.AdminFields.floor) !== -1 && /*#__PURE__*/jsxRuntime.jsx(FormControlLabel, {
        rules: defaultRules,
        label: 'Tầng (Chung cư, cao ốc)',
        labelWidth: labelWidth,
        control: /*#__PURE__*/jsxRuntime.jsx(Input, {
          name: exports.AdminFields.floor,
          value: (adminData === null || adminData === void 0 ? void 0 : adminData.floor) | 0,
          onChange: handleFloorChange
        })
      }, exports.AdminFields.floor), fields.indexOf(exports.AdminFields.postalCode) !== -1 && /*#__PURE__*/jsxRuntime.jsx(FormControlLabel, {
        rules: defaultRules,
        label: 'Postal code',
        labelWidth: labelWidth,
        control: /*#__PURE__*/jsxRuntime.jsx(Input, {
          name: exports.AdminFields.postalCode,
          value: postalCode,
          disabled: true
        })
      }, exports.AdminFields.postalCode)]
    })]
  });
};

var Administrative = function Administrative(props) {
  return /*#__PURE__*/jsxRuntime.jsx(AdministrativeMapProvider, {
    children: /*#__PURE__*/jsxRuntime.jsx(AdministrativeComponent, _objectSpread2({}, props))
  });
};

var Callout = function Callout(props) {
  var severity = props.severity,
      title = props.title,
      onClose = props.onClose,
      children = props.children;

  var _useState = React.useState(true),
      _useState2 = _slicedToArray(_useState, 2),
      showCallout = _useState2[0],
      setShowCallout = _useState2[1];

  var icon = '';

  switch (severity) {
    case 'error':
      icon = 'exclamation-circle';
      break;

    case 'warning':
      icon = 'exclamation-triangle';
      break;

    case 'info':
      icon = 'info-circle';
      break;

    case 'success':
      icon = 'check-circle';
      break;
  }

  var handleClose = function handleClose() {
    setShowCallout(false);

    if (onClose) {
      onClose();
    }
  };

  return showCallout ? /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: "callout-container callout-".concat(severity),
    role: "alert",
    children: [/*#__PURE__*/jsxRuntime.jsx("div", {
      className: "callout-icon",
      children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
        icon: icon,
        type: "regular",
        size: "1.5rem"
      })
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: "callout-message",
      children: [title && /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "callout-title",
        children: title
      }), children]
    }), onClose && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "callout-action",
      children: /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
        icon: "times",
        type: "light",
        size: "1.25rem",
        onClick: handleClose
      })
    })]
  }) : /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {});
};

var SPEED_PER_SECOND = 0.5;
var levels = [100, 65, 50, 0]; // percents of height

var timeout = 10; // timeout to move down

var CollapsibleContainer = function CollapsibleContainer(props) {
  var className = props.className,
      _props$isCollapsible = props.isCollapsible,
      isCollapsible = _props$isCollapsible === void 0 ? true : _props$isCollapsible,
      children = props.children,
      _props$defaultLevel = props.defaultLevel,
      defaultLevel = _props$defaultLevel === void 0 ? 0 : _props$defaultLevel,
      onCollapse = props.onCollapse,
      _props$isScrollbar = props.isScrollbar,
      isScrollbar = _props$isScrollbar === void 0 ? true : _props$isScrollbar,
      width = props.width,
      left = props.left,
      bottom = props.bottom,
      top = props.top,
      isToolbar = props.isToolbar;

  var _useWindowSize = useWindowSize(),
      _useWindowSize2 = _slicedToArray(_useWindowSize, 2),
      originalWidth = _useWindowSize2[0],
      originalHeight = _useWindowSize2[1];

  var _useState = React.useState(originalHeight * levels[defaultLevel] / 100),
      _useState2 = _slicedToArray(_useState, 2),
      size = _useState2[0],
      setSize = _useState2[1];

  var _useState3 = React.useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      pointDown = _useState4[0],
      setPointDown = _useState4[1];

  var _useState5 = React.useState(false),
      _useState6 = _slicedToArray(_useState5, 2),
      active = _useState6[0],
      setActive = _useState6[1];

  var _useState7 = React.useState(-1),
      _useState8 = _slicedToArray(_useState7, 2),
      level = _useState8[0],
      setLevel = _useState8[1];

  var _useState9 = React.useState(originalWidth < 576),
      _useState10 = _slicedToArray(_useState9, 2),
      mobileDisplay = _useState10[0],
      setMobileDisplay = _useState10[1];

  var containerRef = React.useRef(null);
  var scrollRef = React.useRef(null);
  var timeoutRef = React.useRef(null);
  var prevSizeRef = React.useRef(size);
  var holdTimeStartRef = React.useRef(0);
  var downLevelRef = React.useRef(true);
  var startRef = React.useRef(0);
  React.useLayoutEffect(function () {
    if (originalWidth < 576 && !mobileDisplay) {
      setMobileDisplay(mobileDisplay);
    } else if (originalWidth >= 576 && mobileDisplay) {
      setMobileDisplay(!mobileDisplay);
    }
  }, [originalWidth]);
  React.useLayoutEffect(function () {
    setSize(originalHeight * levels[defaultLevel] / 100);
  }, [originalHeight]);
  React.useLayoutEffect(function () {
    if (level >= 0) {
      onCollapse && onCollapse(level);
    }
  }, [level]);
  React.useLayoutEffect(function () {
    if (size !== originalHeight * levels[defaultLevel] / 100) {
      setSize(originalHeight * levels[defaultLevel] / 100);
      setLevel(defaultLevel);
    }
  }, [defaultLevel]);
  React.useLayoutEffect(function () {
    if (containerRef.current) {
      if (containerRef.current.style.height !== "".concat(size, "px")) {
        containerRef.current.style.height = "".concat(size, "px");
      }

      if (size === originalHeight) {
        handleScroll(true);
        containerRef.current.style.borderRadius = 'unset';
        return;
      } else if (containerRef.current.style.borderRadius !== '') {
        containerRef.current.style.borderRadius = '';
      }

      handleScroll(false);
    }
  }, [size]);
  React.useLayoutEffect(function () {
    return function () {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  var handleActive = function handleActive(bool) {
    if (bool) {
      setTimeout(function () {
        return setActive(bool);
      }, 290);
      return;
    }

    setActive(bool);
  };

  var handleStartMove = function handleStartMove(e) {
    setPointDown(true);
    startRef.current = e.clientY;
    prevSizeRef.current = size;
    holdTimeStartRef.current = new Date().getTime();
  };

  var handleMove = function handleMove(e) {
    var delta = e.clientY - startRef.current;

    if (size === originalHeight) {
      startRef.current = e.clientY;

      if (delta < 0) {
        if (prevSizeRef.current !== size) {
          prevSizeRef.current = size;
        }

        return;
      }
    }

    var curSize = Math.round(prevSizeRef.current - delta);

    if (curSize > originalHeight) {
      if (size !== originalHeight) {
        setSize(originalHeight);
      }

      return;
    }

    if (delta > 0 && !downLevelRef.current || delta === 0) {
      return;
    }

    setSize(curSize);
  };

  var handleEndMove = function handleEndMove(e) {
    setPointDown(false);

    if (!downLevelRef.current) {
      return;
    }

    var delta = e.clientY - startRef.current;
    var holdTime = new Date().getTime() - holdTimeStartRef.current;
    var speed = Math.abs(delta / holdTime);

    if (speed > SPEED_PER_SECOND) {
      var curPer = delta > 0 ? levels[levels.length - 1] : levels[0];

      var _level = levels.indexOf(curPer);

      setLevel(_level);
      setSize(originalHeight * curPer / 100);
      return;
    }

    var closestPer = levels.reduce(function (prev, cur) {
      return Math.abs(originalHeight * prev / 100 - size) > Math.abs(originalHeight * cur / 100 - size) ? cur : prev;
    });
    var level = levels.indexOf(closestPer);
    setLevel(level);
    setSize(originalHeight * closestPer / 100);
  };

  var onScroll = function onScroll(element) {
    if (element.scrollTop === 0) {
      if (!downLevelRef.current) {
        setTimeout(function () {
          return downLevelRef.current = true;
        }, timeout);
      }

      return;
    }

    if (downLevelRef.current) {
      downLevelRef.current = false;
    }
  };

  var handleScroll = function handleScroll(bool) {
    if (!scrollRef.current) {
      return;
    }

    if (!bool) {
      if (scrollRef.current.style.flex !== 'none') {
        scrollRef.current.style.flex = 'none';
      }

      return;
    }

    if (scrollRef.current.style.flex !== '1 1 0%') {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      timeoutRef.current = setTimeout(function () {
        if (scrollRef.current) {
          scrollRef.current.style.flex = '1';
        }
      }, 300);
    }
  };

  var content = function content() {
    handleActive(true);
    return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
      children: /*#__PURE__*/jsxRuntime.jsx(Col2, {
        className: "collapsible__body",
        children: mobileDisplay ? /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
          children: [isCollapsible && /*#__PURE__*/jsxRuntime.jsx("div", {
            className: "mb-dragger",
            children: /*#__PURE__*/jsxRuntime.jsx("div", {
              className: "mb-dragger__inner"
            })
          }), isScrollbar ? /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
            containerRef: function containerRef(ref) {
              return scrollRef.current = ref;
            },
            options: {
              suppressScrollX: true
            },
            className: "collapsible__body--scroll",
            onScrollY: onScroll,
            children: active && children
          }) : /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
            children: active && children
          })]
        }) : isScrollbar ? /*#__PURE__*/jsxRuntime.jsx(ScrollView, {
          children: active && children
        }) : /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
          children: active && children
        })
      })
    });
  };

  var renderContent = React.useMemo(function () {
    return content();
  }, [children, isCollapsible, active]);
  var classes = clsx__default['default']('collapsible-container', isCollapsible && !pointDown && 'collapsible-active', className, isToolbar && 'collapsible-toolbar');
  return /*#__PURE__*/jsxRuntime.jsx("div", _objectSpread2(_objectSpread2({
    ref: containerRef,
    className: classes,
    style: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, width && {
      width: width
    }), left && {
      left: left
    }), bottom && {
      paddingBottom: bottom
    }), {}, {
      maxWidth: left ? "calc(100% - ".concat(left, ") ") : '100%',
      maxHeight: top ? "calc(100% - ".concat(top, ") ") : '100%'
    })
  }, isCollapsible ? {
    onPointerDown: handleStartMove,
    onPointerMove: handleMove,
    onPointerUp: handleEndMove
  } : {}), {}, {
    children: renderContent
  }));
};

var QueryBuilderRule = /*#__PURE__*/function (_Component) {
  _inherits(QueryBuilderRule, _Component);

  var _super = _createSuper(QueryBuilderRule);

  function QueryBuilderRule() {
    var _this;

    _classCallCheck(this, QueryBuilderRule);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      property: '',
      operator: null,
      value: '',
      props: _this.props.props,
      operators: []
    });

    _defineProperty$1(_assertThisInitialized(_this), "handlePropertyChanged", function (property) {
      _this.setState({
        property: property,
        operators: _this.getOperators(property)
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleOperatorChanged", function (operator) {
      _this.setState({
        operator: operator
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleValueChange", function (value) {
      _this.setState({
        value: value
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "queryFormStatus", function () {
      return {
        property: _this.state.property,
        operator: _this.state.operator,
        value: _this.state.value
      };
    });

    _defineProperty$1(_assertThisInitialized(_this), "getOperators", function (property) {
      var propSelected = _this.props.props.find(function (x) {
        return x.ColumnName === property;
      });

      if (propSelected) {
        if (propSelected.DataType === 1 || propSelected.DataType === 2 || propSelected.DataType === 4) {
          return [{
            id: 2,
            label: '='
          }, {
            id: 3,
            label: '>'
          }, {
            id: 4,
            label: '<'
          }, {
            id: 5,
            label: '>='
          }, {
            id: 6,
            label: '<='
          }];
        } else if (propSelected.DataType === 3 || propSelected.DataType === 6 || propSelected.DataType === 8) {
          return [{
            id: 0,
            label: 'Bằng'
          }, {
            id: 1,
            label: 'Giống'
          }];
        }
      }

      return [];
    });

    return _this;
  }

  _createClass(QueryBuilderRule, [{
    key: "fillRuleStatus",
    value: function fillRuleStatus(data, props) {
      this.setState({
        props: props,
        property: data.property,
        operator: data.operator,
        value: data.value,
        operators: this.getOperators(data.property)
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      return /*#__PURE__*/jsxRuntime.jsxs(FormGroup, {
        className: 'qr-rule',
        direction: 'row',
        children: [/*#__PURE__*/jsxRuntime.jsx(FormControlLabel, {
          control: /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
            width: "200px",
            value: this.state.property,
            options: this.props.props.map(function (item) {
              return {
                id: item.ColumnName,
                label: item.DisplayName
              };
            }),
            placeholder: 'Chọn thuộc tính',
            onChange: function onChange(event) {
              return _this2.handlePropertyChanged(event);
            }
          })
        }), /*#__PURE__*/jsxRuntime.jsx(FormControlLabel, {
          control: /*#__PURE__*/jsxRuntime.jsx(AdvanceSelect, {
            width: "200px",
            value: this.state.operator,
            options: this.state.operators,
            placeholder: 'Chọn toán tử',
            onChange: function onChange(event) {
              return _this2.handleOperatorChanged(event);
            }
          })
        }), /*#__PURE__*/jsxRuntime.jsx(FormControlLabel, {
          className: 'qr-rule-value',
          control: /*#__PURE__*/jsxRuntime.jsx(Input, {
            placeholder: 'Giá trị',
            autoComplete: "off",
            spellCheck: "false",
            value: this.state.value,
            onChange: this.handleValueChange
          })
        }), /*#__PURE__*/jsxRuntime.jsx("div", {
          className: 'qr-rule-actions',
          children: /*#__PURE__*/jsxRuntime.jsx(Button, {
            color: 'danger',
            icon: 'trash-alt',
            text: 'Xóa',
            onClick: this.props.deleteRule
          })
        })]
      });
    }
  }]);

  return QueryBuilderRule;
}(React.Component);

QueryBuilderRule.propTypes = {
  ruleID: PropTypes__default['default'].string,
  options: PropTypes__default['default'].object,
  onClick: PropTypes__default['default'].func,
  deleteRule: PropTypes__default['default'].func
};
QueryBuilderRule.defaultProps = {
  ruleID: '',
  onClick: function onClick() {},
  deleteRule: function deleteRule() {},
  options: {}
};

var QueryBuilderGroup = /*#__PURE__*/function (_Component) {
  _inherits(QueryBuilderGroup, _Component);

  var _super = _createSuper(QueryBuilderGroup);

  function QueryBuilderGroup() {
    var _this;

    _classCallCheck(this, QueryBuilderGroup);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized(_this), "ruleRefs", []);

    _defineProperty$1(_assertThisInitialized(_this), "groupRefs", []);

    _defineProperty$1(_assertThisInitialized(_this), "state", {
      no: false,
      condition: 'AND',
      groups: [],
      rules: [],
      queryDataChild: {}
    });

    _defineProperty$1(_assertThisInitialized(_this), "clickCondition", function (value) {
      _this.setState({
        condition: value
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "clickNo", function () {
      _this.setState({
        no: !_this.state.no
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "addRule", function () {
      var id = {
        idRandom: CommonHelper.uuid()
      };
      var rulesTemp = [].concat(_toConsumableArray(_this.state.rules), [id]);

      _this.setState({
        rules: rulesTemp
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "addGroup", function () {
      var id = {
        idRandom: CommonHelper.uuid()
      };
      var groupsTemp = [].concat(_toConsumableArray(_this.state.groups), [id]);

      _this.setState({
        groups: groupsTemp
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "deleteSelf", function () {
      _this.props.deleteGroup();
    });

    _defineProperty$1(_assertThisInitialized(_this), "deleteRule", function (idRandom) {
      _this.ruleRefs = _this.ruleRefs.filter(function (x) {
        return x !== null;
      });
      _this.ruleRefs = _this.ruleRefs.filter(function (x) {
        return x.props.ruleID !== idRandom;
      });

      _this.setState({
        rules: _this.state.rules.filter(function (x) {
          return x.idRandom !== idRandom;
        })
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "deleteGroup", function (idRandom) {
      _this.groupRefs = _this.groupRefs.filter(function (x) {
        return x !== null;
      });
      _this.groupRefs = _this.groupRefs.filter(function (x) {
        return x.props.idGroup !== idRandom;
      });

      _this.setState({
        groups: _this.state.groups.filter(function (x) {
          return x.idRandom !== idRandom;
        })
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "setRuleRef", function (ref) {
      _this.ruleRefs.push(ref);
    });

    _defineProperty$1(_assertThisInitialized(_this), "setGroupRef", function (ref) {
      _this.groupRefs.push(ref);
    });

    _defineProperty$1(_assertThisInitialized(_this), "fillFormStatus", function (data) {
      if (data.condition && data.layer) {
        (function () {
          var _this$layerSvc;

          _this.setState({
            no: data.no,
            condition: data.condition
          });

          var rs = (_this$layerSvc = _this.layerSvc) === null || _this$layerSvc === void 0 ? void 0 : _this$layerSvc.getLayerProps(data.layer);
          var props = [];

          if (rs.data) {
            props = rs.data.Properties;
          }

          var _loop = function _loop(i) {
            if (data.rules[i].condition) {
              process.nextTick(function () {
                _this.setState({
                  groups: [].concat(_toConsumableArray(_this.state.groups), [data.rules[i]]),
                  queryDataChild: data.rules[i]
                });
              });
            } else {
              process.nextTick(function () {
                _this.setState({
                  rules: [].concat(_toConsumableArray(_this.state.rules), [data.rules[i]])
                });

                var refRule = _this.ruleRefs[_this.ruleRefs.length - 1];
                refRule.fillRuleStatus(data.rules[i], props);
              });
            }
          };

          for (var i = 0; i < data.rules.length; i++) {
            _loop(i);
          }
        })();
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "queryFormStatus", function () {
      _this.ruleRefs = _this.ruleRefs.filter(function (x) {
        return x !== null;
      });
      _this.groupRefs = _this.groupRefs.filter(function (x) {
        return x !== null;
      });
      var query = {};
      var rules = _this.ruleRefs || {};
      var groups = _this.groupRefs || {};
      var i, j;
      query['no'] = _this.state.no;
      query['condition'] = _this.state.condition;
      query['rules'] = [];
      query['layer'] = _this.props.layer;

      for (i = 0; i < rules.length; i++) {
        query.rules.push(rules[i].queryFormStatus());
      }

      for (j = 0; j < groups.length; j++) {
        query.rules[query.rules.length] = groups[j].queryFormStatus();
      }

      return query;
    });

    return _this;
  }

  _createClass(QueryBuilderGroup, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.fillFormStatus(this.props.queryData);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var rulesJsx = this.state.rules.map(function (c, index) {
        return /*#__PURE__*/jsxRuntime.jsx(QueryBuilderRule, {
          ref: _this2.setRuleRef,
          ruleID: c.idRandom,
          options: _this2.props.options,
          props: _this2.props.props,
          deleteRule: function deleteRule() {
            return _this2.deleteRule(c.idRandom);
          }
        }, index);
      });
      var groupsJsx = this.state.groups.map(function (c) {
        return /*#__PURE__*/jsxRuntime.jsx("div", {
          className: 'qr-rule',
          children: /*#__PURE__*/jsxRuntime.jsx(QueryBuilderGroup, {
            ref: _this2.setGroupRef,
            queryData: _this2.state.queryDataChild,
            idGroup: c.idRandom,
            options: _this2.props.options,
            layer: _this2.props.layer,
            props: _this2.props.props,
            isFirst: false,
            deleteGroup: function deleteGroup() {
              return _this2.deleteGroup(c.idRandom);
            }
          })
        }, c.idRandom);
      });
      return /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "qr-group ".concat(this.props.isFirst ? 'qr-group-root' : ''),
        children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
          className: 'qr-group-header',
          children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
            className: 'qr-group-operator',
            children: [/*#__PURE__*/jsxRuntime.jsx(CheckBox, {
              label: "Kh\xF4ng",
              checked: this.state.no,
              onChange: this.clickNo
            }), /*#__PURE__*/jsxRuntime.jsx(Radio, {
              label: "V\xE0",
              checked: this.state.condition === 'AND',
              onChange: function onChange() {
                return _this2.clickCondition('AND');
              }
            }), /*#__PURE__*/jsxRuntime.jsx(Radio, {
              label: "Ho\u1EB7c",
              checked: this.state.condition === 'OR',
              onChange: function onChange() {
                return _this2.clickCondition('OR');
              }
            })]
          }), /*#__PURE__*/jsxRuntime.jsx("div", {
            className: 'qr-group-expander'
          }), /*#__PURE__*/jsxRuntime.jsxs("div", {
            className: 'qr-group-actions',
            children: [/*#__PURE__*/jsxRuntime.jsx(Button, {
              icon: 'plus',
              text: 'Thêm điều kiện',
              onClick: this.addRule
            }), /*#__PURE__*/jsxRuntime.jsx(Button, {
              icon: 'plus',
              text: 'Thêm nhóm',
              onClick: this.addGroup
            }), !this.props.isFirst && /*#__PURE__*/jsxRuntime.jsx(Button, {
              icon: 'trash-alt',
              text: 'Xóa',
              onClick: this.deleteSelf
            })]
          })]
        }), rulesJsx, groupsJsx]
      });
    }
  }]);

  return QueryBuilderGroup;
}(React.Component);

QueryBuilderGroup.propTypes = {
  layerData: PropTypes__default['default'].array,
  idGroup: PropTypes__default['default'].string,
  queryData: PropTypes__default['default'].object,
  isFirst: PropTypes__default['default'].bool,
  deleteGroup: PropTypes__default['default'].func,
  deleteRule: PropTypes__default['default'].func,

  /**
   * Array of property objects. Property object format: { ColumnName: "", DisplayName: ""}
   */
  props: PropTypes__default['default'].array.isRequired
};
QueryBuilderGroup.defaultProps = {
  layerData: [],
  idGroup: '',
  isFirst: true,
  deleteGroup: function deleteGroup() {},
  deleteRule: function deleteRule() {}
};

var ToolBarToggleButton = /*#__PURE__*/function (_Component) {
  _inherits(ToolBarToggleButton, _Component);

  var _super = _createSuper(ToolBarToggleButton);

  function ToolBarToggleButton() {
    _classCallCheck(this, ToolBarToggleButton);

    return _super.apply(this, arguments);
  }

  _createClass(ToolBarToggleButton, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "tgb-container ".concat(this.props.active ? 'active' : '', " ").concat(this.props.disabled ? 'disabled' : ''),
        onClick: this.props.disabled ? function () {} : this.props.onClick,
        children: /*#__PURE__*/jsxRuntime.jsx("span", {
          className: "tgb-button",
          children: /*#__PURE__*/jsxRuntime.jsx("i", {
            className: "tgb-icon ".concat(this.props.icon)
          })
        })
      });
    }
  }]);

  return ToolBarToggleButton;
}(React.Component);
ToolBarToggleButton.propTypes = {
  className: PropTypes__default['default'].string,
  disabled: PropTypes__default['default'].bool
};
ToolBarToggleButton.defaultProps = {
  className: '',
  disabled: false
};
var ToolBarToggleButtonGroup = /*#__PURE__*/function (_Component2) {
  _inherits(ToolBarToggleButtonGroup, _Component2);

  var _super2 = _createSuper(ToolBarToggleButtonGroup);

  function ToolBarToggleButtonGroup() {
    _classCallCheck(this, ToolBarToggleButtonGroup);

    return _super2.apply(this, arguments);
  }

  _createClass(ToolBarToggleButtonGroup, [{
    key: "render",
    value: function render() {
      var _this = this;

      var children = React__default['default'].Children.map(this.props.children, function (child) {
        return /*#__PURE__*/React__default['default'].cloneElement(child, {
          disabled: _this.props.disabled
        });
      });
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "tgb-group ".concat(this.props.disabled ? 'disable' : ''),
        children: children
      });
    }
  }]);

  return ToolBarToggleButtonGroup;
}(React.Component);
ToolBarToggleButtonGroup.propTypes = {
  className: PropTypes__default['default'].string,
  disabled: PropTypes__default['default'].bool
};
ToolBarToggleButtonGroup.defaultProps = {
  className: '',
  disabled: false
};

var FAIcons = /*#__PURE__*/function (_Component) {
  _inherits(FAIcons, _Component);

  var _super = _createSuper(FAIcons);

  function FAIcons() {
    _classCallCheck(this, FAIcons);

    return _super.apply(this, arguments);
  }

  _createClass(FAIcons, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/jsxRuntime.jsx(Container, {
        className: "icon-list ".concat(this.props.className),
        style: {
          display: 'flex'
        },
        children: this.props.children
      });
    }
  }]);

  return FAIcons;
}(React.Component);
FAIcons.propTypes = {
  /** Class of Icon */
  className: PropTypes__default['default'].string
};
FAIcons.defaultProps = {
  className: ''
};

var SwitchButton = function SwitchButton(props) {
  var onChange = props.onChange,
      checked = props.checked,
      disabled = props.disabled,
      title = props.title;

  var _useState = React.useState(checked),
      _useState2 = _slicedToArray(_useState, 2),
      check = _useState2[0],
      setCheck = _useState2[1];

  React.useEffect(function () {
    setCheck(checked);
  }, [checked]);

  var onSwitchChange = function onSwitchChange() {
    var newValue = !check;
    setCheck(newValue);
    onChange(newValue);
  };

  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: "bar-content",
    children: [/*#__PURE__*/jsxRuntime.jsx(Switch__default['default'], {
      checked: check,
      uncheckedIcon: false,
      checkedIcon: false,
      width: 28,
      height: 14,
      activeBoxShadow: "none",
      disabled: disabled !== null && disabled !== void 0 ? disabled : false,
      className: 'switch-toggle ' + (check === true ? 'active' : 'disable'),
      onChange: onSwitchChange
    }), title && /*#__PURE__*/jsxRuntime.jsx("h3", {
      className: 'bar-title',
      children: /*#__PURE__*/jsxRuntime.jsx(T, {
        children: title
      })
    })]
  });
};
SwitchButton.propTypes = {
  onChange: PropTypes__default['default'].func,
  checked: PropTypes__default['default'].bool,
  disabled: PropTypes__default['default'].bool,
  title: PropTypes__default['default'].string
};

var Step = function Step(props) {
  var _props$status = props.status,
      status = _props$status === void 0 ? 'wait' : _props$status,
      _props$index = props.index,
      index = _props$index === void 0 ? 0 : _props$index,
      _props$size = props.size,
      size = _props$size === void 0 ? 'default' : _props$size,
      _props$typeIcon = props.typeIcon,
      typeIcon = _props$typeIcon === void 0 ? 'regular' : _props$typeIcon;
  var title = props.title,
      subTitle = props.subTitle,
      icon = props.icon,
      description = props.description,
      onClick = props.onClick,
      clickable = props.clickable,
      dot = props.dot,
      spinIcon = props.spinIcon,
      disabled = props.disabled;
  var classes = clsx__default['default']('stepper-item', "stepper-item--".concat(status), disabled && 'stepper-item--disabled');

  var handleClick = function handleClick() {
    return onClick && onClick(index);
  };

  var canClick = clickable && status === 'wait';
  var stepContent = index + 1;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: classes,
    children: /*#__PURE__*/jsxRuntime.jsxs("div", {
      role: canClick ? 'button' : undefined,
      tabIndex: canClick ? 0 : undefined,
      className: "stepper-item__container",
      onClick: canClick ? handleClick : undefined,
      children: [/*#__PURE__*/jsxRuntime.jsx("div", {
        className: "stepper-item__tail"
      }), /*#__PURE__*/jsxRuntime.jsx("div", {
        className: clsx__default['default']('stepper-item__icon', icon && 'stepper-item__icon-custom'),
        children: dot ? /*#__PURE__*/jsxRuntime.jsx("span", {
          className: "stepper-item__dot"
        }) : icon ? /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          icon: icon,
          size: "".concat(size === 'small' ? '0.875rem' : '1rem'),
          spin: spinIcon,
          type: typeIcon
        }) : status === 'finish' ? /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          icon: "check",
          size: "".concat(size === 'small' ? '0.875rem' : '1rem')
        }) : status === 'error' ? /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
          icon: "times",
          size: "".concat(size === 'small' ? '0.875rem' : '1rem'),
          type: "light"
        }) : stepContent
      }), /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: "stepper-item__content",
        children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
          className: "stepper-item__title",
          children: [title, subTitle && /*#__PURE__*/jsxRuntime.jsx("div", {
            className: "stepper-item__subtitle",
            children: subTitle
          })]
        }), description && /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "stepper-item__description",
          children: description
        })]
      })]
    })
  });
};

var Stepper = function Stepper(props) {
  var _props$direction = props.direction,
      direction = _props$direction === void 0 ? 'horizontal' : _props$direction,
      _props$labelPlacement = props.labelPlacement,
      labelPlacement = _props$labelPlacement === void 0 ? 'horizontal' : _props$labelPlacement,
      _props$size = props.size,
      size = _props$size === void 0 ? 'default' : _props$size,
      _props$type = props.type,
      type = _props$type === void 0 ? 'default' : _props$type;
  var className = props.className,
      current = props.current,
      onChange = props.onChange,
      children = props.children,
      progressDot = props.progressDot;

  var _useWindowSize = useWindowSize(),
      _useWindowSize2 = _slicedToArray(_useWindowSize, 1),
      width = _useWindowSize2[0];

  var handleChange = function handleChange(index) {
    return onChange && onChange(index);
  };

  var classes = clsx__default['default'](className, 'stepper__container', width <= 576 ? 'stepper__container--vertical' : "stepper__container--".concat(direction), (labelPlacement === 'vertical' && !progressDot && direction !== 'vertical' || progressDot && direction !== 'vertical') && 'stepper__container__label--vertical', size === 'small' && 'stepper__container--small', progressDot && 'stepper__container--dot', type === 'navigation' && 'stepper-navigation');

  var injectStepProps = function injectStepProps(child, index) {
    var status = current !== undefined ? detectStepStatus(current, index) : current;

    var injectProps = _objectSpread2({
      index: index,
      size: size,
      dot: progressDot,
      onClick: handleChange,
      clickable: !!onChange
    }, status ? {
      status: status
    } : {});

    return isStepComponent(child) ? /*#__PURE__*/React__default['default'].cloneElement(child, injectProps) : child;
  };

  var detectStepStatus = function detectStepStatus(currentIndex, index) {
    return currentIndex > index ? 'finish' : currentIndex === index ? 'current' : undefined;
  };

  var isStepComponent = function isStepComponent(element) {
    return /*#__PURE__*/React__default['default'].isValidElement(element) && element.type === Step;
  };

  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: classes,
    children: React__default['default'].Children.map(children, injectStepProps)
  });
};

exports.ChartType = void 0;

(function (ChartType) {
  ChartType[ChartType["Line"] = 0] = "Line";
  ChartType[ChartType["Doughnut"] = 1] = "Doughnut";
  ChartType[ChartType["Bar"] = 2] = "Bar";
  ChartType[ChartType["Scatter"] = 3] = "Scatter";
  ChartType[ChartType["Pie"] = 4] = "Pie";
  ChartType[ChartType["Polar"] = 5] = "Polar";
  ChartType[ChartType["Radar"] = 6] = "Radar";
})(exports.ChartType || (exports.ChartType = {}));

var Chart = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var data = props.data,
      options = props.options,
      chartType = props.chartType,
      width = props.width,
      height = props.height,
      className = props.className,
      plugins = props.plugins;

  switch (chartType) {
    case exports.ChartType.Doughnut:
      return /*#__PURE__*/jsxRuntime.jsx(reactChartjs2.Doughnut, {
        ref: ref,
        className: className,
        width: width,
        height: height,
        data: data,
        options: options,
        plugins: [_objectSpread2(_objectSpread2({}, ChartDataLabels__default['default']), plugins)]
      });

    case exports.ChartType.Line:
      return /*#__PURE__*/jsxRuntime.jsx(reactChartjs2.Line, {
        ref: ref,
        className: className,
        width: width,
        height: height,
        data: data,
        options: options,
        plugins: [_objectSpread2(_objectSpread2({}, ChartDataLabels__default['default']), plugins)]
      });

    case exports.ChartType.Bar:
      return /*#__PURE__*/jsxRuntime.jsx(reactChartjs2.Bar, {
        ref: ref,
        className: className,
        width: width,
        height: height,
        data: data,
        options: options,
        plugins: [_objectSpread2(_objectSpread2({}, ChartDataLabels__default['default']), plugins)]
      });

    case exports.ChartType.Scatter:
      return /*#__PURE__*/jsxRuntime.jsx(reactChartjs2.Scatter, {
        ref: ref,
        className: className,
        width: width,
        height: height,
        data: data,
        options: options,
        plugins: [_objectSpread2(_objectSpread2({}, ChartDataLabels__default['default']), plugins)]
      });

    case exports.ChartType.Pie:
      return /*#__PURE__*/jsxRuntime.jsx(reactChartjs2.Pie, {
        ref: ref,
        className: className,
        width: width,
        height: height,
        data: data,
        options: options,
        plugins: [_objectSpread2(_objectSpread2({}, ChartDataLabels__default['default']), plugins)]
      });

    case exports.ChartType.Polar:
      return /*#__PURE__*/jsxRuntime.jsx(reactChartjs2.PolarArea, {
        ref: ref,
        className: className,
        width: width,
        height: height,
        data: data,
        options: options,
        plugins: [_objectSpread2(_objectSpread2({}, ChartDataLabels__default['default']), plugins)]
      });

    case exports.ChartType.Radar:
      return /*#__PURE__*/jsxRuntime.jsx(reactChartjs2.Radar, {
        ref: ref,
        className: className,
        width: width,
        height: height,
        data: data,
        options: options,
        plugins: [_objectSpread2(_objectSpread2({}, ChartDataLabels__default['default']), plugins)]
      });

    default:
      return null;
  }
});
Chart.displayName = 'Chart';

var DraggableItem = function DraggableItem(props) {
  var data = props.data,
      children = props.children;

  var _useDrag = reactDnd.useDrag({
    item: {
      type: DND_TYPE,
      data: data
    },
    collect: function collect(monitor) {
      return {
        opacity: monitor.isDragging() ? 0 : 1
      };
    }
  }),
      _useDrag2 = _slicedToArray(_useDrag, 2),
      opacity = _useDrag2[0].opacity,
      drag = _useDrag2[1];

  return /*#__PURE__*/jsxRuntime.jsx("div", {
    ref: drag,
    className: "draggable-item",
    style: {
      opacity: opacity
    },
    children: children
  });
};

var Zone = function Zone(props) {
  var accept = props.accept,
      template = props.template,
      lineSizes = props.lineSizes,
      data = props.data,
      uniqueId = props.uniqueId,
      index = props.index,
      onDrop = props.onDrop,
      itemDisplay = props.itemDisplay;
  var dropEl = React.useRef(null);
  var screenEl = React.useRef(null);
  var direction = React.useRef();

  var _useDrop = reactDnd.useDrop({
    accept: [DND_TYPE].concat(_toConsumableArray(accept || [])),
    collect: function collect(monitor) {
      return {
        isOver: monitor.isOver()
      };
    },
    drop: function drop(droppedResult) {
      direction.current && onDrop(droppedResult, uniqueId, direction.current);
      return {
        name: 'Drop Place'
      };
    },
    hover: function hover(item, monitor) {
      var position = monitor.getClientOffset();

      if (!dropEl.current || !position || !screenEl.current || !template) {
        return;
      }

      var x = position.x,
          y = position.y;

      var _dropEl$current$getBo = dropEl.current.getBoundingClientRect(),
          top = _dropEl$current$getBo.top,
          left = _dropEl$current$getBo.left,
          bottom = _dropEl$current$getBo.bottom,
          right = _dropEl$current$getBo.right,
          width = _dropEl$current$getBo.width,
          height = _dropEl$current$getBo.height;

      var onePartX = width / 3;
      var onePartY = height / 3;

      if (x <= left + onePartX && x >= left) {
        var colStart = template.colStart,
            colSpan = template.colSpan;
        var cols = lineSizes.columns;

        var _index = colStart - 1;

        var size = cols[_index] / (colSpan === 1 ? 2 : 1); // left

        // left
        direction.current = 'left';
        screenEl.current.style.width = "".concat(size, "px");
        screenEl.current.style.height = "".concat(height, "px");
        screenEl.current.style.top = '0';
        screenEl.current.style.left = '0';
      } else if (x >= left + width - onePartX && x <= right) {
        var _colStart = template.colStart,
            _colSpan = template.colSpan;

        var _cols = lineSizes.columns.slice();

        var total = _cols.slice(_colStart - 1, _colStart + _colSpan - 1).reduce(function (result, next) {
          return result += next;
        });

        var _index2 = _colStart + _colSpan - 2;

        var _size = _cols[_index2] / (_colSpan === 1 ? 2 : 1); // right


        // right
        direction.current = 'right';
        screenEl.current.style.width = "".concat(_size, "px");
        screenEl.current.style.height = "".concat(height, "px");
        screenEl.current.style.top = '0';
        screenEl.current.style.left = "".concat(total - _size, "px");
      } else if (y <= top + onePartY && y >= top) {
        var rowStart = template.rowStart,
            rowSpan = template.rowSpan;
        var rows = lineSizes.rows;

        var _index3 = rowStart - 1;

        var _size2 = rows[_index3] / (rowSpan === 1 ? 2 : 1); // top


        // top
        direction.current = 'top';
        screenEl.current.style.width = "".concat(width, "px");
        screenEl.current.style.height = "".concat(_size2, "px");
        screenEl.current.style.top = '0';
        screenEl.current.style.left = '0';
      } else if (y >= top + height - onePartY && y <= bottom) {
        var _rowStart = template.rowStart,
            _rowSpan = template.rowSpan;
        var _rows = lineSizes.rows;

        var _total = _rows.slice(_rowStart - 1, _rowStart + _rowSpan - 1).reduce(function (result, next) {
          return result += next;
        });

        var _index4 = _rowStart + _rowSpan - 2;

        var _size3 = _rows[_index4] / (_rowSpan === 1 ? 2 : 1); // bottom


        // bottom
        direction.current = 'bottom';
        screenEl.current.style.width = "".concat(width, "px");
        screenEl.current.style.height = "".concat(_size3, "px");
        screenEl.current.style.top = "".concat(_total - _size3, "px");
        screenEl.current.style.left = '0';
      } else {
        // replace
        direction.current = 'replace';
        screenEl.current.style.width = "".concat(width, "px");
        screenEl.current.style.height = "".concat(height, "px");
        screenEl.current.style.top = '0';
        screenEl.current.style.left = '0';
      }
    }
  }),
      _useDrop2 = _slicedToArray(_useDrop, 2),
      isOver = _useDrop2[0].isOver,
      drop = _useDrop2[1];

  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    ref: function ref(node) {
      drop(node);
      dropEl.current = node;
    },
    id: uniqueId,
    className: "zone",
    children: [itemDisplay ? itemDisplay(data.value, index) : data.value, /*#__PURE__*/jsxRuntime.jsx("div", {
      ref: screenEl,
      className: clsx__default['default']('screen', isOver && 'over')
    })]
  });
};

var _excluded = ["id"],
    _excluded2 = ["id"];
var DroppableZones = function DroppableZones(props) {
  var accept = props.accept,
      data = props.data,
      itemDisplay = props.itemDisplay,
      onLayoutChange = props.onLayoutChange,
      onDataChange = props.onDataChange;

  var _useState = React.useState(function () {
    var initData = Array.isArray(data) && data ? data : [];
    return initData.map(function (item) {
      return {
        value: item,
        key: createUniqueId()
      };
    });
  }),
      _useState2 = _slicedToArray(_useState, 2),
      zones = _useState2[0],
      setZones = _useState2[1];

  var _useState3 = React.useState({
    rows: [],
    columns: []
  }),
      _useState4 = _slicedToArray(_useState3, 2),
      lineSizes = _useState4[0],
      setLineSizes = _useState4[1];

  var gridTemplate = React.useRef([{
    rowStart: 1,
    rowSpan: 1,
    colStart: 1,
    colSpan: 1,
    id: zones[0].key
  }]);
  var numOfItemPerRow = React.useRef(zones.length === 1 || zones.length === 2 ? zones.length : Math.ceil(Math.sqrt(zones.length)));
  React.useEffect(function () {
    return onLayoutChange && onLayoutChange(lineSizes, gridTemplate.current.map(function (_ref) {
      var id = _ref.id,
          t = _objectWithoutProperties(_ref, _excluded);

      return _objectSpread2(_objectSpread2({}, t), {}, {
        index: zones.findIndex(function (z) {
          return z.key === id;
        })
      });
    }), zones);
  }, [lineSizes, zones]);
  React.useEffect(function () {
    onDataChange && onDataChange(zones);
  }, [zones]);

  var handleDrop = function handleDrop(droppedItem, zoneId, direction) {
    var zonesClone = JSON.parse(JSON.stringify(zones));

    if (direction === 'replace') {
      var draggedIndex = zonesClone.findIndex(function (i) {
        return i.key === droppedItem.key;
      });
      var droppedIndex = zonesClone.findIndex(function (i) {
        return i.key === zoneId;
      });
      var droppedPlace = zonesClone[droppedIndex];

      var _item = draggedIndex >= 0 ? droppedItem : {
        value: droppedItem,
        key: createUniqueId()
      };

      zonesClone.splice(droppedIndex, 1, _item);
      draggedIndex >= 0 && zonesClone.splice(draggedIndex, 1, droppedPlace);
      JSON.stringify(zonesClone) !== JSON.stringify(zones) && setZones(zonesClone);
      return;
    }

    var item = {
      value: droppedItem,
      key: createUniqueId()
    };
    var newZones = handleTemplate(zonesClone, item, zoneId, direction);
    setZones(newZones);
  };

  var handleTemplate = function handleTemplate(list, item, zoneId, direction) {
    var dropAtIndex = list.findIndex(function (z) {
      return z.key === zoneId;
    });
    var dropAtTemplateIndex = gridTemplate.current.findIndex(function (t) {
      return t.id === zoneId;
    });

    if (dropAtTemplateIndex === -1 || dropAtIndex === -1) {
      return list;
    }

    var _gridTemplate$current = gridTemplate.current[dropAtTemplateIndex],
        rowStart = _gridTemplate$current.rowStart,
        rowSpan = _gridTemplate$current.rowSpan,
        colStart = _gridTemplate$current.colStart,
        colSpan = _gridTemplate$current.colSpan;

    if (direction === 'left') {
      if (colSpan === 1) {
        gridTemplate.current = gridTemplate.current.map(function (t) {
          var isPlusStart = t.colStart > colStart || t.colStart === colStart && t.rowStart === rowStart;

          if (isPlusStart) {
            return _objectSpread2(_objectSpread2({}, t), {}, {
              colStart: t.colStart + 1
            });
          }

          var isPlusSpan = t.colStart === colStart || t.colStart < colStart && t.colStart + t.colSpan > colStart;

          if (isPlusSpan) {
            return _objectSpread2(_objectSpread2({}, t), {}, {
              colSpan: t.colSpan + 1
            });
          }

          return t;
        });
        gridTemplate.current.push({
          rowStart: rowStart,
          rowSpan: rowSpan,
          colStart: colStart,
          colSpan: colSpan,
          id: item.key
        });
        var newColLineSizes = [];
        lineSizes.columns.map(function (size, index) {
          if (index === colStart - 1) {
            var s = size / 2;
            newColLineSizes.push(s, s);
            return;
          }

          newColLineSizes.push(size);
        });
        setLineSizes(function (prev) {
          return _objectSpread2(_objectSpread2({}, prev), {}, {
            columns: newColLineSizes
          });
        });
        numOfItemPerRow.current++;
      }

      if (colSpan > 1) {
        gridTemplate.current[dropAtTemplateIndex] = _objectSpread2(_objectSpread2({}, gridTemplate.current[dropAtTemplateIndex]), {}, {
          colStart: colStart + 1,
          colSpan: colSpan - 1
        });
        gridTemplate.current.push({
          rowStart: rowStart,
          rowSpan: rowSpan,
          colStart: colStart,
          colSpan: 1,
          id: item.key
        });
      }
    }

    if (direction === 'right') {
      if (colSpan === 1) {
        gridTemplate.current = gridTemplate.current.map(function (t) {
          var isPlusStart = t.colStart > colStart;

          if (isPlusStart) {
            return _objectSpread2(_objectSpread2({}, t), {}, {
              colStart: t.colStart + 1
            });
          }

          var isPlusSpan = t.colStart === colStart && t.rowStart !== rowStart || t.colStart < colStart && t.colStart + t.colSpan > colStart;

          if (isPlusSpan) {
            return _objectSpread2(_objectSpread2({}, t), {}, {
              colSpan: t.colSpan + 1
            });
          }

          return t;
        });
        gridTemplate.current.push({
          rowStart: rowStart,
          rowSpan: rowSpan,
          colStart: colStart + 1,
          colSpan: colSpan,
          id: item.key
        });
        var _newColLineSizes = [];
        lineSizes.columns.map(function (size, index) {
          if (index === colStart - 1) {
            var s = size / 2;

            _newColLineSizes.push(s, s);

            return;
          }

          _newColLineSizes.push(size);
        });
        setLineSizes(function (prev) {
          return _objectSpread2(_objectSpread2({}, prev), {}, {
            columns: _newColLineSizes
          });
        });
        numOfItemPerRow.current++;
      }

      if (colSpan > 1) {
        gridTemplate.current[dropAtTemplateIndex] = _objectSpread2(_objectSpread2({}, gridTemplate.current[dropAtTemplateIndex]), {}, {
          colSpan: colSpan - 1
        });
        gridTemplate.current.push({
          rowStart: rowStart,
          rowSpan: rowSpan,
          colStart: colStart + colSpan - 1,
          colSpan: 1,
          id: item.key
        });
      }
    }

    if (direction === 'top') {
      if (rowSpan === 1) {
        gridTemplate.current = gridTemplate.current.map(function (t) {
          var isPlusStart = t.rowStart > rowStart || t.rowStart === rowStart && t.colStart === colStart;

          if (isPlusStart) {
            return _objectSpread2(_objectSpread2({}, t), {}, {
              rowStart: t.rowStart + 1
            });
          }

          var isPlusSpan = t.rowStart === rowStart || t.rowStart < rowStart && t.rowStart + t.rowSpan > rowStart;

          if (isPlusSpan) {
            return _objectSpread2(_objectSpread2({}, t), {}, {
              rowSpan: t.rowSpan + 1
            });
          }

          return t;
        });
        gridTemplate.current.push({
          rowStart: rowStart,
          rowSpan: rowSpan,
          colStart: colStart,
          colSpan: colSpan,
          id: item.key
        });
        var newRowLineSizes = [];
        lineSizes.rows.map(function (size, index) {
          if (index === rowStart - 1) {
            var s = size / 2;
            newRowLineSizes.push(s, s);
            return;
          }

          newRowLineSizes.push(size);
        });
        setLineSizes(function (prev) {
          return _objectSpread2(_objectSpread2({}, prev), {}, {
            rows: newRowLineSizes
          });
        });
      }

      if (rowSpan > 1) {
        gridTemplate.current[dropAtTemplateIndex] = _objectSpread2(_objectSpread2({}, gridTemplate.current[dropAtTemplateIndex]), {}, {
          rowStart: rowStart + 1,
          rowSpan: rowSpan - 1
        });
        gridTemplate.current.push({
          rowStart: rowStart,
          rowSpan: 1,
          colStart: colStart,
          colSpan: colSpan,
          id: item.key
        });
      }
    }

    if (direction === 'bottom') {
      if (rowSpan === 1) {
        gridTemplate.current = gridTemplate.current.map(function (t) {
          var isPlusStart = t.rowStart > rowStart;

          if (isPlusStart) {
            return _objectSpread2(_objectSpread2({}, t), {}, {
              rowStart: t.rowStart + 1
            });
          }

          var isPlusSpan = t.rowStart === rowStart && t.colStart !== colStart || t.rowStart < rowStart && t.rowStart + t.rowSpan > rowStart;

          if (isPlusSpan) {
            return _objectSpread2(_objectSpread2({}, t), {}, {
              rowSpan: t.rowSpan + 1
            });
          }

          return t;
        });
        gridTemplate.current.push({
          rowStart: rowStart + 1,
          rowSpan: rowSpan,
          colStart: colStart,
          colSpan: colSpan,
          id: item.key
        });
        var _newRowLineSizes = [];
        lineSizes.rows.map(function (size, index) {
          if (index === rowStart - 1) {
            var s = size / 2;

            _newRowLineSizes.push(s, s);

            return;
          }

          _newRowLineSizes.push(size);
        });
        setLineSizes(function (prev) {
          return _objectSpread2(_objectSpread2({}, prev), {}, {
            rows: _newRowLineSizes
          });
        });
      }

      if (rowSpan > 1) {
        gridTemplate.current[dropAtTemplateIndex] = _objectSpread2(_objectSpread2({}, gridTemplate.current[dropAtTemplateIndex]), {}, {
          rowSpan: rowSpan - 1
        });
        gridTemplate.current.push({
          rowStart: rowStart + rowSpan - 1,
          rowSpan: 1,
          colStart: colStart,
          colSpan: colSpan,
          id: item.key
        });
      }
    }

    list.push(item);
    return list;
  };

  return /*#__PURE__*/jsxRuntime.jsx(ResizableGrid, {
    lineSizes: lineSizes,
    numOfItemPerLine: numOfItemPerRow.current,
    gridTemplates: gridTemplate.current.map(function (_ref2) {
      var id = _ref2.id,
          t = _objectWithoutProperties(_ref2, _excluded2);

      return _objectSpread2(_objectSpread2({}, t), {}, {
        index: zones.findIndex(function (z) {
          return z.key === id;
        })
      });
    }),
    onResizeEnd: function onResizeEnd(sizes) {
      return setLineSizes(sizes);
    },
    children: zones.map(function (item, index) {
      return /*#__PURE__*/jsxRuntime.jsx(Zone, {
        index: index,
        accept: accept,
        lineSizes: lineSizes,
        template: gridTemplate.current.find(function (t) {
          return t.id === item.key;
        }),
        data: item,
        uniqueId: item.key,
        itemDisplay: itemDisplay,
        onDrop: handleDrop
      }, item.key);
    })
  });
};

var DND_TYPE = 'DND_RESIZABLE';
var DnDResizable = function DnDResizable(props) {
  var children = props.children;
  return /*#__PURE__*/jsxRuntime.jsx(reactDnd.DndProvider, {
    backend: reactDndHtml5Backend.HTML5Backend,
    children: children({
      DraggableItem: DraggableItem,
      DroppableZones: DroppableZones
    })
  });
};

var Card = function Card(props) {
  var _tag$size;

  var title = props.title,
      description = props.description,
      icon = props.icon,
      _props$isDisabled = props.isDisabled,
      isDisabled = _props$isDisabled === void 0 ? false : _props$isDisabled,
      href = props.href,
      target = props.target,
      image = props.image,
      _props$imageWidth = props.imageWidth,
      imageWidth = _props$imageWidth === void 0 ? 150 : _props$imageWidth,
      _props$imageHeight = props.imageHeight,
      imageHeight = _props$imageHeight === void 0 ? 100 : _props$imageHeight,
      _props$layout = props.layout,
      layout = _props$layout === void 0 ? 'vertical' : _props$layout,
      footer = props.footer,
      children = props.children,
      className = props.className,
      _props$textAlign = props.textAlign,
      textAlign = _props$textAlign === void 0 ? 'left' : _props$textAlign,
      tag = props.tag,
      _props$hasShadow = props.hasShadow,
      hasShadow = _props$hasShadow === void 0 ? true : _props$hasShadow,
      onTitleClick = props.onTitleClick;
  var isHorizontal = layout === 'horizontal' || image && icon;
  var imageNode, iconNode, optionalCardTop, cardTitle;

  if (image && layout === 'vertical') {
    if ( /*#__PURE__*/React.isValidElement(image) || typeof image === 'string') {
      imageNode = /*#__PURE__*/jsxRuntime.jsx("div", {
        className: "vui-card__image",
        children: /*#__PURE__*/jsxRuntime.jsx(Ratio, {
          width: imageWidth,
          height: imageHeight,
          children: /*#__PURE__*/React.isValidElement(image) ? image : /*#__PURE__*/jsxRuntime.jsx("img", {
            src: image,
            alt: ""
          })
        })
      });
    } else {
      imageNode = null;
    }
  }

  if (icon) {
    iconNode = /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "vui-card__icon",
      children: typeof icon === 'string' ? /*#__PURE__*/jsxRuntime.jsx(vicon.FAIcon, {
        icon: icon
      }) : icon
    });
  }

  if (imageNode || iconNode) {
    optionalCardTop = /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "vui-card__top",
      children: imageNode ? imageNode : !isHorizontal && iconNode
    });
  }

  var titleRef = null;

  if (!isDisabled && href) {
    cardTitle = /*#__PURE__*/jsxRuntime.jsx(Link, {
      ref: function ref(_ref) {
        return titleRef = _ref;
      },
      className: "vui-card__title--link",
      href: href,
      target: target,
      onClick: onTitleClick,
      children: title
    });
  } else if (isDisabled || onTitleClick) {
    cardTitle = /*#__PURE__*/jsxRuntime.jsx("button", {
      ref: function ref(_ref2) {
        return titleRef = _ref2;
      },
      className: "vui-card__title--button",
      disabled: isDisabled,
      onClick: onTitleClick,
      children: title
    });
  } else {
    cardTitle = title;
  }

  var isClickable = !isDisabled && (onTitleClick || href);
  var classes = clsx__default['default']('vui-card', isDisabled && 'vui-card--isDisabled', "vui-card--".concat(textAlign, "Align"), isHorizontal && 'vui-card--horizontal', hasShadow && 'vui-card--hasShadow', isClickable && 'vui-card--isClickable', className);
  var ariaId = createUniqueId();

  var handleCardClick = function handleCardClick(e) {
    titleRef && titleRef !== e.target && titleRef.click();
  };

  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    id: "card".concat(ariaId),
    className: classes,
    onClick: isClickable ? handleCardClick : undefined,
    children: [optionalCardTop, /*#__PURE__*/jsxRuntime.jsxs(Row2, {
      className: "vui-card__content",
      gap: 4,
      children: [isHorizontal && iconNode, /*#__PURE__*/jsxRuntime.jsxs(Col2, {
        gap: 2,
        children: [/*#__PURE__*/jsxRuntime.jsx("div", {
          className: "vui-card__title",
          children: cardTitle
        }), description && /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "vui-card__description",
          children: /*#__PURE__*/jsxRuntime.jsx("p", {
            children: description
          })
        }), children && /*#__PURE__*/jsxRuntime.jsx("div", {
          className: "vui-card__children",
          children: children
        })]
      })]
    }), tag && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "vui-card__tag",
      children: tag.color ? /*#__PURE__*/jsxRuntime.jsx(Tag, {
        textCase: 'sentence',
        text: tag.label,
        color: tag.color,
        size: (_tag$size = tag.size) !== null && _tag$size !== void 0 ? _tag$size : 'medium',
        textStyle: {
          color: tag.textColor
        },
        isRound: true
      }) : /*#__PURE__*/jsxRuntime.jsx("div", {
        children: tag.label
      })
    }), layout === 'vertical' && footer && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: "vui-card__footer",
      children: footer
    })]
  });
};

var jsDiff = diff__namespace;
var DiffType = {
  DEFAULT: 0,
  ADDED: 1,
  REMOVED: 2
};
var DiffMethod = {
  CHARS: 'diffChars',
  WORDS: 'diffWords',
  WORDS_WITH_SPACE: 'diffWordsWithSpace',
  LINES: 'diffLines',
  TRIMMED_LINES: 'diffTrimmedLines',
  SENTENCES: 'diffSentences',
  CSS: 'diffCss'
};

/**
 * Splits diff text by new line and computes final list of diff lines based on
 * conditions.
 *
 * @param value Diff text from the js diff module.
 */
var constructLines = function constructLines(value) {
  var lines = value.split('\n');
  var isAllEmpty = lines.every(function (val) {
    return !val;
  });

  if (isAllEmpty) {
    // This is to avoid added an extra new line in the UI.
    if (lines.length === 2) {
      return [];
    }

    lines.pop();
    return lines;
  }

  var lastLine = lines[lines.length - 1];
  var firstLine = lines[0]; // Remove the first and last element if they are new line character. This is
  // to avoid addition of extra new line in the UI.

  if (!lastLine) {
    lines.pop();
  }

  if (!firstLine) {
    lines.shift();
  }

  return lines;
};
/**
 * Computes word diff information in the line.
 * [TODO]: Consider adding options argument for JsDiff text block comparison
 *
 * @param oldValue Old word in the line.
 * @param newValue New word in the line.
 * @param compareMethod JsDiff text diff method from https://github.com/kpdecker/jsdiff/tree/v4.0.1#api
 */


var computeDiff = function computeDiff(oldValue, newValue) {
  var compareMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DiffMethod.CHARS;
  var diffArray = jsDiff[compareMethod](oldValue, newValue);
  var computedDiff = {
    left: [],
    right: []
  };
  console.log(diffArray);
  diffArray.forEach(function (_ref) {
    var added = _ref.added,
        removed = _ref.removed,
        value = _ref.value;
    var diffInformation = {};

    if (added) {
      var _computedDiff$right;

      diffInformation.type = DiffType.ADDED;
      diffInformation.value = value;
      (_computedDiff$right = computedDiff.right) === null || _computedDiff$right === void 0 ? void 0 : _computedDiff$right.push(diffInformation);
    }

    if (removed) {
      var _computedDiff$left;

      diffInformation.type = DiffType.REMOVED;
      diffInformation.value = value;
      (_computedDiff$left = computedDiff.left) === null || _computedDiff$left === void 0 ? void 0 : _computedDiff$left.push(diffInformation);
    }

    if (!removed && !added) {
      var _computedDiff$right2, _computedDiff$left2;

      diffInformation.type = DiffType.DEFAULT;
      diffInformation.value = value;
      (_computedDiff$right2 = computedDiff.right) === null || _computedDiff$right2 === void 0 ? void 0 : _computedDiff$right2.push(diffInformation);
      (_computedDiff$left2 = computedDiff.left) === null || _computedDiff$left2 === void 0 ? void 0 : _computedDiff$left2.push(diffInformation);
    }

    return diffInformation;
  });
  return computedDiff;
};
/**
 * Computes line wise information based in the js diff information passed. Each
 * line contains information about left and right section. Left side denotes
 * deletion and right side denotes addition.
 *
 * @param oldString Old string to compare.
 * @param newString New string to compare with old string.
 * @param disableWordDiff Flag to enable/disable word diff.
 * @param compareMethod JsDiff text diff method from https://github.com/kpdecker/jsdiff/tree/v4.0.1#api
 * @param linesOffset line number to start counting from
 */


var computeLineInformation = function computeLineInformation(oldString, newString) {
  var disableWordDiff = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var compareMethod = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DiffMethod.CHARS;
  var linesOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var diffArray = diff__namespace.diffLines(oldString.trimRight(), newString.trimRight(), {
    newlineIsToken: true,
    ignoreWhitespace: false,
    ignoreCase: false
  });
  var rightLineNumber = linesOffset;
  var leftLineNumber = linesOffset;
  var lineInformation = [];
  var counter = 0;
  var diffLines = [];
  var ignoreDiffIndexes = [];

  var getLineInformation = function getLineInformation(value, diffIndex, added, removed, evaluateOnlyFirstLine) {
    var lines = constructLines(value);
    return lines.map(function (line, lineIndex) {
      var left = {};
      var right = {};

      if (ignoreDiffIndexes.includes("".concat(diffIndex, "-").concat(lineIndex)) || evaluateOnlyFirstLine && lineIndex !== 0) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        return undefined;
      }

      if (added || removed) {
        if (!diffLines.includes(counter)) {
          diffLines.push(counter);
        }

        if (removed) {
          leftLineNumber += 1;
          left.lineNumber = leftLineNumber;
          left.type = DiffType.REMOVED;
          left.value = line || ' '; // When the current line is of type REMOVED, check the next item in
          // the diff array whether it is of type ADDED. If true, the current
          // diff will be marked as both REMOVED and ADDED. Meaning, the
          // current line is a modification.

          var nextDiff = diffArray[diffIndex + 1];

          if (nextDiff && nextDiff.added) {
            var nextDiffLines = constructLines(nextDiff.value)[lineIndex];

            if (nextDiffLines) {
              var _$right;

              var _ref2 = (_$right = getLineInformation(nextDiff.value, diffIndex, true, false, true)[0].right) !== null && _$right !== void 0 ? _$right : {},
                  rightValue = _ref2.value,
                  lineNumber = _ref2.lineNumber,
                  type = _ref2.type; // When identified as modification, push the next diff to ignore
              // list as the next value will be added in this line computation as
              // right and left values.


              ignoreDiffIndexes.push("".concat(diffIndex + 1, "-").concat(lineIndex));
              right.lineNumber = lineNumber;
              right.type = type; // Do word level diff and assign the corresponding values to the
              // left and right diff information object.

              if (disableWordDiff) {
                right.value = rightValue;
              } else {
                var computedDiff = computeDiff(line, rightValue, compareMethod);
                right.value = computedDiff.right;
                left.value = computedDiff.left;
              }
            }
          }
        } else {
          rightLineNumber += 1;
          right.lineNumber = rightLineNumber;
          right.type = DiffType.ADDED;
          right.value = line;
        }
      } else {
        leftLineNumber += 1;
        rightLineNumber += 1;
        left.lineNumber = leftLineNumber;
        left.type = DiffType.DEFAULT;
        left.value = line;
        right.lineNumber = rightLineNumber;
        right.type = DiffType.DEFAULT;
        right.value = line;
      }

      counter += 1;
      return {
        right: right,
        left: left
      };
    }).filter(Boolean);
  };

  diffArray.forEach(function (_ref3, index) {
    var added = _ref3.added,
        removed = _ref3.removed,
        value = _ref3.value;
    lineInformation = [].concat(_toConsumableArray(lineInformation), _toConsumableArray(getLineInformation(value, index, added, removed)));
  });
  return {
    lineInformation: lineInformation,
    diffLines: diffLines
  };
};

exports.LineNumberPrefix = void 0;

(function (LineNumberPrefix) {
  LineNumberPrefix["LEFT"] = "L";
  LineNumberPrefix["RIGHT"] = "R";
})(exports.LineNumberPrefix || (exports.LineNumberPrefix = {}));

var DiffViewer = function DiffViewer(props) {
  var oldValue = props.oldValue,
      newValue = props.newValue,
      leftTitle = props.leftTitle,
      rightTitle = props.rightTitle,
      _props$splitView = props.splitView,
      splitView = _props$splitView === void 0 ? true : _props$splitView,
      _props$hideLineNumber = props.hideLineNumbers,
      hideLineNumbers = _props$hideLineNumber === void 0 ? false : _props$hideLineNumber,
      _props$disableWordDif = props.disableWordDiff,
      disableWordDiff = _props$disableWordDif === void 0 ? false : _props$disableWordDif,
      _props$compareMethod = props.compareMethod,
      compareMethod = _props$compareMethod === void 0 ? 'diffChars' : _props$compareMethod,
      linesOffset = props.linesOffset,
      _props$extraLinesSurr = props.extraLinesSurroundingDiff,
      extraLinesSurroundingDiff = _props$extraLinesSurr === void 0 ? 3 : _props$extraLinesSurr,
      _props$showDiffOnly = props.showDiffOnly,
      showDiffOnly = _props$showDiffOnly === void 0 ? true : _props$showDiffOnly,
      highlightLines = props.highlightLines,
      renderContent = props.renderContent,
      codeFoldMessageRenderer = props.codeFoldMessageRenderer,
      onLineNumberClick = props.onLineNumberClick; // Array holding the expanded code folding.

  var _useState = React.useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      expandedBlocks = _useState2[0],
      setExpandedBlocks = _useState2[1];
  /**
   * Maps over the word diff and constructs the required React elements to show word diff.
   *
   * @param diffArray Word diff information derived from line information.
   * @param renderer Optional renderer to format diff words. Useful for syntax highlighting.
   */


  var renderWordDiff = function renderWordDiff(diffArray, renderer) {
    return diffArray.map(function (wordDiff, i) {
      var classes = clsx__default['default']('diff__work-diff', wordDiff.type === DiffType.ADDED && 'diff__work-added', wordDiff.type === DiffType.REMOVED && 'diff__work-removed');
      return /*#__PURE__*/jsxRuntime.jsx("span", {
        className: classes,
        children: renderer ? renderer(wordDiff.value) : wordDiff.value
      }, i);
    });
  };

  var onLineNumberClickProxy = function onLineNumberClickProxy(id) {
    if (onLineNumberClick) {
      return function (e) {
        return onLineNumberClick(id, e);
      };
    }

    return function () {};
  };
  /**
   * Maps over the line diff and constructs the required react elements to show line diff. It calls
   * renderWordDiff when encountering word diff. This takes care of both inline and split view line
   * renders.
   *
   * @param lineNumber Line number of the current line.
   * @param type Type of diff of the current line.
   * @param prefix Unique id to prefix with the line numbers.
   * @param value Content of the line. It can be a string or a word diff array.
   * @param additionalLineNumber Additional line number to be shown. Useful for rendering inline
   *  diff view. Right line number will be passed as additionalLineNumber.
   * @param additionalPrefix Similar to prefix but for additional line number.
   */


  var renderLine = function renderLine(lineNumber, type, prefix, value, additionalLineNumber, additionalPrefix) {
    var lineNumberTemplate = "".concat(prefix, "-").concat(lineNumber);
    var additionalLineNumberTemplate = "".concat(additionalPrefix, "-").concat(additionalLineNumber);
    var highlightLine = (highlightLines === null || highlightLines === void 0 ? void 0 : highlightLines.includes(lineNumberTemplate)) || (highlightLines === null || highlightLines === void 0 ? void 0 : highlightLines.includes(additionalLineNumberTemplate));
    var added = type === DiffType.ADDED;
    var removed = type === DiffType.REMOVED;
    var content;

    if (Array.isArray(value)) {
      content = renderWordDiff(value, renderContent);
    } else if (renderContent) {
      content = renderContent(value);
    } else {
      content = value;
    }

    var diffClasses = clsx__default['default'](added && 'diff__line--added', removed && 'diff__line--removed');
    var gutterClasses = clsx__default['default']('diff__gutter', !lineNumber && 'diff__gutter-empty', highlightLine && 'diff__gutter--highlight', diffClasses);
    var markerClasses = clsx__default['default']('diff__marker', !content && 'diff__line--empty', highlightLine && 'diff__line--highlighted', diffClasses);
    var contentClasses = clsx__default['default']('diff__content', !content && 'diff__line--empty', highlightLine && 'diff__line--highlighted', diffClasses);
    return /*#__PURE__*/jsxRuntime.jsxs(React__default['default'].Fragment, {
      children: [!hideLineNumbers && /*#__PURE__*/jsxRuntime.jsx("td", {
        className: gutterClasses,
        onClick: lineNumber && onLineNumberClickProxy(lineNumberTemplate),
        children: /*#__PURE__*/jsxRuntime.jsx("pre", {
          className: "diff__line-number",
          children: lineNumber
        })
      }), !splitView && !hideLineNumbers && /*#__PURE__*/jsxRuntime.jsx("td", {
        className: gutterClasses,
        onClick: additionalLineNumber && onLineNumberClickProxy(additionalLineNumberTemplate),
        children: /*#__PURE__*/jsxRuntime.jsx("pre", {
          className: "diff__line-number",
          children: additionalLineNumber
        })
      }), /*#__PURE__*/jsxRuntime.jsx("td", {
        className: markerClasses,
        children: /*#__PURE__*/jsxRuntime.jsxs("pre", {
          children: [added && '+', removed && '-']
        })
      }), /*#__PURE__*/jsxRuntime.jsx("td", {
        className: contentClasses,
        children: /*#__PURE__*/jsxRuntime.jsx("pre", {
          className: "diff__content-text",
          children: content
        })
      })]
    });
  };
  /**
   * Generates lines for split view.
   *
   * @param obj Line diff information.
   * @param obj.left Life diff information for the left pane of the split view.
   * @param obj.right Life diff information for the right pane of the split view.
   * @param index React key for the lines.
   */


  var renderSplitView = function renderSplitView(_ref, index) {
    var left = _ref.left,
        right = _ref.right;
    return /*#__PURE__*/jsxRuntime.jsxs("tr", {
      className: "diff__line",
      children: [renderLine(left === null || left === void 0 ? void 0 : left.lineNumber, left === null || left === void 0 ? void 0 : left.type, exports.LineNumberPrefix.LEFT, left === null || left === void 0 ? void 0 : left.value), renderLine(left === null || left === void 0 ? void 0 : left.lineNumber, right === null || right === void 0 ? void 0 : right.type, exports.LineNumberPrefix.RIGHT, right === null || right === void 0 ? void 0 : right.value)]
    }, index);
  };
  /**
   * Generates lines for inline view.
   *
   * @param obj Line diff information.
   * @param obj.left Life diff information for the added section of the inline view.
   * @param obj.right Life diff information for the removed section of the inline view.
   * @param index React key for the lines.
   */


  var renderInlineView = function renderInlineView(_ref2, index) {
    var left = _ref2.left,
        right = _ref2.right;
    var content;

    if ((left === null || left === void 0 ? void 0 : left.type) === DiffType.REMOVED && (right === null || right === void 0 ? void 0 : right.type) === DiffType.ADDED) {
      return /*#__PURE__*/jsxRuntime.jsxs(React__default['default'].Fragment, {
        children: [/*#__PURE__*/jsxRuntime.jsx("tr", {
          className: "diff__line",
          children: renderLine(left.lineNumber, left.type, exports.LineNumberPrefix.LEFT, left.value, undefined)
        }), /*#__PURE__*/jsxRuntime.jsx("tr", {
          className: "diff__line",
          children: renderLine(undefined, right.type, exports.LineNumberPrefix.RIGHT, right.value, right.lineNumber)
        })]
      }, index);
    }

    if ((left === null || left === void 0 ? void 0 : left.type) === DiffType.REMOVED) {
      content = renderLine(left.lineNumber, left.type, exports.LineNumberPrefix.LEFT, left.value, undefined);
    }

    if ((left === null || left === void 0 ? void 0 : left.type) === DiffType.DEFAULT) {
      content = renderLine(left.lineNumber, left.type, exports.LineNumberPrefix.LEFT, left.value, right === null || right === void 0 ? void 0 : right.lineNumber, exports.LineNumberPrefix.RIGHT);
    }

    if ((right === null || right === void 0 ? void 0 : right.type) === DiffType.ADDED) {
      content = renderLine(undefined, right.type, exports.LineNumberPrefix.RIGHT, right.value, right.lineNumber);
    }

    return /*#__PURE__*/jsxRuntime.jsx("tr", {
      className: "diff__line",
      children: content
    }, index);
  };
  /**
   * Pushes the target expanded code block to the state. During the re-render,
   * this value is used to expand/fold unmodified code.
   */


  var onBlockExpand = function onBlockExpand(id) {
    var newExpandedBlocks = expandedBlocks.slice();
    newExpandedBlocks.push(id);
    setExpandedBlocks(newExpandedBlocks);
  };
  /**
   * Generates cold fold block. It also uses the custom message renderer when available to show
   * cold fold messages.
   *
   * @param num Number of skipped lines between two blocks.
   * @param blockNumber Code fold block id.
   * @param leftBlockLineNumber First left line number after the current code fold block.
   * @param rightBlockLineNumber First right line number after the current code fold block.
   */


  var renderSkippedLineIndicator = function renderSkippedLineIndicator(num, blockNumber, leftBlockLineNumber, rightBlockLineNumber) {
    var message = codeFoldMessageRenderer ? codeFoldMessageRenderer(num, leftBlockLineNumber, rightBlockLineNumber) : /*#__PURE__*/jsxRuntime.jsxs("pre", {
      className: "diff__code-fold-content",
      children: ["Expand ", num, " lines ..."]
    });

    var content = /*#__PURE__*/jsxRuntime.jsx("td", {
      children: /*#__PURE__*/jsxRuntime.jsx("a", {
        tabIndex: 0,
        onClick: function onClick() {
          return onBlockExpand(blockNumber);
        },
        children: message
      })
    });

    var isUnifiedViewWithoutLineNumbers = !splitView && !hideLineNumbers;
    return /*#__PURE__*/jsxRuntime.jsxs("tr", {
      className: "diff__code-fold",
      children: [!hideLineNumbers && /*#__PURE__*/jsxRuntime.jsx("td", {
        className: "diff__code-fold-gutter"
      }), /*#__PURE__*/jsxRuntime.jsx("td", {
        className: clsx__default['default'](isUnifiedViewWithoutLineNumbers && 'diff__code-fold-gutter')
      }), isUnifiedViewWithoutLineNumbers ? /*#__PURE__*/jsxRuntime.jsxs(React__default['default'].Fragment, {
        children: [/*#__PURE__*/jsxRuntime.jsx("td", {}), content]
      }) : /*#__PURE__*/jsxRuntime.jsxs(React__default['default'].Fragment, {
        children: [content, /*#__PURE__*/jsxRuntime.jsx("td", {})]
      }), /*#__PURE__*/jsxRuntime.jsx("td", {}), /*#__PURE__*/jsxRuntime.jsx("td", {})]
    }, "".concat(leftBlockLineNumber, "-").concat(rightBlockLineNumber));
  };
  /**
   * Generates the entire diff view.
   */


  var renderDiff = function renderDiff() {
    var _computeLineInformati = computeLineInformation(oldValue, newValue, disableWordDiff, compareMethod, linesOffset),
        lineInformation = _computeLineInformati.lineInformation,
        diffLines = _computeLineInformati.diffLines;

    var extraLines = extraLinesSurroundingDiff < 0 ? 0 : extraLinesSurroundingDiff;
    var skippedLines = [];
    return lineInformation.map(function (line, i) {
      var diffBlockStart = diffLines[0];
      var currentPosition = diffBlockStart - i;

      if (showDiffOnly) {
        var _line$left;

        if (currentPosition === -extraLines) {
          skippedLines = [];
          diffLines.shift();
        }

        if (((_line$left = line.left) === null || _line$left === void 0 ? void 0 : _line$left.type) === DiffType.DEFAULT && (currentPosition > extraLines || typeof diffBlockStart === 'undefined') && !expandedBlocks.includes(diffBlockStart)) {
          skippedLines.push(i + 1);

          if (i === lineInformation.length - 1 && skippedLines.length > 1) {
            var _line$right;

            return renderSkippedLineIndicator(skippedLines.length, diffBlockStart, line.left.lineNumber, (_line$right = line.right) === null || _line$right === void 0 ? void 0 : _line$right.lineNumber);
          }

          return null;
        }
      }

      var diffNodes = splitView ? renderSplitView(line, i) : renderInlineView(line, i);

      if (currentPosition === extraLines && skippedLines.length > 0) {
        var _line$left2, _line$right2;

        var _skippedLines = skippedLines,
            length = _skippedLines.length;
        skippedLines = [];
        return /*#__PURE__*/jsxRuntime.jsxs(React__default['default'].Fragment, {
          children: [renderSkippedLineIndicator(length, diffBlockStart, (_line$left2 = line.left) === null || _line$left2 === void 0 ? void 0 : _line$left2.lineNumber, (_line$right2 = line.right) === null || _line$right2 === void 0 ? void 0 : _line$right2.lineNumber), diffNodes]
        }, i);
      }

      return diffNodes;
    });
  };

  var colSpanOnSplitView = hideLineNumbers ? 2 : 3;
  var colSpanOnInlineView = hideLineNumbers ? 2 : 4;

  var title = (leftTitle || rightTitle) && /*#__PURE__*/jsxRuntime.jsxs("tr", {
    children: [/*#__PURE__*/jsxRuntime.jsx("td", {
      colSpan: splitView ? colSpanOnSplitView : colSpanOnInlineView,
      className: "diff__title-block",
      children: /*#__PURE__*/jsxRuntime.jsx("pre", {
        className: "diff__title-left",
        children: leftTitle
      })
    }), splitView && /*#__PURE__*/jsxRuntime.jsx("td", {
      colSpan: colSpanOnSplitView,
      className: "diff__title-block",
      children: /*#__PURE__*/jsxRuntime.jsx("pre", {
        className: "diff__title-right",
        children: rightTitle
      })
    })]
  });

  var nodes = renderDiff();
  var containerClasses = clsx__default['default']('diff__container', splitView && 'diff__split-view');
  return /*#__PURE__*/jsxRuntime.jsx("table", {
    className: containerClasses,
    children: /*#__PURE__*/jsxRuntime.jsxs("tbody", {
      children: [title, nodes]
    })
  });
};

exports.ADVANCE_FILTER_FEATURE = ADVANCE_FILTER_FEATURE;
exports.Administrative = Administrative;
exports.AdvanceSelect = AdvanceSelect;
exports.AdvanceSelectControl = AdvanceSelectControl;
exports.AdvanceSelectPopup = AdvanceSelectPopup;
exports.Alert = Alert;
exports.AnchorOverlay = AnchorOverlay;
exports.AppBody = AppBody;
exports.AutoLogout = AutoLogout;
exports.BorderPanel = BorderPanel;
exports.BorderPanel2 = BorderPanel2;
exports.Box = Box;
exports.BoxImage = BoxImage;
exports.BoxSelectHandler = BoxSelectHandler;
exports.Breadcrumb = Breadcrumb;
exports.BuildingLayer = BuildingLayer;
exports.Button = Button;
exports.COMBINE_OPTIONS = COMBINE_OPTIONS;
exports.Calendar = Calendar;
exports.CallTimer = CallTimer;
exports.Callout = Callout;
exports.Card = Card;
exports.Chart = Chart;
exports.ChatActions = ChatActions;
exports.ChatBoxComponent = ChatBoxComponent;
exports.ChatBoxHeader = ChatBoxHeader;
exports.ChatListComponent = ChatListComponent;
exports.ChatListItem = ChatListItem;
exports.ChatView = ChatView;
exports.CheckBox = CheckBox;
exports.CheckBoxGroup = CheckBoxGroup;
exports.CircleMarker = CircleMarker;
exports.CircleMarkerWithDistance = CircleMarkerWithDistance;
exports.ClearableInput = ClearableInput;
exports.Col2 = Col2;
exports.Collapse = Collapse;
exports.CollapsibleContainer = CollapsibleContainer;
exports.CollapsibleSection = CollapsibleSection;
exports.ColorPicker = ColorPicker;
exports.Column = Column;
exports.ColumnSelector = ColumnSelector;
exports.ColumnTogglePanel = ColumnTogglePanel;
exports.Compass = Compass;
exports.Confirm = Confirm;
exports.ContainField = ContainField;
exports.Container = Container;
exports.ContainerPanel = ContainerPanel;
exports.ContainerPanel2 = ContainerPanel2;
exports.ContextMenu = ContextMenu;
exports.CropImage = CropImage;
exports.DND_TYPE = DND_TYPE;
exports.DataFilterPanel = DataFilterPanel;
exports.DataGrid = DataGrid;
exports.DataGridBottomBar = DataGridBottomBar;
exports.DataGridCell = DataGridCell;
exports.DataGridToolbar = DataGridToolbar;
exports.DataSearchPanel = DataSearchPanel;
exports.DataSortPanel = DataSortPanel;
exports.DataToolBar = DataToolBar;
exports.DataToolBarContext = DataToolBarContext;
exports.DateTimePicker = DateTimePicker;
exports.Day = Day;
exports.DescriptionGroup = DescriptionGroup;
exports.DescriptionItem = DescriptionItem;
exports.DetectImage = DetectImage;
exports.DialPad = DialPad;
exports.DiffViewer = DiffViewer;
exports.DnDResizable = DnDResizable;
exports.DomainContext = DomainContext;
exports.DomainProvider = DomainProvider;
exports.DraggableItem = DraggableItem;
exports.Drawer = Drawer;
exports.DroppableZones = DroppableZones;
exports.DynamicDisplay = DynamicDisplay;
exports.DynamicDisplayForm = DynamicDisplayForm;
exports.DynamicForm = DynamicForm;
exports.EmptyButton = EmptyButton;
exports.EmptyData = EmptyData;
exports.Expanded = Expanded;
exports.FAIcons = FAIcons;
exports.FSDataBody = FSDataBody;
exports.FSDataContainer = FSDataContainer;
exports.FSDataContent = FSDataContent;
exports.FSImage = FSImage;
exports.FeatureBar = FeatureBar;
exports.FeatureBarBottom = FeatureBarBottom;
exports.FeatureBarTop = FeatureBarTop;
exports.FeatureItem = FeatureItem;
exports.FeatureLink = FeatureLink;
exports.FeatureText = FeatureText;
exports.Field = Field;
exports.FieldSet = FieldSet;
exports.FilterInput = FilterInput;
exports.FilterValue = FilterValue;
exports.Flex = Flex;
exports.FlexPanel = FlexPanel;
exports.FlexPanel2 = FlexPanel2;
exports.Form = Form;
exports.FormControl = FormControl;
exports.FormControlLabel = FormControlLabel;
exports.FormField = FormField;
exports.FormGroup = FormGroup;
exports.FullScreenButton = FullScreenButton;
exports.FullScreenContext = FullScreenContext;
exports.FullScreenOverlay = FullScreenOverlay;
exports.FullScreenOverlayContext = FullScreenOverlayContext;
exports.FullScreenProvider = FullScreenProvider;
exports.GeoMap = GeoMap;
exports.GroupAvatar = GroupAvatar;
exports.GroupSettingPopup = GroupSettingPopup;
exports.HD1 = HD1;
exports.HD2 = HD2;
exports.HD3 = HD3;
exports.HD4 = HD4;
exports.HD5 = HD5;
exports.HD6 = HD6;
exports.I18nContext = I18nContext;
exports.I18nProvider = I18nProvider;
exports.IconButton = IconButton;
exports.Iframe = Iframe;
exports.Image = Image$1;
exports.ImageGrid = ImageGrid;
exports.ImageInput = ImageInput;
exports.ImageReader = ImageReader;
exports.Info = Info;
exports.Input = Input;
exports.InputAppend = InputAppend;
exports.InputGroup = InputGroup;
exports.InputMoment = InputMoment;
exports.InputPrepend = InputPrepend;
exports.JSONInputEditor = JSONInputEditor;
exports.JsonToFormParser = JsonToFormParser;
exports.Label = Label;
exports.LargeDataPaging = LargeDataPaging;
exports.LazyLoadList = LazyLoadList;
exports.Li = Li;
exports.Line = Line;
exports.Link = Link;
exports.ListItem = ListItem;
exports.Loading = Loading;
exports.MAPPED_TEXT_VARIANT_CLASSES = MAPPED_TEXT_VARIANT_CLASSES;
exports.Map = Map$2;
exports.MapButtonGroup = MapButtonGroup;
exports.MapContext = MapContext;
exports.MapControlButton = MapControlButton;
exports.MapDisplaySchemaToDisplayTypes = MapDisplaySchemaToDisplayTypes;
exports.MapProvider = MapProvider;
exports.MapUtil = MapUtil;
exports.MapVDMSDataTypesToDataTypes = MapVDMSDataTypesToDataTypes;
exports.MarkerPopup = MarkerPopup;
exports.MenuItem = MenuItem;
exports.ModalContext = ModalContext;
exports.ModalProvider = ModalProvider;
exports.Moment = Moment;
exports.Month = Month;
exports.MonthPicker = MonthPicker;
exports.MultilineInput = MultilineInput;
exports.NavigationMenu = NavigationMenu;
exports.NotFoundPage = NotFoundPage;
exports.Overlay = Overlay;
exports.PageTitle = PageTitle;
exports.PaginationRow = PaginationRow;
exports.Paging = Paging;
exports.PagingCount = PagingCount;
exports.Panel = Panel;
exports.Panel2 = Panel2;
exports.PanelBody = PanelBody;
exports.PanelBody2 = PanelBody2;
exports.PanelFooter = PanelFooter;
exports.PanelHeader = PanelHeader;
exports.PanelHeaderWithSwitcher = PanelHeaderWithSwitcher;
exports.Panorama = Panorama;
exports.PointMarker = PointMarker;
exports.PopOver = PopOver;
exports.PopOverTooltip = PopOverTooltip;
exports.PopperTooltip = PopperTooltip;
exports.Popup = Popup;
exports.PopupFooter = PopupFooter;
exports.Positioned = Positioned;
exports.Post = Post;
exports.ProgressBar = ProgressBar;
exports.ProgressInProgressBar = ProgressInProgressBar;
exports.ProgressLinear = ProgressLinear;
exports.QueryBuilderGroup = QueryBuilderGroup;
exports.QueryBuilderRule = QueryBuilderRule;
exports.Radio = Radio;
exports.Rail = Rail;
exports.RangeDateTime = RangeDateTime;
exports.RangeThumb = RangeThumb;
exports.RangeTime = RangeTime;
exports.Ratio = Ratio;
exports.Resizable = Resizable;
exports.ResizableGrid = ResizableGrid;
exports.ResizableMultiPanel = ResizableMultiPanel;
exports.ResizableSinglePanel = ResizableSinglePanel;
exports.ResizeableHeader = ResizeableHeader;
exports.ResponsiveGrid = ResponsiveGrid;
exports.ResponsiveGridItem = ResponsiveGridItem;
exports.RichText = RichText;
exports.Row = Row;
exports.Row2 = Row2;
exports.SCHEMAS = SCHEMAS;
exports.ScrollView = ScrollView;
exports.SearchBox = SearchBox;
exports.SearchField = SearchField;
exports.SearchSuggestContainer = SearchSuggestContainer;
exports.Section = Section;
exports.SectionHeader = SectionHeader;
exports.Select = Select;
exports.Separator = Separator;
exports.SideBar = SideBar;
exports.Slider = Slider;
exports.SliderLabels = SliderLabels;
exports.SliderMarks = SliderMarks;
exports.SmartForm = SmartForm;
exports.Spacer = Spacer;
exports.Spinner = Spinner;
exports.Status = Status;
exports.Step = Step;
exports.Stepper = Stepper;
exports.StyleSwitcher = StyleSwitcher;
exports.Sub1 = Sub1;
exports.Sub2 = Sub2;
exports.SuggestItem = SuggestItem;
exports.SuggestList = SuggestList;
exports.SwitchButton = SwitchButton;
exports.T = T;
exports.TB1 = TB1;
exports.TB2 = TB2;
exports.THEME_SWITCHING_CLASS = THEME_SWITCHING_CLASS;
exports.Tab = Tab;
exports.Table = Table;
exports.TableRow = TableRow;
exports.TableRowCell = TableRowCell;
exports.Tabs = Tabs;
exports.Tag = Tag;
exports.TenantContext = TenantContext;
exports.TenantProvider = TenantProvider;
exports.ThemeContext = ThemeContext;
exports.ThemeIcon = ThemeIcon;
exports.ThemeProvider = ThemeProvider;
exports.Time = Time;
exports.Toast = Toast;
exports.ToastStack = ToastStack;
exports.ToggleButton = ToggleButton;
exports.ToolBarToggleButton = ToolBarToggleButton;
exports.ToolBarToggleButtonGroup = ToolBarToggleButtonGroup;
exports.Tooltip = Tooltip$1;
exports.Tooltip2 = Tooltip2;
exports.Track = Track;
exports.TrackingMarker = TrackingMarker;
exports.Tree = Tree;
exports.TreeGrid = TreeGrid;
exports.TreeItem = TreeItem$1;
exports.TreeSelect = TreeSelect;
exports.TreeSelectPopup = TreeSelectPopup;
exports.TreeView = TreeView;
exports.Typography = Typography;
exports.Ul = Ul;
exports.UploadImage = UploadImage;
exports.UserAvatar = UserAvatar;
exports.UserListComponent = UserListComponent;
exports.UserListItem = UserListItem;
exports.VerticalLine = VerticalLine;
exports.VideoPlayer = VideoPlayer;
exports.WebSocketService = WebSocketService;
exports.WindowFixedItem = WindowFixedItem;
exports.WindowPopup = WindowPopup;
exports.WindowScreen = WindowScreen;
exports.YearPicker = YearPicker;
exports.Zone = Zone;
exports.alert = alert;
exports.confirm = confirm;
exports.drawer = drawer;
exports.getOperators = getOperators;
exports.language = language;
exports.mapColumnSchemaToDataType = mapColumnSchemaToDataType;
exports.mapStyleList = mapStyleList;
exports.spin = spin;
exports.themeList = themeList;
exports.toast = toast;
exports.useI18n = useI18n;
exports.useMergeState = useMergeState;
exports.useModal = useModal;
exports.useOutsideClick = useOutsideClick;
exports.usePagination = usePagination;
exports.useResizeMap = useResizeMap;
exports.useStateCallback = useStateCallback;
exports.useSubMenuOption = useSubMenuOption;
exports.useTenant = useTenant;
exports.useWindowSize = useWindowSize;
exports.withI18n = withI18n;
exports.withModal = withModal;
exports.withResizeMap = withResizeMap;
exports.withTenant = withTenant;
Object.keys(vicon).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return vicon[k];
    }
  });
});
